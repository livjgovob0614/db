/* vetisamsC.cpp
   Generated by gSOAP 2.8.8 from vetisams.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "slib.h"
#include "vetisamsH.h"
#pragma hdrstop

SOAP_SOURCE_STAMP("@(#) vetisamsC.cpp ver 2.8.8 2018-05-22 16:35:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void FASTCALL soap_serializeheader(struct soap *soap)
{
	if(soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int FASTCALL soap_putheader(struct soap *soap)
{
	if(soap->header) {
		soap->part = SOAP_IN_HEADER;
		if(soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if(!soap->header) {
		if((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void FASTCALL soap_fault(struct soap *soap)
{
	if(!soap->fault) {
		soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if(!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if(soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	return soap->fault ? soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL) : SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
			soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 1) {
		if(!soap->fault->detail) {
			soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if(!soap->fault->SOAP_ENV__Detail) {
		soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if(soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_getindependent(struct soap *soap)
{
	int t;
	if(soap->version == 1) {
		for(;;) {
			if(!soap_getelement(soap, &t))
				if(soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if(oneof2(soap->error, SOAP_NO_TAG, SOAP_EOF))
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	(void)type;
	if(soap_peek_element(soap))
		return NULL;
	if(!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch(*type) {
	case SOAP_TYPE_byte: return soap_in_byte(soap, 0, 0, "xsd:byte");
	case SOAP_TYPE_dic__Minute: return soap_in_dic__Minute(soap, 0, 0, "dic:Minute");
	case SOAP_TYPE_dic__Hour: return soap_in_dic__Hour(soap, 0, 0, "dic:Hour");
	case SOAP_TYPE_dic__Day: return soap_in_dic__Day(soap, 0, 0, "dic:Day");
	case SOAP_TYPE_dic__Month: return soap_in_dic__Month(soap, 0, 0, "dic:Month");
	case SOAP_TYPE_dic__Year: return soap_in_dic__Year(soap, 0, 0, "dic:Year");
	case SOAP_TYPE_base__Hour: return soap_in_base__Hour(soap, 0, 0, "base:Hour");
	case SOAP_TYPE_base__Day: return soap_in_base__Day(soap, 0, 0, "base:Day");
	case SOAP_TYPE_base__Month: return soap_in_base__Month(soap, 0, 0, "base:Month");
	case SOAP_TYPE_base__Year: return soap_in_base__Year(soap, 0, 0, "base:Year");
	case SOAP_TYPE_int: return soap_in_int(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_in_LONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_in_unsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_in_unsignedInt(soap, 0, 0, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_in_time(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_in_bool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_vd__AnimalSpentPeriod: return soap_in_vd__AnimalSpentPeriod(soap, 0, 0, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_vd__VetDocumentStatus: return soap_in_vd__VetDocumentStatus(soap, 0, 0, "vd:VetDocumentStatus");
	case SOAP_TYPE_vd__VetDocumentType: return soap_in_vd__VetDocumentType(soap, 0, 0, "vd:VetDocumentType");
	case SOAP_TYPE_vd__VetDocumentForm: return soap_in_vd__VetDocumentForm(soap, 0, 0, "vd:VetDocumentForm");
	case SOAP_TYPE_vd__DeliveryInspectionResult: return soap_in_vd__DeliveryInspectionResult(soap, 0, 0, "vd:DeliveryInspectionResult");
	case SOAP_TYPE_vd__DeliveryDecision: return soap_in_vd__DeliveryDecision(soap, 0, 0, "vd:DeliveryDecision");
	case SOAP_TYPE_dic__ProductMarkingClass: return soap_in_dic__ProductMarkingClass(soap, 0, 0, "dic:ProductMarkingClass");
	case SOAP_TYPE_dic__TransportationStorageType: return soap_in_dic__TransportationStorageType(soap, 0, 0, "dic:TransportationStorageType");
	case SOAP_TYPE_dic__DocumentNature: return soap_in_dic__DocumentNature(soap, 0, 0, "dic:DocumentNature");
	case SOAP_TYPE_dic__EnterpriseRole: return soap_in_dic__EnterpriseRole(soap, 0, 0, "dic:EnterpriseRole");
	case SOAP_TYPE_vd__ProcessingProcedureType: return soap_in_vd__ProcessingProcedureType(soap, 0, 0, "vd:ProcessingProcedureType");
	case SOAP_TYPE_vd__VeterinaryEventType: return soap_in_vd__VeterinaryEventType(soap, 0, 0, "vd:VeterinaryEventType");
	case SOAP_TYPE_vd__StockEntryBlankFilter: return soap_in_vd__StockEntryBlankFilter(soap, 0, 0, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_dic__VaccinationType: return soap_in_dic__VaccinationType(soap, 0, 0, "dic:VaccinationType");
	case SOAP_TYPE_dic__ProsperityType: return soap_in_dic__ProsperityType(soap, 0, 0, "dic:ProsperityType");
	case SOAP_TYPE_dic__RegionalizationDecision: return soap_in_dic__RegionalizationDecision(soap, 0, 0, "dic:RegionalizationDecision");
	case SOAP_TYPE_dic__ResearchResult: return soap_in_dic__ResearchResult(soap, 0, 0, "dic:ResearchResult");
	case SOAP_TYPE_dic__TransportType: return soap_in_dic__TransportType(soap, 0, 0, "dic:TransportType");
	case SOAP_TYPE_dic__ReferenceType: return soap_in_dic__ReferenceType(soap, 0, 0, "dic:ReferenceType");
	case SOAP_TYPE_dic__DocumentType: return soap_in_dic__DocumentType(soap, 0, 0, "dic:DocumentType");
	case SOAP_TYPE_dic__ProductType: return soap_in_dic__ProductType(soap, 0, 0, "dic:ProductType");
	case SOAP_TYPE_dic__BusinessEntityType: return soap_in_dic__BusinessEntityType(soap, 0, 0, "dic:BusinessEntityType");
	case SOAP_TYPE_dic__EnterpriseGroup: return soap_in_dic__EnterpriseGroup(soap, 0, 0, "dic:EnterpriseGroup");
	case SOAP_TYPE_dic__PackingCodeType: return soap_in_dic__PackingCodeType(soap, 0, 0, "dic:PackingCodeType");
	case SOAP_TYPE_dic__PackageLevelType: return soap_in_dic__PackageLevelType(soap, 0, 0, "dic:PackageLevelType");
	case SOAP_TYPE_app__ContentEncoding: return soap_in_app__ContentEncoding(soap, 0, 0, "app:ContentEncoding");
	case SOAP_TYPE_app__ApplicationStatus: return soap_in_app__ApplicationStatus(soap, 0, 0, "app:ApplicationStatus");
	case SOAP_TYPE_base__RegisterModificationType: return soap_in_base__RegisterModificationType(soap, 0, 0, "base:RegisterModificationType");
	case SOAP_TYPE_app__BinaryContent: return soap_in_app__BinaryContent(soap, 0, 0, "app:BinaryContent");
	case SOAP_TYPE_vd__Citizenship: return soap_in_vd__Citizenship(soap, 0, 0, "vd:Citizenship");
	case SOAP_TYPE_vd__WorkingArea: return soap_in_vd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_vd__UserAuthority: return soap_in_vd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_vd__WorkingAreaList: return soap_in_vd__WorkingAreaList(soap, 0, 0, "vd:WorkingAreaList");
	case SOAP_TYPE_vd__AuthorityList: return soap_in_vd__AuthorityList(soap, 0, 0, "vd:AuthorityList");
	case SOAP_TYPE_vd__UserList: return soap_in_vd__UserList(soap, 0, 0, "vd:UserList");
	case SOAP_TYPE_vd__User: return soap_in_vd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_vd__ProcessingProcedure: return soap_in_vd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_vd__RouteSectionR13nRules: return soap_in_vd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_vd__RegionalizationClause: return soap_in_vd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_vd__VetDocumentStatusChange: return soap_in_vd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_vd__StockEntryEventList: return soap_in_vd__StockEntryEventList(soap, 0, 0, "vd:StockEntryEventList");
	case SOAP_TYPE_vd__BatchOrigin: return soap_in_vd__BatchOrigin(soap, 0, 0, "vd:BatchOrigin");
	case SOAP_TYPE_vd__VeterinaryAuthentication: return soap_in_vd__VeterinaryAuthentication(soap, 0, 0, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_vd__QuarantineEvent: return soap_in_vd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_vd__AnimalMedicationEvent: return soap_in_vd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return soap_in_vd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_vd__VeterinaryEvent: return soap_in_vd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_vd__ReferencedDocument: return soap_in_vd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_vd__CertifiedConsignment: return soap_in_vd__CertifiedConsignment(soap, 0, 0, "vd:CertifiedConsignment");
	case SOAP_TYPE_vd__CertifiedBatch: return soap_in_vd__CertifiedBatch(soap, 0, 0, "vd:CertifiedBatch");
	case SOAP_TYPE_vd__ENTModificationOperation: return soap_in_vd__ENTModificationOperation(soap, 0, 0, "vd:ENTModificationOperation");
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return soap_in_vd__BEActivityLocationsModificationOperation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_vd__BEModificationOperation: return soap_in_vd__BEModificationOperation(soap, 0, 0, "vd:BEModificationOperation");
	case SOAP_TYPE_vd__PSLModificationOperation: return soap_in_vd__PSLModificationOperation(soap, 0, 0, "vd:PSLModificationOperation");
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return soap_in_vd__MergeStockEntriesOperation(soap, 0, 0, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_vd__ProductionOperation: return soap_in_vd__ProductionOperation(soap, 0, 0, "vd:ProductionOperation");
	case SOAP_TYPE_vd__ShipmentRoute: return soap_in_vd__ShipmentRoute(soap, 0, 0, "vd:ShipmentRoute");
	case SOAP_TYPE_vd__ShipmentRoutePoint: return soap_in_vd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_vd__TransportNumber: return soap_in_vd__TransportNumber(soap, 0, 0, "vd:TransportNumber");
	case SOAP_TYPE_vd__TransportInfo: return soap_in_vd__TransportInfo(soap, 0, 0, "vd:TransportInfo");
	case SOAP_TYPE_vd__Waybill: return soap_in_vd__Waybill(soap, 0, 0, "vd:Waybill");
	case SOAP_TYPE_vd__Document: return soap_in_vd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_vd__StockEntrySearchPattern: return soap_in_vd__StockEntrySearchPattern(soap, 0, 0, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_vd__StockDiscrepancy: return soap_in_vd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_vd__StockEntryList: return soap_in_vd__StockEntryList(soap, 0, 0, "vd:StockEntryList");
	case SOAP_TYPE_vd__StockEntry: return soap_in_vd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_vd__DiscrepancyReason: return soap_in_vd__DiscrepancyReason(soap, 0, 0, "vd:DiscrepancyReason");
	case SOAP_TYPE_vd__DiscrepancyReport: return soap_in_vd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_vd__VetDocumentList: return soap_in_vd__VetDocumentList(soap, 0, 0, "vd:VetDocumentList");
	case SOAP_TYPE_vd__GoodsDate: return soap_in_vd__GoodsDate(soap, 0, 0, "vd:GoodsDate");
	case SOAP_TYPE_vd__ConsignmentDocumentList: return soap_in_vd__ConsignmentDocumentList(soap, 0, 0, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_vd__DeliveryInspection: return soap_in_vd__DeliveryInspection(soap, 0, 0, "vd:DeliveryInspection");
	case SOAP_TYPE_vd__DeliveryFactList: return soap_in_vd__DeliveryFactList(soap, 0, 0, "vd:DeliveryFactList");
	case SOAP_TYPE_vd__Delivery: return soap_in_vd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_vd__ProductiveBatch: return soap_in_vd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_vd__RawBatch: return soap_in_vd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_vd__Consignment: return soap_in_vd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_vd__Batch: return soap_in_vd__Batch(soap, 0, 0, "vd:Batch");
	case SOAP_TYPE_vd__VetDocument: return soap_in_vd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_dic__ActivityLocationList: return soap_in_dic__ActivityLocationList(soap, 0, 0, "dic:ActivityLocationList");
	case SOAP_TYPE_dic__ResearchMethodList: return soap_in_dic__ResearchMethodList(soap, 0, 0, "dic:ResearchMethodList");
	case SOAP_TYPE_dic__AnimalDiseaseList: return soap_in_dic__AnimalDiseaseList(soap, 0, 0, "dic:AnimalDiseaseList");
	case SOAP_TYPE_dic__RegionalizationShippingRuleList: return soap_in_dic__RegionalizationShippingRuleList(soap, 0, 0, "dic:RegionalizationShippingRuleList");
	case SOAP_TYPE_dic__RegionalizationRegionStatusList: return soap_in_dic__RegionalizationRegionStatusList(soap, 0, 0, "dic:RegionalizationRegionStatusList");
	case SOAP_TYPE_dic__RegionalizationConditionList: return soap_in_dic__RegionalizationConditionList(soap, 0, 0, "dic:RegionalizationConditionList");
	case SOAP_TYPE_dic__Area: return soap_in_dic__Area(soap, 0, 0, "dic:Area");
	case SOAP_TYPE_dic__RegionalizationRegionStatus: return soap_in_dic__RegionalizationRegionStatus(soap, 0, 0, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_dic__RegionalizationStatus: return soap_in_dic__RegionalizationStatus(soap, 0, 0, "dic:RegionalizationStatus");
	case SOAP_TYPE_dic__RegionalizationShippingRule: return soap_in_dic__RegionalizationShippingRule(soap, 0, 0, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_dic__RegionalizationRequirement: return soap_in_dic__RegionalizationRequirement(soap, 0, 0, "dic:RegionalizationRequirement");
	case SOAP_TYPE_dic__RegionalizationConditionGroup: return soap_in_dic__RegionalizationConditionGroup(soap, 0, 0, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_dic__RegionalizationCondition: return soap_in_dic__RegionalizationCondition(soap, 0, 0, "dic:RegionalizationCondition");
	case SOAP_TYPE_dic__MedicinalDrug: return soap_in_dic__MedicinalDrug(soap, 0, 0, "dic:MedicinalDrug");
	case SOAP_TYPE_dic__ResearchMethod: return soap_in_dic__ResearchMethod(soap, 0, 0, "dic:ResearchMethod");
	case SOAP_TYPE_dic__AnimalDisease: return soap_in_dic__AnimalDisease(soap, 0, 0, "dic:AnimalDisease");
	case SOAP_TYPE_dic__Indicator: return soap_in_dic__Indicator(soap, 0, 0, "dic:Indicator");
	case SOAP_TYPE_dic__Organization: return soap_in_dic__Organization(soap, 0, 0, "dic:Organization");
	case SOAP_TYPE_dic__EnterpriseOfficialRegistration: return soap_in_dic__EnterpriseOfficialRegistration(soap, 0, 0, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_dic__Location: return soap_in_dic__Location(soap, 0, 0, "dic:Location");
	case SOAP_TYPE_dic__Packaging: return soap_in_dic__Packaging(soap, 0, 0, "dic:Packaging");
	case SOAP_TYPE_dic__ProductItemProducing: return soap_in_dic__ProductItemProducing(soap, 0, 0, "dic:ProductItemProducing");
	case SOAP_TYPE_dic__ComplexDate: return soap_in_dic__ComplexDate(soap, 0, 0, "dic:ComplexDate");
	case SOAP_TYPE_dic__PackageList: return soap_in_dic__PackageList(soap, 0, 0, "dic:PackageList");
	case SOAP_TYPE_dic__Package: return soap_in_dic__Package(soap, 0, 0, "dic:Package");
	case SOAP_TYPE_dic__ProductMarks: return soap_in_dic__ProductMarks(soap, 0, 0, "dic:ProductMarks");
	case SOAP_TYPE_dic__ProductItemList: return soap_in_dic__ProductItemList(soap, 0, 0, "dic:ProductItemList");
	case SOAP_TYPE_dic__SubProductList: return soap_in_dic__SubProductList(soap, 0, 0, "dic:SubProductList");
	case SOAP_TYPE_dic__ProductList: return soap_in_dic__ProductList(soap, 0, 0, "dic:ProductList");
	case SOAP_TYPE_dic__SubProduct: return soap_in_dic__SubProduct(soap, 0, 0, "dic:SubProduct");
	case SOAP_TYPE_dic__Product: return soap_in_dic__Product(soap, 0, 0, "dic:Product");
	case SOAP_TYPE_dic__ProductItem: return soap_in_dic__ProductItem(soap, 0, 0, "dic:ProductItem");
	case SOAP_TYPE_dic__BusinessEntityList: return soap_in_dic__BusinessEntityList(soap, 0, 0, "dic:BusinessEntityList");
	case SOAP_TYPE_dic__IncorporationForm: return soap_in_dic__IncorporationForm(soap, 0, 0, "dic:IncorporationForm");
	case SOAP_TYPE_dic__BusinessEntity: return soap_in_dic__BusinessEntity(soap, 0, 0, "dic:BusinessEntity");
	case SOAP_TYPE_dic__BusinessMember: return soap_in_dic__BusinessMember(soap, 0, 0, "dic:BusinessMember");
	case SOAP_TYPE_dic__EnterpriseList: return soap_in_dic__EnterpriseList(soap, 0, 0, "dic:EnterpriseList");
	case SOAP_TYPE_dic__EnterpriseNumberList: return soap_in_dic__EnterpriseNumberList(soap, 0, 0, "dic:EnterpriseNumberList");
	case SOAP_TYPE_dic__ProducerList: return soap_in_dic__ProducerList(soap, 0, 0, "dic:ProducerList");
	case SOAP_TYPE_dic__Producer: return soap_in_dic__Producer(soap, 0, 0, "dic:Producer");
	case SOAP_TYPE_dic__EnterpriseActivity: return soap_in_dic__EnterpriseActivity(soap, 0, 0, "dic:EnterpriseActivity");
	case SOAP_TYPE_dic__EnterpriseActivityList: return soap_in_dic__EnterpriseActivityList(soap, 0, 0, "dic:EnterpriseActivityList");
	case SOAP_TYPE_dic__Enterprise: return soap_in_dic__Enterprise(soap, 0, 0, "dic:Enterprise");
	case SOAP_TYPE_dic__StreetList: return soap_in_dic__StreetList(soap, 0, 0, "dic:StreetList");
	case SOAP_TYPE_dic__LocalityList: return soap_in_dic__LocalityList(soap, 0, 0, "dic:LocalityList");
	case SOAP_TYPE_dic__DistrictList: return soap_in_dic__DistrictList(soap, 0, 0, "dic:DistrictList");
	case SOAP_TYPE_dic__RegionList: return soap_in_dic__RegionList(soap, 0, 0, "dic:RegionList");
	case SOAP_TYPE_dic__CountryList: return soap_in_dic__CountryList(soap, 0, 0, "dic:CountryList");
	case SOAP_TYPE_dic__Address: return soap_in_dic__Address(soap, 0, 0, "dic:Address");
	case SOAP_TYPE_dic__Street: return soap_in_dic__Street(soap, 0, 0, "dic:Street");
	case SOAP_TYPE_dic__Locality: return soap_in_dic__Locality(soap, 0, 0, "dic:Locality");
	case SOAP_TYPE_dic__District: return soap_in_dic__District(soap, 0, 0, "dic:District");
	case SOAP_TYPE_dic__Region: return soap_in_dic__Region(soap, 0, 0, "dic:Region");
	case SOAP_TYPE_dic__AddressObjectView: return soap_in_dic__AddressObjectView(soap, 0, 0, "dic:AddressObjectView");
	case SOAP_TYPE_dic__FederalDistrict: return soap_in_dic__FederalDistrict(soap, 0, 0, "dic:FederalDistrict");
	case SOAP_TYPE_dic__Country: return soap_in_dic__Country(soap, 0, 0, "dic:Country");
	case SOAP_TYPE_dic__UnitList: return soap_in_dic__UnitList(soap, 0, 0, "dic:UnitList");
	case SOAP_TYPE_dic__PurposeList: return soap_in_dic__PurposeList(soap, 0, 0, "dic:PurposeList");
	case SOAP_TYPE_dic__PackingType: return soap_in_dic__PackingType(soap, 0, 0, "dic:PackingType");
	case SOAP_TYPE_dic__Unit: return soap_in_dic__Unit(soap, 0, 0, "dic:Unit");
	case SOAP_TYPE_dic__Purpose: return soap_in_dic__Purpose(soap, 0, 0, "dic:Purpose");
	case SOAP_TYPE_app__BusinessError: return soap_in_app__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_app__BusinessErrorList: return soap_in_app__BusinessErrorList(soap, 0, 0, "app:BusinessErrorList");
	case SOAP_TYPE_app__ApplicationResultData: return soap_in_app__ApplicationResultData(soap, 0, 0, "app:ApplicationResultData");
	case SOAP_TYPE_app__ApplicationData: return soap_in_app__ApplicationData(soap, 0, 0, "app:ApplicationData");
	case SOAP_TYPE_app__ApplicationResultWrapper: return soap_in_app__ApplicationResultWrapper(soap, 0, 0, "app:ApplicationResultWrapper");
	case SOAP_TYPE_app__ApplicationDataWrapper: return soap_in_app__ApplicationDataWrapper(soap, 0, 0, "app:ApplicationDataWrapper");
	case SOAP_TYPE_app__Application: return soap_in_app__Application(soap, 0, 0, "app:Application");
	case SOAP_TYPE_base__ComplexDate: return soap_in_base__ComplexDate(soap, 0, 0, "base:ComplexDate");
	case SOAP_TYPE_base__Error: return soap_in_base__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_base__FaultInfo: return soap_in_base__FaultInfo(soap, 0, 0, "base:FaultInfo");
	case SOAP_TYPE_base__EntityList: return soap_in_base__EntityList(soap, 0, 0, "base:EntityList");
	case SOAP_TYPE_base__DateInterval: return soap_in_base__DateInterval(soap, 0, 0, "base:DateInterval");
	case SOAP_TYPE_base__ListOptions: return soap_in_base__ListOptions(soap, 0, 0, "base:ListOptions");
	case SOAP_TYPE_base__GenericVersioningEntity: return soap_in_base__GenericVersioningEntity(soap, 0, 0, "base:GenericVersioningEntity");
	case SOAP_TYPE_base__GenericEntity: return soap_in_base__GenericEntity(soap, 0, 0, "base:GenericEntity");
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse: return soap_in_g2ba__GetApplicableUserAuthorityListResponse(soap, 0, 0, "g2ba:GetApplicableUserAuthorityListResponse");
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest: return soap_in_g2ba__GetApplicableUserAuthorityListRequest(soap, 0, 0, "g2ba:GetApplicableUserAuthorityListRequest");
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse: return soap_in_g2ba__UnbindBusinessEntityUserResponse(soap, 0, 0, "g2ba:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest: return soap_in_g2ba__UnbindBusinessEntityUserRequest(soap, 0, 0, "g2ba:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse: return soap_in_g2ba__UpdateUserWorkingAreasResponse(soap, 0, 0, "g2ba:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest: return soap_in_g2ba__UpdateUserWorkingAreasRequest(soap, 0, 0, "g2ba:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse: return soap_in_g2ba__UpdateUserAuthoritiesResponse(soap, 0, 0, "g2ba:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest: return soap_in_g2ba__UpdateUserAuthoritiesRequest(soap, 0, 0, "g2ba:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserResponse: return soap_in_g2ba__GetBusinessEntityUserResponse(soap, 0, 0, "g2ba:GetBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserRequest: return soap_in_g2ba__GetBusinessEntityUserRequest(soap, 0, 0, "g2ba:GetBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse: return soap_in_g2ba__GetBusinessEntityUserListResponse(soap, 0, 0, "g2ba:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest: return soap_in_g2ba__GetBusinessEntityUserListRequest(soap, 0, 0, "g2ba:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_g2ba__AddBusinessEntityUserResponse: return soap_in_g2ba__AddBusinessEntityUserResponse(soap, 0, 0, "g2ba:AddBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__AddBusinessEntityUserRequest: return soap_in_g2ba__AddBusinessEntityUserRequest(soap, 0, 0, "g2ba:AddBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse: return soap_in_g2ba__CheckShipmentRegionalizationResponse(soap, 0, 0, "g2ba:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest: return soap_in_g2ba__CheckShipmentRegionalizationRequest(soap, 0, 0, "g2ba:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse: return soap_in_g2ba__UpdateVeterinaryEventsResponse(soap, 0, 0, "g2ba:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest: return soap_in_g2ba__UpdateVeterinaryEventsRequest(soap, 0, 0, "g2ba:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse: return soap_in_g2ba__UpdateTransportMovementDetailsResponse(soap, 0, 0, "g2ba:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest: return soap_in_g2ba__UpdateTransportMovementDetailsRequest(soap, 0, 0, "g2ba:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_g2ba__GetStockEntryVersionListResponse: return soap_in_g2ba__GetStockEntryVersionListResponse(soap, 0, 0, "g2ba:GetStockEntryVersionListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryVersionListRequest: return soap_in_g2ba__GetStockEntryVersionListRequest(soap, 0, 0, "g2ba:GetStockEntryVersionListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryListResponse: return soap_in_g2ba__GetStockEntryListResponse(soap, 0, 0, "g2ba:GetStockEntryListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryListRequest: return soap_in_g2ba__GetStockEntryListRequest(soap, 0, 0, "g2ba:GetStockEntryListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryChangesListResponse: return soap_in_g2ba__GetStockEntryChangesListResponse(soap, 0, 0, "g2ba:GetStockEntryChangesListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryChangesListRequest: return soap_in_g2ba__GetStockEntryChangesListRequest(soap, 0, 0, "g2ba:GetStockEntryChangesListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryByUuidResponse: return soap_in_g2ba__GetStockEntryByUuidResponse(soap, 0, 0, "g2ba:GetStockEntryByUuidResponse");
	case SOAP_TYPE_g2ba__GetStockEntryByUuidRequest: return soap_in_g2ba__GetStockEntryByUuidRequest(soap, 0, 0, "g2ba:GetStockEntryByUuidRequest");
	case SOAP_TYPE_g2ba__GetStockEntryByGuidResponse: return soap_in_g2ba__GetStockEntryByGuidResponse(soap, 0, 0, "g2ba:GetStockEntryByGuidResponse");
	case SOAP_TYPE_g2ba__GetStockEntryByGuidRequest: return soap_in_g2ba__GetStockEntryByGuidRequest(soap, 0, 0, "g2ba:GetStockEntryByGuidRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse: return soap_in_g2ba__GetVetDocumentChangesListResponse(soap, 0, 0, "g2ba:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest: return soap_in_g2ba__GetVetDocumentChangesListRequest(soap, 0, 0, "g2ba:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentListResponse: return soap_in_g2ba__GetVetDocumentListResponse(soap, 0, 0, "g2ba:GetVetDocumentListResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentListRequest: return soap_in_g2ba__GetVetDocumentListRequest(soap, 0, 0, "g2ba:GetVetDocumentListRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse: return soap_in_g2ba__GetVetDocumentByUuidResponse(soap, 0, 0, "g2ba:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest: return soap_in_g2ba__GetVetDocumentByUuidRequest(soap, 0, 0, "g2ba:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_g2ba__ModifyProducerStockListResponse: return soap_in_g2ba__ModifyProducerStockListResponse(soap, 0, 0, "g2ba:ModifyProducerStockListResponse");
	case SOAP_TYPE_g2ba__ModifyProducerStockListRequest: return soap_in_g2ba__ModifyProducerStockListRequest(soap, 0, 0, "g2ba:ModifyProducerStockListRequest");
	case SOAP_TYPE_g2ba__ResolveDiscrepancyResponse: return soap_in_g2ba__ResolveDiscrepancyResponse(soap, 0, 0, "g2ba:ResolveDiscrepancyResponse");
	case SOAP_TYPE_g2ba__ResolveDiscrepancyRequest: return soap_in_g2ba__ResolveDiscrepancyRequest(soap, 0, 0, "g2ba:ResolveDiscrepancyRequest");
	case SOAP_TYPE_g2ba__ModifyActivityLocationsResponse: return soap_in_g2ba__ModifyActivityLocationsResponse(soap, 0, 0, "g2ba:ModifyActivityLocationsResponse");
	case SOAP_TYPE_g2ba__ModifyActivityLocationsRequest: return soap_in_g2ba__ModifyActivityLocationsRequest(soap, 0, 0, "g2ba:ModifyActivityLocationsRequest");
	case SOAP_TYPE_g2ba__ModifyEnterpriseResponse: return soap_in_g2ba__ModifyEnterpriseResponse(soap, 0, 0, "g2ba:ModifyEnterpriseResponse");
	case SOAP_TYPE_g2ba__ModifyEnterpriseRequest: return soap_in_g2ba__ModifyEnterpriseRequest(soap, 0, 0, "g2ba:ModifyEnterpriseRequest");
	case SOAP_TYPE_g2ba__ModifyBusinessEntityResponse: return soap_in_g2ba__ModifyBusinessEntityResponse(soap, 0, 0, "g2ba:ModifyBusinessEntityResponse");
	case SOAP_TYPE_g2ba__ModifyBusinessEntityRequest: return soap_in_g2ba__ModifyBusinessEntityRequest(soap, 0, 0, "g2ba:ModifyBusinessEntityRequest");
	case SOAP_TYPE_g2ba__WithdrawVetDocumentResponse: return soap_in_g2ba__WithdrawVetDocumentResponse(soap, 0, 0, "g2ba:WithdrawVetDocumentResponse");
	case SOAP_TYPE_g2ba__WithdrawVetDocumentRequest: return soap_in_g2ba__WithdrawVetDocumentRequest(soap, 0, 0, "g2ba:WithdrawVetDocumentRequest");
	case SOAP_TYPE_g2ba__MergeStockEntriesResponse: return soap_in_g2ba__MergeStockEntriesResponse(soap, 0, 0, "g2ba:MergeStockEntriesResponse");
	case SOAP_TYPE_g2ba__MergeStockEntriesRequest: return soap_in_g2ba__MergeStockEntriesRequest(soap, 0, 0, "g2ba:MergeStockEntriesRequest");
	case SOAP_TYPE_g2ba__RegisterProductionOperationResponse: return soap_in_g2ba__RegisterProductionOperationResponse(soap, 0, 0, "g2ba:RegisterProductionOperationResponse");
	case SOAP_TYPE_g2ba__RegisterProductionOperationRequest: return soap_in_g2ba__RegisterProductionOperationRequest(soap, 0, 0, "g2ba:RegisterProductionOperationRequest");
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse: return soap_in_g2ba__PrepareOutgoingConsignmentResponse(soap, 0, 0, "g2ba:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest: return soap_in_g2ba__PrepareOutgoingConsignmentRequest(soap, 0, 0, "g2ba:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse: return soap_in_g2ba__ProcessIncomingConsignmentResponse(soap, 0, 0, "g2ba:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest: return soap_in_g2ba__ProcessIncomingConsignmentRequest(soap, 0, 0, "g2ba:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_g2ba__MercuryApplicationRequest: return soap_in_g2ba__MercuryApplicationRequest(soap, 0, 0, "g2ba:MercuryApplicationRequest");
	case SOAP_TYPE_xsd__base64Binary: return soap_in_xsd__base64Binary(soap, 0, 0, "xsd:base64Binary");
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListResponse: return soap_in_PointerTog2ba__GetApplicableUserAuthorityListResponse(soap, 0, 0, "g2ba:GetApplicableUserAuthorityListResponse");
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListRequest: return soap_in_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, 0, 0, "g2ba:GetApplicableUserAuthorityListRequest");
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserResponse: return soap_in_PointerTog2ba__UnbindBusinessEntityUserResponse(soap, 0, 0, "g2ba:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserRequest: return soap_in_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, 0, 0, "g2ba:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasResponse: return soap_in_PointerTog2ba__UpdateUserWorkingAreasResponse(soap, 0, 0, "g2ba:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasRequest: return soap_in_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, 0, 0, "g2ba:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesResponse: return soap_in_PointerTog2ba__UpdateUserAuthoritiesResponse(soap, 0, 0, "g2ba:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesRequest: return soap_in_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, 0, 0, "g2ba:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserResponse: return soap_in_PointerTog2ba__GetBusinessEntityUserResponse(soap, 0, 0, "g2ba:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserRequest: return soap_in_PointerTog2ba__GetBusinessEntityUserRequest(soap, 0, 0, "g2ba:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListResponse: return soap_in_PointerTog2ba__GetBusinessEntityUserListResponse(soap, 0, 0, "g2ba:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListRequest: return soap_in_PointerTog2ba__GetBusinessEntityUserListRequest(soap, 0, 0, "g2ba:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserResponse: return soap_in_PointerTog2ba__AddBusinessEntityUserResponse(soap, 0, 0, "g2ba:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserRequest: return soap_in_PointerTog2ba__AddBusinessEntityUserRequest(soap, 0, 0, "g2ba:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationResponse: return soap_in_PointerTog2ba__CheckShipmentRegionalizationResponse(soap, 0, 0, "g2ba:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationRequest: return soap_in_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, 0, 0, "g2ba:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsResponse: return soap_in_PointerTog2ba__UpdateVeterinaryEventsResponse(soap, 0, 0, "g2ba:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsRequest: return soap_in_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, 0, 0, "g2ba:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsResponse: return soap_in_PointerTog2ba__UpdateTransportMovementDetailsResponse(soap, 0, 0, "g2ba:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsRequest: return soap_in_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, 0, 0, "g2ba:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListResponse: return soap_in_PointerTog2ba__GetStockEntryVersionListResponse(soap, 0, 0, "g2ba:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListRequest: return soap_in_PointerTog2ba__GetStockEntryVersionListRequest(soap, 0, 0, "g2ba:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListResponse: return soap_in_PointerTog2ba__GetStockEntryChangesListResponse(soap, 0, 0, "g2ba:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListRequest: return soap_in_PointerTog2ba__GetStockEntryChangesListRequest(soap, 0, 0, "g2ba:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListResponse: return soap_in_PointerTog2ba__GetStockEntryListResponse(soap, 0, 0, "g2ba:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListRequest: return soap_in_PointerTog2ba__GetStockEntryListRequest(soap, 0, 0, "g2ba:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidResponse: return soap_in_PointerTog2ba__GetStockEntryByUuidResponse(soap, 0, 0, "g2ba:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidRequest: return soap_in_PointerTog2ba__GetStockEntryByUuidRequest(soap, 0, 0, "g2ba:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidResponse: return soap_in_PointerTog2ba__GetStockEntryByGuidResponse(soap, 0, 0, "g2ba:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidRequest: return soap_in_PointerTog2ba__GetStockEntryByGuidRequest(soap, 0, 0, "g2ba:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListResponse: return soap_in_PointerTog2ba__GetVetDocumentChangesListResponse(soap, 0, 0, "g2ba:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListRequest: return soap_in_PointerTog2ba__GetVetDocumentChangesListRequest(soap, 0, 0, "g2ba:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListResponse: return soap_in_PointerTog2ba__GetVetDocumentListResponse(soap, 0, 0, "g2ba:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListRequest: return soap_in_PointerTog2ba__GetVetDocumentListRequest(soap, 0, 0, "g2ba:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidResponse: return soap_in_PointerTog2ba__GetVetDocumentByUuidResponse(soap, 0, 0, "g2ba:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidRequest: return soap_in_PointerTog2ba__GetVetDocumentByUuidRequest(soap, 0, 0, "g2ba:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListResponse: return soap_in_PointerTog2ba__ModifyProducerStockListResponse(soap, 0, 0, "g2ba:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListRequest: return soap_in_PointerTog2ba__ModifyProducerStockListRequest(soap, 0, 0, "g2ba:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyResponse: return soap_in_PointerTog2ba__ResolveDiscrepancyResponse(soap, 0, 0, "g2ba:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyRequest: return soap_in_PointerTog2ba__ResolveDiscrepancyRequest(soap, 0, 0, "g2ba:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsResponse: return soap_in_PointerTog2ba__ModifyActivityLocationsResponse(soap, 0, 0, "g2ba:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsRequest: return soap_in_PointerTog2ba__ModifyActivityLocationsRequest(soap, 0, 0, "g2ba:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseResponse: return soap_in_PointerTog2ba__ModifyEnterpriseResponse(soap, 0, 0, "g2ba:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseRequest: return soap_in_PointerTog2ba__ModifyEnterpriseRequest(soap, 0, 0, "g2ba:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityResponse: return soap_in_PointerTog2ba__ModifyBusinessEntityResponse(soap, 0, 0, "g2ba:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityRequest: return soap_in_PointerTog2ba__ModifyBusinessEntityRequest(soap, 0, 0, "g2ba:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentResponse: return soap_in_PointerTog2ba__WithdrawVetDocumentResponse(soap, 0, 0, "g2ba:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentRequest: return soap_in_PointerTog2ba__WithdrawVetDocumentRequest(soap, 0, 0, "g2ba:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesResponse: return soap_in_PointerTog2ba__MergeStockEntriesResponse(soap, 0, 0, "g2ba:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesRequest: return soap_in_PointerTog2ba__MergeStockEntriesRequest(soap, 0, 0, "g2ba:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationResponse: return soap_in_PointerTog2ba__RegisterProductionOperationResponse(soap, 0, 0, "g2ba:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationRequest: return soap_in_PointerTog2ba__RegisterProductionOperationRequest(soap, 0, 0, "g2ba:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentResponse: return soap_in_PointerTog2ba__PrepareOutgoingConsignmentResponse(soap, 0, 0, "g2ba:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentRequest: return soap_in_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, 0, 0, "g2ba:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentResponse: return soap_in_PointerTog2ba__ProcessIncomingConsignmentResponse(soap, 0, 0, "g2ba:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentRequest: return soap_in_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, 0, 0, "g2ba:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: return soap_in_PointerTo_ws__receiveApplicationResultResponse(soap, 0, 0, "ws:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: return soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, 0, 0, "ws:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: return soap_in_PointerTo_ws__submitApplicationResponse(soap, 0, 0, "ws:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: return soap_in_PointerTo_ws__submitApplicationRequest(soap, 0, 0, "ws:submitApplicationRequest");
	case SOAP_TYPE_PointerTobase__FaultInfo: return soap_in_PointerTobase__FaultInfo(soap, 0, 0, "base:FaultInfo");
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: return soap_in_PointerTovd__StockEntryBlankFilter(soap, 0, 0, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTovd__StockEntryEventList: return soap_in_PointerTovd__StockEntryEventList(soap, 0, 0, "vd:StockEntryEventList");
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: return soap_in_PointerTovd__DiscrepancyReason(soap, 0, 0, "vd:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: return soap_in_PointerToPointerTovd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: return soap_in_PointerTovd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: return soap_in_PointerTovd__VeterinaryAuthentication(soap, 0, 0, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: return soap_in_PointerTovd__CertifiedConsignment(soap, 0, 0, "vd:CertifiedConsignment");
	case SOAP_TYPE_PointerTovd__CertifiedBatch: return soap_in_PointerTovd__CertifiedBatch(soap, 0, 0, "vd:CertifiedBatch");
	case SOAP_TYPE_PointerTovd__VetDocumentForm: return soap_in_PointerTovd__VetDocumentForm(soap, 0, 0, "vd:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationStatus: return soap_in_PointerToPointerTodic__RegionalizationStatus(soap, 0, 0, "dic:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerTodic__Area: return soap_in_PointerToPointerTodic__Area(soap, 0, 0, "dic:Area");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRequirement: return soap_in_PointerToPointerTodic__RegionalizationRequirement(soap, 0, 0, "dic:RegionalizationRequirement");
	case SOAP_TYPE_PointerTodic__RegionalizationRequirement: return soap_in_PointerTodic__RegionalizationRequirement(soap, 0, 0, "dic:RegionalizationRequirement");
	case SOAP_TYPE_PointerTodic__RegionalizationDecision: return soap_in_PointerTodic__RegionalizationDecision(soap, 0, 0, "dic:RegionalizationDecision");
	case SOAP_TYPE_PointerTodic__RegionalizationStatus: return soap_in_PointerTodic__RegionalizationStatus(soap, 0, 0, "dic:RegionalizationStatus");
	case SOAP_TYPE_PointerTodic__Packaging: return soap_in_PointerTodic__Packaging(soap, 0, 0, "dic:Packaging");
	case SOAP_TYPE_PointerToPointerTodic__ProductItemProducing: return soap_in_PointerToPointerTodic__ProductItemProducing(soap, 0, 0, "dic:ProductItemProducing");
	case SOAP_TYPE_PointerTodic__ProductItemProducing: return soap_in_PointerTodic__ProductItemProducing(soap, 0, 0, "dic:ProductItemProducing");
	case SOAP_TYPE_PointerTo_dic__BusinessEntity_activityLocation: return soap_in_PointerTo_dic__BusinessEntity_activityLocation(soap, 0, 0, "dic:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerTodic__IncorporationForm: return soap_in_PointerTodic__IncorporationForm(soap, 0, 0, "dic:IncorporationForm");
	case SOAP_TYPE_PointerTodic__BusinessEntityType: return soap_in_PointerTodic__BusinessEntityType(soap, 0, 0, "dic:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseOfficialRegistration: return soap_in_PointerToPointerTodic__EnterpriseOfficialRegistration(soap, 0, 0, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration: return soap_in_PointerTodic__EnterpriseOfficialRegistration(soap, 0, 0, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTodic__EnterpriseActivityList: return soap_in_PointerTodic__EnterpriseActivityList(soap, 0, 0, "dic:EnterpriseActivityList");
	case SOAP_TYPE_PointerTodic__EnterpriseNumberList: return soap_in_PointerTodic__EnterpriseNumberList(soap, 0, 0, "dic:EnterpriseNumberList");
	case SOAP_TYPE_PointerTodic__EnterpriseType: return soap_in_PointerTodic__EnterpriseType(soap, 0, 0, "dic:EnterpriseType");
	case SOAP_TYPE_PointerTodic__PackingCodeType: return soap_in_PointerTodic__PackingCodeType(soap, 0, 0, "dic:PackingCodeType");
	case SOAP_TYPE_PointerTobase__UUID: return soap_in_PointerTobase__UUID(soap, 0, 0, "base:UUID");
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: return soap_in_PointerTovd__StockEntrySearchPattern(soap, 0, 0, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTobase__DateInterval: return soap_in_PointerTobase__DateInterval(soap, 0, 0, "base:DateInterval");
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: return soap_in_PointerTovd__VetDocumentStatus(soap, 0, 0, "vd:VetDocumentStatus");
	case SOAP_TYPE_PointerTovd__VetDocumentType: return soap_in_PointerTovd__VetDocumentType(soap, 0, 0, "vd:VetDocumentType");
	case SOAP_TYPE_PointerTobase__ListOptions: return soap_in_PointerTobase__ListOptions(soap, 0, 0, "base:ListOptions");
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: return soap_in_PointerTovd__PSLModificationOperation(soap, 0, 0, "vd:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: return soap_in_PointerToPointerTovd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: return soap_in_PointerTovd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: return soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: return soap_in_PointerTovd__ENTModificationOperation(soap, 0, 0, "vd:ENTModificationOperation");
	case SOAP_TYPE_PointerTovd__BEModificationOperation: return soap_in_PointerTovd__BEModificationOperation(soap, 0, 0, "vd:BEModificationOperation");
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: return soap_in_PointerTovd__MergeStockEntriesOperation(soap, 0, 0, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTovd__ProductionOperation: return soap_in_PointerTovd__ProductionOperation(soap, 0, 0, "vd:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTovd__Delivery: return soap_in_PointerToPointerTovd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: return soap_in_PointerToPointerTovd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: return soap_in_PointerTovd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DeliveryFactList: return soap_in_PointerTovd__DeliveryFactList(soap, 0, 0, "vd:DeliveryFactList");
	case SOAP_TYPE_PointerTovd__Delivery: return soap_in_PointerTovd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: return soap_in_PointerToPointerTovd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingArea: return soap_in_PointerTovd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingAreaList: return soap_in_PointerTovd__WorkingAreaList(soap, 0, 0, "vd:WorkingAreaList");
	case SOAP_TYPE_PointerTovd__SNILSType: return soap_in_PointerTovd__SNILSType(soap, 0, 0, "vd:SNILSType");
	case SOAP_TYPE_PointerTovd__Citizenship: return soap_in_PointerTovd__Citizenship(soap, 0, 0, "vd:Citizenship");
	case SOAP_TYPE_PointerTodic__MedicinalDrug: return soap_in_PointerTodic__MedicinalDrug(soap, 0, 0, "dic:MedicinalDrug");
	case SOAP_TYPE_PointerTodic__Indicator: return soap_in_PointerTodic__Indicator(soap, 0, 0, "dic:Indicator");
	case SOAP_TYPE_PointerTodic__DocumentType: return soap_in_PointerTodic__DocumentType(soap, 0, 0, "dic:DocumentType");
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: return soap_in_PointerTovd__ConsignmentDocumentList(soap, 0, 0, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTovd__Consignment: return soap_in_PointerToPointerTovd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_PointerTovd__Consignment: return soap_in_PointerTovd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_PointerToPointerTodic__BusinessMember: return soap_in_PointerToPointerTodic__BusinessMember(soap, 0, 0, "dic:BusinessMember");
	case SOAP_TYPE_PointerToPointerTodic__ResearchMethod: return soap_in_PointerToPointerTodic__ResearchMethod(soap, 0, 0, "dic:ResearchMethod");
	case SOAP_TYPE_PointerTodic__ResearchMethod: return soap_in_PointerTodic__ResearchMethod(soap, 0, 0, "dic:ResearchMethod");
	case SOAP_TYPE_PointerToPointerTodic__AnimalDisease: return soap_in_PointerToPointerTodic__AnimalDisease(soap, 0, 0, "dic:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRegionStatus: return soap_in_PointerToPointerTodic__RegionalizationRegionStatus(soap, 0, 0, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerTodic__RegionalizationRegionStatus: return soap_in_PointerTodic__RegionalizationRegionStatus(soap, 0, 0, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerTodic__ProductItem: return soap_in_PointerToPointerTodic__ProductItem(soap, 0, 0, "dic:ProductItem");
	case SOAP_TYPE_PointerToPointerTodic__SubProduct: return soap_in_PointerToPointerTodic__SubProduct(soap, 0, 0, "dic:SubProduct");
	case SOAP_TYPE_PointerToPointerTodic__Product: return soap_in_PointerToPointerTodic__Product(soap, 0, 0, "dic:Product");
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseActivity: return soap_in_PointerToPointerTodic__EnterpriseActivity(soap, 0, 0, "dic:EnterpriseActivity");
	case SOAP_TYPE_PointerTodic__EnterpriseActivity: return soap_in_PointerTodic__EnterpriseActivity(soap, 0, 0, "dic:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerTodic__Street: return soap_in_PointerToPointerTodic__Street(soap, 0, 0, "dic:Street");
	case SOAP_TYPE_PointerToPointerTodic__Locality: return soap_in_PointerToPointerTodic__Locality(soap, 0, 0, "dic:Locality");
	case SOAP_TYPE_PointerToPointerTodic__District: return soap_in_PointerToPointerTodic__District(soap, 0, 0, "dic:District");
	case SOAP_TYPE_PointerToPointerTodic__Region: return soap_in_PointerToPointerTodic__Region(soap, 0, 0, "dic:Region");
	case SOAP_TYPE_PointerToPointerTodic__Country: return soap_in_PointerToPointerTodic__Country(soap, 0, 0, "dic:Country");
	case SOAP_TYPE_PointerToPointerTodic__Unit: return soap_in_PointerToPointerTodic__Unit(soap, 0, 0, "dic:Unit");
	case SOAP_TYPE_PointerToPointerTodic__Purpose: return soap_in_PointerToPointerTodic__Purpose(soap, 0, 0, "dic:Purpose");
	case SOAP_TYPE_PointerTobase__VersionStatus: return soap_in_PointerTobase__VersionStatus(soap, 0, 0, "base:VersionStatus");
	case SOAP_TYPE_PointerTovd__AuthorityList: return soap_in_PointerTovd__AuthorityList(soap, 0, 0, "vd:AuthorityList");
	case SOAP_TYPE_PointerTovd__UserList: return soap_in_PointerTovd__UserList(soap, 0, 0, "vd:UserList");
	case SOAP_TYPE_PointerToPointerTovd__User: return soap_in_PointerToPointerTovd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: return soap_in_PointerToPointerTovd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: return soap_in_PointerTovd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__VetDocumentList: return soap_in_PointerTovd__VetDocumentList(soap, 0, 0, "vd:VetDocumentList");
	case SOAP_TYPE_PointerToPointerTodic__Enterprise: return soap_in_PointerToPointerTodic__Enterprise(soap, 0, 0, "dic:Enterprise");
	case SOAP_TYPE_PointerToPointerTodic__BusinessEntity: return soap_in_PointerToPointerTodic__BusinessEntity(soap, 0, 0, "dic:BusinessEntity");
	case SOAP_TYPE_PointerTodic__OTPToken: return soap_in_PointerTodic__OTPToken(soap, 0, 0, "dic:OTPToken");
	case SOAP_TYPE_PointerToapp__Application: return soap_in_PointerToapp__Application(soap, 0, 0, "app:Application");
	case SOAP_TYPE_PointerTodic__Area: return soap_in_PointerTodic__Area(soap, 0, 0, "dic:Area");
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: return soap_in_PointerToPointerTovd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_PointerTovd__UserAuthority: return soap_in_PointerTovd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationShippingRule: return soap_in_PointerToPointerTodic__RegionalizationShippingRule(soap, 0, 0, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTodic__RegionalizationShippingRule: return soap_in_PointerTodic__RegionalizationShippingRule(soap, 0, 0, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTobase__SequenceNumber: return soap_in_PointerTobase__SequenceNumber(soap, 0, 0, "base:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: return soap_in_PointerToPointerTovd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: return soap_in_PointerToPointerTovd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerTovd__RegionalizationClause: return soap_in_PointerTovd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: return soap_in_PointerToPointerTovd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: return soap_in_PointerTovd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: return soap_in_PointerToPointerTovd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: return soap_in_PointerTovd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__QuarantineEvent: return soap_in_PointerTovd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: return soap_in_PointerToPointerTovd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: return soap_in_PointerTovd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: return soap_in_PointerTovd__AnimalSpentPeriod(soap, 0, 0, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_PointerTodic__ResearchResult: return soap_in_PointerTodic__ResearchResult(soap, 0, 0, "dic:ResearchResult");
	case SOAP_TYPE_PointerTodic__Purpose: return soap_in_PointerTodic__Purpose(soap, 0, 0, "dic:Purpose");
	case SOAP_TYPE_PointerToPointerTovd__Document: return soap_in_PointerToPointerTovd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_PointerTovd__Document: return soap_in_PointerTovd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_PointerTodic__Organization: return soap_in_PointerTodic__Organization(soap, 0, 0, "dic:Organization");
	case SOAP_TYPE_PointerTodic__Location: return soap_in_PointerTodic__Location(soap, 0, 0, "dic:Location");
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: return soap_in_PointerTovd__VeterinaryEventType(soap, 0, 0, "vd:VeterinaryEventType");
	case SOAP_TYPE_PointerTovd__ShipmentRoute: return soap_in_PointerTovd__ShipmentRoute(soap, 0, 0, "vd:ShipmentRoute");
	case SOAP_TYPE_PointerTodic__TransportationStorageType: return soap_in_PointerTodic__TransportationStorageType(soap, 0, 0, "dic:TransportationStorageType");
	case SOAP_TYPE_PointerTovd__TransportInfo: return soap_in_PointerTovd__TransportInfo(soap, 0, 0, "vd:TransportInfo");
	case SOAP_TYPE_PointerTovd__Batch: return soap_in_PointerTovd__Batch(soap, 0, 0, "vd:Batch");
	case SOAP_TYPE_PointerTodic__EnterpriseList: return soap_in_PointerTodic__EnterpriseList(soap, 0, 0, "dic:EnterpriseList");
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: return soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerTodic__BusinessEntityList: return soap_in_PointerTodic__BusinessEntityList(soap, 0, 0, "dic:BusinessEntityList");
	case SOAP_TYPE_PointerTodic__ProductItemList: return soap_in_PointerTodic__ProductItemList(soap, 0, 0, "dic:ProductItemList");
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: return soap_in_PointerToPointerTovd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_PointerTobase__RegisterModificationType: return soap_in_PointerTobase__RegisterModificationType(soap, 0, 0, "base:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: return soap_in_PointerToPointerTovd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: return soap_in_PointerTovd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: return soap_in_PointerToPointerTovd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerTovd__ProductiveBatch: return soap_in_PointerTovd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: return soap_in_PointerToPointerTovd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_PointerTovd__RawBatch: return soap_in_PointerTovd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: return soap_in_PointerToPointerTovd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: return soap_in_PointerTovd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__TransportNumber: return soap_in_PointerTovd__TransportNumber(soap, 0, 0, "vd:TransportNumber");
	case SOAP_TYPE_PointerTodic__TransportType: return soap_in_PointerTodic__TransportType(soap, 0, 0, "dic:TransportType");
	case SOAP_TYPE_PointerTovd__StockEntryList: return soap_in_PointerTovd__StockEntryList(soap, 0, 0, "vd:StockEntryList");
	case SOAP_TYPE_PointerTodic__ComplexDate: return soap_in_PointerTodic__ComplexDate(soap, 0, 0, "dic:ComplexDate");
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: return soap_in_PointerToPointerTovd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerTovd__ReferencedDocument: return soap_in_PointerTovd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: return soap_in_PointerToPointerTovd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__VetDocument: return soap_in_PointerTovd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__Waybill: return soap_in_PointerTovd__Waybill(soap, 0, 0, "vd:Waybill");
	case SOAP_TYPE_PointerTovd__User: return soap_in_PointerTovd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_PointerTovd__DeliveryInspection: return soap_in_PointerTovd__DeliveryInspection(soap, 0, 0, "vd:DeliveryInspection");
	case SOAP_TYPE_PointerTovd__StockEntry: return soap_in_PointerTovd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_PointerTodic__PackageList: return soap_in_PointerTodic__PackageList(soap, 0, 0, "dic:PackageList");
	case SOAP_TYPE_PointerTovd__BatchOrigin: return soap_in_PointerTovd__BatchOrigin(soap, 0, 0, "vd:BatchOrigin");
	case SOAP_TYPE_PointerTovd__GoodsDate: return soap_in_PointerTovd__GoodsDate(soap, 0, 0, "vd:GoodsDate");
	case SOAP_TYPE_PointerTodic__ProductItem: return soap_in_PointerTodic__ProductItem(soap, 0, 0, "dic:ProductItem");
	case SOAP_TYPE_PointerTodic__SubProduct: return soap_in_PointerTodic__SubProduct(soap, 0, 0, "dic:SubProduct");
	case SOAP_TYPE_PointerTodic__Product: return soap_in_PointerTodic__Product(soap, 0, 0, "dic:Product");
	case SOAP_TYPE_PointerTodic__ProductType: return soap_in_PointerTodic__ProductType(soap, 0, 0, "dic:ProductType");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationConditionGroup: return soap_in_PointerToPointerTodic__RegionalizationConditionGroup(soap, 0, 0, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTodic__RegionalizationConditionGroup: return soap_in_PointerTodic__RegionalizationConditionGroup(soap, 0, 0, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTodic__AnimalDisease: return soap_in_PointerTodic__AnimalDisease(soap, 0, 0, "dic:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationCondition: return soap_in_PointerToPointerTodic__RegionalizationCondition(soap, 0, 0, "dic:RegionalizationCondition");
	case SOAP_TYPE_PointerTodic__RegionalizationCondition: return soap_in_PointerTodic__RegionalizationCondition(soap, 0, 0, "dic:RegionalizationCondition");
	case SOAP_TYPE_PointerTodic__BusinessMember: return soap_in_PointerTodic__BusinessMember(soap, 0, 0, "dic:BusinessMember");
	case SOAP_TYPE_PointerTobase__Identifier: return soap_in_PointerTobase__Identifier(soap, 0, 0, "base:Identifier");
	case SOAP_TYPE_PointerTodic__Address: return soap_in_PointerTodic__Address(soap, 0, 0, "dic:Address");
	case SOAP_TYPE_PointerTodic__Unit: return soap_in_PointerTodic__Unit(soap, 0, 0, "dic:Unit");
	case SOAP_TYPE_PointerTobase__Decimal: return soap_in_PointerTobase__Decimal(soap, 0, 0, "base:Decimal");
	case SOAP_TYPE_PointerTodic__Minute: return soap_in_PointerTodic__Minute(soap, 0, 0, "dic:Minute");
	case SOAP_TYPE_PointerTodic__Hour: return soap_in_PointerTodic__Hour(soap, 0, 0, "dic:Hour");
	case SOAP_TYPE_PointerTodic__Day: return soap_in_PointerTodic__Day(soap, 0, 0, "dic:Day");
	case SOAP_TYPE_PointerTodic__Month: return soap_in_PointerTodic__Month(soap, 0, 0, "dic:Month");
	case SOAP_TYPE_PointerTodic__Year: return soap_in_PointerTodic__Year(soap, 0, 0, "dic:Year");
	case SOAP_TYPE_PointerToPointerTodic__Package: return soap_in_PointerToPointerTodic__Package(soap, 0, 0, "dic:Package");
	case SOAP_TYPE_PointerTodic__Package: return soap_in_PointerTodic__Package(soap, 0, 0, "dic:Package");
	case SOAP_TYPE_PointerToPointerTodic__ProductMarks: return soap_in_PointerToPointerTodic__ProductMarks(soap, 0, 0, "dic:ProductMarks");
	case SOAP_TYPE_PointerTodic__ProductMarks: return soap_in_PointerTodic__ProductMarks(soap, 0, 0, "dic:ProductMarks");
	case SOAP_TYPE_PointerTodic__PackingType: return soap_in_PointerTodic__PackingType(soap, 0, 0, "dic:PackingType");
	case SOAP_TYPE_PointerTodic__GLNType: return soap_in_PointerTodic__GLNType(soap, 0, 0, "dic:GLNType");
	case SOAP_TYPE_PointerTodic__BusinessEntity: return soap_in_PointerTodic__BusinessEntity(soap, 0, 0, "dic:BusinessEntity");
	case SOAP_TYPE_PointerTobase__String255: return soap_in_PointerTobase__String255(soap, 0, 0, "base:String255");
	case SOAP_TYPE_PointerToPointerTodic__Producer: return soap_in_PointerToPointerTodic__Producer(soap, 0, 0, "dic:Producer");
	case SOAP_TYPE_PointerTodic__Producer: return soap_in_PointerTodic__Producer(soap, 0, 0, "dic:Producer");
	case SOAP_TYPE_PointerTodic__EnterpriseRole: return soap_in_PointerTodic__EnterpriseRole(soap, 0, 0, "dic:EnterpriseRole");
	case SOAP_TYPE_PointerTodic__Enterprise: return soap_in_PointerTodic__Enterprise(soap, 0, 0, "dic:Enterprise");
	case SOAP_TYPE_PointerTobase__NText: return soap_in_PointerTobase__NText(soap, 0, 0, "base:NText");
	case SOAP_TYPE_PointerTodic__Street: return soap_in_PointerTodic__Street(soap, 0, 0, "dic:Street");
	case SOAP_TYPE_PointerTodic__Locality: return soap_in_PointerTodic__Locality(soap, 0, 0, "dic:Locality");
	case SOAP_TYPE_PointerTodic__District: return soap_in_PointerTodic__District(soap, 0, 0, "dic:District");
	case SOAP_TYPE_PointerTodic__Region: return soap_in_PointerTodic__Region(soap, 0, 0, "dic:Region");
	case SOAP_TYPE_PointerTodic__FederalDistrict: return soap_in_PointerTodic__FederalDistrict(soap, 0, 0, "dic:FederalDistrict");
	case SOAP_TYPE_PointerTodic__Country: return soap_in_PointerTodic__Country(soap, 0, 0, "dic:Country");
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: return soap_in_PointerToPointerToapp__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__BusinessError: return soap_in_PointerToapp__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__ContentEncoding: return soap_in_PointerToapp__ContentEncoding(soap, 0, 0, "app:ContentEncoding");
	case SOAP_TYPE_PointerToapp__BusinessErrorList: return soap_in_PointerToapp__BusinessErrorList(soap, 0, 0, "app:BusinessErrorList");
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: return soap_in_PointerToapp__ApplicationResultWrapper(soap, 0, 0, "app:ApplicationResultWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: return soap_in_PointerToapp__ApplicationDataWrapper(soap, 0, 0, "app:ApplicationDataWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationStatus: return soap_in_PointerToapp__ApplicationStatus(soap, 0, 0, "app:ApplicationStatus");
	case SOAP_TYPE_PointerTobase__Hour: return soap_in_PointerTobase__Hour(soap, 0, 0, "base:Hour");
	case SOAP_TYPE_PointerTobase__Day: return soap_in_PointerTobase__Day(soap, 0, 0, "base:Day");
	case SOAP_TYPE_PointerTobase__Month: return soap_in_PointerTobase__Month(soap, 0, 0, "base:Month");
	case SOAP_TYPE_PointerTobase__Year: return soap_in_PointerTobase__Year(soap, 0, 0, "base:Year");
	case SOAP_TYPE_PointerToPointerTobase__Error: return soap_in_PointerToPointerTobase__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_PointerTobase__Error: return soap_in_PointerTobase__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_PointerTobool: return soap_in_PointerTobool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_in_PointerToLONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_in_PointerToint(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_in_PointerTotime(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason:
	{
		char ** s = soap_in_vd__VetDocumentStatusChangeReason(soap, 0, 0, "vd:VetDocumentStatusChangeReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__GRNType:
	{
		char ** s = soap_in_dic__GRNType(soap, 0, 0, "dic:GRNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_vd__SNILSType:
	{
		char ** s = soap_in_vd__SNILSType(soap, 0, 0, "vd:SNILSType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_vd__StockEntryNumber:
	{
		char ** s = soap_in_vd__StockEntryNumber(soap, 0, 0, "vd:StockEntryNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__OTPToken:
	{
		char ** s = soap_in_dic__OTPToken(soap, 0, 0, "dic:OTPToken");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__GTINType:
	{
		char ** s = soap_in_dic__GTINType(soap, 0, 0, "dic:GTINType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__GLNType:
	{
		char ** s = soap_in_dic__GLNType(soap, 0, 0, "dic:GLNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__ENTModificationReason:
	{
		char ** s = soap_in_dic__ENTModificationReason(soap, 0, 0, "dic:ENTModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__BEModificationReason:
	{
		char ** s = soap_in_dic__BEModificationReason(soap, 0, 0, "dic:BEModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__EnterpriseType:
	{
		char ** s = soap_in_dic__EnterpriseType(soap, 0, 0, "dic:EnterpriseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__Code3:
	{
		char ** s = soap_in_dic__Code3(soap, 0, 0, "dic:Code3");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_dic__Code:
	{
		char ** s = soap_in_dic__Code(soap, 0, 0, "dic:Code");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_app__APIKey:
	{
		char ** s = soap_in_app__APIKey(soap, 0, 0, "app:APIKey");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__SequenceNumber:
	{
		char ** s = soap_in_base__SequenceNumber(soap, 0, 0, "base:SequenceNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Identifier:
	{
		char ** s = soap_in_base__Identifier(soap, 0, 0, "base:Identifier");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__VersionStatus:
	{
		char ** s = soap_in_base__VersionStatus(soap, 0, 0, "base:VersionStatus");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Decimal:
	{
		char ** s = soap_in_base__Decimal(soap, 0, 0, "base:Decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__String32:
	{
		char ** s = soap_in_base__String32(soap, 0, 0, "base:String32");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__String255:
	{
		char ** s = soap_in_base__String255(soap, 0, 0, "base:String255");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__NText:
	{
		char ** s = soap_in_base__NText(soap, 0, 0, "base:NText");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Text:
	{
		char ** s = soap_in_base__Text(soap, 0, 0, "base:Text");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__UUID:
	{
		char ** s = soap_in_base__UUID(soap, 0, 0, "base:UUID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{
		char ** s = soap_in_xsd__token(soap, 0, 0, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__positiveInteger:
	{
		char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, "xsd:positiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{
		char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{
		char ** s = soap_in_xsd__integer(soap, 0, 0, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{
		char ** s = soap_in_xsd__decimal(soap, 0, 0, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{
		char ** s = soap_in_xsd__date(soap, 0, 0, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte: return soap_in_PointerTounsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name:
	{
		char ** s = soap_in_xsd__Name(soap, 0, 0, "xsd:Name");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{
		char ** s = soap_in_xsd__NCName(soap, 0, 0, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__IDREF:
	{
		char ** s = soap_in_xsd__IDREF(soap, 0, 0, "xsd:IDREF");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{
		char ** s = soap_in_xsd__ID(soap, 0, 0, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{
		char ** s = soap_in__QName(soap, 0, 0, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{
		char ** s = soap_in_string(soap, 0, 0, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if(!*t)
			t = soap->tag;
		if(!soap_match_tag(soap, t, "app:BinaryContent")) { *type = SOAP_TYPE_app__BinaryContent; return soap_in_app__BinaryContent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Citizenship")) { *type = SOAP_TYPE_vd__Citizenship; return soap_in_vd__Citizenship(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:WorkingArea")) { *type = SOAP_TYPE_vd__WorkingArea; return soap_in_vd__WorkingArea(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:UserAuthority")) { *type = SOAP_TYPE_vd__UserAuthority; return soap_in_vd__UserAuthority(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:WorkingAreaList")) { *type = SOAP_TYPE_vd__WorkingAreaList; return soap_in_vd__WorkingAreaList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AuthorityList")) { *type = SOAP_TYPE_vd__AuthorityList; return soap_in_vd__AuthorityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:UserList")) { *type = SOAP_TYPE_vd__UserList; return soap_in_vd__UserList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:User")) { *type = SOAP_TYPE_vd__User; return soap_in_vd__User(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProcessingProcedure")) { *type = SOAP_TYPE_vd__ProcessingProcedure; return soap_in_vd__ProcessingProcedure(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RouteSectionR13nRules")) { *type = SOAP_TYPE_vd__RouteSectionR13nRules; return soap_in_vd__RouteSectionR13nRules(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RegionalizationClause")) { *type = SOAP_TYPE_vd__RegionalizationClause; return soap_in_vd__RegionalizationClause(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatusChange")) { *type = SOAP_TYPE_vd__VetDocumentStatusChange; return soap_in_vd__VetDocumentStatusChange(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryEventList")) { *type = SOAP_TYPE_vd__StockEntryEventList; return soap_in_vd__StockEntryEventList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BatchOrigin")) { *type = SOAP_TYPE_vd__BatchOrigin; return soap_in_vd__BatchOrigin(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryAuthentication")) { *type = SOAP_TYPE_vd__VeterinaryAuthentication; return soap_in_vd__VeterinaryAuthentication(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:QuarantineEvent")) { *type = SOAP_TYPE_vd__QuarantineEvent; return soap_in_vd__QuarantineEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AnimalMedicationEvent")) { *type = SOAP_TYPE_vd__AnimalMedicationEvent; return soap_in_vd__AnimalMedicationEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:LaboratoryResearchEvent")) { *type = SOAP_TYPE_vd__LaboratoryResearchEvent; return soap_in_vd__LaboratoryResearchEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryEvent")) { *type = SOAP_TYPE_vd__VeterinaryEvent; return soap_in_vd__VeterinaryEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ReferencedDocument")) { *type = SOAP_TYPE_vd__ReferencedDocument; return soap_in_vd__ReferencedDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:CertifiedConsignment")) { *type = SOAP_TYPE_vd__CertifiedConsignment; return soap_in_vd__CertifiedConsignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:CertifiedBatch")) { *type = SOAP_TYPE_vd__CertifiedBatch; return soap_in_vd__CertifiedBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ENTModificationOperation")) { *type = SOAP_TYPE_vd__ENTModificationOperation; return soap_in_vd__ENTModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEActivityLocationsModificationOperation")) { *type = SOAP_TYPE_vd__BEActivityLocationsModificationOperation; return soap_in_vd__BEActivityLocationsModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEModificationOperation")) { *type = SOAP_TYPE_vd__BEModificationOperation; return soap_in_vd__BEModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:PSLModificationOperation")) { *type = SOAP_TYPE_vd__PSLModificationOperation; return soap_in_vd__PSLModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:MergeStockEntriesOperation")) { *type = SOAP_TYPE_vd__MergeStockEntriesOperation; return soap_in_vd__MergeStockEntriesOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProductionOperation")) { *type = SOAP_TYPE_vd__ProductionOperation; return soap_in_vd__ProductionOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ShipmentRoute")) { *type = SOAP_TYPE_vd__ShipmentRoute; return soap_in_vd__ShipmentRoute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ShipmentRoutePoint")) { *type = SOAP_TYPE_vd__ShipmentRoutePoint; return soap_in_vd__ShipmentRoutePoint(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:TransportNumber")) { *type = SOAP_TYPE_vd__TransportNumber; return soap_in_vd__TransportNumber(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:TransportInfo")) { *type = SOAP_TYPE_vd__TransportInfo; return soap_in_vd__TransportInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Waybill")) { *type = SOAP_TYPE_vd__Waybill; return soap_in_vd__Waybill(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Document")) { *type = SOAP_TYPE_vd__Document; return soap_in_vd__Document(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntrySearchPattern")) { *type = SOAP_TYPE_vd__StockEntrySearchPattern; return soap_in_vd__StockEntrySearchPattern(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockDiscrepancy")) { *type = SOAP_TYPE_vd__StockDiscrepancy; return soap_in_vd__StockDiscrepancy(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryList")) { *type = SOAP_TYPE_vd__StockEntryList; return soap_in_vd__StockEntryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntry")) { *type = SOAP_TYPE_vd__StockEntry; return soap_in_vd__StockEntry(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DiscrepancyReason")) { *type = SOAP_TYPE_vd__DiscrepancyReason; return soap_in_vd__DiscrepancyReason(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DiscrepancyReport")) { *type = SOAP_TYPE_vd__DiscrepancyReport; return soap_in_vd__DiscrepancyReport(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentList")) { *type = SOAP_TYPE_vd__VetDocumentList; return soap_in_vd__VetDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:GoodsDate")) { *type = SOAP_TYPE_vd__GoodsDate; return soap_in_vd__GoodsDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ConsignmentDocumentList")) { *type = SOAP_TYPE_vd__ConsignmentDocumentList; return soap_in_vd__ConsignmentDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryInspection")) { *type = SOAP_TYPE_vd__DeliveryInspection; return soap_in_vd__DeliveryInspection(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryFactList")) { *type = SOAP_TYPE_vd__DeliveryFactList; return soap_in_vd__DeliveryFactList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Delivery")) { *type = SOAP_TYPE_vd__Delivery; return soap_in_vd__Delivery(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProductiveBatch")) { *type = SOAP_TYPE_vd__ProductiveBatch; return soap_in_vd__ProductiveBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RawBatch")) { *type = SOAP_TYPE_vd__RawBatch; return soap_in_vd__RawBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Consignment")) { *type = SOAP_TYPE_vd__Consignment; return soap_in_vd__Consignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Batch")) { *type = SOAP_TYPE_vd__Batch; return soap_in_vd__Batch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocument")) { *type = SOAP_TYPE_vd__VetDocument; return soap_in_vd__VetDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ActivityLocationList")) { *type = SOAP_TYPE_dic__ActivityLocationList; return soap_in_dic__ActivityLocationList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ResearchMethodList")) { *type = SOAP_TYPE_dic__ResearchMethodList; return soap_in_dic__ResearchMethodList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:AnimalDiseaseList")) { *type = SOAP_TYPE_dic__AnimalDiseaseList; return soap_in_dic__AnimalDiseaseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationShippingRuleList")) { *type = SOAP_TYPE_dic__RegionalizationShippingRuleList; return soap_in_dic__RegionalizationShippingRuleList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationRegionStatusList")) { *type = SOAP_TYPE_dic__RegionalizationRegionStatusList; return soap_in_dic__RegionalizationRegionStatusList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationConditionList")) { *type = SOAP_TYPE_dic__RegionalizationConditionList; return soap_in_dic__RegionalizationConditionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Area")) { *type = SOAP_TYPE_dic__Area; return soap_in_dic__Area(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationRegionStatus")) { *type = SOAP_TYPE_dic__RegionalizationRegionStatus; return soap_in_dic__RegionalizationRegionStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationStatus")) { *type = SOAP_TYPE_dic__RegionalizationStatus; return soap_in_dic__RegionalizationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationShippingRule")) { *type = SOAP_TYPE_dic__RegionalizationShippingRule; return soap_in_dic__RegionalizationShippingRule(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationRequirement")) { *type = SOAP_TYPE_dic__RegionalizationRequirement; return soap_in_dic__RegionalizationRequirement(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationConditionGroup")) { *type = SOAP_TYPE_dic__RegionalizationConditionGroup; return soap_in_dic__RegionalizationConditionGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationCondition")) { *type = SOAP_TYPE_dic__RegionalizationCondition; return soap_in_dic__RegionalizationCondition(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:MedicinalDrug")) { *type = SOAP_TYPE_dic__MedicinalDrug; return soap_in_dic__MedicinalDrug(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ResearchMethod")) { *type = SOAP_TYPE_dic__ResearchMethod; return soap_in_dic__ResearchMethod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:AnimalDisease")) { *type = SOAP_TYPE_dic__AnimalDisease; return soap_in_dic__AnimalDisease(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Indicator")) { *type = SOAP_TYPE_dic__Indicator; return soap_in_dic__Indicator(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Organization")) { *type = SOAP_TYPE_dic__Organization; return soap_in_dic__Organization(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseOfficialRegistration")) { *type = SOAP_TYPE_dic__EnterpriseOfficialRegistration; return soap_in_dic__EnterpriseOfficialRegistration(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Location")) { *type = SOAP_TYPE_dic__Location; return soap_in_dic__Location(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Packaging")) { *type = SOAP_TYPE_dic__Packaging; return soap_in_dic__Packaging(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductItemProducing")) { *type = SOAP_TYPE_dic__ProductItemProducing; return soap_in_dic__ProductItemProducing(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ComplexDate")) { *type = SOAP_TYPE_dic__ComplexDate; return soap_in_dic__ComplexDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:PackageList")) { *type = SOAP_TYPE_dic__PackageList; return soap_in_dic__PackageList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Package")) { *type = SOAP_TYPE_dic__Package; return soap_in_dic__Package(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductMarks")) { *type = SOAP_TYPE_dic__ProductMarks; return soap_in_dic__ProductMarks(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductItemList")) { *type = SOAP_TYPE_dic__ProductItemList; return soap_in_dic__ProductItemList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:SubProductList")) { *type = SOAP_TYPE_dic__SubProductList; return soap_in_dic__SubProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductList")) { *type = SOAP_TYPE_dic__ProductList; return soap_in_dic__ProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:SubProduct")) { *type = SOAP_TYPE_dic__SubProduct; return soap_in_dic__SubProduct(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Product")) { *type = SOAP_TYPE_dic__Product; return soap_in_dic__Product(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductItem")) { *type = SOAP_TYPE_dic__ProductItem; return soap_in_dic__ProductItem(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:BusinessEntityList")) { *type = SOAP_TYPE_dic__BusinessEntityList; return soap_in_dic__BusinessEntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:IncorporationForm")) { *type = SOAP_TYPE_dic__IncorporationForm; return soap_in_dic__IncorporationForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:BusinessEntity")) { *type = SOAP_TYPE_dic__BusinessEntity; return soap_in_dic__BusinessEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:BusinessMember")) { *type = SOAP_TYPE_dic__BusinessMember; return soap_in_dic__BusinessMember(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseList")) { *type = SOAP_TYPE_dic__EnterpriseList; return soap_in_dic__EnterpriseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseNumberList")) { *type = SOAP_TYPE_dic__EnterpriseNumberList; return soap_in_dic__EnterpriseNumberList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProducerList")) { *type = SOAP_TYPE_dic__ProducerList; return soap_in_dic__ProducerList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Producer")) { *type = SOAP_TYPE_dic__Producer; return soap_in_dic__Producer(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseActivity")) { *type = SOAP_TYPE_dic__EnterpriseActivity; return soap_in_dic__EnterpriseActivity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseActivityList")) { *type = SOAP_TYPE_dic__EnterpriseActivityList; return soap_in_dic__EnterpriseActivityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Enterprise")) { *type = SOAP_TYPE_dic__Enterprise; return soap_in_dic__Enterprise(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:StreetList")) { *type = SOAP_TYPE_dic__StreetList; return soap_in_dic__StreetList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:LocalityList")) { *type = SOAP_TYPE_dic__LocalityList; return soap_in_dic__LocalityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:DistrictList")) { *type = SOAP_TYPE_dic__DistrictList; return soap_in_dic__DistrictList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionList")) { *type = SOAP_TYPE_dic__RegionList; return soap_in_dic__RegionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:CountryList")) { *type = SOAP_TYPE_dic__CountryList; return soap_in_dic__CountryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Address")) { *type = SOAP_TYPE_dic__Address; return soap_in_dic__Address(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Street")) { *type = SOAP_TYPE_dic__Street; return soap_in_dic__Street(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Locality")) { *type = SOAP_TYPE_dic__Locality; return soap_in_dic__Locality(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:District")) { *type = SOAP_TYPE_dic__District; return soap_in_dic__District(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Region")) { *type = SOAP_TYPE_dic__Region; return soap_in_dic__Region(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:AddressObjectView")) { *type = SOAP_TYPE_dic__AddressObjectView; return soap_in_dic__AddressObjectView(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:FederalDistrict")) { *type = SOAP_TYPE_dic__FederalDistrict; return soap_in_dic__FederalDistrict(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Country")) { *type = SOAP_TYPE_dic__Country; return soap_in_dic__Country(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:UnitList")) { *type = SOAP_TYPE_dic__UnitList; return soap_in_dic__UnitList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:PurposeList")) { *type = SOAP_TYPE_dic__PurposeList; return soap_in_dic__PurposeList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:PackingType")) { *type = SOAP_TYPE_dic__PackingType; return soap_in_dic__PackingType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Unit")) { *type = SOAP_TYPE_dic__Unit; return soap_in_dic__Unit(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Purpose")) { *type = SOAP_TYPE_dic__Purpose; return soap_in_dic__Purpose(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:BusinessError")) { *type = SOAP_TYPE_app__BusinessError; return soap_in_app__BusinessError(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:BusinessErrorList")) { *type = SOAP_TYPE_app__BusinessErrorList; return soap_in_app__BusinessErrorList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationResultData")) { *type = SOAP_TYPE_app__ApplicationResultData; return soap_in_app__ApplicationResultData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationData")) { *type = SOAP_TYPE_app__ApplicationData; return soap_in_app__ApplicationData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationResultWrapper")) { *type = SOAP_TYPE_app__ApplicationResultWrapper; return soap_in_app__ApplicationResultWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationDataWrapper")) { *type = SOAP_TYPE_app__ApplicationDataWrapper; return soap_in_app__ApplicationDataWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:Application")) { *type = SOAP_TYPE_app__Application; return soap_in_app__Application(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:ComplexDate")) { *type = SOAP_TYPE_base__ComplexDate; return soap_in_base__ComplexDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Error")) { *type = SOAP_TYPE_base__Error; return soap_in_base__Error(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:FaultInfo")) { *type = SOAP_TYPE_base__FaultInfo; return soap_in_base__FaultInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:EntityList")) { *type = SOAP_TYPE_base__EntityList; return soap_in_base__EntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:DateInterval")) { *type = SOAP_TYPE_base__DateInterval; return soap_in_base__DateInterval(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:ListOptions")) { *type = SOAP_TYPE_base__ListOptions; return soap_in_base__ListOptions(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:GenericVersioningEntity")) { *type = SOAP_TYPE_base__GenericVersioningEntity; return soap_in_base__GenericVersioningEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:GenericEntity")) { *type = SOAP_TYPE_base__GenericEntity; return soap_in_base__GenericEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetApplicableUserAuthorityListResponse")) { *type = SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse; return soap_in_g2ba__GetApplicableUserAuthorityListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetApplicableUserAuthorityListRequest")) { *type = SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest; return soap_in_g2ba__GetApplicableUserAuthorityListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UnbindBusinessEntityUserResponse")) { *type = SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse; return soap_in_g2ba__UnbindBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UnbindBusinessEntityUserRequest")) { *type = SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest; return soap_in_g2ba__UnbindBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateUserWorkingAreasResponse")) { *type = SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse; return soap_in_g2ba__UpdateUserWorkingAreasResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateUserWorkingAreasRequest")) { *type = SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest; return soap_in_g2ba__UpdateUserWorkingAreasRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateUserAuthoritiesResponse")) { *type = SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse; return soap_in_g2ba__UpdateUserAuthoritiesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateUserAuthoritiesRequest")) { *type = SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest; return soap_in_g2ba__UpdateUserAuthoritiesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetBusinessEntityUserResponse")) { *type = SOAP_TYPE_g2ba__GetBusinessEntityUserResponse; return soap_in_g2ba__GetBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetBusinessEntityUserRequest")) { *type = SOAP_TYPE_g2ba__GetBusinessEntityUserRequest; return soap_in_g2ba__GetBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetBusinessEntityUserListResponse")) { *type = SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse; return soap_in_g2ba__GetBusinessEntityUserListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetBusinessEntityUserListRequest")) { *type = SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest; return soap_in_g2ba__GetBusinessEntityUserListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:AddBusinessEntityUserResponse")) { *type = SOAP_TYPE_g2ba__AddBusinessEntityUserResponse; return soap_in_g2ba__AddBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:AddBusinessEntityUserRequest")) { *type = SOAP_TYPE_g2ba__AddBusinessEntityUserRequest; return soap_in_g2ba__AddBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:CheckShipmentRegionalizationResponse")) { *type = SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse; return soap_in_g2ba__CheckShipmentRegionalizationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:CheckShipmentRegionalizationRequest")) { *type = SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest; return soap_in_g2ba__CheckShipmentRegionalizationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateVeterinaryEventsResponse")) { *type = SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse; return soap_in_g2ba__UpdateVeterinaryEventsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateVeterinaryEventsRequest")) { *type = SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest; return soap_in_g2ba__UpdateVeterinaryEventsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateTransportMovementDetailsResponse")) { *type = SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse; return soap_in_g2ba__UpdateTransportMovementDetailsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:UpdateTransportMovementDetailsRequest")) { *type = SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest; return soap_in_g2ba__UpdateTransportMovementDetailsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryVersionListResponse")) { *type = SOAP_TYPE_g2ba__GetStockEntryVersionListResponse; return soap_in_g2ba__GetStockEntryVersionListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryVersionListRequest")) { *type = SOAP_TYPE_g2ba__GetStockEntryVersionListRequest; return soap_in_g2ba__GetStockEntryVersionListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryListResponse")) { *type = SOAP_TYPE_g2ba__GetStockEntryListResponse; return soap_in_g2ba__GetStockEntryListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryListRequest")) { *type = SOAP_TYPE_g2ba__GetStockEntryListRequest; return soap_in_g2ba__GetStockEntryListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryChangesListResponse")) { *type = SOAP_TYPE_g2ba__GetStockEntryChangesListResponse; return soap_in_g2ba__GetStockEntryChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryChangesListRequest")) { *type = SOAP_TYPE_g2ba__GetStockEntryChangesListRequest; return soap_in_g2ba__GetStockEntryChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryByUuidResponse")) { *type = SOAP_TYPE_g2ba__GetStockEntryByUuidResponse; return soap_in_g2ba__GetStockEntryByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryByUuidRequest")) { *type = SOAP_TYPE_g2ba__GetStockEntryByUuidRequest; return soap_in_g2ba__GetStockEntryByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryByGuidResponse")) { *type = SOAP_TYPE_g2ba__GetStockEntryByGuidResponse; return soap_in_g2ba__GetStockEntryByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetStockEntryByGuidRequest")) { *type = SOAP_TYPE_g2ba__GetStockEntryByGuidRequest; return soap_in_g2ba__GetStockEntryByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentChangesListResponse")) { *type = SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse; return soap_in_g2ba__GetVetDocumentChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentChangesListRequest")) { *type = SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest; return soap_in_g2ba__GetVetDocumentChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentListResponse")) { *type = SOAP_TYPE_g2ba__GetVetDocumentListResponse; return soap_in_g2ba__GetVetDocumentListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentListRequest")) { *type = SOAP_TYPE_g2ba__GetVetDocumentListRequest; return soap_in_g2ba__GetVetDocumentListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentByUuidResponse")) { *type = SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse; return soap_in_g2ba__GetVetDocumentByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:GetVetDocumentByUuidRequest")) { *type = SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest; return soap_in_g2ba__GetVetDocumentByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyProducerStockListResponse")) { *type = SOAP_TYPE_g2ba__ModifyProducerStockListResponse; return soap_in_g2ba__ModifyProducerStockListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyProducerStockListRequest")) { *type = SOAP_TYPE_g2ba__ModifyProducerStockListRequest; return soap_in_g2ba__ModifyProducerStockListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ResolveDiscrepancyResponse")) { *type = SOAP_TYPE_g2ba__ResolveDiscrepancyResponse; return soap_in_g2ba__ResolveDiscrepancyResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ResolveDiscrepancyRequest")) { *type = SOAP_TYPE_g2ba__ResolveDiscrepancyRequest; return soap_in_g2ba__ResolveDiscrepancyRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyActivityLocationsResponse")) { *type = SOAP_TYPE_g2ba__ModifyActivityLocationsResponse; return soap_in_g2ba__ModifyActivityLocationsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyActivityLocationsRequest")) { *type = SOAP_TYPE_g2ba__ModifyActivityLocationsRequest; return soap_in_g2ba__ModifyActivityLocationsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyEnterpriseResponse")) { *type = SOAP_TYPE_g2ba__ModifyEnterpriseResponse; return soap_in_g2ba__ModifyEnterpriseResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyEnterpriseRequest")) { *type = SOAP_TYPE_g2ba__ModifyEnterpriseRequest; return soap_in_g2ba__ModifyEnterpriseRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyBusinessEntityResponse")) { *type = SOAP_TYPE_g2ba__ModifyBusinessEntityResponse; return soap_in_g2ba__ModifyBusinessEntityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ModifyBusinessEntityRequest")) { *type = SOAP_TYPE_g2ba__ModifyBusinessEntityRequest; return soap_in_g2ba__ModifyBusinessEntityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:WithdrawVetDocumentResponse")) { *type = SOAP_TYPE_g2ba__WithdrawVetDocumentResponse; return soap_in_g2ba__WithdrawVetDocumentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:WithdrawVetDocumentRequest")) { *type = SOAP_TYPE_g2ba__WithdrawVetDocumentRequest; return soap_in_g2ba__WithdrawVetDocumentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:MergeStockEntriesResponse")) { *type = SOAP_TYPE_g2ba__MergeStockEntriesResponse; return soap_in_g2ba__MergeStockEntriesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:MergeStockEntriesRequest")) { *type = SOAP_TYPE_g2ba__MergeStockEntriesRequest; return soap_in_g2ba__MergeStockEntriesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:RegisterProductionOperationResponse")) { *type = SOAP_TYPE_g2ba__RegisterProductionOperationResponse; return soap_in_g2ba__RegisterProductionOperationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:RegisterProductionOperationRequest")) { *type = SOAP_TYPE_g2ba__RegisterProductionOperationRequest; return soap_in_g2ba__RegisterProductionOperationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:PrepareOutgoingConsignmentResponse")) { *type = SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse; return soap_in_g2ba__PrepareOutgoingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:PrepareOutgoingConsignmentRequest")) { *type = SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest; return soap_in_g2ba__PrepareOutgoingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ProcessIncomingConsignmentResponse")) { *type = SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse; return soap_in_g2ba__ProcessIncomingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:ProcessIncomingConsignmentRequest")) { *type = SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest; return soap_in_g2ba__ProcessIncomingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "g2ba:MercuryApplicationRequest")) { *type = SOAP_TYPE_g2ba__MercuryApplicationRequest; return soap_in_g2ba__MercuryApplicationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:base64Binary")) { *type = SOAP_TYPE_xsd__base64Binary; return soap_in_xsd__base64Binary(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:byte")) { *type = SOAP_TYPE_byte; return soap_in_byte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Minute")) { *type = SOAP_TYPE_dic__Minute; return soap_in_dic__Minute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Hour")) { *type = SOAP_TYPE_dic__Hour; return soap_in_dic__Hour(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Day")) { *type = SOAP_TYPE_dic__Day; return soap_in_dic__Day(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Month")) { *type = SOAP_TYPE_dic__Month; return soap_in_dic__Month(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:Year")) { *type = SOAP_TYPE_dic__Year; return soap_in_dic__Year(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Hour")) { *type = SOAP_TYPE_base__Hour; return soap_in_base__Hour(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Day")) { *type = SOAP_TYPE_base__Day; return soap_in_base__Day(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Month")) { *type = SOAP_TYPE_base__Month; return soap_in_base__Month(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Year")) { *type = SOAP_TYPE_base__Year; return soap_in_base__Year(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:int")) { *type = SOAP_TYPE_int; return soap_in_int(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:long")) { *type = SOAP_TYPE_LONG64; return soap_in_LONG64(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedByte")) { *type = SOAP_TYPE_unsignedByte; return soap_in_unsignedByte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedInt")) { *type = SOAP_TYPE_unsignedInt; return soap_in_unsignedInt(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:dateTime")) { *type = SOAP_TYPE_time; return soap_in_time(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:boolean")) { *type = SOAP_TYPE_bool; return soap_in_bool(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AnimalSpentPeriod")) { *type = SOAP_TYPE_vd__AnimalSpentPeriod; return soap_in_vd__AnimalSpentPeriod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatus")) { *type = SOAP_TYPE_vd__VetDocumentStatus; return soap_in_vd__VetDocumentStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentType")) { *type = SOAP_TYPE_vd__VetDocumentType; return soap_in_vd__VetDocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentForm")) { *type = SOAP_TYPE_vd__VetDocumentForm; return soap_in_vd__VetDocumentForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryInspectionResult")) { *type = SOAP_TYPE_vd__DeliveryInspectionResult; return soap_in_vd__DeliveryInspectionResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryDecision")) { *type = SOAP_TYPE_vd__DeliveryDecision; return soap_in_vd__DeliveryDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductMarkingClass")) { *type = SOAP_TYPE_dic__ProductMarkingClass; return soap_in_dic__ProductMarkingClass(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:TransportationStorageType")) { *type = SOAP_TYPE_dic__TransportationStorageType; return soap_in_dic__TransportationStorageType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:DocumentNature")) { *type = SOAP_TYPE_dic__DocumentNature; return soap_in_dic__DocumentNature(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseRole")) { *type = SOAP_TYPE_dic__EnterpriseRole; return soap_in_dic__EnterpriseRole(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProcessingProcedureType")) { *type = SOAP_TYPE_vd__ProcessingProcedureType; return soap_in_vd__ProcessingProcedureType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryEventType")) { *type = SOAP_TYPE_vd__VeterinaryEventType; return soap_in_vd__VeterinaryEventType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryBlankFilter")) { *type = SOAP_TYPE_vd__StockEntryBlankFilter; return soap_in_vd__StockEntryBlankFilter(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:VaccinationType")) { *type = SOAP_TYPE_dic__VaccinationType; return soap_in_dic__VaccinationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProsperityType")) { *type = SOAP_TYPE_dic__ProsperityType; return soap_in_dic__ProsperityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:RegionalizationDecision")) { *type = SOAP_TYPE_dic__RegionalizationDecision; return soap_in_dic__RegionalizationDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ResearchResult")) { *type = SOAP_TYPE_dic__ResearchResult; return soap_in_dic__ResearchResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:TransportType")) { *type = SOAP_TYPE_dic__TransportType; return soap_in_dic__TransportType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ReferenceType")) { *type = SOAP_TYPE_dic__ReferenceType; return soap_in_dic__ReferenceType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:DocumentType")) { *type = SOAP_TYPE_dic__DocumentType; return soap_in_dic__DocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:ProductType")) { *type = SOAP_TYPE_dic__ProductType; return soap_in_dic__ProductType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:BusinessEntityType")) { *type = SOAP_TYPE_dic__BusinessEntityType; return soap_in_dic__BusinessEntityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:EnterpriseGroup")) { *type = SOAP_TYPE_dic__EnterpriseGroup; return soap_in_dic__EnterpriseGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:PackingCodeType")) { *type = SOAP_TYPE_dic__PackingCodeType; return soap_in_dic__PackingCodeType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "dic:PackageLevelType")) { *type = SOAP_TYPE_dic__PackageLevelType; return soap_in_dic__PackageLevelType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ContentEncoding")) { *type = SOAP_TYPE_app__ContentEncoding; return soap_in_app__ContentEncoding(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationStatus")) { *type = SOAP_TYPE_app__ApplicationStatus; return soap_in_app__ApplicationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:RegisterModificationType")) { *type = SOAP_TYPE_base__RegisterModificationType; return soap_in_base__RegisterModificationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatusChangeReason")) {
			*type = SOAP_TYPE_vd__VetDocumentStatusChangeReason;
			char ** s = soap_in_vd__VetDocumentStatusChangeReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:GRNType")) {
			*type = SOAP_TYPE_dic__GRNType;
			char ** s = soap_in_dic__GRNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "vd:SNILSType")) {
			*type = SOAP_TYPE_vd__SNILSType;
			char ** s = soap_in_vd__SNILSType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "vd:StockEntryNumber")) {
			*type = SOAP_TYPE_vd__StockEntryNumber;
			char ** s = soap_in_vd__StockEntryNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:OTPToken")) {
			*type = SOAP_TYPE_dic__OTPToken;
			char ** s = soap_in_dic__OTPToken(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:GTINType")) {
			*type = SOAP_TYPE_dic__GTINType;
			char ** s = soap_in_dic__GTINType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:GLNType")) {
			*type = SOAP_TYPE_dic__GLNType;
			char ** s = soap_in_dic__GLNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:ENTModificationReason")) {
			*type = SOAP_TYPE_dic__ENTModificationReason;
			char ** s = soap_in_dic__ENTModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:BEModificationReason")) {
			*type = SOAP_TYPE_dic__BEModificationReason;
			char ** s = soap_in_dic__BEModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:EnterpriseType")) {
			*type = SOAP_TYPE_dic__EnterpriseType;
			char ** s = soap_in_dic__EnterpriseType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:Code3")) {
			*type = SOAP_TYPE_dic__Code3;
			char ** s = soap_in_dic__Code3(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "dic:Code")) {
			*type = SOAP_TYPE_dic__Code;
			char ** s = soap_in_dic__Code(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "app:APIKey")) {
			*type = SOAP_TYPE_app__APIKey;
			char ** s = soap_in_app__APIKey(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:SequenceNumber")) {
			*type = SOAP_TYPE_base__SequenceNumber;
			char ** s = soap_in_base__SequenceNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Identifier")) {
			*type = SOAP_TYPE_base__Identifier;
			char ** s = soap_in_base__Identifier(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:VersionStatus")) {
			*type = SOAP_TYPE_base__VersionStatus;
			char ** s = soap_in_base__VersionStatus(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Decimal")) {
			*type = SOAP_TYPE_base__Decimal;
			char ** s = soap_in_base__Decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:String32")) {
			*type = SOAP_TYPE_base__String32;
			char ** s = soap_in_base__String32(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:String255")) {
			*type = SOAP_TYPE_base__String255;
			char ** s = soap_in_base__String255(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:NText")) {
			*type = SOAP_TYPE_base__NText;
			char ** s = soap_in_base__NText(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Text")) {
			*type = SOAP_TYPE_base__Text;
			char ** s = soap_in_base__Text(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:UUID")) {
			*type = SOAP_TYPE_base__UUID;
			char ** s = soap_in_base__UUID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:token")) {
			*type = SOAP_TYPE_xsd__token;
			char ** s = soap_in_xsd__token(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:positiveInteger")) {
			*type = SOAP_TYPE_xsd__positiveInteger;
			char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:nonNegativeInteger")) {
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:integer")) {
			*type = SOAP_TYPE_xsd__integer;
			char ** s = soap_in_xsd__integer(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:decimal")) {
			*type = SOAP_TYPE_xsd__decimal;
			char ** s = soap_in_xsd__decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:date")) {
			*type = SOAP_TYPE_xsd__date;
			char ** s = soap_in_xsd__date(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:Name")) {
			*type = SOAP_TYPE_xsd__Name;
			char ** s = soap_in_xsd__Name(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:NCName")) {
			*type = SOAP_TYPE_xsd__NCName;
			char ** s = soap_in_xsd__NCName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:IDREF")) {
			*type = SOAP_TYPE_xsd__IDREF;
			char ** s = soap_in_xsd__IDREF(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:ID")) {
			*type = SOAP_TYPE_xsd__ID;
			char ** s = soap_in_xsd__ID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:QName")) {
			*type = SOAP_TYPE__QName;
			char ** s = soap_in__QName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:string")) {
			*type = SOAP_TYPE_string;
			char ** s = soap_in_string(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if(!soap_match_tag(soap, t, "dic:BusinessEntity-activityLocation")) { *type = SOAP_TYPE__dic__BusinessEntity_activityLocation; return soap_in__dic__BusinessEntity_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEActivityLocationsModificationOperation-activityLocation")) { *type = SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation; return soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:receiveApplicationResultResponse")) { *type = SOAP_TYPE__ws__receiveApplicationResultResponse; return soap_in__ws__receiveApplicationResultResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:receiveApplicationResultRequest")) { *type = SOAP_TYPE__ws__receiveApplicationResultRequest; return soap_in__ws__receiveApplicationResultRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:submitApplicationResponse")) { *type = SOAP_TYPE__ws__submitApplicationResponse; return soap_in__ws__submitApplicationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:submitApplicationRequest")) { *type = SOAP_TYPE__ws__submitApplicationRequest; return soap_in__ws__submitApplicationRequest(soap, 0, 0, 0); }
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if(!soap_peek_element(soap)) {
		int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if(soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if(((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if(!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			soap->error = soap->fignore ? soap->fignore(soap, soap->tag) : SOAP_OK;
			DBGLOG(TEST, if(!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if(!soap->error && soap->body)
			{	soap->level++;
				while(!soap_ignore_element(soap))
					;
				if(soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_putindependent(struct soap *soap)
{
	if(soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for(int i = 0; i < SOAP_PTRHASH; i++)
			for(struct soap_plist * pp = soap->pht[i]; pp; pp = pp->next)
				if(pp->mark1 == 2 || pp->mark2 == 2)
					if(soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	(void)tag;
	switch(type) {
	case SOAP_TYPE_byte: return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_dic__Minute: return soap_out_dic__Minute(soap, tag, id, (const int *)ptr, "dic:Minute");
	case SOAP_TYPE_dic__Hour: return soap_out_dic__Hour(soap, tag, id, (const int *)ptr, "dic:Hour");
	case SOAP_TYPE_dic__Day: return soap_out_dic__Day(soap, tag, id, (const int *)ptr, "dic:Day");
	case SOAP_TYPE_dic__Month: return soap_out_dic__Month(soap, tag, id, (const int *)ptr, "dic:Month");
	case SOAP_TYPE_dic__Year: return soap_out_dic__Year(soap, tag, id, (const int *)ptr, "dic:Year");
	case SOAP_TYPE_base__Hour: return soap_out_base__Hour(soap, tag, id, (const int *)ptr, "base:Hour");
	case SOAP_TYPE_base__Day: return soap_out_base__Day(soap, tag, id, (const int *)ptr, "base:Day");
	case SOAP_TYPE_base__Month: return soap_out_base__Month(soap, tag, id, (const int *)ptr, "base:Month");
	case SOAP_TYPE_base__Year: return soap_out_base__Year(soap, tag, id, (const int *)ptr, "base:Year");
	case SOAP_TYPE_int: return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_vd__AnimalSpentPeriod: return soap_out_vd__AnimalSpentPeriod(soap, tag, id, (const enum vd__AnimalSpentPeriod *)ptr, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_vd__VetDocumentStatus: return soap_out_vd__VetDocumentStatus(soap, tag, id, (const enum vd__VetDocumentStatus *)ptr, "vd:VetDocumentStatus");
	case SOAP_TYPE_vd__VetDocumentType: return soap_out_vd__VetDocumentType(soap, tag, id, (const enum vd__VetDocumentType *)ptr, "vd:VetDocumentType");
	case SOAP_TYPE_vd__VetDocumentForm: return soap_out_vd__VetDocumentForm(soap, tag, id, (const enum vd__VetDocumentForm *)ptr, "vd:VetDocumentForm");
	case SOAP_TYPE_vd__DeliveryInspectionResult: return soap_out_vd__DeliveryInspectionResult(soap, tag, id, (const enum vd__DeliveryInspectionResult *)ptr, "vd:DeliveryInspectionResult");
	case SOAP_TYPE_vd__DeliveryDecision: return soap_out_vd__DeliveryDecision(soap, tag, id, (const enum vd__DeliveryDecision *)ptr, "vd:DeliveryDecision");
	case SOAP_TYPE_dic__ProductMarkingClass: return soap_out_dic__ProductMarkingClass(soap, tag, id, (const enum dic__ProductMarkingClass *)ptr, "dic:ProductMarkingClass");
	case SOAP_TYPE_dic__TransportationStorageType: return soap_out_dic__TransportationStorageType(soap, tag, id, (const enum dic__TransportationStorageType *)ptr, "dic:TransportationStorageType");
	case SOAP_TYPE_dic__DocumentNature: return soap_out_dic__DocumentNature(soap, tag, id, (const enum dic__DocumentNature *)ptr, "dic:DocumentNature");
	case SOAP_TYPE_dic__EnterpriseRole: return soap_out_dic__EnterpriseRole(soap, tag, id, (const enum dic__EnterpriseRole *)ptr, "dic:EnterpriseRole");
	case SOAP_TYPE_vd__ProcessingProcedureType: return soap_out_vd__ProcessingProcedureType(soap, tag, id, (const enum vd__ProcessingProcedureType *)ptr, "vd:ProcessingProcedureType");
	case SOAP_TYPE_vd__VeterinaryEventType: return soap_out_vd__VeterinaryEventType(soap, tag, id, (const enum vd__VeterinaryEventType *)ptr, "vd:VeterinaryEventType");
	case SOAP_TYPE_vd__StockEntryBlankFilter: return soap_out_vd__StockEntryBlankFilter(soap, tag, id, (const enum vd__StockEntryBlankFilter *)ptr, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_dic__VaccinationType: return soap_out_dic__VaccinationType(soap, tag, id, (const enum dic__VaccinationType *)ptr, "dic:VaccinationType");
	case SOAP_TYPE_dic__ProsperityType: return soap_out_dic__ProsperityType(soap, tag, id, (const enum dic__ProsperityType *)ptr, "dic:ProsperityType");
	case SOAP_TYPE_dic__RegionalizationDecision: return soap_out_dic__RegionalizationDecision(soap, tag, id, (const enum dic__RegionalizationDecision *)ptr, "dic:RegionalizationDecision");
	case SOAP_TYPE_dic__ResearchResult: return soap_out_dic__ResearchResult(soap, tag, id, (const enum dic__ResearchResult *)ptr, "dic:ResearchResult");
	case SOAP_TYPE_dic__TransportType: return soap_out_dic__TransportType(soap, tag, id, (const enum dic__TransportType *)ptr, "dic:TransportType");
	case SOAP_TYPE_dic__ReferenceType: return soap_out_dic__ReferenceType(soap, tag, id, (const enum dic__ReferenceType *)ptr, "dic:ReferenceType");
	case SOAP_TYPE_dic__DocumentType: return soap_out_dic__DocumentType(soap, tag, id, (const enum dic__DocumentType *)ptr, "dic:DocumentType");
	case SOAP_TYPE_dic__ProductType: return soap_out_dic__ProductType(soap, tag, id, (const enum dic__ProductType *)ptr, "dic:ProductType");
	case SOAP_TYPE_dic__BusinessEntityType: return soap_out_dic__BusinessEntityType(soap, tag, id, (const enum dic__BusinessEntityType *)ptr, "dic:BusinessEntityType");
	case SOAP_TYPE_dic__EnterpriseGroup: return soap_out_dic__EnterpriseGroup(soap, tag, id, (const enum dic__EnterpriseGroup *)ptr, "dic:EnterpriseGroup");
	case SOAP_TYPE_dic__PackingCodeType: return soap_out_dic__PackingCodeType(soap, tag, id, (const enum dic__PackingCodeType *)ptr, "dic:PackingCodeType");
	case SOAP_TYPE_dic__PackageLevelType: return soap_out_dic__PackageLevelType(soap, tag, id, (const enum dic__PackageLevelType *)ptr, "dic:PackageLevelType");
	case SOAP_TYPE_app__ContentEncoding: return soap_out_app__ContentEncoding(soap, tag, id, (const enum app__ContentEncoding *)ptr, "app:ContentEncoding");
	case SOAP_TYPE_app__ApplicationStatus: return soap_out_app__ApplicationStatus(soap, tag, id, (const enum app__ApplicationStatus *)ptr, "app:ApplicationStatus");
	case SOAP_TYPE_base__RegisterModificationType: return soap_out_base__RegisterModificationType(soap, tag, id, (const enum base__RegisterModificationType *)ptr, "base:RegisterModificationType");
	case SOAP_TYPE__dic__BusinessEntity_activityLocation: return ((_dic__BusinessEntity_activityLocation *)ptr)->soap_out(soap, "dic:BusinessEntity-activityLocation", id, NULL);
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: return ((_vd__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_out(soap, "vd:BEActivityLocationsModificationOperation-activityLocation", id, NULL);
	case SOAP_TYPE_app__BinaryContent: return soap_out_app__BinaryContent(soap, tag, id, (const xsd__base64Binary *)ptr, "app:BinaryContent");
	case SOAP_TYPE__ws__receiveApplicationResultResponse: return ((_ws__receiveApplicationResultResponse *)ptr)->soap_out(soap, "ws:receiveApplicationResultResponse", id, NULL);
	case SOAP_TYPE__ws__receiveApplicationResultRequest: return ((_ws__receiveApplicationResultRequest *)ptr)->soap_out(soap, "ws:receiveApplicationResultRequest", id, NULL);
	case SOAP_TYPE__ws__submitApplicationResponse: return ((_ws__submitApplicationResponse *)ptr)->soap_out(soap, "ws:submitApplicationResponse", id, NULL);
	case SOAP_TYPE__ws__submitApplicationRequest: return ((_ws__submitApplicationRequest *)ptr)->soap_out(soap, "ws:submitApplicationRequest", id, NULL);
	case SOAP_TYPE_vd__Citizenship: return ((vd__Citizenship *)ptr)->soap_out(soap, tag, id, "vd:Citizenship");
	case SOAP_TYPE_vd__WorkingArea: return ((vd__WorkingArea *)ptr)->soap_out(soap, tag, id, "vd:WorkingArea");
	case SOAP_TYPE_vd__UserAuthority: return ((vd__UserAuthority *)ptr)->soap_out(soap, tag, id, "vd:UserAuthority");
	case SOAP_TYPE_vd__WorkingAreaList: return ((vd__WorkingAreaList *)ptr)->soap_out(soap, tag, id, "vd:WorkingAreaList");
	case SOAP_TYPE_vd__AuthorityList: return ((vd__AuthorityList *)ptr)->soap_out(soap, tag, id, "vd:AuthorityList");
	case SOAP_TYPE_vd__UserList: return ((vd__UserList *)ptr)->soap_out(soap, tag, id, "vd:UserList");
	case SOAP_TYPE_vd__User: return ((vd__User *)ptr)->soap_out(soap, tag, id, "vd:User");
	case SOAP_TYPE_vd__ProcessingProcedure: return ((vd__ProcessingProcedure *)ptr)->soap_out(soap, tag, id, "vd:ProcessingProcedure");
	case SOAP_TYPE_vd__RouteSectionR13nRules: return ((vd__RouteSectionR13nRules *)ptr)->soap_out(soap, tag, id, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_vd__RegionalizationClause: return ((vd__RegionalizationClause *)ptr)->soap_out(soap, tag, id, "vd:RegionalizationClause");
	case SOAP_TYPE_vd__VetDocumentStatusChange: return ((vd__VetDocumentStatusChange *)ptr)->soap_out(soap, tag, id, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_vd__StockEntryEventList: return ((vd__StockEntryEventList *)ptr)->soap_out(soap, tag, id, "vd:StockEntryEventList");
	case SOAP_TYPE_vd__BatchOrigin: return ((vd__BatchOrigin *)ptr)->soap_out(soap, tag, id, "vd:BatchOrigin");
	case SOAP_TYPE_vd__VeterinaryAuthentication: return ((vd__VeterinaryAuthentication *)ptr)->soap_out(soap, tag, id, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_vd__QuarantineEvent: return ((vd__QuarantineEvent *)ptr)->soap_out(soap, tag, id, "vd:QuarantineEvent");
	case SOAP_TYPE_vd__AnimalMedicationEvent: return ((vd__AnimalMedicationEvent *)ptr)->soap_out(soap, tag, id, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return ((vd__LaboratoryResearchEvent *)ptr)->soap_out(soap, tag, id, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_vd__VeterinaryEvent: return ((vd__VeterinaryEvent *)ptr)->soap_out(soap, tag, id, "vd:VeterinaryEvent");
	case SOAP_TYPE_vd__ReferencedDocument: return ((vd__ReferencedDocument *)ptr)->soap_out(soap, tag, id, "vd:ReferencedDocument");
	case SOAP_TYPE_vd__CertifiedConsignment: return ((vd__CertifiedConsignment *)ptr)->soap_out(soap, tag, id, "vd:CertifiedConsignment");
	case SOAP_TYPE_vd__CertifiedBatch: return ((vd__CertifiedBatch *)ptr)->soap_out(soap, tag, id, "vd:CertifiedBatch");
	case SOAP_TYPE_vd__ENTModificationOperation: return ((vd__ENTModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:ENTModificationOperation");
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return ((vd__BEActivityLocationsModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_vd__BEModificationOperation: return ((vd__BEModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:BEModificationOperation");
	case SOAP_TYPE_vd__PSLModificationOperation: return ((vd__PSLModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:PSLModificationOperation");
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return ((vd__MergeStockEntriesOperation *)ptr)->soap_out(soap, tag, id, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_vd__ProductionOperation: return ((vd__ProductionOperation *)ptr)->soap_out(soap, tag, id, "vd:ProductionOperation");
	case SOAP_TYPE_vd__ShipmentRoute: return ((vd__ShipmentRoute *)ptr)->soap_out(soap, tag, id, "vd:ShipmentRoute");
	case SOAP_TYPE_vd__ShipmentRoutePoint: return ((vd__ShipmentRoutePoint *)ptr)->soap_out(soap, tag, id, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_vd__TransportNumber: return ((vd__TransportNumber *)ptr)->soap_out(soap, tag, id, "vd:TransportNumber");
	case SOAP_TYPE_vd__TransportInfo: return ((vd__TransportInfo *)ptr)->soap_out(soap, tag, id, "vd:TransportInfo");
	case SOAP_TYPE_vd__Waybill: return ((vd__Waybill *)ptr)->soap_out(soap, tag, id, "vd:Waybill");
	case SOAP_TYPE_vd__Document: return ((vd__Document *)ptr)->soap_out(soap, tag, id, "vd:Document");
	case SOAP_TYPE_vd__StockEntrySearchPattern: return ((vd__StockEntrySearchPattern *)ptr)->soap_out(soap, tag, id, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_vd__StockDiscrepancy: return ((vd__StockDiscrepancy *)ptr)->soap_out(soap, tag, id, "vd:StockDiscrepancy");
	case SOAP_TYPE_vd__StockEntryList: return ((vd__StockEntryList *)ptr)->soap_out(soap, tag, id, "vd:StockEntryList");
	case SOAP_TYPE_vd__StockEntry: return ((vd__StockEntry *)ptr)->soap_out(soap, tag, id, "vd:StockEntry");
	case SOAP_TYPE_vd__DiscrepancyReason: return ((vd__DiscrepancyReason *)ptr)->soap_out(soap, tag, id, "vd:DiscrepancyReason");
	case SOAP_TYPE_vd__DiscrepancyReport: return ((vd__DiscrepancyReport *)ptr)->soap_out(soap, tag, id, "vd:DiscrepancyReport");
	case SOAP_TYPE_vd__VetDocumentList: return ((vd__VetDocumentList *)ptr)->soap_out(soap, tag, id, "vd:VetDocumentList");
	case SOAP_TYPE_vd__GoodsDate: return ((vd__GoodsDate *)ptr)->soap_out(soap, tag, id, "vd:GoodsDate");
	case SOAP_TYPE_vd__ConsignmentDocumentList: return ((vd__ConsignmentDocumentList *)ptr)->soap_out(soap, tag, id, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_vd__DeliveryInspection: return ((vd__DeliveryInspection *)ptr)->soap_out(soap, tag, id, "vd:DeliveryInspection");
	case SOAP_TYPE_vd__DeliveryFactList: return ((vd__DeliveryFactList *)ptr)->soap_out(soap, tag, id, "vd:DeliveryFactList");
	case SOAP_TYPE_vd__Delivery: return ((vd__Delivery *)ptr)->soap_out(soap, tag, id, "vd:Delivery");
	case SOAP_TYPE_vd__ProductiveBatch: return ((vd__ProductiveBatch *)ptr)->soap_out(soap, tag, id, "vd:ProductiveBatch");
	case SOAP_TYPE_vd__RawBatch: return ((vd__RawBatch *)ptr)->soap_out(soap, tag, id, "vd:RawBatch");
	case SOAP_TYPE_vd__Consignment: return ((vd__Consignment *)ptr)->soap_out(soap, tag, id, "vd:Consignment");
	case SOAP_TYPE_vd__Batch: return ((vd__Batch *)ptr)->soap_out(soap, tag, id, "vd:Batch");
	case SOAP_TYPE_vd__VetDocument: return ((vd__VetDocument *)ptr)->soap_out(soap, tag, id, "vd:VetDocument");
	case SOAP_TYPE_dic__ActivityLocationList: return ((dic__ActivityLocationList *)ptr)->soap_out(soap, tag, id, "dic:ActivityLocationList");
	case SOAP_TYPE_dic__ResearchMethodList: return ((dic__ResearchMethodList *)ptr)->soap_out(soap, tag, id, "dic:ResearchMethodList");
	case SOAP_TYPE_dic__AnimalDiseaseList: return ((dic__AnimalDiseaseList *)ptr)->soap_out(soap, tag, id, "dic:AnimalDiseaseList");
	case SOAP_TYPE_dic__RegionalizationShippingRuleList: return ((dic__RegionalizationShippingRuleList *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationShippingRuleList");
	case SOAP_TYPE_dic__RegionalizationRegionStatusList: return ((dic__RegionalizationRegionStatusList *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationRegionStatusList");
	case SOAP_TYPE_dic__RegionalizationConditionList: return ((dic__RegionalizationConditionList *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationConditionList");
	case SOAP_TYPE_dic__Area: return ((dic__Area *)ptr)->soap_out(soap, tag, id, "dic:Area");
	case SOAP_TYPE_dic__RegionalizationRegionStatus: return ((dic__RegionalizationRegionStatus *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_dic__RegionalizationStatus: return ((dic__RegionalizationStatus *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationStatus");
	case SOAP_TYPE_dic__RegionalizationShippingRule: return ((dic__RegionalizationShippingRule *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_dic__RegionalizationRequirement: return ((dic__RegionalizationRequirement *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationRequirement");
	case SOAP_TYPE_dic__RegionalizationConditionGroup: return ((dic__RegionalizationConditionGroup *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_dic__RegionalizationCondition: return ((dic__RegionalizationCondition *)ptr)->soap_out(soap, tag, id, "dic:RegionalizationCondition");
	case SOAP_TYPE_dic__MedicinalDrug: return ((dic__MedicinalDrug *)ptr)->soap_out(soap, tag, id, "dic:MedicinalDrug");
	case SOAP_TYPE_dic__ResearchMethod: return ((dic__ResearchMethod *)ptr)->soap_out(soap, tag, id, "dic:ResearchMethod");
	case SOAP_TYPE_dic__AnimalDisease: return ((dic__AnimalDisease *)ptr)->soap_out(soap, tag, id, "dic:AnimalDisease");
	case SOAP_TYPE_dic__Indicator: return ((dic__Indicator *)ptr)->soap_out(soap, tag, id, "dic:Indicator");
	case SOAP_TYPE_dic__Organization: return ((dic__Organization *)ptr)->soap_out(soap, tag, id, "dic:Organization");
	case SOAP_TYPE_dic__EnterpriseOfficialRegistration: return ((dic__EnterpriseOfficialRegistration *)ptr)->soap_out(soap, tag, id, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_dic__Location: return ((dic__Location *)ptr)->soap_out(soap, tag, id, "dic:Location");
	case SOAP_TYPE_dic__Packaging: return ((dic__Packaging *)ptr)->soap_out(soap, tag, id, "dic:Packaging");
	case SOAP_TYPE_dic__ProductItemProducing: return ((dic__ProductItemProducing *)ptr)->soap_out(soap, tag, id, "dic:ProductItemProducing");
	case SOAP_TYPE_dic__ComplexDate: return ((dic__ComplexDate *)ptr)->soap_out(soap, tag, id, "dic:ComplexDate");
	case SOAP_TYPE_dic__PackageList: return ((dic__PackageList *)ptr)->soap_out(soap, tag, id, "dic:PackageList");
	case SOAP_TYPE_dic__Package: return ((dic__Package *)ptr)->soap_out(soap, tag, id, "dic:Package");
	case SOAP_TYPE_dic__ProductMarks: return ((dic__ProductMarks *)ptr)->soap_out(soap, tag, id, "dic:ProductMarks");
	case SOAP_TYPE_dic__ProductItemList: return ((dic__ProductItemList *)ptr)->soap_out(soap, tag, id, "dic:ProductItemList");
	case SOAP_TYPE_dic__SubProductList: return ((dic__SubProductList *)ptr)->soap_out(soap, tag, id, "dic:SubProductList");
	case SOAP_TYPE_dic__ProductList: return ((dic__ProductList *)ptr)->soap_out(soap, tag, id, "dic:ProductList");
	case SOAP_TYPE_dic__SubProduct: return ((dic__SubProduct *)ptr)->soap_out(soap, tag, id, "dic:SubProduct");
	case SOAP_TYPE_dic__Product: return ((dic__Product *)ptr)->soap_out(soap, tag, id, "dic:Product");
	case SOAP_TYPE_dic__ProductItem: return ((dic__ProductItem *)ptr)->soap_out(soap, tag, id, "dic:ProductItem");
	case SOAP_TYPE_dic__BusinessEntityList: return ((dic__BusinessEntityList *)ptr)->soap_out(soap, tag, id, "dic:BusinessEntityList");
	case SOAP_TYPE_dic__IncorporationForm: return ((dic__IncorporationForm *)ptr)->soap_out(soap, tag, id, "dic:IncorporationForm");
	case SOAP_TYPE_dic__BusinessEntity: return ((dic__BusinessEntity *)ptr)->soap_out(soap, tag, id, "dic:BusinessEntity");
	case SOAP_TYPE_dic__BusinessMember: return ((dic__BusinessMember *)ptr)->soap_out(soap, tag, id, "dic:BusinessMember");
	case SOAP_TYPE_dic__EnterpriseList: return ((dic__EnterpriseList *)ptr)->soap_out(soap, tag, id, "dic:EnterpriseList");
	case SOAP_TYPE_dic__EnterpriseNumberList: return ((dic__EnterpriseNumberList *)ptr)->soap_out(soap, tag, id, "dic:EnterpriseNumberList");
	case SOAP_TYPE_dic__ProducerList: return ((dic__ProducerList *)ptr)->soap_out(soap, tag, id, "dic:ProducerList");
	case SOAP_TYPE_dic__Producer: return ((dic__Producer *)ptr)->soap_out(soap, tag, id, "dic:Producer");
	case SOAP_TYPE_dic__EnterpriseActivity: return ((dic__EnterpriseActivity *)ptr)->soap_out(soap, tag, id, "dic:EnterpriseActivity");
	case SOAP_TYPE_dic__EnterpriseActivityList: return ((dic__EnterpriseActivityList *)ptr)->soap_out(soap, tag, id, "dic:EnterpriseActivityList");
	case SOAP_TYPE_dic__Enterprise: return ((dic__Enterprise *)ptr)->soap_out(soap, tag, id, "dic:Enterprise");
	case SOAP_TYPE_dic__StreetList: return ((dic__StreetList *)ptr)->soap_out(soap, tag, id, "dic:StreetList");
	case SOAP_TYPE_dic__LocalityList: return ((dic__LocalityList *)ptr)->soap_out(soap, tag, id, "dic:LocalityList");
	case SOAP_TYPE_dic__DistrictList: return ((dic__DistrictList *)ptr)->soap_out(soap, tag, id, "dic:DistrictList");
	case SOAP_TYPE_dic__RegionList: return ((dic__RegionList *)ptr)->soap_out(soap, tag, id, "dic:RegionList");
	case SOAP_TYPE_dic__CountryList: return ((dic__CountryList *)ptr)->soap_out(soap, tag, id, "dic:CountryList");
	case SOAP_TYPE_dic__Address: return ((dic__Address *)ptr)->soap_out(soap, tag, id, "dic:Address");
	case SOAP_TYPE_dic__Street: return ((dic__Street *)ptr)->soap_out(soap, tag, id, "dic:Street");
	case SOAP_TYPE_dic__Locality: return ((dic__Locality *)ptr)->soap_out(soap, tag, id, "dic:Locality");
	case SOAP_TYPE_dic__District: return ((dic__District *)ptr)->soap_out(soap, tag, id, "dic:District");
	case SOAP_TYPE_dic__Region: return ((dic__Region *)ptr)->soap_out(soap, tag, id, "dic:Region");
	case SOAP_TYPE_dic__AddressObjectView: return ((dic__AddressObjectView *)ptr)->soap_out(soap, tag, id, "dic:AddressObjectView");
	case SOAP_TYPE_dic__FederalDistrict: return ((dic__FederalDistrict *)ptr)->soap_out(soap, tag, id, "dic:FederalDistrict");
	case SOAP_TYPE_dic__Country: return ((dic__Country *)ptr)->soap_out(soap, tag, id, "dic:Country");
	case SOAP_TYPE_dic__UnitList: return ((dic__UnitList *)ptr)->soap_out(soap, tag, id, "dic:UnitList");
	case SOAP_TYPE_dic__PurposeList: return ((dic__PurposeList *)ptr)->soap_out(soap, tag, id, "dic:PurposeList");
	case SOAP_TYPE_dic__PackingType: return ((dic__PackingType *)ptr)->soap_out(soap, tag, id, "dic:PackingType");
	case SOAP_TYPE_dic__Unit: return ((dic__Unit *)ptr)->soap_out(soap, tag, id, "dic:Unit");
	case SOAP_TYPE_dic__Purpose: return ((dic__Purpose *)ptr)->soap_out(soap, tag, id, "dic:Purpose");
	case SOAP_TYPE_app__BusinessError: return ((app__BusinessError *)ptr)->soap_out(soap, tag, id, "app:BusinessError");
	case SOAP_TYPE_app__BusinessErrorList: return ((app__BusinessErrorList *)ptr)->soap_out(soap, tag, id, "app:BusinessErrorList");
	case SOAP_TYPE_app__ApplicationResultData: return ((app__ApplicationResultData *)ptr)->soap_out(soap, tag, id, "app:ApplicationResultData");
	case SOAP_TYPE_app__ApplicationData: return ((app__ApplicationData *)ptr)->soap_out(soap, tag, id, "app:ApplicationData");
	case SOAP_TYPE_app__ApplicationResultWrapper: return ((app__ApplicationResultWrapper *)ptr)->soap_out(soap, tag, id, "app:ApplicationResultWrapper");
	case SOAP_TYPE_app__ApplicationDataWrapper: return ((app__ApplicationDataWrapper *)ptr)->soap_out(soap, tag, id, "app:ApplicationDataWrapper");
	case SOAP_TYPE_app__Application: return ((app__Application *)ptr)->soap_out(soap, tag, id, "app:Application");
	case SOAP_TYPE_base__ComplexDate: return ((base__ComplexDate *)ptr)->soap_out(soap, tag, id, "base:ComplexDate");
	case SOAP_TYPE_base__Error: return ((base__Error *)ptr)->soap_out(soap, tag, id, "base:Error");
	case SOAP_TYPE_base__FaultInfo: return ((base__FaultInfo *)ptr)->soap_out(soap, tag, id, "base:FaultInfo");
	case SOAP_TYPE_base__EntityList: return ((base__EntityList *)ptr)->soap_out(soap, tag, id, "base:EntityList");
	case SOAP_TYPE_base__DateInterval: return ((base__DateInterval *)ptr)->soap_out(soap, tag, id, "base:DateInterval");
	case SOAP_TYPE_base__ListOptions: return ((base__ListOptions *)ptr)->soap_out(soap, tag, id, "base:ListOptions");
	case SOAP_TYPE_base__GenericVersioningEntity: return ((base__GenericVersioningEntity *)ptr)->soap_out(soap, tag, id, "base:GenericVersioningEntity");
	case SOAP_TYPE_base__GenericEntity: return ((base__GenericEntity *)ptr)->soap_out(soap, tag, id, "base:GenericEntity");
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse: return ((g2ba__GetApplicableUserAuthorityListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetApplicableUserAuthorityListResponse");
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest: return ((g2ba__GetApplicableUserAuthorityListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetApplicableUserAuthorityListRequest");
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse: return ((g2ba__UnbindBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "g2ba:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest: return ((g2ba__UnbindBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "g2ba:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse: return ((g2ba__UpdateUserWorkingAreasResponse *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest: return ((g2ba__UpdateUserWorkingAreasRequest *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse: return ((g2ba__UpdateUserAuthoritiesResponse *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest: return ((g2ba__UpdateUserAuthoritiesRequest *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserResponse: return ((g2ba__GetBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserRequest: return ((g2ba__GetBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse: return ((g2ba__GetBusinessEntityUserListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest: return ((g2ba__GetBusinessEntityUserListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_g2ba__AddBusinessEntityUserResponse: return ((g2ba__AddBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "g2ba:AddBusinessEntityUserResponse");
	case SOAP_TYPE_g2ba__AddBusinessEntityUserRequest: return ((g2ba__AddBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "g2ba:AddBusinessEntityUserRequest");
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse: return ((g2ba__CheckShipmentRegionalizationResponse *)ptr)->soap_out(soap, tag, id, "g2ba:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest: return ((g2ba__CheckShipmentRegionalizationRequest *)ptr)->soap_out(soap, tag, id, "g2ba:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse: return ((g2ba__UpdateVeterinaryEventsResponse *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest: return ((g2ba__UpdateVeterinaryEventsRequest *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse: return ((g2ba__UpdateTransportMovementDetailsResponse *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest: return ((g2ba__UpdateTransportMovementDetailsRequest *)ptr)->soap_out(soap, tag, id, "g2ba:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_g2ba__GetStockEntryVersionListResponse: return ((g2ba__GetStockEntryVersionListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryVersionListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryVersionListRequest: return ((g2ba__GetStockEntryVersionListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryVersionListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryListResponse: return ((g2ba__GetStockEntryListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryListRequest: return ((g2ba__GetStockEntryListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryChangesListResponse: return ((g2ba__GetStockEntryChangesListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryChangesListResponse");
	case SOAP_TYPE_g2ba__GetStockEntryChangesListRequest: return ((g2ba__GetStockEntryChangesListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryChangesListRequest");
	case SOAP_TYPE_g2ba__GetStockEntryByUuidResponse: return ((g2ba__GetStockEntryByUuidResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryByUuidResponse");
	case SOAP_TYPE_g2ba__GetStockEntryByUuidRequest: return ((g2ba__GetStockEntryByUuidRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryByUuidRequest");
	case SOAP_TYPE_g2ba__GetStockEntryByGuidResponse: return ((g2ba__GetStockEntryByGuidResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryByGuidResponse");
	case SOAP_TYPE_g2ba__GetStockEntryByGuidRequest: return ((g2ba__GetStockEntryByGuidRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetStockEntryByGuidRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse: return ((g2ba__GetVetDocumentChangesListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest: return ((g2ba__GetVetDocumentChangesListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentListResponse: return ((g2ba__GetVetDocumentListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentListResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentListRequest: return ((g2ba__GetVetDocumentListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentListRequest");
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse: return ((g2ba__GetVetDocumentByUuidResponse *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest: return ((g2ba__GetVetDocumentByUuidRequest *)ptr)->soap_out(soap, tag, id, "g2ba:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_g2ba__ModifyProducerStockListResponse: return ((g2ba__ModifyProducerStockListResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyProducerStockListResponse");
	case SOAP_TYPE_g2ba__ModifyProducerStockListRequest: return ((g2ba__ModifyProducerStockListRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyProducerStockListRequest");
	case SOAP_TYPE_g2ba__ResolveDiscrepancyResponse: return ((g2ba__ResolveDiscrepancyResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ResolveDiscrepancyResponse");
	case SOAP_TYPE_g2ba__ResolveDiscrepancyRequest: return ((g2ba__ResolveDiscrepancyRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ResolveDiscrepancyRequest");
	case SOAP_TYPE_g2ba__ModifyActivityLocationsResponse: return ((g2ba__ModifyActivityLocationsResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyActivityLocationsResponse");
	case SOAP_TYPE_g2ba__ModifyActivityLocationsRequest: return ((g2ba__ModifyActivityLocationsRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyActivityLocationsRequest");
	case SOAP_TYPE_g2ba__ModifyEnterpriseResponse: return ((g2ba__ModifyEnterpriseResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyEnterpriseResponse");
	case SOAP_TYPE_g2ba__ModifyEnterpriseRequest: return ((g2ba__ModifyEnterpriseRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyEnterpriseRequest");
	case SOAP_TYPE_g2ba__ModifyBusinessEntityResponse: return ((g2ba__ModifyBusinessEntityResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyBusinessEntityResponse");
	case SOAP_TYPE_g2ba__ModifyBusinessEntityRequest: return ((g2ba__ModifyBusinessEntityRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ModifyBusinessEntityRequest");
	case SOAP_TYPE_g2ba__WithdrawVetDocumentResponse: return ((g2ba__WithdrawVetDocumentResponse *)ptr)->soap_out(soap, tag, id, "g2ba:WithdrawVetDocumentResponse");
	case SOAP_TYPE_g2ba__WithdrawVetDocumentRequest: return ((g2ba__WithdrawVetDocumentRequest *)ptr)->soap_out(soap, tag, id, "g2ba:WithdrawVetDocumentRequest");
	case SOAP_TYPE_g2ba__MergeStockEntriesResponse: return ((g2ba__MergeStockEntriesResponse *)ptr)->soap_out(soap, tag, id, "g2ba:MergeStockEntriesResponse");
	case SOAP_TYPE_g2ba__MergeStockEntriesRequest: return ((g2ba__MergeStockEntriesRequest *)ptr)->soap_out(soap, tag, id, "g2ba:MergeStockEntriesRequest");
	case SOAP_TYPE_g2ba__RegisterProductionOperationResponse: return ((g2ba__RegisterProductionOperationResponse *)ptr)->soap_out(soap, tag, id, "g2ba:RegisterProductionOperationResponse");
	case SOAP_TYPE_g2ba__RegisterProductionOperationRequest: return ((g2ba__RegisterProductionOperationRequest *)ptr)->soap_out(soap, tag, id, "g2ba:RegisterProductionOperationRequest");
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse: return ((g2ba__PrepareOutgoingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "g2ba:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest: return ((g2ba__PrepareOutgoingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "g2ba:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse: return ((g2ba__ProcessIncomingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "g2ba:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest: return ((g2ba__ProcessIncomingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "g2ba:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_g2ba__MercuryApplicationRequest: return ((g2ba__MercuryApplicationRequest *)ptr)->soap_out(soap, tag, id, "g2ba:MercuryApplicationRequest");
	case SOAP_TYPE_xsd__base64Binary: return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListResponse: return soap_out_PointerTog2ba__GetApplicableUserAuthorityListResponse(soap, tag, id, (g2ba__GetApplicableUserAuthorityListResponse *const*)ptr, "g2ba:GetApplicableUserAuthorityListResponse");
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListRequest: return soap_out_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, tag, id, (g2ba__GetApplicableUserAuthorityListRequest *const*)ptr, "g2ba:GetApplicableUserAuthorityListRequest");
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserResponse: return soap_out_PointerTog2ba__UnbindBusinessEntityUserResponse(soap, tag, id, (g2ba__UnbindBusinessEntityUserResponse *const*)ptr, "g2ba:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserRequest: return soap_out_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, tag, id, (g2ba__UnbindBusinessEntityUserRequest *const*)ptr, "g2ba:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasResponse: return soap_out_PointerTog2ba__UpdateUserWorkingAreasResponse(soap, tag, id, (g2ba__UpdateUserWorkingAreasResponse *const*)ptr, "g2ba:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasRequest: return soap_out_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, tag, id, (g2ba__UpdateUserWorkingAreasRequest *const*)ptr, "g2ba:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesResponse: return soap_out_PointerTog2ba__UpdateUserAuthoritiesResponse(soap, tag, id, (g2ba__UpdateUserAuthoritiesResponse *const*)ptr, "g2ba:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesRequest: return soap_out_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, tag, id, (g2ba__UpdateUserAuthoritiesRequest *const*)ptr, "g2ba:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserResponse: return soap_out_PointerTog2ba__GetBusinessEntityUserResponse(soap, tag, id, (g2ba__GetBusinessEntityUserResponse *const*)ptr, "g2ba:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserRequest: return soap_out_PointerTog2ba__GetBusinessEntityUserRequest(soap, tag, id, (g2ba__GetBusinessEntityUserRequest *const*)ptr, "g2ba:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListResponse: return soap_out_PointerTog2ba__GetBusinessEntityUserListResponse(soap, tag, id, (g2ba__GetBusinessEntityUserListResponse *const*)ptr, "g2ba:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListRequest: return soap_out_PointerTog2ba__GetBusinessEntityUserListRequest(soap, tag, id, (g2ba__GetBusinessEntityUserListRequest *const*)ptr, "g2ba:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserResponse: return soap_out_PointerTog2ba__AddBusinessEntityUserResponse(soap, tag, id, (g2ba__AddBusinessEntityUserResponse *const*)ptr, "g2ba:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserRequest: return soap_out_PointerTog2ba__AddBusinessEntityUserRequest(soap, tag, id, (g2ba__AddBusinessEntityUserRequest *const*)ptr, "g2ba:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationResponse: return soap_out_PointerTog2ba__CheckShipmentRegionalizationResponse(soap, tag, id, (g2ba__CheckShipmentRegionalizationResponse *const*)ptr, "g2ba:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationRequest: return soap_out_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, tag, id, (g2ba__CheckShipmentRegionalizationRequest *const*)ptr, "g2ba:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsResponse: return soap_out_PointerTog2ba__UpdateVeterinaryEventsResponse(soap, tag, id, (g2ba__UpdateVeterinaryEventsResponse *const*)ptr, "g2ba:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsRequest: return soap_out_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, tag, id, (g2ba__UpdateVeterinaryEventsRequest *const*)ptr, "g2ba:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsResponse: return soap_out_PointerTog2ba__UpdateTransportMovementDetailsResponse(soap, tag, id, (g2ba__UpdateTransportMovementDetailsResponse *const*)ptr, "g2ba:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsRequest: return soap_out_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, tag, id, (g2ba__UpdateTransportMovementDetailsRequest *const*)ptr, "g2ba:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListResponse: return soap_out_PointerTog2ba__GetStockEntryVersionListResponse(soap, tag, id, (g2ba__GetStockEntryVersionListResponse *const*)ptr, "g2ba:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListRequest: return soap_out_PointerTog2ba__GetStockEntryVersionListRequest(soap, tag, id, (g2ba__GetStockEntryVersionListRequest *const*)ptr, "g2ba:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListResponse: return soap_out_PointerTog2ba__GetStockEntryChangesListResponse(soap, tag, id, (g2ba__GetStockEntryChangesListResponse *const*)ptr, "g2ba:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListRequest: return soap_out_PointerTog2ba__GetStockEntryChangesListRequest(soap, tag, id, (g2ba__GetStockEntryChangesListRequest *const*)ptr, "g2ba:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListResponse: return soap_out_PointerTog2ba__GetStockEntryListResponse(soap, tag, id, (g2ba__GetStockEntryListResponse *const*)ptr, "g2ba:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListRequest: return soap_out_PointerTog2ba__GetStockEntryListRequest(soap, tag, id, (g2ba__GetStockEntryListRequest *const*)ptr, "g2ba:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidResponse: return soap_out_PointerTog2ba__GetStockEntryByUuidResponse(soap, tag, id, (g2ba__GetStockEntryByUuidResponse *const*)ptr, "g2ba:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidRequest: return soap_out_PointerTog2ba__GetStockEntryByUuidRequest(soap, tag, id, (g2ba__GetStockEntryByUuidRequest *const*)ptr, "g2ba:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidResponse: return soap_out_PointerTog2ba__GetStockEntryByGuidResponse(soap, tag, id, (g2ba__GetStockEntryByGuidResponse *const*)ptr, "g2ba:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidRequest: return soap_out_PointerTog2ba__GetStockEntryByGuidRequest(soap, tag, id, (g2ba__GetStockEntryByGuidRequest *const*)ptr, "g2ba:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListResponse: return soap_out_PointerTog2ba__GetVetDocumentChangesListResponse(soap, tag, id, (g2ba__GetVetDocumentChangesListResponse *const*)ptr, "g2ba:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListRequest: return soap_out_PointerTog2ba__GetVetDocumentChangesListRequest(soap, tag, id, (g2ba__GetVetDocumentChangesListRequest *const*)ptr, "g2ba:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListResponse: return soap_out_PointerTog2ba__GetVetDocumentListResponse(soap, tag, id, (g2ba__GetVetDocumentListResponse *const*)ptr, "g2ba:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListRequest: return soap_out_PointerTog2ba__GetVetDocumentListRequest(soap, tag, id, (g2ba__GetVetDocumentListRequest *const*)ptr, "g2ba:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidResponse: return soap_out_PointerTog2ba__GetVetDocumentByUuidResponse(soap, tag, id, (g2ba__GetVetDocumentByUuidResponse *const*)ptr, "g2ba:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidRequest: return soap_out_PointerTog2ba__GetVetDocumentByUuidRequest(soap, tag, id, (g2ba__GetVetDocumentByUuidRequest *const*)ptr, "g2ba:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListResponse: return soap_out_PointerTog2ba__ModifyProducerStockListResponse(soap, tag, id, (g2ba__ModifyProducerStockListResponse *const*)ptr, "g2ba:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListRequest: return soap_out_PointerTog2ba__ModifyProducerStockListRequest(soap, tag, id, (g2ba__ModifyProducerStockListRequest *const*)ptr, "g2ba:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyResponse: return soap_out_PointerTog2ba__ResolveDiscrepancyResponse(soap, tag, id, (g2ba__ResolveDiscrepancyResponse *const*)ptr, "g2ba:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyRequest: return soap_out_PointerTog2ba__ResolveDiscrepancyRequest(soap, tag, id, (g2ba__ResolveDiscrepancyRequest *const*)ptr, "g2ba:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsResponse: return soap_out_PointerTog2ba__ModifyActivityLocationsResponse(soap, tag, id, (g2ba__ModifyActivityLocationsResponse *const*)ptr, "g2ba:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsRequest: return soap_out_PointerTog2ba__ModifyActivityLocationsRequest(soap, tag, id, (g2ba__ModifyActivityLocationsRequest *const*)ptr, "g2ba:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseResponse: return soap_out_PointerTog2ba__ModifyEnterpriseResponse(soap, tag, id, (g2ba__ModifyEnterpriseResponse *const*)ptr, "g2ba:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseRequest: return soap_out_PointerTog2ba__ModifyEnterpriseRequest(soap, tag, id, (g2ba__ModifyEnterpriseRequest *const*)ptr, "g2ba:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityResponse: return soap_out_PointerTog2ba__ModifyBusinessEntityResponse(soap, tag, id, (g2ba__ModifyBusinessEntityResponse *const*)ptr, "g2ba:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityRequest: return soap_out_PointerTog2ba__ModifyBusinessEntityRequest(soap, tag, id, (g2ba__ModifyBusinessEntityRequest *const*)ptr, "g2ba:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentResponse: return soap_out_PointerTog2ba__WithdrawVetDocumentResponse(soap, tag, id, (g2ba__WithdrawVetDocumentResponse *const*)ptr, "g2ba:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentRequest: return soap_out_PointerTog2ba__WithdrawVetDocumentRequest(soap, tag, id, (g2ba__WithdrawVetDocumentRequest *const*)ptr, "g2ba:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesResponse: return soap_out_PointerTog2ba__MergeStockEntriesResponse(soap, tag, id, (g2ba__MergeStockEntriesResponse *const*)ptr, "g2ba:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesRequest: return soap_out_PointerTog2ba__MergeStockEntriesRequest(soap, tag, id, (g2ba__MergeStockEntriesRequest *const*)ptr, "g2ba:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationResponse: return soap_out_PointerTog2ba__RegisterProductionOperationResponse(soap, tag, id, (g2ba__RegisterProductionOperationResponse *const*)ptr, "g2ba:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationRequest: return soap_out_PointerTog2ba__RegisterProductionOperationRequest(soap, tag, id, (g2ba__RegisterProductionOperationRequest *const*)ptr, "g2ba:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentResponse: return soap_out_PointerTog2ba__PrepareOutgoingConsignmentResponse(soap, tag, id, (g2ba__PrepareOutgoingConsignmentResponse *const*)ptr, "g2ba:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentRequest: return soap_out_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, tag, id, (g2ba__PrepareOutgoingConsignmentRequest *const*)ptr, "g2ba:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentResponse: return soap_out_PointerTog2ba__ProcessIncomingConsignmentResponse(soap, tag, id, (g2ba__ProcessIncomingConsignmentResponse *const*)ptr, "g2ba:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentRequest: return soap_out_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, tag, id, (g2ba__ProcessIncomingConsignmentRequest *const*)ptr, "g2ba:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: return soap_out_PointerTo_ws__receiveApplicationResultResponse(soap, tag, id, (_ws__receiveApplicationResultResponse *const*)ptr, "ws:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: return soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, tag, id, (_ws__receiveApplicationResultRequest *const*)ptr, "ws:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: return soap_out_PointerTo_ws__submitApplicationResponse(soap, tag, id, (_ws__submitApplicationResponse *const*)ptr, "ws:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: return soap_out_PointerTo_ws__submitApplicationRequest(soap, tag, id, (_ws__submitApplicationRequest *const*)ptr, "ws:submitApplicationRequest");
	case SOAP_TYPE_PointerTobase__FaultInfo: return soap_out_PointerTobase__FaultInfo(soap, tag, id, (base__FaultInfo *const*)ptr, "base:FaultInfo");
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: return soap_out_PointerTovd__StockEntryBlankFilter(soap, tag, id, (enum vd__StockEntryBlankFilter *const*)ptr, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTovd__StockEntryEventList: return soap_out_PointerTovd__StockEntryEventList(soap, tag, id, (vd__StockEntryEventList *const*)ptr, "vd:StockEntryEventList");
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: return soap_out_PointerTovd__DiscrepancyReason(soap, tag, id, (vd__DiscrepancyReason *const*)ptr, "vd:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: return soap_out_PointerToPointerTovd__VetDocumentStatusChange(soap, tag, id, (vd__VetDocumentStatusChange **const*)ptr, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: return soap_out_PointerTovd__VetDocumentStatusChange(soap, tag, id, (vd__VetDocumentStatusChange *const*)ptr, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: return soap_out_PointerTovd__VeterinaryAuthentication(soap, tag, id, (vd__VeterinaryAuthentication *const*)ptr, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: return soap_out_PointerTovd__CertifiedConsignment(soap, tag, id, (vd__CertifiedConsignment *const*)ptr, "vd:CertifiedConsignment");
	case SOAP_TYPE_PointerTovd__CertifiedBatch: return soap_out_PointerTovd__CertifiedBatch(soap, tag, id, (vd__CertifiedBatch *const*)ptr, "vd:CertifiedBatch");
	case SOAP_TYPE_PointerTovd__VetDocumentForm: return soap_out_PointerTovd__VetDocumentForm(soap, tag, id, (enum vd__VetDocumentForm *const*)ptr, "vd:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationStatus: return soap_out_PointerToPointerTodic__RegionalizationStatus(soap, tag, id, (dic__RegionalizationStatus **const*)ptr, "dic:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerTodic__Area: return soap_out_PointerToPointerTodic__Area(soap, tag, id, (dic__Area **const*)ptr, "dic:Area");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRequirement: return soap_out_PointerToPointerTodic__RegionalizationRequirement(soap, tag, id, (dic__RegionalizationRequirement **const*)ptr, "dic:RegionalizationRequirement");
	case SOAP_TYPE_PointerTodic__RegionalizationRequirement: return soap_out_PointerTodic__RegionalizationRequirement(soap, tag, id, (dic__RegionalizationRequirement *const*)ptr, "dic:RegionalizationRequirement");
	case SOAP_TYPE_PointerTodic__RegionalizationDecision: return soap_out_PointerTodic__RegionalizationDecision(soap, tag, id, (enum dic__RegionalizationDecision *const*)ptr, "dic:RegionalizationDecision");
	case SOAP_TYPE_PointerTodic__RegionalizationStatus: return soap_out_PointerTodic__RegionalizationStatus(soap, tag, id, (dic__RegionalizationStatus *const*)ptr, "dic:RegionalizationStatus");
	case SOAP_TYPE_PointerTodic__Packaging: return soap_out_PointerTodic__Packaging(soap, tag, id, (dic__Packaging *const*)ptr, "dic:Packaging");
	case SOAP_TYPE_PointerToPointerTodic__ProductItemProducing: return soap_out_PointerToPointerTodic__ProductItemProducing(soap, tag, id, (dic__ProductItemProducing **const*)ptr, "dic:ProductItemProducing");
	case SOAP_TYPE_PointerTodic__ProductItemProducing: return soap_out_PointerTodic__ProductItemProducing(soap, tag, id, (dic__ProductItemProducing *const*)ptr, "dic:ProductItemProducing");
	case SOAP_TYPE_PointerTo_dic__BusinessEntity_activityLocation: return soap_out_PointerTo_dic__BusinessEntity_activityLocation(soap, tag, id, (_dic__BusinessEntity_activityLocation *const*)ptr, "dic:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerTodic__IncorporationForm: return soap_out_PointerTodic__IncorporationForm(soap, tag, id, (dic__IncorporationForm *const*)ptr, "dic:IncorporationForm");
	case SOAP_TYPE_PointerTodic__BusinessEntityType: return soap_out_PointerTodic__BusinessEntityType(soap, tag, id, (enum dic__BusinessEntityType *const*)ptr, "dic:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseOfficialRegistration: return soap_out_PointerToPointerTodic__EnterpriseOfficialRegistration(soap, tag, id, (dic__EnterpriseOfficialRegistration **const*)ptr, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration: return soap_out_PointerTodic__EnterpriseOfficialRegistration(soap, tag, id, (dic__EnterpriseOfficialRegistration *const*)ptr, "dic:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTodic__EnterpriseActivityList: return soap_out_PointerTodic__EnterpriseActivityList(soap, tag, id, (dic__EnterpriseActivityList *const*)ptr, "dic:EnterpriseActivityList");
	case SOAP_TYPE_PointerTodic__EnterpriseNumberList: return soap_out_PointerTodic__EnterpriseNumberList(soap, tag, id, (dic__EnterpriseNumberList *const*)ptr, "dic:EnterpriseNumberList");
	case SOAP_TYPE_PointerTodic__EnterpriseType: return soap_out_PointerTodic__EnterpriseType(soap, tag, id, (char **const*)ptr, "dic:EnterpriseType");
	case SOAP_TYPE_PointerTodic__PackingCodeType: return soap_out_PointerTodic__PackingCodeType(soap, tag, id, (enum dic__PackingCodeType *const*)ptr, "dic:PackingCodeType");
	case SOAP_TYPE_PointerTobase__UUID: return soap_out_PointerTobase__UUID(soap, tag, id, (char **const*)ptr, "base:UUID");
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: return soap_out_PointerTovd__StockEntrySearchPattern(soap, tag, id, (vd__StockEntrySearchPattern *const*)ptr, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTobase__DateInterval: return soap_out_PointerTobase__DateInterval(soap, tag, id, (base__DateInterval *const*)ptr, "base:DateInterval");
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: return soap_out_PointerTovd__VetDocumentStatus(soap, tag, id, (enum vd__VetDocumentStatus *const*)ptr, "vd:VetDocumentStatus");
	case SOAP_TYPE_PointerTovd__VetDocumentType: return soap_out_PointerTovd__VetDocumentType(soap, tag, id, (enum vd__VetDocumentType *const*)ptr, "vd:VetDocumentType");
	case SOAP_TYPE_PointerTobase__ListOptions: return soap_out_PointerTobase__ListOptions(soap, tag, id, (base__ListOptions *const*)ptr, "base:ListOptions");
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: return soap_out_PointerTovd__PSLModificationOperation(soap, tag, id, (vd__PSLModificationOperation *const*)ptr, "vd:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: return soap_out_PointerToPointerTovd__StockDiscrepancy(soap, tag, id, (vd__StockDiscrepancy **const*)ptr, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: return soap_out_PointerTovd__StockDiscrepancy(soap, tag, id, (vd__StockDiscrepancy *const*)ptr, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: return soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, tag, id, (vd__BEActivityLocationsModificationOperation *const*)ptr, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: return soap_out_PointerTovd__ENTModificationOperation(soap, tag, id, (vd__ENTModificationOperation *const*)ptr, "vd:ENTModificationOperation");
	case SOAP_TYPE_PointerTovd__BEModificationOperation: return soap_out_PointerTovd__BEModificationOperation(soap, tag, id, (vd__BEModificationOperation *const*)ptr, "vd:BEModificationOperation");
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: return soap_out_PointerTovd__MergeStockEntriesOperation(soap, tag, id, (vd__MergeStockEntriesOperation *const*)ptr, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTovd__ProductionOperation: return soap_out_PointerTovd__ProductionOperation(soap, tag, id, (vd__ProductionOperation *const*)ptr, "vd:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTovd__Delivery: return soap_out_PointerToPointerTovd__Delivery(soap, tag, id, (vd__Delivery **const*)ptr, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: return soap_out_PointerToPointerTovd__DiscrepancyReport(soap, tag, id, (vd__DiscrepancyReport **const*)ptr, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: return soap_out_PointerTovd__DiscrepancyReport(soap, tag, id, (vd__DiscrepancyReport *const*)ptr, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DeliveryFactList: return soap_out_PointerTovd__DeliveryFactList(soap, tag, id, (vd__DeliveryFactList *const*)ptr, "vd:DeliveryFactList");
	case SOAP_TYPE_PointerTovd__Delivery: return soap_out_PointerTovd__Delivery(soap, tag, id, (vd__Delivery *const*)ptr, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: return soap_out_PointerToPointerTovd__WorkingArea(soap, tag, id, (vd__WorkingArea **const*)ptr, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingArea: return soap_out_PointerTovd__WorkingArea(soap, tag, id, (vd__WorkingArea *const*)ptr, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingAreaList: return soap_out_PointerTovd__WorkingAreaList(soap, tag, id, (vd__WorkingAreaList *const*)ptr, "vd:WorkingAreaList");
	case SOAP_TYPE_PointerTovd__SNILSType: return soap_out_PointerTovd__SNILSType(soap, tag, id, (char **const*)ptr, "vd:SNILSType");
	case SOAP_TYPE_PointerTovd__Citizenship: return soap_out_PointerTovd__Citizenship(soap, tag, id, (vd__Citizenship *const*)ptr, "vd:Citizenship");
	case SOAP_TYPE_PointerTodic__MedicinalDrug: return soap_out_PointerTodic__MedicinalDrug(soap, tag, id, (dic__MedicinalDrug *const*)ptr, "dic:MedicinalDrug");
	case SOAP_TYPE_PointerTodic__Indicator: return soap_out_PointerTodic__Indicator(soap, tag, id, (dic__Indicator *const*)ptr, "dic:Indicator");
	case SOAP_TYPE_PointerTodic__DocumentType: return soap_out_PointerTodic__DocumentType(soap, tag, id, (enum dic__DocumentType *const*)ptr, "dic:DocumentType");
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: return soap_out_PointerTovd__ConsignmentDocumentList(soap, tag, id, (vd__ConsignmentDocumentList *const*)ptr, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTovd__Consignment: return soap_out_PointerToPointerTovd__Consignment(soap, tag, id, (vd__Consignment **const*)ptr, "vd:Consignment");
	case SOAP_TYPE_PointerTovd__Consignment: return soap_out_PointerTovd__Consignment(soap, tag, id, (vd__Consignment *const*)ptr, "vd:Consignment");
	case SOAP_TYPE_PointerToPointerTodic__BusinessMember: return soap_out_PointerToPointerTodic__BusinessMember(soap, tag, id, (dic__BusinessMember **const*)ptr, "dic:BusinessMember");
	case SOAP_TYPE_PointerToPointerTodic__ResearchMethod: return soap_out_PointerToPointerTodic__ResearchMethod(soap, tag, id, (dic__ResearchMethod **const*)ptr, "dic:ResearchMethod");
	case SOAP_TYPE_PointerTodic__ResearchMethod: return soap_out_PointerTodic__ResearchMethod(soap, tag, id, (dic__ResearchMethod *const*)ptr, "dic:ResearchMethod");
	case SOAP_TYPE_PointerToPointerTodic__AnimalDisease: return soap_out_PointerToPointerTodic__AnimalDisease(soap, tag, id, (dic__AnimalDisease **const*)ptr, "dic:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRegionStatus: return soap_out_PointerToPointerTodic__RegionalizationRegionStatus(soap, tag, id, (dic__RegionalizationRegionStatus **const*)ptr, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerTodic__RegionalizationRegionStatus: return soap_out_PointerTodic__RegionalizationRegionStatus(soap, tag, id, (dic__RegionalizationRegionStatus *const*)ptr, "dic:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerTodic__ProductItem: return soap_out_PointerToPointerTodic__ProductItem(soap, tag, id, (dic__ProductItem **const*)ptr, "dic:ProductItem");
	case SOAP_TYPE_PointerToPointerTodic__SubProduct: return soap_out_PointerToPointerTodic__SubProduct(soap, tag, id, (dic__SubProduct **const*)ptr, "dic:SubProduct");
	case SOAP_TYPE_PointerToPointerTodic__Product: return soap_out_PointerToPointerTodic__Product(soap, tag, id, (dic__Product **const*)ptr, "dic:Product");
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseActivity: return soap_out_PointerToPointerTodic__EnterpriseActivity(soap, tag, id, (dic__EnterpriseActivity **const*)ptr, "dic:EnterpriseActivity");
	case SOAP_TYPE_PointerTodic__EnterpriseActivity: return soap_out_PointerTodic__EnterpriseActivity(soap, tag, id, (dic__EnterpriseActivity *const*)ptr, "dic:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerTodic__Street: return soap_out_PointerToPointerTodic__Street(soap, tag, id, (dic__Street **const*)ptr, "dic:Street");
	case SOAP_TYPE_PointerToPointerTodic__Locality: return soap_out_PointerToPointerTodic__Locality(soap, tag, id, (dic__Locality **const*)ptr, "dic:Locality");
	case SOAP_TYPE_PointerToPointerTodic__District: return soap_out_PointerToPointerTodic__District(soap, tag, id, (dic__District **const*)ptr, "dic:District");
	case SOAP_TYPE_PointerToPointerTodic__Region: return soap_out_PointerToPointerTodic__Region(soap, tag, id, (dic__Region **const*)ptr, "dic:Region");
	case SOAP_TYPE_PointerToPointerTodic__Country: return soap_out_PointerToPointerTodic__Country(soap, tag, id, (dic__Country **const*)ptr, "dic:Country");
	case SOAP_TYPE_PointerToPointerTodic__Unit: return soap_out_PointerToPointerTodic__Unit(soap, tag, id, (dic__Unit **const*)ptr, "dic:Unit");
	case SOAP_TYPE_PointerToPointerTodic__Purpose: return soap_out_PointerToPointerTodic__Purpose(soap, tag, id, (dic__Purpose **const*)ptr, "dic:Purpose");
	case SOAP_TYPE_PointerTobase__VersionStatus: return soap_out_PointerTobase__VersionStatus(soap, tag, id, (char **const*)ptr, "base:VersionStatus");
	case SOAP_TYPE_PointerTovd__AuthorityList: return soap_out_PointerTovd__AuthorityList(soap, tag, id, (vd__AuthorityList *const*)ptr, "vd:AuthorityList");
	case SOAP_TYPE_PointerTovd__UserList: return soap_out_PointerTovd__UserList(soap, tag, id, (vd__UserList *const*)ptr, "vd:UserList");
	case SOAP_TYPE_PointerToPointerTovd__User: return soap_out_PointerToPointerTovd__User(soap, tag, id, (vd__User **const*)ptr, "vd:User");
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: return soap_out_PointerToPointerTovd__RouteSectionR13nRules(soap, tag, id, (vd__RouteSectionR13nRules **const*)ptr, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: return soap_out_PointerTovd__RouteSectionR13nRules(soap, tag, id, (vd__RouteSectionR13nRules *const*)ptr, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__VetDocumentList: return soap_out_PointerTovd__VetDocumentList(soap, tag, id, (vd__VetDocumentList *const*)ptr, "vd:VetDocumentList");
	case SOAP_TYPE_PointerToPointerTodic__Enterprise: return soap_out_PointerToPointerTodic__Enterprise(soap, tag, id, (dic__Enterprise **const*)ptr, "dic:Enterprise");
	case SOAP_TYPE_PointerToPointerTodic__BusinessEntity: return soap_out_PointerToPointerTodic__BusinessEntity(soap, tag, id, (dic__BusinessEntity **const*)ptr, "dic:BusinessEntity");
	case SOAP_TYPE_PointerTodic__OTPToken: return soap_out_PointerTodic__OTPToken(soap, tag, id, (char **const*)ptr, "dic:OTPToken");
	case SOAP_TYPE_PointerToapp__Application: return soap_out_PointerToapp__Application(soap, tag, id, (app__Application *const*)ptr, "app:Application");
	case SOAP_TYPE_PointerTodic__Area: return soap_out_PointerTodic__Area(soap, tag, id, (dic__Area *const*)ptr, "dic:Area");
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: return soap_out_PointerToPointerTovd__UserAuthority(soap, tag, id, (vd__UserAuthority **const*)ptr, "vd:UserAuthority");
	case SOAP_TYPE_PointerTovd__UserAuthority: return soap_out_PointerTovd__UserAuthority(soap, tag, id, (vd__UserAuthority *const*)ptr, "vd:UserAuthority");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationShippingRule: return soap_out_PointerToPointerTodic__RegionalizationShippingRule(soap, tag, id, (dic__RegionalizationShippingRule **const*)ptr, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTodic__RegionalizationShippingRule: return soap_out_PointerTodic__RegionalizationShippingRule(soap, tag, id, (dic__RegionalizationShippingRule *const*)ptr, "dic:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTobase__SequenceNumber: return soap_out_PointerTobase__SequenceNumber(soap, tag, id, (char **const*)ptr, "base:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: return soap_out_PointerToPointerTovd__QuarantineEvent(soap, tag, id, (vd__QuarantineEvent **const*)ptr, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: return soap_out_PointerToPointerTovd__RegionalizationClause(soap, tag, id, (vd__RegionalizationClause **const*)ptr, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerTovd__RegionalizationClause: return soap_out_PointerTovd__RegionalizationClause(soap, tag, id, (vd__RegionalizationClause *const*)ptr, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: return soap_out_PointerToPointerTovd__VeterinaryEvent(soap, tag, id, (vd__VeterinaryEvent **const*)ptr, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: return soap_out_PointerTovd__VeterinaryEvent(soap, tag, id, (vd__VeterinaryEvent *const*)ptr, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: return soap_out_PointerToPointerTovd__AnimalMedicationEvent(soap, tag, id, (vd__AnimalMedicationEvent **const*)ptr, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: return soap_out_PointerTovd__AnimalMedicationEvent(soap, tag, id, (vd__AnimalMedicationEvent *const*)ptr, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__QuarantineEvent: return soap_out_PointerTovd__QuarantineEvent(soap, tag, id, (vd__QuarantineEvent *const*)ptr, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: return soap_out_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag, id, (vd__LaboratoryResearchEvent **const*)ptr, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: return soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag, id, (vd__LaboratoryResearchEvent *const*)ptr, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: return soap_out_PointerTovd__AnimalSpentPeriod(soap, tag, id, (enum vd__AnimalSpentPeriod *const*)ptr, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_PointerTodic__ResearchResult: return soap_out_PointerTodic__ResearchResult(soap, tag, id, (enum dic__ResearchResult *const*)ptr, "dic:ResearchResult");
	case SOAP_TYPE_PointerTodic__Purpose: return soap_out_PointerTodic__Purpose(soap, tag, id, (dic__Purpose *const*)ptr, "dic:Purpose");
	case SOAP_TYPE_PointerToPointerTovd__Document: return soap_out_PointerToPointerTovd__Document(soap, tag, id, (vd__Document **const*)ptr, "vd:Document");
	case SOAP_TYPE_PointerTovd__Document: return soap_out_PointerTovd__Document(soap, tag, id, (vd__Document *const*)ptr, "vd:Document");
	case SOAP_TYPE_PointerTodic__Organization: return soap_out_PointerTodic__Organization(soap, tag, id, (dic__Organization *const*)ptr, "dic:Organization");
	case SOAP_TYPE_PointerTodic__Location: return soap_out_PointerTodic__Location(soap, tag, id, (dic__Location *const*)ptr, "dic:Location");
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: return soap_out_PointerTovd__VeterinaryEventType(soap, tag, id, (enum vd__VeterinaryEventType *const*)ptr, "vd:VeterinaryEventType");
	case SOAP_TYPE_PointerTovd__ShipmentRoute: return soap_out_PointerTovd__ShipmentRoute(soap, tag, id, (vd__ShipmentRoute *const*)ptr, "vd:ShipmentRoute");
	case SOAP_TYPE_PointerTodic__TransportationStorageType: return soap_out_PointerTodic__TransportationStorageType(soap, tag, id, (enum dic__TransportationStorageType *const*)ptr, "dic:TransportationStorageType");
	case SOAP_TYPE_PointerTovd__TransportInfo: return soap_out_PointerTovd__TransportInfo(soap, tag, id, (vd__TransportInfo *const*)ptr, "vd:TransportInfo");
	case SOAP_TYPE_PointerTovd__Batch: return soap_out_PointerTovd__Batch(soap, tag, id, (vd__Batch *const*)ptr, "vd:Batch");
	case SOAP_TYPE_PointerTodic__EnterpriseList: return soap_out_PointerTodic__EnterpriseList(soap, tag, id, (dic__EnterpriseList *const*)ptr, "dic:EnterpriseList");
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: return soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, (_vd__BEActivityLocationsModificationOperation_activityLocation *const*)ptr, "vd:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerTodic__BusinessEntityList: return soap_out_PointerTodic__BusinessEntityList(soap, tag, id, (dic__BusinessEntityList *const*)ptr, "dic:BusinessEntityList");
	case SOAP_TYPE_PointerTodic__ProductItemList: return soap_out_PointerTodic__ProductItemList(soap, tag, id, (dic__ProductItemList *const*)ptr, "dic:ProductItemList");
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: return soap_out_PointerToPointerTovd__StockEntry(soap, tag, id, (vd__StockEntry **const*)ptr, "vd:StockEntry");
	case SOAP_TYPE_PointerTobase__RegisterModificationType: return soap_out_PointerTobase__RegisterModificationType(soap, tag, id, (enum base__RegisterModificationType *const*)ptr, "base:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: return soap_out_PointerToPointerTovd__ProcessingProcedure(soap, tag, id, (vd__ProcessingProcedure **const*)ptr, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: return soap_out_PointerTovd__ProcessingProcedure(soap, tag, id, (vd__ProcessingProcedure *const*)ptr, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: return soap_out_PointerToPointerTovd__ProductiveBatch(soap, tag, id, (vd__ProductiveBatch **const*)ptr, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerTovd__ProductiveBatch: return soap_out_PointerTovd__ProductiveBatch(soap, tag, id, (vd__ProductiveBatch *const*)ptr, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: return soap_out_PointerToPointerTovd__RawBatch(soap, tag, id, (vd__RawBatch **const*)ptr, "vd:RawBatch");
	case SOAP_TYPE_PointerTovd__RawBatch: return soap_out_PointerTovd__RawBatch(soap, tag, id, (vd__RawBatch *const*)ptr, "vd:RawBatch");
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: return soap_out_PointerToPointerTovd__ShipmentRoutePoint(soap, tag, id, (vd__ShipmentRoutePoint **const*)ptr, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: return soap_out_PointerTovd__ShipmentRoutePoint(soap, tag, id, (vd__ShipmentRoutePoint *const*)ptr, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__TransportNumber: return soap_out_PointerTovd__TransportNumber(soap, tag, id, (vd__TransportNumber *const*)ptr, "vd:TransportNumber");
	case SOAP_TYPE_PointerTodic__TransportType: return soap_out_PointerTodic__TransportType(soap, tag, id, (enum dic__TransportType *const*)ptr, "dic:TransportType");
	case SOAP_TYPE_PointerTovd__StockEntryList: return soap_out_PointerTovd__StockEntryList(soap, tag, id, (vd__StockEntryList *const*)ptr, "vd:StockEntryList");
	case SOAP_TYPE_PointerTodic__ComplexDate: return soap_out_PointerTodic__ComplexDate(soap, tag, id, (dic__ComplexDate *const*)ptr, "dic:ComplexDate");
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: return soap_out_PointerToPointerTovd__ReferencedDocument(soap, tag, id, (vd__ReferencedDocument **const*)ptr, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerTovd__ReferencedDocument: return soap_out_PointerTovd__ReferencedDocument(soap, tag, id, (vd__ReferencedDocument *const*)ptr, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: return soap_out_PointerToPointerTovd__VetDocument(soap, tag, id, (vd__VetDocument **const*)ptr, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__VetDocument: return soap_out_PointerTovd__VetDocument(soap, tag, id, (vd__VetDocument *const*)ptr, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__Waybill: return soap_out_PointerTovd__Waybill(soap, tag, id, (vd__Waybill *const*)ptr, "vd:Waybill");
	case SOAP_TYPE_PointerTovd__User: return soap_out_PointerTovd__User(soap, tag, id, (vd__User *const*)ptr, "vd:User");
	case SOAP_TYPE_PointerTovd__DeliveryInspection: return soap_out_PointerTovd__DeliveryInspection(soap, tag, id, (vd__DeliveryInspection *const*)ptr, "vd:DeliveryInspection");
	case SOAP_TYPE_PointerTovd__StockEntry: return soap_out_PointerTovd__StockEntry(soap, tag, id, (vd__StockEntry *const*)ptr, "vd:StockEntry");
	case SOAP_TYPE_PointerTodic__PackageList: return soap_out_PointerTodic__PackageList(soap, tag, id, (dic__PackageList *const*)ptr, "dic:PackageList");
	case SOAP_TYPE_PointerTovd__BatchOrigin: return soap_out_PointerTovd__BatchOrigin(soap, tag, id, (vd__BatchOrigin *const*)ptr, "vd:BatchOrigin");
	case SOAP_TYPE_PointerTovd__GoodsDate: return soap_out_PointerTovd__GoodsDate(soap, tag, id, (vd__GoodsDate *const*)ptr, "vd:GoodsDate");
	case SOAP_TYPE_PointerTodic__ProductItem: return soap_out_PointerTodic__ProductItem(soap, tag, id, (dic__ProductItem *const*)ptr, "dic:ProductItem");
	case SOAP_TYPE_PointerTodic__SubProduct: return soap_out_PointerTodic__SubProduct(soap, tag, id, (dic__SubProduct *const*)ptr, "dic:SubProduct");
	case SOAP_TYPE_PointerTodic__Product: return soap_out_PointerTodic__Product(soap, tag, id, (dic__Product *const*)ptr, "dic:Product");
	case SOAP_TYPE_PointerTodic__ProductType: return soap_out_PointerTodic__ProductType(soap, tag, id, (enum dic__ProductType *const*)ptr, "dic:ProductType");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationConditionGroup: return soap_out_PointerToPointerTodic__RegionalizationConditionGroup(soap, tag, id, (dic__RegionalizationConditionGroup **const*)ptr, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTodic__RegionalizationConditionGroup: return soap_out_PointerTodic__RegionalizationConditionGroup(soap, tag, id, (dic__RegionalizationConditionGroup *const*)ptr, "dic:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTodic__AnimalDisease: return soap_out_PointerTodic__AnimalDisease(soap, tag, id, (dic__AnimalDisease *const*)ptr, "dic:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationCondition: return soap_out_PointerToPointerTodic__RegionalizationCondition(soap, tag, id, (dic__RegionalizationCondition **const*)ptr, "dic:RegionalizationCondition");
	case SOAP_TYPE_PointerTodic__RegionalizationCondition: return soap_out_PointerTodic__RegionalizationCondition(soap, tag, id, (dic__RegionalizationCondition *const*)ptr, "dic:RegionalizationCondition");
	case SOAP_TYPE_PointerTodic__BusinessMember: return soap_out_PointerTodic__BusinessMember(soap, tag, id, (dic__BusinessMember *const*)ptr, "dic:BusinessMember");
	case SOAP_TYPE_PointerTobase__Identifier: return soap_out_PointerTobase__Identifier(soap, tag, id, (char **const*)ptr, "base:Identifier");
	case SOAP_TYPE_PointerTodic__Address: return soap_out_PointerTodic__Address(soap, tag, id, (dic__Address *const*)ptr, "dic:Address");
	case SOAP_TYPE_PointerTodic__Unit: return soap_out_PointerTodic__Unit(soap, tag, id, (dic__Unit *const*)ptr, "dic:Unit");
	case SOAP_TYPE_PointerTobase__Decimal: return soap_out_PointerTobase__Decimal(soap, tag, id, (char **const*)ptr, "base:Decimal");
	case SOAP_TYPE_PointerTodic__Minute: return soap_out_PointerTodic__Minute(soap, tag, id, (int *const*)ptr, "dic:Minute");
	case SOAP_TYPE_PointerTodic__Hour: return soap_out_PointerTodic__Hour(soap, tag, id, (int *const*)ptr, "dic:Hour");
	case SOAP_TYPE_PointerTodic__Day: return soap_out_PointerTodic__Day(soap, tag, id, (int *const*)ptr, "dic:Day");
	case SOAP_TYPE_PointerTodic__Month: return soap_out_PointerTodic__Month(soap, tag, id, (int *const*)ptr, "dic:Month");
	case SOAP_TYPE_PointerTodic__Year: return soap_out_PointerTodic__Year(soap, tag, id, (int *const*)ptr, "dic:Year");
	case SOAP_TYPE_PointerToPointerTodic__Package: return soap_out_PointerToPointerTodic__Package(soap, tag, id, (dic__Package **const*)ptr, "dic:Package");
	case SOAP_TYPE_PointerTodic__Package: return soap_out_PointerTodic__Package(soap, tag, id, (dic__Package *const*)ptr, "dic:Package");
	case SOAP_TYPE_PointerToPointerTodic__ProductMarks: return soap_out_PointerToPointerTodic__ProductMarks(soap, tag, id, (dic__ProductMarks **const*)ptr, "dic:ProductMarks");
	case SOAP_TYPE_PointerTodic__ProductMarks: return soap_out_PointerTodic__ProductMarks(soap, tag, id, (dic__ProductMarks *const*)ptr, "dic:ProductMarks");
	case SOAP_TYPE_PointerTodic__PackingType: return soap_out_PointerTodic__PackingType(soap, tag, id, (dic__PackingType *const*)ptr, "dic:PackingType");
	case SOAP_TYPE_PointerTodic__GLNType: return soap_out_PointerTodic__GLNType(soap, tag, id, (char **const*)ptr, "dic:GLNType");
	case SOAP_TYPE_PointerTodic__BusinessEntity: return soap_out_PointerTodic__BusinessEntity(soap, tag, id, (dic__BusinessEntity *const*)ptr, "dic:BusinessEntity");
	case SOAP_TYPE_PointerTobase__String255: return soap_out_PointerTobase__String255(soap, tag, id, (char **const*)ptr, "base:String255");
	case SOAP_TYPE_PointerToPointerTodic__Producer: return soap_out_PointerToPointerTodic__Producer(soap, tag, id, (dic__Producer **const*)ptr, "dic:Producer");
	case SOAP_TYPE_PointerTodic__Producer: return soap_out_PointerTodic__Producer(soap, tag, id, (dic__Producer *const*)ptr, "dic:Producer");
	case SOAP_TYPE_PointerTodic__EnterpriseRole: return soap_out_PointerTodic__EnterpriseRole(soap, tag, id, (enum dic__EnterpriseRole *const*)ptr, "dic:EnterpriseRole");
	case SOAP_TYPE_PointerTodic__Enterprise: return soap_out_PointerTodic__Enterprise(soap, tag, id, (dic__Enterprise *const*)ptr, "dic:Enterprise");
	case SOAP_TYPE_PointerTobase__NText: return soap_out_PointerTobase__NText(soap, tag, id, (char **const*)ptr, "base:NText");
	case SOAP_TYPE_PointerTodic__Street: return soap_out_PointerTodic__Street(soap, tag, id, (dic__Street *const*)ptr, "dic:Street");
	case SOAP_TYPE_PointerTodic__Locality: return soap_out_PointerTodic__Locality(soap, tag, id, (dic__Locality *const*)ptr, "dic:Locality");
	case SOAP_TYPE_PointerTodic__District: return soap_out_PointerTodic__District(soap, tag, id, (dic__District *const*)ptr, "dic:District");
	case SOAP_TYPE_PointerTodic__Region: return soap_out_PointerTodic__Region(soap, tag, id, (dic__Region *const*)ptr, "dic:Region");
	case SOAP_TYPE_PointerTodic__FederalDistrict: return soap_out_PointerTodic__FederalDistrict(soap, tag, id, (dic__FederalDistrict *const*)ptr, "dic:FederalDistrict");
	case SOAP_TYPE_PointerTodic__Country: return soap_out_PointerTodic__Country(soap, tag, id, (dic__Country *const*)ptr, "dic:Country");
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: return soap_out_PointerToPointerToapp__BusinessError(soap, tag, id, (app__BusinessError **const*)ptr, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__BusinessError: return soap_out_PointerToapp__BusinessError(soap, tag, id, (app__BusinessError *const*)ptr, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__ContentEncoding: return soap_out_PointerToapp__ContentEncoding(soap, tag, id, (enum app__ContentEncoding *const*)ptr, "app:ContentEncoding");
	case SOAP_TYPE_PointerToapp__BusinessErrorList: return soap_out_PointerToapp__BusinessErrorList(soap, tag, id, (app__BusinessErrorList *const*)ptr, "app:BusinessErrorList");
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: return soap_out_PointerToapp__ApplicationResultWrapper(soap, tag, id, (app__ApplicationResultWrapper *const*)ptr, "app:ApplicationResultWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: return soap_out_PointerToapp__ApplicationDataWrapper(soap, tag, id, (app__ApplicationDataWrapper *const*)ptr, "app:ApplicationDataWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationStatus: return soap_out_PointerToapp__ApplicationStatus(soap, tag, id, (enum app__ApplicationStatus *const*)ptr, "app:ApplicationStatus");
	case SOAP_TYPE_PointerTobase__Hour: return soap_out_PointerTobase__Hour(soap, tag, id, (int *const*)ptr, "base:Hour");
	case SOAP_TYPE_PointerTobase__Day: return soap_out_PointerTobase__Day(soap, tag, id, (int *const*)ptr, "base:Day");
	case SOAP_TYPE_PointerTobase__Month: return soap_out_PointerTobase__Month(soap, tag, id, (int *const*)ptr, "base:Month");
	case SOAP_TYPE_PointerTobase__Year: return soap_out_PointerTobase__Year(soap, tag, id, (int *const*)ptr, "base:Year");
	case SOAP_TYPE_PointerToPointerTobase__Error: return soap_out_PointerToPointerTobase__Error(soap, tag, id, (base__Error **const*)ptr, "base:Error");
	case SOAP_TYPE_PointerTobase__Error: return soap_out_PointerTobase__Error(soap, tag, id, (base__Error *const*)ptr, "base:Error");
	case SOAP_TYPE_PointerTobool: return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:VetDocumentStatusChangeReason");
	case SOAP_TYPE_dic__GRNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:GRNType");
	case SOAP_TYPE_vd__SNILSType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:SNILSType");
	case SOAP_TYPE_vd__StockEntryNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:StockEntryNumber");
	case SOAP_TYPE_dic__OTPToken: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:OTPToken");
	case SOAP_TYPE_dic__GTINType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:GTINType");
	case SOAP_TYPE_dic__GLNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:GLNType");
	case SOAP_TYPE_dic__ENTModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:ENTModificationReason");
	case SOAP_TYPE_dic__BEModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:BEModificationReason");
	case SOAP_TYPE_dic__EnterpriseType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:EnterpriseType");
	case SOAP_TYPE_dic__Code3: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:Code3");
	case SOAP_TYPE_dic__Code: return soap_out_string(soap, tag, id, (char*const*)&ptr, "dic:Code");
	case SOAP_TYPE_app__APIKey: return soap_out_string(soap, tag, id, (char*const*)&ptr, "app:APIKey");
	case SOAP_TYPE_base__SequenceNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:SequenceNumber");
	case SOAP_TYPE_base__Identifier: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Identifier");
	case SOAP_TYPE_base__VersionStatus: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:VersionStatus");
	case SOAP_TYPE_base__Decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Decimal");
	case SOAP_TYPE_base__String32: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:String32");
	case SOAP_TYPE_base__String255: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:String255");
	case SOAP_TYPE_base__NText: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:NText");
	case SOAP_TYPE_base__Text: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Text");
	case SOAP_TYPE_base__UUID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:UUID");
	case SOAP_TYPE_xsd__token: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__positiveInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_PointerTounsignedByte: return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:Name");
	case SOAP_TYPE_xsd__NCName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__IDREF: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
	case SOAP_TYPE__QName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch(type) {
	case SOAP_TYPE__dic__BusinessEntity_activityLocation: ((_dic__BusinessEntity_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: ((_vd__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BinaryContent: soap_serialize_app__BinaryContent(soap, (const xsd__base64Binary *)ptr); break;
	case SOAP_TYPE__ws__receiveApplicationResultResponse: ((_ws__receiveApplicationResultResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__receiveApplicationResultRequest: ((_ws__receiveApplicationResultRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__submitApplicationResponse: ((_ws__submitApplicationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__submitApplicationRequest: ((_ws__submitApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Citizenship: ((vd__Citizenship *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__WorkingArea: ((vd__WorkingArea *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__UserAuthority: ((vd__UserAuthority *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__WorkingAreaList: ((vd__WorkingAreaList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__AuthorityList: ((vd__AuthorityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__UserList: ((vd__UserList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__User: ((vd__User *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProcessingProcedure: ((vd__ProcessingProcedure *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RouteSectionR13nRules: ((vd__RouteSectionR13nRules *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RegionalizationClause: ((vd__RegionalizationClause *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocumentStatusChange: ((vd__VetDocumentStatusChange *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntryEventList: ((vd__StockEntryEventList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BatchOrigin: ((vd__BatchOrigin *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VeterinaryAuthentication: ((vd__VeterinaryAuthentication *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__QuarantineEvent: ((vd__QuarantineEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__AnimalMedicationEvent: ((vd__AnimalMedicationEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__LaboratoryResearchEvent: ((vd__LaboratoryResearchEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VeterinaryEvent: ((vd__VeterinaryEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ReferencedDocument: ((vd__ReferencedDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__CertifiedConsignment: ((vd__CertifiedConsignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__CertifiedBatch: ((vd__CertifiedBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ENTModificationOperation: ((vd__ENTModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: ((vd__BEActivityLocationsModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BEModificationOperation: ((vd__BEModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__PSLModificationOperation: ((vd__PSLModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__MergeStockEntriesOperation: ((vd__MergeStockEntriesOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProductionOperation: ((vd__ProductionOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ShipmentRoute: ((vd__ShipmentRoute *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ShipmentRoutePoint: ((vd__ShipmentRoutePoint *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__TransportNumber: ((vd__TransportNumber *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__TransportInfo: ((vd__TransportInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Waybill: ((vd__Waybill *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Document: ((vd__Document *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntrySearchPattern: ((vd__StockEntrySearchPattern *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockDiscrepancy: ((vd__StockDiscrepancy *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntryList: ((vd__StockEntryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntry: ((vd__StockEntry *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DiscrepancyReason: ((vd__DiscrepancyReason *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DiscrepancyReport: ((vd__DiscrepancyReport *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocumentList: ((vd__VetDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__GoodsDate: ((vd__GoodsDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ConsignmentDocumentList: ((vd__ConsignmentDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DeliveryInspection: ((vd__DeliveryInspection *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DeliveryFactList: ((vd__DeliveryFactList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Delivery: ((vd__Delivery *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProductiveBatch: ((vd__ProductiveBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RawBatch: ((vd__RawBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Consignment: ((vd__Consignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Batch: ((vd__Batch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocument: ((vd__VetDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ActivityLocationList: ((dic__ActivityLocationList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ResearchMethodList: ((dic__ResearchMethodList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__AnimalDiseaseList: ((dic__AnimalDiseaseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationShippingRuleList: ((dic__RegionalizationShippingRuleList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationRegionStatusList: ((dic__RegionalizationRegionStatusList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationConditionList: ((dic__RegionalizationConditionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Area: ((dic__Area *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationRegionStatus: ((dic__RegionalizationRegionStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationStatus: ((dic__RegionalizationStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationShippingRule: ((dic__RegionalizationShippingRule *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationRequirement: ((dic__RegionalizationRequirement *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationConditionGroup: ((dic__RegionalizationConditionGroup *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionalizationCondition: ((dic__RegionalizationCondition *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__MedicinalDrug: ((dic__MedicinalDrug *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ResearchMethod: ((dic__ResearchMethod *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__AnimalDisease: ((dic__AnimalDisease *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Indicator: ((dic__Indicator *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Organization: ((dic__Organization *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__EnterpriseOfficialRegistration: ((dic__EnterpriseOfficialRegistration *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Location: ((dic__Location *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Packaging: ((dic__Packaging *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProductItemProducing: ((dic__ProductItemProducing *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ComplexDate: ((dic__ComplexDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__PackageList: ((dic__PackageList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Package: ((dic__Package *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProductMarks: ((dic__ProductMarks *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProductItemList: ((dic__ProductItemList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__SubProductList: ((dic__SubProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProductList: ((dic__ProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__SubProduct: ((dic__SubProduct *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Product: ((dic__Product *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProductItem: ((dic__ProductItem *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__BusinessEntityList: ((dic__BusinessEntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__IncorporationForm: ((dic__IncorporationForm *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__BusinessEntity: ((dic__BusinessEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__BusinessMember: ((dic__BusinessMember *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__EnterpriseList: ((dic__EnterpriseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__EnterpriseNumberList: ((dic__EnterpriseNumberList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__ProducerList: ((dic__ProducerList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Producer: ((dic__Producer *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__EnterpriseActivity: ((dic__EnterpriseActivity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__EnterpriseActivityList: ((dic__EnterpriseActivityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Enterprise: ((dic__Enterprise *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__StreetList: ((dic__StreetList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__LocalityList: ((dic__LocalityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__DistrictList: ((dic__DistrictList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__RegionList: ((dic__RegionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__CountryList: ((dic__CountryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Address: ((dic__Address *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Street: ((dic__Street *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Locality: ((dic__Locality *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__District: ((dic__District *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Region: ((dic__Region *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__AddressObjectView: ((dic__AddressObjectView *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__FederalDistrict: ((dic__FederalDistrict *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Country: ((dic__Country *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__UnitList: ((dic__UnitList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__PurposeList: ((dic__PurposeList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__PackingType: ((dic__PackingType *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Unit: ((dic__Unit *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_dic__Purpose: ((dic__Purpose *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BusinessError: ((app__BusinessError *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BusinessErrorList: ((app__BusinessErrorList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationResultData: ((app__ApplicationResultData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationData: ((app__ApplicationData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationResultWrapper: ((app__ApplicationResultWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationDataWrapper: ((app__ApplicationDataWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__Application: ((app__Application *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__ComplexDate: ((base__ComplexDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__Error: ((base__Error *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__FaultInfo: ((base__FaultInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__EntityList: ((base__EntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__DateInterval: ((base__DateInterval *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__ListOptions: ((base__ListOptions *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__GenericVersioningEntity: ((base__GenericVersioningEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__GenericEntity: ((base__GenericEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse: ((g2ba__GetApplicableUserAuthorityListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest: ((g2ba__GetApplicableUserAuthorityListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse: ((g2ba__UnbindBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest: ((g2ba__UnbindBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse: ((g2ba__UpdateUserWorkingAreasResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest: ((g2ba__UpdateUserWorkingAreasRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse: ((g2ba__UpdateUserAuthoritiesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest: ((g2ba__UpdateUserAuthoritiesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserResponse: ((g2ba__GetBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserRequest: ((g2ba__GetBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse: ((g2ba__GetBusinessEntityUserListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest: ((g2ba__GetBusinessEntityUserListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__AddBusinessEntityUserResponse: ((g2ba__AddBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__AddBusinessEntityUserRequest: ((g2ba__AddBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse: ((g2ba__CheckShipmentRegionalizationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest: ((g2ba__CheckShipmentRegionalizationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse: ((g2ba__UpdateVeterinaryEventsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest: ((g2ba__UpdateVeterinaryEventsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse: ((g2ba__UpdateTransportMovementDetailsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest: ((g2ba__UpdateTransportMovementDetailsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryVersionListResponse: ((g2ba__GetStockEntryVersionListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryVersionListRequest: ((g2ba__GetStockEntryVersionListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryListResponse: ((g2ba__GetStockEntryListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryListRequest: ((g2ba__GetStockEntryListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryChangesListResponse: ((g2ba__GetStockEntryChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryChangesListRequest: ((g2ba__GetStockEntryChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryByUuidResponse: ((g2ba__GetStockEntryByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryByUuidRequest: ((g2ba__GetStockEntryByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryByGuidResponse: ((g2ba__GetStockEntryByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetStockEntryByGuidRequest: ((g2ba__GetStockEntryByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse: ((g2ba__GetVetDocumentChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest: ((g2ba__GetVetDocumentChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentListResponse: ((g2ba__GetVetDocumentListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentListRequest: ((g2ba__GetVetDocumentListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse: ((g2ba__GetVetDocumentByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest: ((g2ba__GetVetDocumentByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyProducerStockListResponse: ((g2ba__ModifyProducerStockListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyProducerStockListRequest: ((g2ba__ModifyProducerStockListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ResolveDiscrepancyResponse: ((g2ba__ResolveDiscrepancyResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ResolveDiscrepancyRequest: ((g2ba__ResolveDiscrepancyRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyActivityLocationsResponse: ((g2ba__ModifyActivityLocationsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyActivityLocationsRequest: ((g2ba__ModifyActivityLocationsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyEnterpriseResponse: ((g2ba__ModifyEnterpriseResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyEnterpriseRequest: ((g2ba__ModifyEnterpriseRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyBusinessEntityResponse: ((g2ba__ModifyBusinessEntityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ModifyBusinessEntityRequest: ((g2ba__ModifyBusinessEntityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__WithdrawVetDocumentResponse: ((g2ba__WithdrawVetDocumentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__WithdrawVetDocumentRequest: ((g2ba__WithdrawVetDocumentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__MergeStockEntriesResponse: ((g2ba__MergeStockEntriesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__MergeStockEntriesRequest: ((g2ba__MergeStockEntriesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__RegisterProductionOperationResponse: ((g2ba__RegisterProductionOperationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__RegisterProductionOperationRequest: ((g2ba__RegisterProductionOperationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse: ((g2ba__PrepareOutgoingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest: ((g2ba__PrepareOutgoingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse: ((g2ba__ProcessIncomingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest: ((g2ba__ProcessIncomingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_g2ba__MercuryApplicationRequest: ((g2ba__MercuryApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_xsd__base64Binary: ((xsd__base64Binary *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE___g2b__getApplicableUserAuthorityListRequest: soap_serialize___g2b__getApplicableUserAuthorityListRequest(soap, (const struct __g2b__getApplicableUserAuthorityListRequest *)ptr); break;
	case SOAP_TYPE___g2b__unbindBusinessEntityUserRequest: soap_serialize___g2b__unbindBusinessEntityUserRequest(soap, (const struct __g2b__unbindBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___g2b__updateUserWorkingAreasRequest: soap_serialize___g2b__updateUserWorkingAreasRequest(soap, (const struct __g2b__updateUserWorkingAreasRequest *)ptr); break;
	case SOAP_TYPE___g2b__updateUserAuthoritiesRequest: soap_serialize___g2b__updateUserAuthoritiesRequest(soap, (const struct __g2b__updateUserAuthoritiesRequest *)ptr); break;
	case SOAP_TYPE___g2b__getBusinessEntityUserRequest: soap_serialize___g2b__getBusinessEntityUserRequest(soap, (const struct __g2b__getBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___g2b__getBusinessEntityUserListRequest: soap_serialize___g2b__getBusinessEntityUserListRequest(soap, (const struct __g2b__getBusinessEntityUserListRequest *)ptr); break;
	case SOAP_TYPE___g2b__addBusinessEntityUserRequest: soap_serialize___g2b__addBusinessEntityUserRequest(soap, (const struct __g2b__addBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___g2b__checkShipmentRegionalizationRequest: soap_serialize___g2b__checkShipmentRegionalizationRequest(soap, (const struct __g2b__checkShipmentRegionalizationRequest *)ptr); break;
	case SOAP_TYPE___g2b__updateVeterinaryEventsRequest: soap_serialize___g2b__updateVeterinaryEventsRequest(soap, (const struct __g2b__updateVeterinaryEventsRequest *)ptr); break;
	case SOAP_TYPE___g2b__updateTransportMovementDetailsRequest: soap_serialize___g2b__updateTransportMovementDetailsRequest(soap, (const struct __g2b__updateTransportMovementDetailsRequest *)ptr); break;
	case SOAP_TYPE___g2b__getStockEntryVersionListRequest: soap_serialize___g2b__getStockEntryVersionListRequest(soap, (const struct __g2b__getStockEntryVersionListRequest *)ptr); break;
	case SOAP_TYPE___g2b__getStockEntryChangesListRequest: soap_serialize___g2b__getStockEntryChangesListRequest(soap, (const struct __g2b__getStockEntryChangesListRequest *)ptr); break;
	case SOAP_TYPE___g2b__getStockEntryListRequest: soap_serialize___g2b__getStockEntryListRequest(soap, (const struct __g2b__getStockEntryListRequest *)ptr); break;
	case SOAP_TYPE___g2b__getStockEntryByUuidRequest: soap_serialize___g2b__getStockEntryByUuidRequest(soap, (const struct __g2b__getStockEntryByUuidRequest *)ptr); break;
	case SOAP_TYPE___g2b__getStockEntryByGuidRequest: soap_serialize___g2b__getStockEntryByGuidRequest(soap, (const struct __g2b__getStockEntryByGuidRequest *)ptr); break;
	case SOAP_TYPE___g2b__getVetDocumentChangesListRequest: soap_serialize___g2b__getVetDocumentChangesListRequest(soap, (const struct __g2b__getVetDocumentChangesListRequest *)ptr); break;
	case SOAP_TYPE___g2b__getVetDocumentListRequest: soap_serialize___g2b__getVetDocumentListRequest(soap, (const struct __g2b__getVetDocumentListRequest *)ptr); break;
	case SOAP_TYPE___g2b__getVetDocumentByUuidRequest: soap_serialize___g2b__getVetDocumentByUuidRequest(soap, (const struct __g2b__getVetDocumentByUuidRequest *)ptr); break;
	case SOAP_TYPE___g2b__modifyProducerStockListRequest: soap_serialize___g2b__modifyProducerStockListRequest(soap, (const struct __g2b__modifyProducerStockListRequest *)ptr); break;
	case SOAP_TYPE___g2b__resolveDiscrepancyRequest: soap_serialize___g2b__resolveDiscrepancyRequest(soap, (const struct __g2b__resolveDiscrepancyRequest *)ptr); break;
	case SOAP_TYPE___g2b__modifyActivityLocationsRequest: soap_serialize___g2b__modifyActivityLocationsRequest(soap, (const struct __g2b__modifyActivityLocationsRequest *)ptr); break;
	case SOAP_TYPE___g2b__modifyEnterpriseRequest: soap_serialize___g2b__modifyEnterpriseRequest(soap, (const struct __g2b__modifyEnterpriseRequest *)ptr); break;
	case SOAP_TYPE___g2b__modifyBusinessEntityRequest: soap_serialize___g2b__modifyBusinessEntityRequest(soap, (const struct __g2b__modifyBusinessEntityRequest *)ptr); break;
	case SOAP_TYPE___g2b__withdrawVetDocumentRequest: soap_serialize___g2b__withdrawVetDocumentRequest(soap, (const struct __g2b__withdrawVetDocumentRequest *)ptr); break;
	case SOAP_TYPE___g2b__mergeStockEntriesRequest: soap_serialize___g2b__mergeStockEntriesRequest(soap, (const struct __g2b__mergeStockEntriesRequest *)ptr); break;
	case SOAP_TYPE___g2b__registerProductionOperationRequest: soap_serialize___g2b__registerProductionOperationRequest(soap, (const struct __g2b__registerProductionOperationRequest *)ptr); break;
	case SOAP_TYPE___g2b__prepareOutgoingConsignmentRequest: soap_serialize___g2b__prepareOutgoingConsignmentRequest(soap, (const struct __g2b__prepareOutgoingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___g2b__processIncomingConsignmentRequest: soap_serialize___g2b__processIncomingConsignmentRequest(soap, (const struct __g2b__processIncomingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___apps__receiveApplicationResult: soap_serialize___apps__receiveApplicationResult(soap, (const struct __apps__receiveApplicationResult *)ptr); break;
	case SOAP_TYPE___apps__submitApplicationRequest: soap_serialize___apps__submitApplicationRequest(soap, (const struct __apps__submitApplicationRequest *)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListResponse: soap_serialize_PointerTog2ba__GetApplicableUserAuthorityListResponse(soap, (g2ba__GetApplicableUserAuthorityListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListRequest: soap_serialize_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, (g2ba__GetApplicableUserAuthorityListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserResponse: soap_serialize_PointerTog2ba__UnbindBusinessEntityUserResponse(soap, (g2ba__UnbindBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserRequest: soap_serialize_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, (g2ba__UnbindBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasResponse: soap_serialize_PointerTog2ba__UpdateUserWorkingAreasResponse(soap, (g2ba__UpdateUserWorkingAreasResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasRequest: soap_serialize_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, (g2ba__UpdateUserWorkingAreasRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesResponse: soap_serialize_PointerTog2ba__UpdateUserAuthoritiesResponse(soap, (g2ba__UpdateUserAuthoritiesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesRequest: soap_serialize_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, (g2ba__UpdateUserAuthoritiesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserResponse: soap_serialize_PointerTog2ba__GetBusinessEntityUserResponse(soap, (g2ba__GetBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserRequest: soap_serialize_PointerTog2ba__GetBusinessEntityUserRequest(soap, (g2ba__GetBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListResponse: soap_serialize_PointerTog2ba__GetBusinessEntityUserListResponse(soap, (g2ba__GetBusinessEntityUserListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListRequest: soap_serialize_PointerTog2ba__GetBusinessEntityUserListRequest(soap, (g2ba__GetBusinessEntityUserListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserResponse: soap_serialize_PointerTog2ba__AddBusinessEntityUserResponse(soap, (g2ba__AddBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserRequest: soap_serialize_PointerTog2ba__AddBusinessEntityUserRequest(soap, (g2ba__AddBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationResponse: soap_serialize_PointerTog2ba__CheckShipmentRegionalizationResponse(soap, (g2ba__CheckShipmentRegionalizationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationRequest: soap_serialize_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, (g2ba__CheckShipmentRegionalizationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsResponse: soap_serialize_PointerTog2ba__UpdateVeterinaryEventsResponse(soap, (g2ba__UpdateVeterinaryEventsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsRequest: soap_serialize_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, (g2ba__UpdateVeterinaryEventsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsResponse: soap_serialize_PointerTog2ba__UpdateTransportMovementDetailsResponse(soap, (g2ba__UpdateTransportMovementDetailsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsRequest: soap_serialize_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, (g2ba__UpdateTransportMovementDetailsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListResponse: soap_serialize_PointerTog2ba__GetStockEntryVersionListResponse(soap, (g2ba__GetStockEntryVersionListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListRequest: soap_serialize_PointerTog2ba__GetStockEntryVersionListRequest(soap, (g2ba__GetStockEntryVersionListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListResponse: soap_serialize_PointerTog2ba__GetStockEntryChangesListResponse(soap, (g2ba__GetStockEntryChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListRequest: soap_serialize_PointerTog2ba__GetStockEntryChangesListRequest(soap, (g2ba__GetStockEntryChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListResponse: soap_serialize_PointerTog2ba__GetStockEntryListResponse(soap, (g2ba__GetStockEntryListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryListRequest: soap_serialize_PointerTog2ba__GetStockEntryListRequest(soap, (g2ba__GetStockEntryListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidResponse: soap_serialize_PointerTog2ba__GetStockEntryByUuidResponse(soap, (g2ba__GetStockEntryByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidRequest: soap_serialize_PointerTog2ba__GetStockEntryByUuidRequest(soap, (g2ba__GetStockEntryByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidResponse: soap_serialize_PointerTog2ba__GetStockEntryByGuidResponse(soap, (g2ba__GetStockEntryByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidRequest: soap_serialize_PointerTog2ba__GetStockEntryByGuidRequest(soap, (g2ba__GetStockEntryByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListResponse: soap_serialize_PointerTog2ba__GetVetDocumentChangesListResponse(soap, (g2ba__GetVetDocumentChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListRequest: soap_serialize_PointerTog2ba__GetVetDocumentChangesListRequest(soap, (g2ba__GetVetDocumentChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListResponse: soap_serialize_PointerTog2ba__GetVetDocumentListResponse(soap, (g2ba__GetVetDocumentListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentListRequest: soap_serialize_PointerTog2ba__GetVetDocumentListRequest(soap, (g2ba__GetVetDocumentListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidResponse: soap_serialize_PointerTog2ba__GetVetDocumentByUuidResponse(soap, (g2ba__GetVetDocumentByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidRequest: soap_serialize_PointerTog2ba__GetVetDocumentByUuidRequest(soap, (g2ba__GetVetDocumentByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListResponse: soap_serialize_PointerTog2ba__ModifyProducerStockListResponse(soap, (g2ba__ModifyProducerStockListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyProducerStockListRequest: soap_serialize_PointerTog2ba__ModifyProducerStockListRequest(soap, (g2ba__ModifyProducerStockListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyResponse: soap_serialize_PointerTog2ba__ResolveDiscrepancyResponse(soap, (g2ba__ResolveDiscrepancyResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyRequest: soap_serialize_PointerTog2ba__ResolveDiscrepancyRequest(soap, (g2ba__ResolveDiscrepancyRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsResponse: soap_serialize_PointerTog2ba__ModifyActivityLocationsResponse(soap, (g2ba__ModifyActivityLocationsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsRequest: soap_serialize_PointerTog2ba__ModifyActivityLocationsRequest(soap, (g2ba__ModifyActivityLocationsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseResponse: soap_serialize_PointerTog2ba__ModifyEnterpriseResponse(soap, (g2ba__ModifyEnterpriseResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyEnterpriseRequest: soap_serialize_PointerTog2ba__ModifyEnterpriseRequest(soap, (g2ba__ModifyEnterpriseRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityResponse: soap_serialize_PointerTog2ba__ModifyBusinessEntityResponse(soap, (g2ba__ModifyBusinessEntityResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityRequest: soap_serialize_PointerTog2ba__ModifyBusinessEntityRequest(soap, (g2ba__ModifyBusinessEntityRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentResponse: soap_serialize_PointerTog2ba__WithdrawVetDocumentResponse(soap, (g2ba__WithdrawVetDocumentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentRequest: soap_serialize_PointerTog2ba__WithdrawVetDocumentRequest(soap, (g2ba__WithdrawVetDocumentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesResponse: soap_serialize_PointerTog2ba__MergeStockEntriesResponse(soap, (g2ba__MergeStockEntriesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__MergeStockEntriesRequest: soap_serialize_PointerTog2ba__MergeStockEntriesRequest(soap, (g2ba__MergeStockEntriesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationResponse: soap_serialize_PointerTog2ba__RegisterProductionOperationResponse(soap, (g2ba__RegisterProductionOperationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__RegisterProductionOperationRequest: soap_serialize_PointerTog2ba__RegisterProductionOperationRequest(soap, (g2ba__RegisterProductionOperationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentResponse: soap_serialize_PointerTog2ba__PrepareOutgoingConsignmentResponse(soap, (g2ba__PrepareOutgoingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentRequest: soap_serialize_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, (g2ba__PrepareOutgoingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentResponse: soap_serialize_PointerTog2ba__ProcessIncomingConsignmentResponse(soap, (g2ba__ProcessIncomingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentRequest: soap_serialize_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, (g2ba__ProcessIncomingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: soap_serialize_PointerTo_ws__receiveApplicationResultResponse(soap, (_ws__receiveApplicationResultResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: soap_serialize_PointerTo_ws__receiveApplicationResultRequest(soap, (_ws__receiveApplicationResultRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: soap_serialize_PointerTo_ws__submitApplicationResponse(soap, (_ws__submitApplicationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: soap_serialize_PointerTo_ws__submitApplicationRequest(soap, (_ws__submitApplicationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__FaultInfo: soap_serialize_PointerTobase__FaultInfo(soap, (base__FaultInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: soap_serialize_PointerTovd__StockEntryBlankFilter(soap, (enum vd__StockEntryBlankFilter *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryEventList: soap_serialize_PointerTovd__StockEntryEventList(soap, (vd__StockEntryEventList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: soap_serialize_PointerTovd__DiscrepancyReason(soap, (vd__DiscrepancyReason *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: soap_serialize_PointerToPointerTovd__VetDocumentStatusChange(soap, (vd__VetDocumentStatusChange **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: soap_serialize_PointerTovd__VetDocumentStatusChange(soap, (vd__VetDocumentStatusChange *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: soap_serialize_PointerTovd__VeterinaryAuthentication(soap, (vd__VeterinaryAuthentication *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: soap_serialize_PointerTovd__CertifiedConsignment(soap, (vd__CertifiedConsignment *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__CertifiedBatch: soap_serialize_PointerTovd__CertifiedBatch(soap, (vd__CertifiedBatch *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentForm: soap_serialize_PointerTovd__VetDocumentForm(soap, (enum vd__VetDocumentForm *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationStatus: soap_serialize_PointerToPointerTodic__RegionalizationStatus(soap, (dic__RegionalizationStatus **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Area: soap_serialize_PointerToPointerTodic__Area(soap, (dic__Area **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRequirement: soap_serialize_PointerToPointerTodic__RegionalizationRequirement(soap, (dic__RegionalizationRequirement **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationRequirement: soap_serialize_PointerTodic__RegionalizationRequirement(soap, (dic__RegionalizationRequirement *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationDecision: soap_serialize_PointerTodic__RegionalizationDecision(soap, (enum dic__RegionalizationDecision *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationStatus: soap_serialize_PointerTodic__RegionalizationStatus(soap, (dic__RegionalizationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Packaging: soap_serialize_PointerTodic__Packaging(soap, (dic__Packaging *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__ProductItemProducing: soap_serialize_PointerToPointerTodic__ProductItemProducing(soap, (dic__ProductItemProducing **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ProductItemProducing: soap_serialize_PointerTodic__ProductItemProducing(soap, (dic__ProductItemProducing *const*)ptr); break;
	case SOAP_TYPE_PointerTo_dic__BusinessEntity_activityLocation: soap_serialize_PointerTo_dic__BusinessEntity_activityLocation(soap, (_dic__BusinessEntity_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__IncorporationForm: soap_serialize_PointerTodic__IncorporationForm(soap, (dic__IncorporationForm *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__BusinessEntityType: soap_serialize_PointerTodic__BusinessEntityType(soap, (enum dic__BusinessEntityType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseOfficialRegistration: soap_serialize_PointerToPointerTodic__EnterpriseOfficialRegistration(soap, (dic__EnterpriseOfficialRegistration **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration: soap_serialize_PointerTodic__EnterpriseOfficialRegistration(soap, (dic__EnterpriseOfficialRegistration *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseActivityList: soap_serialize_PointerTodic__EnterpriseActivityList(soap, (dic__EnterpriseActivityList *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseNumberList: soap_serialize_PointerTodic__EnterpriseNumberList(soap, (dic__EnterpriseNumberList *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseType: soap_serialize_PointerTodic__EnterpriseType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__PackingCodeType: soap_serialize_PointerTodic__PackingCodeType(soap, (enum dic__PackingCodeType *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__UUID: soap_serialize_PointerTobase__UUID(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: soap_serialize_PointerTovd__StockEntrySearchPattern(soap, (vd__StockEntrySearchPattern *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__DateInterval: soap_serialize_PointerTobase__DateInterval(soap, (base__DateInterval *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: soap_serialize_PointerTovd__VetDocumentStatus(soap, (enum vd__VetDocumentStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentType: soap_serialize_PointerTovd__VetDocumentType(soap, (enum vd__VetDocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__ListOptions: soap_serialize_PointerTobase__ListOptions(soap, (base__ListOptions *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: soap_serialize_PointerTovd__PSLModificationOperation(soap, (vd__PSLModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: soap_serialize_PointerToPointerTovd__StockDiscrepancy(soap, (vd__StockDiscrepancy **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: soap_serialize_PointerTovd__StockDiscrepancy(soap, (vd__StockDiscrepancy *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(soap, (vd__BEActivityLocationsModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: soap_serialize_PointerTovd__ENTModificationOperation(soap, (vd__ENTModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BEModificationOperation: soap_serialize_PointerTovd__BEModificationOperation(soap, (vd__BEModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: soap_serialize_PointerTovd__MergeStockEntriesOperation(soap, (vd__MergeStockEntriesOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProductionOperation: soap_serialize_PointerTovd__ProductionOperation(soap, (vd__ProductionOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Delivery: soap_serialize_PointerToPointerTovd__Delivery(soap, (vd__Delivery **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: soap_serialize_PointerToPointerTovd__DiscrepancyReport(soap, (vd__DiscrepancyReport **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: soap_serialize_PointerTovd__DiscrepancyReport(soap, (vd__DiscrepancyReport *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DeliveryFactList: soap_serialize_PointerTovd__DeliveryFactList(soap, (vd__DeliveryFactList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Delivery: soap_serialize_PointerTovd__Delivery(soap, (vd__Delivery *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: soap_serialize_PointerToPointerTovd__WorkingArea(soap, (vd__WorkingArea **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__WorkingArea: soap_serialize_PointerTovd__WorkingArea(soap, (vd__WorkingArea *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__WorkingAreaList: soap_serialize_PointerTovd__WorkingAreaList(soap, (vd__WorkingAreaList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__SNILSType: soap_serialize_PointerTovd__SNILSType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Citizenship: soap_serialize_PointerTovd__Citizenship(soap, (vd__Citizenship *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__MedicinalDrug: soap_serialize_PointerTodic__MedicinalDrug(soap, (dic__MedicinalDrug *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Indicator: soap_serialize_PointerTodic__Indicator(soap, (dic__Indicator *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__DocumentType: soap_serialize_PointerTodic__DocumentType(soap, (enum dic__DocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: soap_serialize_PointerTovd__ConsignmentDocumentList(soap, (vd__ConsignmentDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Consignment: soap_serialize_PointerToPointerTovd__Consignment(soap, (vd__Consignment **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Consignment: soap_serialize_PointerTovd__Consignment(soap, (vd__Consignment *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__BusinessMember: soap_serialize_PointerToPointerTodic__BusinessMember(soap, (dic__BusinessMember **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__ResearchMethod: soap_serialize_PointerToPointerTodic__ResearchMethod(soap, (dic__ResearchMethod **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ResearchMethod: soap_serialize_PointerTodic__ResearchMethod(soap, (dic__ResearchMethod *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__AnimalDisease: soap_serialize_PointerToPointerTodic__AnimalDisease(soap, (dic__AnimalDisease **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationRegionStatus: soap_serialize_PointerToPointerTodic__RegionalizationRegionStatus(soap, (dic__RegionalizationRegionStatus **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationRegionStatus: soap_serialize_PointerTodic__RegionalizationRegionStatus(soap, (dic__RegionalizationRegionStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__ProductItem: soap_serialize_PointerToPointerTodic__ProductItem(soap, (dic__ProductItem **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__SubProduct: soap_serialize_PointerToPointerTodic__SubProduct(soap, (dic__SubProduct **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Product: soap_serialize_PointerToPointerTodic__Product(soap, (dic__Product **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__EnterpriseActivity: soap_serialize_PointerToPointerTodic__EnterpriseActivity(soap, (dic__EnterpriseActivity **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseActivity: soap_serialize_PointerTodic__EnterpriseActivity(soap, (dic__EnterpriseActivity *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Street: soap_serialize_PointerToPointerTodic__Street(soap, (dic__Street **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Locality: soap_serialize_PointerToPointerTodic__Locality(soap, (dic__Locality **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__District: soap_serialize_PointerToPointerTodic__District(soap, (dic__District **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Region: soap_serialize_PointerToPointerTodic__Region(soap, (dic__Region **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Country: soap_serialize_PointerToPointerTodic__Country(soap, (dic__Country **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Unit: soap_serialize_PointerToPointerTodic__Unit(soap, (dic__Unit **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Purpose: soap_serialize_PointerToPointerTodic__Purpose(soap, (dic__Purpose **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__VersionStatus: soap_serialize_PointerTobase__VersionStatus(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AuthorityList: soap_serialize_PointerTovd__AuthorityList(soap, (vd__AuthorityList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__UserList: soap_serialize_PointerTovd__UserList(soap, (vd__UserList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__User: soap_serialize_PointerToPointerTovd__User(soap, (vd__User **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: soap_serialize_PointerToPointerTovd__RouteSectionR13nRules(soap, (vd__RouteSectionR13nRules **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: soap_serialize_PointerTovd__RouteSectionR13nRules(soap, (vd__RouteSectionR13nRules *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentList: soap_serialize_PointerTovd__VetDocumentList(soap, (vd__VetDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Enterprise: soap_serialize_PointerToPointerTodic__Enterprise(soap, (dic__Enterprise **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__BusinessEntity: soap_serialize_PointerToPointerTodic__BusinessEntity(soap, (dic__BusinessEntity **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__OTPToken: soap_serialize_PointerTodic__OTPToken(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToapp__Application: soap_serialize_PointerToapp__Application(soap, (app__Application *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Area: soap_serialize_PointerTodic__Area(soap, (dic__Area *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: soap_serialize_PointerToPointerTovd__UserAuthority(soap, (vd__UserAuthority **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__UserAuthority: soap_serialize_PointerTovd__UserAuthority(soap, (vd__UserAuthority *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationShippingRule: soap_serialize_PointerToPointerTodic__RegionalizationShippingRule(soap, (dic__RegionalizationShippingRule **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationShippingRule: soap_serialize_PointerTodic__RegionalizationShippingRule(soap, (dic__RegionalizationShippingRule *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__SequenceNumber: soap_serialize_PointerTobase__SequenceNumber(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: soap_serialize_PointerToPointerTovd__QuarantineEvent(soap, (vd__QuarantineEvent **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: soap_serialize_PointerToPointerTovd__RegionalizationClause(soap, (vd__RegionalizationClause **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RegionalizationClause: soap_serialize_PointerTovd__RegionalizationClause(soap, (vd__RegionalizationClause *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: soap_serialize_PointerToPointerTovd__VeterinaryEvent(soap, (vd__VeterinaryEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: soap_serialize_PointerTovd__VeterinaryEvent(soap, (vd__VeterinaryEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: soap_serialize_PointerToPointerTovd__AnimalMedicationEvent(soap, (vd__AnimalMedicationEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: soap_serialize_PointerTovd__AnimalMedicationEvent(soap, (vd__AnimalMedicationEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__QuarantineEvent: soap_serialize_PointerTovd__QuarantineEvent(soap, (vd__QuarantineEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: soap_serialize_PointerToPointerTovd__LaboratoryResearchEvent(soap, (vd__LaboratoryResearchEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, (vd__LaboratoryResearchEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: soap_serialize_PointerTovd__AnimalSpentPeriod(soap, (enum vd__AnimalSpentPeriod *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ResearchResult: soap_serialize_PointerTodic__ResearchResult(soap, (enum dic__ResearchResult *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Purpose: soap_serialize_PointerTodic__Purpose(soap, (dic__Purpose *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Document: soap_serialize_PointerToPointerTovd__Document(soap, (vd__Document **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Document: soap_serialize_PointerTovd__Document(soap, (vd__Document *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Organization: soap_serialize_PointerTodic__Organization(soap, (dic__Organization *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Location: soap_serialize_PointerTodic__Location(soap, (dic__Location *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: soap_serialize_PointerTovd__VeterinaryEventType(soap, (enum vd__VeterinaryEventType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ShipmentRoute: soap_serialize_PointerTovd__ShipmentRoute(soap, (vd__ShipmentRoute *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__TransportationStorageType: soap_serialize_PointerTodic__TransportationStorageType(soap, (enum dic__TransportationStorageType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__TransportInfo: soap_serialize_PointerTovd__TransportInfo(soap, (vd__TransportInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Batch: soap_serialize_PointerTovd__Batch(soap, (vd__Batch *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseList: soap_serialize_PointerTodic__EnterpriseList(soap, (dic__EnterpriseList *const*)ptr); break;
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: soap_serialize_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, (_vd__BEActivityLocationsModificationOperation_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__BusinessEntityList: soap_serialize_PointerTodic__BusinessEntityList(soap, (dic__BusinessEntityList *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ProductItemList: soap_serialize_PointerTodic__ProductItemList(soap, (dic__ProductItemList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: soap_serialize_PointerToPointerTovd__StockEntry(soap, (vd__StockEntry **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__RegisterModificationType: soap_serialize_PointerTobase__RegisterModificationType(soap, (enum base__RegisterModificationType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: soap_serialize_PointerToPointerTovd__ProcessingProcedure(soap, (vd__ProcessingProcedure **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: soap_serialize_PointerTovd__ProcessingProcedure(soap, (vd__ProcessingProcedure *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: soap_serialize_PointerToPointerTovd__ProductiveBatch(soap, (vd__ProductiveBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProductiveBatch: soap_serialize_PointerTovd__ProductiveBatch(soap, (vd__ProductiveBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: soap_serialize_PointerToPointerTovd__RawBatch(soap, (vd__RawBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RawBatch: soap_serialize_PointerTovd__RawBatch(soap, (vd__RawBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: soap_serialize_PointerToPointerTovd__ShipmentRoutePoint(soap, (vd__ShipmentRoutePoint **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: soap_serialize_PointerTovd__ShipmentRoutePoint(soap, (vd__ShipmentRoutePoint *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__TransportNumber: soap_serialize_PointerTovd__TransportNumber(soap, (vd__TransportNumber *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__TransportType: soap_serialize_PointerTodic__TransportType(soap, (enum dic__TransportType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryList: soap_serialize_PointerTovd__StockEntryList(soap, (vd__StockEntryList *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ComplexDate: soap_serialize_PointerTodic__ComplexDate(soap, (dic__ComplexDate *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: soap_serialize_PointerToPointerTovd__ReferencedDocument(soap, (vd__ReferencedDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ReferencedDocument: soap_serialize_PointerTovd__ReferencedDocument(soap, (vd__ReferencedDocument *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: soap_serialize_PointerToPointerTovd__VetDocument(soap, (vd__VetDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocument: soap_serialize_PointerTovd__VetDocument(soap, (vd__VetDocument *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Waybill: soap_serialize_PointerTovd__Waybill(soap, (vd__Waybill *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__User: soap_serialize_PointerTovd__User(soap, (vd__User *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DeliveryInspection: soap_serialize_PointerTovd__DeliveryInspection(soap, (vd__DeliveryInspection *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntry: soap_serialize_PointerTovd__StockEntry(soap, (vd__StockEntry *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__PackageList: soap_serialize_PointerTodic__PackageList(soap, (dic__PackageList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BatchOrigin: soap_serialize_PointerTovd__BatchOrigin(soap, (vd__BatchOrigin *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__GoodsDate: soap_serialize_PointerTovd__GoodsDate(soap, (vd__GoodsDate *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ProductItem: soap_serialize_PointerTodic__ProductItem(soap, (dic__ProductItem *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__SubProduct: soap_serialize_PointerTodic__SubProduct(soap, (dic__SubProduct *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Product: soap_serialize_PointerTodic__Product(soap, (dic__Product *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ProductType: soap_serialize_PointerTodic__ProductType(soap, (enum dic__ProductType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationConditionGroup: soap_serialize_PointerToPointerTodic__RegionalizationConditionGroup(soap, (dic__RegionalizationConditionGroup **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationConditionGroup: soap_serialize_PointerTodic__RegionalizationConditionGroup(soap, (dic__RegionalizationConditionGroup *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__AnimalDisease: soap_serialize_PointerTodic__AnimalDisease(soap, (dic__AnimalDisease *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__RegionalizationCondition: soap_serialize_PointerToPointerTodic__RegionalizationCondition(soap, (dic__RegionalizationCondition **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__RegionalizationCondition: soap_serialize_PointerTodic__RegionalizationCondition(soap, (dic__RegionalizationCondition *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__BusinessMember: soap_serialize_PointerTodic__BusinessMember(soap, (dic__BusinessMember *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Identifier: soap_serialize_PointerTobase__Identifier(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Address: soap_serialize_PointerTodic__Address(soap, (dic__Address *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Unit: soap_serialize_PointerTodic__Unit(soap, (dic__Unit *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Decimal: soap_serialize_PointerTobase__Decimal(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Minute: soap_serialize_PointerTodic__Minute(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Hour: soap_serialize_PointerTodic__Hour(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Day: soap_serialize_PointerTodic__Day(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Month: soap_serialize_PointerTodic__Month(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Year: soap_serialize_PointerTodic__Year(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Package: soap_serialize_PointerToPointerTodic__Package(soap, (dic__Package **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Package: soap_serialize_PointerTodic__Package(soap, (dic__Package *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__ProductMarks: soap_serialize_PointerToPointerTodic__ProductMarks(soap, (dic__ProductMarks **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__ProductMarks: soap_serialize_PointerTodic__ProductMarks(soap, (dic__ProductMarks *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__PackingType: soap_serialize_PointerTodic__PackingType(soap, (dic__PackingType *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__GLNType: soap_serialize_PointerTodic__GLNType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__BusinessEntity: soap_serialize_PointerTodic__BusinessEntity(soap, (dic__BusinessEntity *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__String255: soap_serialize_PointerTobase__String255(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTodic__Producer: soap_serialize_PointerToPointerTodic__Producer(soap, (dic__Producer **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Producer: soap_serialize_PointerTodic__Producer(soap, (dic__Producer *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__EnterpriseRole: soap_serialize_PointerTodic__EnterpriseRole(soap, (enum dic__EnterpriseRole *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Enterprise: soap_serialize_PointerTodic__Enterprise(soap, (dic__Enterprise *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__NText: soap_serialize_PointerTobase__NText(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Street: soap_serialize_PointerTodic__Street(soap, (dic__Street *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Locality: soap_serialize_PointerTodic__Locality(soap, (dic__Locality *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__District: soap_serialize_PointerTodic__District(soap, (dic__District *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Region: soap_serialize_PointerTodic__Region(soap, (dic__Region *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__FederalDistrict: soap_serialize_PointerTodic__FederalDistrict(soap, (dic__FederalDistrict *const*)ptr); break;
	case SOAP_TYPE_PointerTodic__Country: soap_serialize_PointerTodic__Country(soap, (dic__Country *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: soap_serialize_PointerToPointerToapp__BusinessError(soap, (app__BusinessError **const*)ptr); break;
	case SOAP_TYPE_PointerToapp__BusinessError: soap_serialize_PointerToapp__BusinessError(soap, (app__BusinessError *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ContentEncoding: soap_serialize_PointerToapp__ContentEncoding(soap, (enum app__ContentEncoding *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__BusinessErrorList: soap_serialize_PointerToapp__BusinessErrorList(soap, (app__BusinessErrorList *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: soap_serialize_PointerToapp__ApplicationResultWrapper(soap, (app__ApplicationResultWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: soap_serialize_PointerToapp__ApplicationDataWrapper(soap, (app__ApplicationDataWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationStatus: soap_serialize_PointerToapp__ApplicationStatus(soap, (enum app__ApplicationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Hour: soap_serialize_PointerTobase__Hour(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Day: soap_serialize_PointerTobase__Day(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Month: soap_serialize_PointerTobase__Month(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Year: soap_serialize_PointerTobase__Year(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTobase__Error: soap_serialize_PointerToPointerTobase__Error(soap, (base__Error **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Error: soap_serialize_PointerTobase__Error(soap, (base__Error *const*)ptr); break;
	case SOAP_TYPE_PointerTobool: soap_serialize_PointerTobool(soap, (bool *const*)ptr); break;
	case SOAP_TYPE_PointerToLONG64: soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr); break;
	case SOAP_TYPE_PointerToint: soap_serialize_PointerToint(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTotime: soap_serialize_PointerTotime(soap, (time_t *const*)ptr); break;
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__GRNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_vd__SNILSType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_vd__StockEntryNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__OTPToken: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__GTINType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__GLNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__ENTModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__BEModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__EnterpriseType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__Code3: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_dic__Code: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_app__APIKey: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__SequenceNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Identifier: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__VersionStatus: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__String32: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__String255: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__NText: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Text: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__UUID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__token: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__positiveInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__nonNegativeInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__integer: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__date: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_PointerTounsignedByte: soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr); break;
	case SOAP_TYPE_xsd__Name: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__NCName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__IDREF: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__ID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE__QName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_string: soap_serialize_string(soap, (char*const*)&ptr); break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 vetisams_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	(void)type;
	switch(t) {
	case SOAP_TYPE_xsd__base64Binary: return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__GenericEntity: return (void*)soap_instantiate_base__GenericEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__ListOptions: return (void*)soap_instantiate_base__ListOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__DateInterval: return (void*)soap_instantiate_base__DateInterval(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__EntityList: return (void*)soap_instantiate_base__EntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__FaultInfo: return (void*)soap_instantiate_base__FaultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__ComplexDate: return (void*)soap_instantiate_base__ComplexDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__Application: return (void*)soap_instantiate_app__Application(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationDataWrapper: return (void*)soap_instantiate_app__ApplicationDataWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationResultWrapper: return (void*)soap_instantiate_app__ApplicationResultWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationData: return (void*)soap_instantiate_app__ApplicationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationResultData: return (void*)soap_instantiate_app__ApplicationResultData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__BusinessErrorList: return (void*)soap_instantiate_app__BusinessErrorList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Address: return (void*)soap_instantiate_dic__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Producer: return (void*)soap_instantiate_dic__Producer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProducerList: return (void*)soap_instantiate_dic__ProducerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__EnterpriseNumberList: return (void*)soap_instantiate_dic__EnterpriseNumberList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__BusinessMember: return (void*)soap_instantiate_dic__BusinessMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Package: return (void*)soap_instantiate_dic__Package(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__PackageList: return (void*)soap_instantiate_dic__PackageList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ComplexDate: return (void*)soap_instantiate_dic__ComplexDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProductItemProducing: return (void*)soap_instantiate_dic__ProductItemProducing(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Packaging: return (void*)soap_instantiate_dic__Packaging(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Location: return (void*)soap_instantiate_dic__Location(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__EnterpriseOfficialRegistration: return (void*)soap_instantiate_dic__EnterpriseOfficialRegistration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Organization: return (void*)soap_instantiate_dic__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__MedicinalDrug: return (void*)soap_instantiate_dic__MedicinalDrug(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationConditionGroup: return (void*)soap_instantiate_dic__RegionalizationConditionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationRequirement: return (void*)soap_instantiate_dic__RegionalizationRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationStatus: return (void*)soap_instantiate_dic__RegionalizationStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Batch: return (void*)soap_instantiate_vd__Batch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RawBatch: return (void*)soap_instantiate_vd__RawBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DeliveryFactList: return (void*)soap_instantiate_vd__DeliveryFactList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DeliveryInspection: return (void*)soap_instantiate_vd__DeliveryInspection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ConsignmentDocumentList: return (void*)soap_instantiate_vd__ConsignmentDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__GoodsDate: return (void*)soap_instantiate_vd__GoodsDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockDiscrepancy: return (void*)soap_instantiate_vd__StockDiscrepancy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__TransportInfo: return (void*)soap_instantiate_vd__TransportInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__TransportNumber: return (void*)soap_instantiate_vd__TransportNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ShipmentRoute: return (void*)soap_instantiate_vd__ShipmentRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProductionOperation: return (void*)soap_instantiate_vd__ProductionOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return (void*)soap_instantiate_vd__MergeStockEntriesOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__PSLModificationOperation: return (void*)soap_instantiate_vd__PSLModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BEModificationOperation: return (void*)soap_instantiate_vd__BEModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: return (void*)soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return (void*)soap_instantiate_vd__BEActivityLocationsModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ENTModificationOperation: return (void*)soap_instantiate_vd__ENTModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__CertifiedBatch: return (void*)soap_instantiate_vd__CertifiedBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__CertifiedConsignment: return (void*)soap_instantiate_vd__CertifiedConsignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VeterinaryEvent: return (void*)soap_instantiate_vd__VeterinaryEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VeterinaryAuthentication: return (void*)soap_instantiate_vd__VeterinaryAuthentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BatchOrigin: return (void*)soap_instantiate_vd__BatchOrigin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntryEventList: return (void*)soap_instantiate_vd__StockEntryEventList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocumentStatusChange: return (void*)soap_instantiate_vd__VetDocumentStatusChange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RegionalizationClause: return (void*)soap_instantiate_vd__RegionalizationClause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RouteSectionR13nRules: return (void*)soap_instantiate_vd__RouteSectionR13nRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProcessingProcedure: return (void*)soap_instantiate_vd__ProcessingProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__AuthorityList: return (void*)soap_instantiate_vd__AuthorityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__UserAuthority: return (void*)soap_instantiate_vd__UserAuthority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__WorkingArea: return (void*)soap_instantiate_vd__WorkingArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Citizenship: return (void*)soap_instantiate_vd__Citizenship(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__submitApplicationRequest: return (void*)soap_instantiate__ws__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__submitApplicationResponse: return (void*)soap_instantiate__ws__submitApplicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__receiveApplicationResultRequest: return (void*)soap_instantiate__ws__receiveApplicationResultRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__receiveApplicationResultResponse: return (void*)soap_instantiate__ws__receiveApplicationResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__MercuryApplicationRequest: return (void*)soap_instantiate_g2ba__MercuryApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse: return (void*)soap_instantiate_g2ba__ProcessIncomingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse: return (void*)soap_instantiate_g2ba__PrepareOutgoingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__RegisterProductionOperationResponse: return (void*)soap_instantiate_g2ba__RegisterProductionOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__MergeStockEntriesResponse: return (void*)soap_instantiate_g2ba__MergeStockEntriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__WithdrawVetDocumentResponse: return (void*)soap_instantiate_g2ba__WithdrawVetDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyBusinessEntityResponse: return (void*)soap_instantiate_g2ba__ModifyBusinessEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyEnterpriseResponse: return (void*)soap_instantiate_g2ba__ModifyEnterpriseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyActivityLocationsResponse: return (void*)soap_instantiate_g2ba__ModifyActivityLocationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ResolveDiscrepancyResponse: return (void*)soap_instantiate_g2ba__ResolveDiscrepancyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyProducerStockListResponse: return (void*)soap_instantiate_g2ba__ModifyProducerStockListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse: return (void*)soap_instantiate_g2ba__GetVetDocumentByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentListResponse: return (void*)soap_instantiate_g2ba__GetVetDocumentListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse: return (void*)soap_instantiate_g2ba__GetVetDocumentChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryByGuidResponse: return (void*)soap_instantiate_g2ba__GetStockEntryByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryByUuidResponse: return (void*)soap_instantiate_g2ba__GetStockEntryByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryChangesListResponse: return (void*)soap_instantiate_g2ba__GetStockEntryChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryListResponse: return (void*)soap_instantiate_g2ba__GetStockEntryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryVersionListResponse: return (void*)soap_instantiate_g2ba__GetStockEntryVersionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse: return (void*)soap_instantiate_g2ba__UpdateTransportMovementDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse: return (void*)soap_instantiate_g2ba__UpdateVeterinaryEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse: return (void*)soap_instantiate_g2ba__CheckShipmentRegionalizationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__AddBusinessEntityUserResponse: return (void*)soap_instantiate_g2ba__AddBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse: return (void*)soap_instantiate_g2ba__GetBusinessEntityUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetBusinessEntityUserResponse: return (void*)soap_instantiate_g2ba__GetBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse: return (void*)soap_instantiate_g2ba__UpdateUserAuthoritiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse: return (void*)soap_instantiate_g2ba__UpdateUserWorkingAreasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse: return (void*)soap_instantiate_g2ba__UnbindBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse: return (void*)soap_instantiate_g2ba__GetApplicableUserAuthorityListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__GenericVersioningEntity: return (void*)soap_instantiate_base__GenericVersioningEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__Error: return (void*)soap_instantiate_base__Error(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__PurposeList: return (void*)soap_instantiate_dic__PurposeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__UnitList: return (void*)soap_instantiate_dic__UnitList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__CountryList: return (void*)soap_instantiate_dic__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionList: return (void*)soap_instantiate_dic__RegionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__DistrictList: return (void*)soap_instantiate_dic__DistrictList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__LocalityList: return (void*)soap_instantiate_dic__LocalityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__StreetList: return (void*)soap_instantiate_dic__StreetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__EnterpriseActivityList: return (void*)soap_instantiate_dic__EnterpriseActivityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__EnterpriseActivity: return (void*)soap_instantiate_dic__EnterpriseActivity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__EnterpriseList: return (void*)soap_instantiate_dic__EnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__IncorporationForm: return (void*)soap_instantiate_dic__IncorporationForm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__BusinessEntityList: return (void*)soap_instantiate_dic__BusinessEntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProductList: return (void*)soap_instantiate_dic__ProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__SubProductList: return (void*)soap_instantiate_dic__SubProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProductItemList: return (void*)soap_instantiate_dic__ProductItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Area: return (void*)soap_instantiate_dic__Area(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationConditionList: return (void*)soap_instantiate_dic__RegionalizationConditionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationRegionStatusList: return (void*)soap_instantiate_dic__RegionalizationRegionStatusList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationShippingRuleList: return (void*)soap_instantiate_dic__RegionalizationShippingRuleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__AnimalDiseaseList: return (void*)soap_instantiate_dic__AnimalDiseaseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ResearchMethodList: return (void*)soap_instantiate_dic__ResearchMethodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ActivityLocationList: return (void*)soap_instantiate_dic__ActivityLocationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Consignment: return (void*)soap_instantiate_vd__Consignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProductiveBatch: return (void*)soap_instantiate_vd__ProductiveBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Delivery: return (void*)soap_instantiate_vd__Delivery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocumentList: return (void*)soap_instantiate_vd__VetDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DiscrepancyReason: return (void*)soap_instantiate_vd__DiscrepancyReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntryList: return (void*)soap_instantiate_vd__StockEntryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Document: return (void*)soap_instantiate_vd__Document(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ShipmentRoutePoint: return (void*)soap_instantiate_vd__ShipmentRoutePoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return (void*)soap_instantiate_vd__LaboratoryResearchEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__AnimalMedicationEvent: return (void*)soap_instantiate_vd__AnimalMedicationEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__QuarantineEvent: return (void*)soap_instantiate_vd__QuarantineEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__User: return (void*)soap_instantiate_vd__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__UserList: return (void*)soap_instantiate_vd__UserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__WorkingAreaList: return (void*)soap_instantiate_vd__WorkingAreaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest: return (void*)soap_instantiate_g2ba__ProcessIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest: return (void*)soap_instantiate_g2ba__PrepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__RegisterProductionOperationRequest: return (void*)soap_instantiate_g2ba__RegisterProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__MergeStockEntriesRequest: return (void*)soap_instantiate_g2ba__MergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__WithdrawVetDocumentRequest: return (void*)soap_instantiate_g2ba__WithdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyBusinessEntityRequest: return (void*)soap_instantiate_g2ba__ModifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyEnterpriseRequest: return (void*)soap_instantiate_g2ba__ModifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyActivityLocationsRequest: return (void*)soap_instantiate_g2ba__ModifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ResolveDiscrepancyRequest: return (void*)soap_instantiate_g2ba__ResolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__ModifyProducerStockListRequest: return (void*)soap_instantiate_g2ba__ModifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest: return (void*)soap_instantiate_g2ba__GetVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentListRequest: return (void*)soap_instantiate_g2ba__GetVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest: return (void*)soap_instantiate_g2ba__GetVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryByGuidRequest: return (void*)soap_instantiate_g2ba__GetStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryByUuidRequest: return (void*)soap_instantiate_g2ba__GetStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryChangesListRequest: return (void*)soap_instantiate_g2ba__GetStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryListRequest: return (void*)soap_instantiate_g2ba__GetStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetStockEntryVersionListRequest: return (void*)soap_instantiate_g2ba__GetStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest: return (void*)soap_instantiate_g2ba__UpdateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest: return (void*)soap_instantiate_g2ba__UpdateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest: return (void*)soap_instantiate_g2ba__CheckShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__AddBusinessEntityUserRequest: return (void*)soap_instantiate_g2ba__AddBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest: return (void*)soap_instantiate_g2ba__GetBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetBusinessEntityUserRequest: return (void*)soap_instantiate_g2ba__GetBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest: return (void*)soap_instantiate_g2ba__UpdateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest: return (void*)soap_instantiate_g2ba__UpdateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest: return (void*)soap_instantiate_g2ba__UnbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest: return (void*)soap_instantiate_g2ba__GetApplicableUserAuthorityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__BusinessError: return (void*)soap_instantiate_app__BusinessError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Purpose: return (void*)soap_instantiate_dic__Purpose(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Unit: return (void*)soap_instantiate_dic__Unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__PackingType: return (void*)soap_instantiate_dic__PackingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Country: return (void*)soap_instantiate_dic__Country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__FederalDistrict: return (void*)soap_instantiate_dic__FederalDistrict(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__AddressObjectView: return (void*)soap_instantiate_dic__AddressObjectView(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Enterprise: return (void*)soap_instantiate_dic__Enterprise(soap, -1, type, arrayType, n);
	case SOAP_TYPE__dic__BusinessEntity_activityLocation: return (void*)soap_instantiate__dic__BusinessEntity_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__BusinessEntity: return (void*)soap_instantiate_dic__BusinessEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProductItem: return (void*)soap_instantiate_dic__ProductItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Product: return (void*)soap_instantiate_dic__Product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__SubProduct: return (void*)soap_instantiate_dic__SubProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ProductMarks: return (void*)soap_instantiate_dic__ProductMarks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Indicator: return (void*)soap_instantiate_dic__Indicator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__AnimalDisease: return (void*)soap_instantiate_dic__AnimalDisease(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__ResearchMethod: return (void*)soap_instantiate_dic__ResearchMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationCondition: return (void*)soap_instantiate_dic__RegionalizationCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationShippingRule: return (void*)soap_instantiate_dic__RegionalizationShippingRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__RegionalizationRegionStatus: return (void*)soap_instantiate_dic__RegionalizationRegionStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocument: return (void*)soap_instantiate_vd__VetDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DiscrepancyReport: return (void*)soap_instantiate_vd__DiscrepancyReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntry: return (void*)soap_instantiate_vd__StockEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Waybill: return (void*)soap_instantiate_vd__Waybill(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ReferencedDocument: return (void*)soap_instantiate_vd__ReferencedDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Region: return (void*)soap_instantiate_dic__Region(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__District: return (void*)soap_instantiate_dic__District(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Locality: return (void*)soap_instantiate_dic__Locality(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dic__Street: return (void*)soap_instantiate_dic__Street(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntrySearchPattern: return (void*)soap_instantiate_vd__StockEntrySearchPattern(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail: return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___apps__submitApplicationRequest: return (void*)soap_instantiate___apps__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___apps__receiveApplicationResult: return (void*)soap_instantiate___apps__receiveApplicationResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__processIncomingConsignmentRequest: return (void*)soap_instantiate___g2b__processIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__prepareOutgoingConsignmentRequest: return (void*)soap_instantiate___g2b__prepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__registerProductionOperationRequest: return (void*)soap_instantiate___g2b__registerProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__mergeStockEntriesRequest: return (void*)soap_instantiate___g2b__mergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__withdrawVetDocumentRequest: return (void*)soap_instantiate___g2b__withdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__modifyBusinessEntityRequest: return (void*)soap_instantiate___g2b__modifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__modifyEnterpriseRequest: return (void*)soap_instantiate___g2b__modifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__modifyActivityLocationsRequest: return (void*)soap_instantiate___g2b__modifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__resolveDiscrepancyRequest: return (void*)soap_instantiate___g2b__resolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__modifyProducerStockListRequest: return (void*)soap_instantiate___g2b__modifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getVetDocumentByUuidRequest: return (void*)soap_instantiate___g2b__getVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getVetDocumentListRequest: return (void*)soap_instantiate___g2b__getVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getVetDocumentChangesListRequest: return (void*)soap_instantiate___g2b__getVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getStockEntryByGuidRequest: return (void*)soap_instantiate___g2b__getStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getStockEntryByUuidRequest: return (void*)soap_instantiate___g2b__getStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getStockEntryListRequest: return (void*)soap_instantiate___g2b__getStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getStockEntryChangesListRequest: return (void*)soap_instantiate___g2b__getStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getStockEntryVersionListRequest: return (void*)soap_instantiate___g2b__getStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__updateTransportMovementDetailsRequest: return (void*)soap_instantiate___g2b__updateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__updateVeterinaryEventsRequest: return (void*)soap_instantiate___g2b__updateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__checkShipmentRegionalizationRequest: return (void*)soap_instantiate___g2b__checkShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__addBusinessEntityUserRequest: return (void*)soap_instantiate___g2b__addBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getBusinessEntityUserListRequest: return (void*)soap_instantiate___g2b__getBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getBusinessEntityUserRequest: return (void*)soap_instantiate___g2b__getBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__updateUserAuthoritiesRequest: return (void*)soap_instantiate___g2b__updateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__updateUserWorkingAreasRequest: return (void*)soap_instantiate___g2b__updateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__unbindBusinessEntityUserRequest: return (void*)soap_instantiate___g2b__unbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___g2b__getApplicableUserAuthorityListRequest: return (void*)soap_instantiate___g2b__getApplicableUserAuthorityListRequest(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header: return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code: return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason: return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault: return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_app__BinaryContent: return (void*)soap_instantiate_app__BinaryContent(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 vetisams_fdelete(struct soap_clist *p)
{
	switch(p->type) {
	case SOAP_TYPE_xsd__base64Binary:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_base__GenericEntity:
		if(p->size < 0) SOAP_DELETE((base__GenericEntity*)p->ptr); else SOAP_DELETE_ARRAY((base__GenericEntity*)p->ptr);
		break;
	case SOAP_TYPE_base__ListOptions:
		if(p->size < 0) SOAP_DELETE((base__ListOptions*)p->ptr); else SOAP_DELETE_ARRAY((base__ListOptions*)p->ptr);
		break;
	case SOAP_TYPE_base__DateInterval:
		if(p->size < 0) SOAP_DELETE((base__DateInterval*)p->ptr); else SOAP_DELETE_ARRAY((base__DateInterval*)p->ptr);
		break;
	case SOAP_TYPE_base__EntityList:
		if(p->size < 0) SOAP_DELETE((base__EntityList*)p->ptr); else SOAP_DELETE_ARRAY((base__EntityList*)p->ptr);
		break;
	case SOAP_TYPE_base__FaultInfo:
		if(p->size < 0) SOAP_DELETE((base__FaultInfo*)p->ptr); else SOAP_DELETE_ARRAY((base__FaultInfo*)p->ptr);
		break;
	case SOAP_TYPE_base__ComplexDate:
		if(p->size < 0) SOAP_DELETE((base__ComplexDate*)p->ptr); else SOAP_DELETE_ARRAY((base__ComplexDate*)p->ptr);
		break;
	case SOAP_TYPE_app__Application:
		if(p->size < 0) SOAP_DELETE((app__Application*)p->ptr); else SOAP_DELETE_ARRAY((app__Application*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationDataWrapper:
		if(p->size < 0) SOAP_DELETE((app__ApplicationDataWrapper*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationDataWrapper*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationResultWrapper:
		if(p->size < 0) SOAP_DELETE((app__ApplicationResultWrapper*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationResultWrapper*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationData:
		if(p->size < 0) SOAP_DELETE((app__ApplicationData*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationData*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationResultData:
		if(p->size < 0) SOAP_DELETE((app__ApplicationResultData*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationResultData*)p->ptr);
		break;
	case SOAP_TYPE_app__BusinessErrorList:
		if(p->size < 0) SOAP_DELETE((app__BusinessErrorList*)p->ptr); else SOAP_DELETE_ARRAY((app__BusinessErrorList*)p->ptr);
		break;
	case SOAP_TYPE_dic__Address:
		if(p->size < 0) SOAP_DELETE((dic__Address*)p->ptr); else SOAP_DELETE_ARRAY((dic__Address*)p->ptr);
		break;
	case SOAP_TYPE_dic__Producer:
		if(p->size < 0) SOAP_DELETE((dic__Producer*)p->ptr); else SOAP_DELETE_ARRAY((dic__Producer*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProducerList:
		if(p->size < 0) SOAP_DELETE((dic__ProducerList*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProducerList*)p->ptr);
		break;
	case SOAP_TYPE_dic__EnterpriseNumberList:
		if(p->size < 0) SOAP_DELETE((dic__EnterpriseNumberList*)p->ptr); else SOAP_DELETE_ARRAY((dic__EnterpriseNumberList*)p->ptr);
		break;
	case SOAP_TYPE_dic__BusinessMember:
		if(p->size < 0) SOAP_DELETE((dic__BusinessMember*)p->ptr); else SOAP_DELETE_ARRAY((dic__BusinessMember*)p->ptr);
		break;
	case SOAP_TYPE_dic__Package:
		if(p->size < 0) SOAP_DELETE((dic__Package*)p->ptr); else SOAP_DELETE_ARRAY((dic__Package*)p->ptr);
		break;
	case SOAP_TYPE_dic__PackageList:
		if(p->size < 0) SOAP_DELETE((dic__PackageList*)p->ptr); else SOAP_DELETE_ARRAY((dic__PackageList*)p->ptr);
		break;
	case SOAP_TYPE_dic__ComplexDate:
		if(p->size < 0) SOAP_DELETE((dic__ComplexDate*)p->ptr); else SOAP_DELETE_ARRAY((dic__ComplexDate*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProductItemProducing:
		if(p->size < 0) SOAP_DELETE((dic__ProductItemProducing*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProductItemProducing*)p->ptr);
		break;
	case SOAP_TYPE_dic__Packaging:
		if(p->size < 0) SOAP_DELETE((dic__Packaging*)p->ptr); else SOAP_DELETE_ARRAY((dic__Packaging*)p->ptr);
		break;
	case SOAP_TYPE_dic__Location:
		if(p->size < 0) SOAP_DELETE((dic__Location*)p->ptr); else SOAP_DELETE_ARRAY((dic__Location*)p->ptr);
		break;
	case SOAP_TYPE_dic__EnterpriseOfficialRegistration:
		if(p->size < 0) SOAP_DELETE((dic__EnterpriseOfficialRegistration*)p->ptr); else SOAP_DELETE_ARRAY((dic__EnterpriseOfficialRegistration*)p->ptr);
		break;
	case SOAP_TYPE_dic__Organization:
		if(p->size < 0) SOAP_DELETE((dic__Organization*)p->ptr); else SOAP_DELETE_ARRAY((dic__Organization*)p->ptr);
		break;
	case SOAP_TYPE_dic__MedicinalDrug:
		if(p->size < 0) SOAP_DELETE((dic__MedicinalDrug*)p->ptr); else SOAP_DELETE_ARRAY((dic__MedicinalDrug*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationConditionGroup:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationConditionGroup*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationConditionGroup*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationRequirement:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationRequirement*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationRequirement*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationStatus:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationStatus*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationStatus*)p->ptr);
		break;
	case SOAP_TYPE_vd__Batch:
		if(p->size < 0) SOAP_DELETE((vd__Batch*)p->ptr); else SOAP_DELETE_ARRAY((vd__Batch*)p->ptr);
		break;
	case SOAP_TYPE_vd__RawBatch:
		if(p->size < 0) SOAP_DELETE((vd__RawBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__RawBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__DeliveryFactList:
		if(p->size < 0) SOAP_DELETE((vd__DeliveryFactList*)p->ptr); else SOAP_DELETE_ARRAY((vd__DeliveryFactList*)p->ptr);
		break;
	case SOAP_TYPE_vd__DeliveryInspection:
		if(p->size < 0) SOAP_DELETE((vd__DeliveryInspection*)p->ptr); else SOAP_DELETE_ARRAY((vd__DeliveryInspection*)p->ptr);
		break;
	case SOAP_TYPE_vd__ConsignmentDocumentList:
		if(p->size < 0) SOAP_DELETE((vd__ConsignmentDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((vd__ConsignmentDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_vd__GoodsDate:
		if(p->size < 0) SOAP_DELETE((vd__GoodsDate*)p->ptr); else SOAP_DELETE_ARRAY((vd__GoodsDate*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockDiscrepancy:
		if(p->size < 0) SOAP_DELETE((vd__StockDiscrepancy*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockDiscrepancy*)p->ptr);
		break;
	case SOAP_TYPE_vd__TransportInfo:
		if(p->size < 0) SOAP_DELETE((vd__TransportInfo*)p->ptr); else SOAP_DELETE_ARRAY((vd__TransportInfo*)p->ptr);
		break;
	case SOAP_TYPE_vd__TransportNumber:
		if(p->size < 0) SOAP_DELETE((vd__TransportNumber*)p->ptr); else SOAP_DELETE_ARRAY((vd__TransportNumber*)p->ptr);
		break;
	case SOAP_TYPE_vd__ShipmentRoute:
		if(p->size < 0) SOAP_DELETE((vd__ShipmentRoute*)p->ptr); else SOAP_DELETE_ARRAY((vd__ShipmentRoute*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProductionOperation:
		if(p->size < 0) SOAP_DELETE((vd__ProductionOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProductionOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__MergeStockEntriesOperation:
		if(p->size < 0) SOAP_DELETE((vd__MergeStockEntriesOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__MergeStockEntriesOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__PSLModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__PSLModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__PSLModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__BEModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__BEModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__BEModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation:
		if(p->size < 0) SOAP_DELETE((_vd__BEActivityLocationsModificationOperation_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_vd__BEActivityLocationsModificationOperation_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__BEActivityLocationsModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__BEActivityLocationsModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__ENTModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__ENTModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__ENTModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__CertifiedBatch:
		if(p->size < 0) SOAP_DELETE((vd__CertifiedBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__CertifiedBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__CertifiedConsignment:
		if(p->size < 0) SOAP_DELETE((vd__CertifiedConsignment*)p->ptr); else SOAP_DELETE_ARRAY((vd__CertifiedConsignment*)p->ptr);
		break;
	case SOAP_TYPE_vd__VeterinaryEvent:
		if(p->size < 0) SOAP_DELETE((vd__VeterinaryEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__VeterinaryEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__VeterinaryAuthentication:
		if(p->size < 0) SOAP_DELETE((vd__VeterinaryAuthentication*)p->ptr); else SOAP_DELETE_ARRAY((vd__VeterinaryAuthentication*)p->ptr);
		break;
	case SOAP_TYPE_vd__BatchOrigin:
		if(p->size < 0) SOAP_DELETE((vd__BatchOrigin*)p->ptr); else SOAP_DELETE_ARRAY((vd__BatchOrigin*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntryEventList:
		if(p->size < 0) SOAP_DELETE((vd__StockEntryEventList*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntryEventList*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocumentStatusChange:
		if(p->size < 0) SOAP_DELETE((vd__VetDocumentStatusChange*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocumentStatusChange*)p->ptr);
		break;
	case SOAP_TYPE_vd__RegionalizationClause:
		if(p->size < 0) SOAP_DELETE((vd__RegionalizationClause*)p->ptr); else SOAP_DELETE_ARRAY((vd__RegionalizationClause*)p->ptr);
		break;
	case SOAP_TYPE_vd__RouteSectionR13nRules:
		if(p->size < 0) SOAP_DELETE((vd__RouteSectionR13nRules*)p->ptr); else SOAP_DELETE_ARRAY((vd__RouteSectionR13nRules*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProcessingProcedure:
		if(p->size < 0) SOAP_DELETE((vd__ProcessingProcedure*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProcessingProcedure*)p->ptr);
		break;
	case SOAP_TYPE_vd__AuthorityList:
		if(p->size < 0) SOAP_DELETE((vd__AuthorityList*)p->ptr); else SOAP_DELETE_ARRAY((vd__AuthorityList*)p->ptr);
		break;
	case SOAP_TYPE_vd__UserAuthority:
		if(p->size < 0) SOAP_DELETE((vd__UserAuthority*)p->ptr); else SOAP_DELETE_ARRAY((vd__UserAuthority*)p->ptr);
		break;
	case SOAP_TYPE_vd__WorkingArea:
		if(p->size < 0) SOAP_DELETE((vd__WorkingArea*)p->ptr); else SOAP_DELETE_ARRAY((vd__WorkingArea*)p->ptr);
		break;
	case SOAP_TYPE_vd__Citizenship:
		if(p->size < 0) SOAP_DELETE((vd__Citizenship*)p->ptr); else SOAP_DELETE_ARRAY((vd__Citizenship*)p->ptr);
		break;
	case SOAP_TYPE__ws__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((_ws__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ws__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE__ws__submitApplicationResponse:
		if(p->size < 0) SOAP_DELETE((_ws__submitApplicationResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ws__submitApplicationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ws__receiveApplicationResultRequest:
		if(p->size < 0) SOAP_DELETE((_ws__receiveApplicationResultRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ws__receiveApplicationResultRequest*)p->ptr);
		break;
	case SOAP_TYPE__ws__receiveApplicationResultResponse:
		if(p->size < 0) SOAP_DELETE((_ws__receiveApplicationResultResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ws__receiveApplicationResultResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__MercuryApplicationRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__MercuryApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__MercuryApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ProcessIncomingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ProcessIncomingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__PrepareOutgoingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__PrepareOutgoingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__RegisterProductionOperationResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__RegisterProductionOperationResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__RegisterProductionOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__MergeStockEntriesResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__MergeStockEntriesResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__MergeStockEntriesResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__WithdrawVetDocumentResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__WithdrawVetDocumentResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__WithdrawVetDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyBusinessEntityResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyBusinessEntityResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyBusinessEntityResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyEnterpriseResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyEnterpriseResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyEnterpriseResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyActivityLocationsResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyActivityLocationsResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyActivityLocationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ResolveDiscrepancyResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ResolveDiscrepancyResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ResolveDiscrepancyResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyProducerStockListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyProducerStockListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyProducerStockListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryByGuidResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryByUuidResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryChangesListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryVersionListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryVersionListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryVersionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateTransportMovementDetailsResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateTransportMovementDetailsResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateVeterinaryEventsResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateVeterinaryEventsResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__CheckShipmentRegionalizationResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__CheckShipmentRegionalizationResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__AddBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__AddBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__AddBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetBusinessEntityUserListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetBusinessEntityUserListResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateUserAuthoritiesResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateUserAuthoritiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateUserWorkingAreasResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateUserWorkingAreasResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__UnbindBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UnbindBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse:
		if(p->size < 0) SOAP_DELETE((g2ba__GetApplicableUserAuthorityListResponse*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetApplicableUserAuthorityListResponse*)p->ptr);
		break;
	case SOAP_TYPE_base__GenericVersioningEntity:
		if(p->size < 0) SOAP_DELETE((base__GenericVersioningEntity*)p->ptr); else SOAP_DELETE_ARRAY((base__GenericVersioningEntity*)p->ptr);
		break;
	case SOAP_TYPE_base__Error:
		if(p->size < 0) SOAP_DELETE((base__Error*)p->ptr); else SOAP_DELETE_ARRAY((base__Error*)p->ptr);
		break;
	case SOAP_TYPE_dic__PurposeList:
		if(p->size < 0) SOAP_DELETE((dic__PurposeList*)p->ptr); else SOAP_DELETE_ARRAY((dic__PurposeList*)p->ptr);
		break;
	case SOAP_TYPE_dic__UnitList:
		if(p->size < 0) SOAP_DELETE((dic__UnitList*)p->ptr); else SOAP_DELETE_ARRAY((dic__UnitList*)p->ptr);
		break;
	case SOAP_TYPE_dic__CountryList:
		if(p->size < 0) SOAP_DELETE((dic__CountryList*)p->ptr); else SOAP_DELETE_ARRAY((dic__CountryList*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionList:
		if(p->size < 0) SOAP_DELETE((dic__RegionList*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionList*)p->ptr);
		break;
	case SOAP_TYPE_dic__DistrictList:
		if(p->size < 0) SOAP_DELETE((dic__DistrictList*)p->ptr); else SOAP_DELETE_ARRAY((dic__DistrictList*)p->ptr);
		break;
	case SOAP_TYPE_dic__LocalityList:
		if(p->size < 0) SOAP_DELETE((dic__LocalityList*)p->ptr); else SOAP_DELETE_ARRAY((dic__LocalityList*)p->ptr);
		break;
	case SOAP_TYPE_dic__StreetList:
		if(p->size < 0) SOAP_DELETE((dic__StreetList*)p->ptr); else SOAP_DELETE_ARRAY((dic__StreetList*)p->ptr);
		break;
	case SOAP_TYPE_dic__EnterpriseActivityList:
		if(p->size < 0) SOAP_DELETE((dic__EnterpriseActivityList*)p->ptr); else SOAP_DELETE_ARRAY((dic__EnterpriseActivityList*)p->ptr);
		break;
	case SOAP_TYPE_dic__EnterpriseActivity:
		if(p->size < 0) SOAP_DELETE((dic__EnterpriseActivity*)p->ptr); else SOAP_DELETE_ARRAY((dic__EnterpriseActivity*)p->ptr);
		break;
	case SOAP_TYPE_dic__EnterpriseList:
		if(p->size < 0) SOAP_DELETE((dic__EnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((dic__EnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE_dic__IncorporationForm:
		if(p->size < 0) SOAP_DELETE((dic__IncorporationForm*)p->ptr); else SOAP_DELETE_ARRAY((dic__IncorporationForm*)p->ptr);
		break;
	case SOAP_TYPE_dic__BusinessEntityList:
		if(p->size < 0) SOAP_DELETE((dic__BusinessEntityList*)p->ptr); else SOAP_DELETE_ARRAY((dic__BusinessEntityList*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProductList:
		if(p->size < 0) SOAP_DELETE((dic__ProductList*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProductList*)p->ptr);
		break;
	case SOAP_TYPE_dic__SubProductList:
		if(p->size < 0) SOAP_DELETE((dic__SubProductList*)p->ptr); else SOAP_DELETE_ARRAY((dic__SubProductList*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProductItemList:
		if(p->size < 0) SOAP_DELETE((dic__ProductItemList*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProductItemList*)p->ptr);
		break;
	case SOAP_TYPE_dic__Area:
		if(p->size < 0) SOAP_DELETE((dic__Area*)p->ptr); else SOAP_DELETE_ARRAY((dic__Area*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationConditionList:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationConditionList*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationConditionList*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationRegionStatusList:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationRegionStatusList*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationRegionStatusList*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationShippingRuleList:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationShippingRuleList*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationShippingRuleList*)p->ptr);
		break;
	case SOAP_TYPE_dic__AnimalDiseaseList:
		if(p->size < 0) SOAP_DELETE((dic__AnimalDiseaseList*)p->ptr); else SOAP_DELETE_ARRAY((dic__AnimalDiseaseList*)p->ptr);
		break;
	case SOAP_TYPE_dic__ResearchMethodList:
		if(p->size < 0) SOAP_DELETE((dic__ResearchMethodList*)p->ptr); else SOAP_DELETE_ARRAY((dic__ResearchMethodList*)p->ptr);
		break;
	case SOAP_TYPE_dic__ActivityLocationList:
		if(p->size < 0) SOAP_DELETE((dic__ActivityLocationList*)p->ptr); else SOAP_DELETE_ARRAY((dic__ActivityLocationList*)p->ptr);
		break;
	case SOAP_TYPE_vd__Consignment:
		if(p->size < 0) SOAP_DELETE((vd__Consignment*)p->ptr); else SOAP_DELETE_ARRAY((vd__Consignment*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProductiveBatch:
		if(p->size < 0) SOAP_DELETE((vd__ProductiveBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProductiveBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__Delivery:
		if(p->size < 0) SOAP_DELETE((vd__Delivery*)p->ptr); else SOAP_DELETE_ARRAY((vd__Delivery*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocumentList:
		if(p->size < 0) SOAP_DELETE((vd__VetDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_vd__DiscrepancyReason:
		if(p->size < 0) SOAP_DELETE((vd__DiscrepancyReason*)p->ptr); else SOAP_DELETE_ARRAY((vd__DiscrepancyReason*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntryList:
		if(p->size < 0) SOAP_DELETE((vd__StockEntryList*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntryList*)p->ptr);
		break;
	case SOAP_TYPE_vd__Document:
		if(p->size < 0) SOAP_DELETE((vd__Document*)p->ptr); else SOAP_DELETE_ARRAY((vd__Document*)p->ptr);
		break;
	case SOAP_TYPE_vd__ShipmentRoutePoint:
		if(p->size < 0) SOAP_DELETE((vd__ShipmentRoutePoint*)p->ptr); else SOAP_DELETE_ARRAY((vd__ShipmentRoutePoint*)p->ptr);
		break;
	case SOAP_TYPE_vd__LaboratoryResearchEvent:
		if(p->size < 0) SOAP_DELETE((vd__LaboratoryResearchEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__LaboratoryResearchEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__AnimalMedicationEvent:
		if(p->size < 0) SOAP_DELETE((vd__AnimalMedicationEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__AnimalMedicationEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__QuarantineEvent:
		if(p->size < 0) SOAP_DELETE((vd__QuarantineEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__QuarantineEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__User:
		if(p->size < 0) SOAP_DELETE((vd__User*)p->ptr); else SOAP_DELETE_ARRAY((vd__User*)p->ptr);
		break;
	case SOAP_TYPE_vd__UserList:
		if(p->size < 0) SOAP_DELETE((vd__UserList*)p->ptr); else SOAP_DELETE_ARRAY((vd__UserList*)p->ptr);
		break;
	case SOAP_TYPE_vd__WorkingAreaList:
		if(p->size < 0) SOAP_DELETE((vd__WorkingAreaList*)p->ptr); else SOAP_DELETE_ARRAY((vd__WorkingAreaList*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ProcessIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ProcessIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__PrepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__PrepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__RegisterProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__RegisterProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__RegisterProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__MergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__MergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__MergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__WithdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__WithdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__WithdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ResolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ResolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ResolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__ModifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__ModifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__ModifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__CheckShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__CheckShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__AddBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__AddBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__AddBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__UpdateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UpdateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__UnbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__UnbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((g2ba__GetApplicableUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((g2ba__GetApplicableUserAuthorityListRequest*)p->ptr);
		break;
	case SOAP_TYPE_app__BusinessError:
		if(p->size < 0) SOAP_DELETE((app__BusinessError*)p->ptr); else SOAP_DELETE_ARRAY((app__BusinessError*)p->ptr);
		break;
	case SOAP_TYPE_dic__Purpose:
		if(p->size < 0) SOAP_DELETE((dic__Purpose*)p->ptr); else SOAP_DELETE_ARRAY((dic__Purpose*)p->ptr);
		break;
	case SOAP_TYPE_dic__Unit:
		if(p->size < 0) SOAP_DELETE((dic__Unit*)p->ptr); else SOAP_DELETE_ARRAY((dic__Unit*)p->ptr);
		break;
	case SOAP_TYPE_dic__PackingType:
		if(p->size < 0) SOAP_DELETE((dic__PackingType*)p->ptr); else SOAP_DELETE_ARRAY((dic__PackingType*)p->ptr);
		break;
	case SOAP_TYPE_dic__Country:
		if(p->size < 0) SOAP_DELETE((dic__Country*)p->ptr); else SOAP_DELETE_ARRAY((dic__Country*)p->ptr);
		break;
	case SOAP_TYPE_dic__FederalDistrict:
		if(p->size < 0) SOAP_DELETE((dic__FederalDistrict*)p->ptr); else SOAP_DELETE_ARRAY((dic__FederalDistrict*)p->ptr);
		break;
	case SOAP_TYPE_dic__AddressObjectView:
		if(p->size < 0) SOAP_DELETE((dic__AddressObjectView*)p->ptr); else SOAP_DELETE_ARRAY((dic__AddressObjectView*)p->ptr);
		break;
	case SOAP_TYPE_dic__Enterprise:
		if(p->size < 0) SOAP_DELETE((dic__Enterprise*)p->ptr); else SOAP_DELETE_ARRAY((dic__Enterprise*)p->ptr);
		break;
	case SOAP_TYPE__dic__BusinessEntity_activityLocation:
		if(p->size < 0) SOAP_DELETE((_dic__BusinessEntity_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_dic__BusinessEntity_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_dic__BusinessEntity:
		if(p->size < 0) SOAP_DELETE((dic__BusinessEntity*)p->ptr); else SOAP_DELETE_ARRAY((dic__BusinessEntity*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProductItem:
		if(p->size < 0) SOAP_DELETE((dic__ProductItem*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProductItem*)p->ptr);
		break;
	case SOAP_TYPE_dic__Product:
		if(p->size < 0) SOAP_DELETE((dic__Product*)p->ptr); else SOAP_DELETE_ARRAY((dic__Product*)p->ptr);
		break;
	case SOAP_TYPE_dic__SubProduct:
		if(p->size < 0) SOAP_DELETE((dic__SubProduct*)p->ptr); else SOAP_DELETE_ARRAY((dic__SubProduct*)p->ptr);
		break;
	case SOAP_TYPE_dic__ProductMarks:
		if(p->size < 0) SOAP_DELETE((dic__ProductMarks*)p->ptr); else SOAP_DELETE_ARRAY((dic__ProductMarks*)p->ptr);
		break;
	case SOAP_TYPE_dic__Indicator:
		if(p->size < 0) SOAP_DELETE((dic__Indicator*)p->ptr); else SOAP_DELETE_ARRAY((dic__Indicator*)p->ptr);
		break;
	case SOAP_TYPE_dic__AnimalDisease:
		if(p->size < 0) SOAP_DELETE((dic__AnimalDisease*)p->ptr); else SOAP_DELETE_ARRAY((dic__AnimalDisease*)p->ptr);
		break;
	case SOAP_TYPE_dic__ResearchMethod:
		if(p->size < 0) SOAP_DELETE((dic__ResearchMethod*)p->ptr); else SOAP_DELETE_ARRAY((dic__ResearchMethod*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationCondition:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationCondition*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationCondition*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationShippingRule:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationShippingRule*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationShippingRule*)p->ptr);
		break;
	case SOAP_TYPE_dic__RegionalizationRegionStatus:
		if(p->size < 0) SOAP_DELETE((dic__RegionalizationRegionStatus*)p->ptr); else SOAP_DELETE_ARRAY((dic__RegionalizationRegionStatus*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocument:
		if(p->size < 0) SOAP_DELETE((vd__VetDocument*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocument*)p->ptr);
		break;
	case SOAP_TYPE_vd__DiscrepancyReport:
		if(p->size < 0) SOAP_DELETE((vd__DiscrepancyReport*)p->ptr); else SOAP_DELETE_ARRAY((vd__DiscrepancyReport*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntry:
		if(p->size < 0) SOAP_DELETE((vd__StockEntry*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntry*)p->ptr);
		break;
	case SOAP_TYPE_vd__Waybill:
		if(p->size < 0) SOAP_DELETE((vd__Waybill*)p->ptr); else SOAP_DELETE_ARRAY((vd__Waybill*)p->ptr);
		break;
	case SOAP_TYPE_vd__ReferencedDocument:
		if(p->size < 0) SOAP_DELETE((vd__ReferencedDocument*)p->ptr); else SOAP_DELETE_ARRAY((vd__ReferencedDocument*)p->ptr);
		break;
	case SOAP_TYPE_dic__Region:
		if(p->size < 0) SOAP_DELETE((dic__Region*)p->ptr); else SOAP_DELETE_ARRAY((dic__Region*)p->ptr);
		break;
	case SOAP_TYPE_dic__District:
		if(p->size < 0) SOAP_DELETE((dic__District*)p->ptr); else SOAP_DELETE_ARRAY((dic__District*)p->ptr);
		break;
	case SOAP_TYPE_dic__Locality:
		if(p->size < 0) SOAP_DELETE((dic__Locality*)p->ptr); else SOAP_DELETE_ARRAY((dic__Locality*)p->ptr);
		break;
	case SOAP_TYPE_dic__Street:
		if(p->size < 0) SOAP_DELETE((dic__Street*)p->ptr); else SOAP_DELETE_ARRAY((dic__Street*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntrySearchPattern:
		if(p->size < 0) SOAP_DELETE((vd__StockEntrySearchPattern*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntrySearchPattern*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___apps__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((struct __apps__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __apps__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE___apps__receiveApplicationResult:
		if(p->size < 0) SOAP_DELETE((struct __apps__receiveApplicationResult*)p->ptr); else SOAP_DELETE_ARRAY((struct __apps__receiveApplicationResult*)p->ptr);
		break;
	case SOAP_TYPE___g2b__processIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__processIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__processIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__prepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__prepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__prepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__registerProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__registerProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__registerProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__mergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__mergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__mergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__withdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__withdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__withdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__modifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__modifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__modifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__modifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__modifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__modifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__modifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__modifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__modifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__resolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__resolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__resolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__modifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__modifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__modifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__updateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__updateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__updateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__updateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__updateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__updateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__checkShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__checkShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__checkShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__addBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__addBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__addBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__updateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__updateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__updateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__updateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__updateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__updateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__unbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__unbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__unbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___g2b__getApplicableUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((struct __g2b__getApplicableUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __g2b__getApplicableUserAuthorityListRequest*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_app__BinaryContent:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{
	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, vetisams_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * FASTCALL soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{;
	char * p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	return soap_out_byte(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if((p = soap_in_byte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Minute(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_dic__Minute);
}

SOAP_FMAC3 int * FASTCALL soap_in_dic__Minute(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_dic__Minute);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 59) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Minute(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Minute);
	return soap_out_dic__Minute(soap, tag?tag:"dic:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_dic__Minute(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Hour(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_dic__Hour);
}

SOAP_FMAC3 int * FASTCALL soap_in_dic__Hour(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_dic__Hour);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 23) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Hour(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Hour);
	return soap_out_dic__Hour(soap, tag?tag:"dic:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_dic__Hour(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Day(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_dic__Day);
}

SOAP_FMAC3 int * FASTCALL soap_in_dic__Day(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_dic__Day);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 31) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Day(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Day);
	return soap_out_dic__Day(soap, tag?tag:"dic:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_dic__Day(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Month(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_dic__Month);
}

SOAP_FMAC3 int * FASTCALL soap_in_dic__Month(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_dic__Month);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 12) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Month(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Month);
	return soap_out_dic__Month(soap, tag?tag:"dic:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_dic__Month(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Year(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_dic__Year);
}

SOAP_FMAC3 int * FASTCALL soap_in_dic__Year(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_dic__Year);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Year(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Year);
	return soap_out_dic__Year(soap, tag?tag:"dic:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_dic__Year(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Hour(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_base__Hour);
}

SOAP_FMAC3 int * FASTCALL soap_in_base__Hour(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_base__Hour);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 23) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Hour(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Hour);
	return soap_out_base__Hour(soap, tag?tag:"base:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_base__Hour(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Day(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_base__Day);
}

SOAP_FMAC3 int * FASTCALL soap_in_base__Day(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_base__Day);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 31) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Day(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Day);
	return soap_out_base__Day(soap, tag?tag:"base:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_base__Day(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Month(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_base__Month);
}

SOAP_FMAC3 int * FASTCALL soap_in_base__Month(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_base__Month);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 12) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Month(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Month);
	return soap_out_base__Month(soap, tag?tag:"base:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_base__Month(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Year(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_base__Year);
}

SOAP_FMAC3 int * FASTCALL soap_in_base__Year(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_base__Year);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Year(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Year);
	return soap_out_base__Year(soap, tag?tag:"base:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_base__Year(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * FASTCALL soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	return soap_out_int(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_int(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * FASTCALL soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{;
	LONG64 * p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	return soap_out_LONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if((p = soap_in_LONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * FASTCALL soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{;
	unsigned char * p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	return soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * FASTCALL soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{;
	unsigned int * p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	return soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedInt(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * FASTCALL soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{;
	time_t * p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	return soap_out_time(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if((p = soap_in_time(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int FASTCALL soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if(map)
		*a = (bool)(map->code != 0);
	else {
		long n;
		if(soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * FASTCALL soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	return soap_out_bool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if((p = soap_in_bool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__AnimalSpentPeriod
	*a = SOAP_DEFAULT_vd__AnimalSpentPeriod;
#else
	*a = (enum vd__AnimalSpentPeriod)0;
#endif
}

static const struct soap_code_map soap_codes_vd__AnimalSpentPeriod[] =
{	{ (long)vd__AnimalSpentPeriod__FROM_USCOREBIRTH, "FROM_BIRTH" },
	{ (long)vd__AnimalSpentPeriod__NOT_USCORELESS_USCORESIX_USCOREMONTHS, "NOT_LESS_SIX_MONTHS" },
	{ (long)vd__AnimalSpentPeriod__IN_USCOREMONTHS, "IN_MONTHS" },
	{ (long)vd__AnimalSpentPeriod__ZERO, "ZERO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__AnimalSpentPeriod2s(struct soap *soap, enum vd__AnimalSpentPeriod n)
{
	const char *s = soap_code_str(soap_codes_vd__AnimalSpentPeriod, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, const enum vd__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AnimalSpentPeriod), type) || soap_send(soap, soap_vd__AnimalSpentPeriod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__AnimalSpentPeriod(struct soap *soap, const char *s, enum vd__AnimalSpentPeriod *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__AnimalSpentPeriod, s);
	if(map)
		*a = (enum vd__AnimalSpentPeriod)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__AnimalSpentPeriod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod * FASTCALL soap_in_vd__AnimalSpentPeriod(struct soap *soap, const char *tag, enum vd__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__AnimalSpentPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AnimalSpentPeriod, sizeof(enum vd__AnimalSpentPeriod), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__AnimalSpentPeriod(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__AnimalSpentPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AnimalSpentPeriod, 0, sizeof(enum vd__AnimalSpentPeriod), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__AnimalSpentPeriod(struct soap *soap, const enum vd__AnimalSpentPeriod *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__AnimalSpentPeriod);
	return soap_out_vd__AnimalSpentPeriod(soap, tag?tag:"vd:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod * SOAP_FMAC4 soap_get_vd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentStatus
	*a = SOAP_DEFAULT_vd__VetDocumentStatus;
#else
	*a = (enum vd__VetDocumentStatus)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentStatus[] =
{	{ (long)vd__VetDocumentStatus__CREATED, "CREATED" },
	{ (long)vd__VetDocumentStatus__CONFIRMED, "CONFIRMED" },
	{ (long)vd__VetDocumentStatus__WITHDRAWN, "WITHDRAWN" },
	{ (long)vd__VetDocumentStatus__UTILIZED, "UTILIZED" },
	{ (long)vd__VetDocumentStatus__FINALIZED, "FINALIZED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentStatus2s(struct soap *soap, enum vd__VetDocumentStatus n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatus(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentStatus), type) || soap_send(soap, soap_vd__VetDocumentStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentStatus(struct soap *soap, const char *s, enum vd__VetDocumentStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentStatus, s);
	if(map)
		*a = (enum vd__VetDocumentStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentStatus * FASTCALL soap_in_vd__VetDocumentStatus(struct soap *soap, const char *tag, enum vd__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentStatus, sizeof(enum vd__VetDocumentStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentStatus, 0, sizeof(enum vd__VetDocumentStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentStatus(struct soap *soap, const enum vd__VetDocumentStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatus);
	return soap_out_vd__VetDocumentStatus(soap, tag?tag:"vd:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentStatus * SOAP_FMAC4 soap_get_vd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentType
	*a = SOAP_DEFAULT_vd__VetDocumentType;
#else
	*a = (enum vd__VetDocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentType[] =
{	{ (long)vd__VetDocumentType__TRANSPORT, "TRANSPORT" },
	{ (long)vd__VetDocumentType__PRODUCTIVE, "PRODUCTIVE" },
	{ (long)vd__VetDocumentType__RETURNABLE, "RETURNABLE" },
	{ (long)vd__VetDocumentType__INCOMING, "INCOMING" },
	{ (long)vd__VetDocumentType__OUTGOING, "OUTGOING" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentType2s(struct soap *soap, enum vd__VetDocumentType n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentType(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentType), type) || soap_send(soap, soap_vd__VetDocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentType(struct soap *soap, const char *s, enum vd__VetDocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentType, s);
	if(map)
		*a = (enum vd__VetDocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentType * FASTCALL soap_in_vd__VetDocumentType(struct soap *soap, const char *tag, enum vd__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentType, sizeof(enum vd__VetDocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentType, 0, sizeof(enum vd__VetDocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentType(struct soap *soap, const enum vd__VetDocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentType);
	return soap_out_vd__VetDocumentType(soap, tag?tag:"vd:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentType * SOAP_FMAC4 soap_get_vd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentForm
	*a = SOAP_DEFAULT_vd__VetDocumentForm;
#else
	*a = (enum vd__VetDocumentForm)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentForm[] =
{	{ (long)vd__VetDocumentForm__CERTCU1, "CERTCU1" },
	{ (long)vd__VetDocumentForm__LIC1, "LIC1" },
	{ (long)vd__VetDocumentForm__CERTCU2, "CERTCU2" },
	{ (long)vd__VetDocumentForm__LIC2, "LIC2" },
	{ (long)vd__VetDocumentForm__CERTCU3, "CERTCU3" },
	{ (long)vd__VetDocumentForm__LIC3, "LIC3" },
	{ (long)vd__VetDocumentForm__NOTE4, "NOTE4" },
	{ (long)vd__VetDocumentForm__CERT5I, "CERT5I" },
	{ (long)vd__VetDocumentForm__CERT61, "CERT61" },
	{ (long)vd__VetDocumentForm__CERT62, "CERT62" },
	{ (long)vd__VetDocumentForm__CERT63, "CERT63" },
	{ (long)vd__VetDocumentForm__PRODUCTIVE, "PRODUCTIVE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentForm2s(struct soap *soap, enum vd__VetDocumentForm n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentForm, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentForm(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentForm), type) || soap_send(soap, soap_vd__VetDocumentForm2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentForm(struct soap *soap, const char *s, enum vd__VetDocumentForm *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentForm, s);
	if(map)
		*a = (enum vd__VetDocumentForm)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentForm)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentForm * FASTCALL soap_in_vd__VetDocumentForm(struct soap *soap, const char *tag, enum vd__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentForm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentForm, sizeof(enum vd__VetDocumentForm), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentForm(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentForm, 0, sizeof(enum vd__VetDocumentForm), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentForm(struct soap *soap, const enum vd__VetDocumentForm *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentForm);
	return soap_out_vd__VetDocumentForm(soap, tag?tag:"vd:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentForm * SOAP_FMAC4 soap_get_vd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__DeliveryInspectionResult(struct soap *soap, enum vd__DeliveryInspectionResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__DeliveryInspectionResult
	*a = SOAP_DEFAULT_vd__DeliveryInspectionResult;
#else
	*a = (enum vd__DeliveryInspectionResult)0;
#endif
}

static const struct soap_code_map soap_codes_vd__DeliveryInspectionResult[] =
{	{ (long)vd__DeliveryInspectionResult__CORRESPONDS, "CORRESPONDS" },
	{ (long)vd__DeliveryInspectionResult__MISMATCH, "MISMATCH" },
	{ (long)vd__DeliveryInspectionResult__UNSUPERVISED, "UNSUPERVISED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__DeliveryInspectionResult2s(struct soap *soap, enum vd__DeliveryInspectionResult n)
{
	const char *s = soap_code_str(soap_codes_vd__DeliveryInspectionResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryInspectionResult(struct soap *soap, const char *tag, int id, const enum vd__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryInspectionResult), type) || soap_send(soap, soap_vd__DeliveryInspectionResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__DeliveryInspectionResult(struct soap *soap, const char *s, enum vd__DeliveryInspectionResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__DeliveryInspectionResult, s);
	if(map)
		*a = (enum vd__DeliveryInspectionResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__DeliveryInspectionResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__DeliveryInspectionResult * FASTCALL soap_in_vd__DeliveryInspectionResult(struct soap *soap, const char *tag, enum vd__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__DeliveryInspectionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryInspectionResult, sizeof(enum vd__DeliveryInspectionResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__DeliveryInspectionResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__DeliveryInspectionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryInspectionResult, 0, sizeof(enum vd__DeliveryInspectionResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__DeliveryInspectionResult(struct soap *soap, const enum vd__DeliveryInspectionResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__DeliveryInspectionResult);
	return soap_out_vd__DeliveryInspectionResult(soap, tag?tag:"vd:DeliveryInspectionResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__DeliveryInspectionResult * SOAP_FMAC4 soap_get_vd__DeliveryInspectionResult(struct soap *soap, enum vd__DeliveryInspectionResult *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryInspectionResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__DeliveryDecision(struct soap *soap, enum vd__DeliveryDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__DeliveryDecision
	*a = SOAP_DEFAULT_vd__DeliveryDecision;
#else
	*a = (enum vd__DeliveryDecision)0;
#endif
}

static const struct soap_code_map soap_codes_vd__DeliveryDecision[] =
{	{ (long)vd__DeliveryDecision__ACCEPT_USCOREALL, "ACCEPT_ALL" },
	{ (long)vd__DeliveryDecision__PARTIALLY, "PARTIALLY" },
	{ (long)vd__DeliveryDecision__RETURN_USCOREALL, "RETURN_ALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__DeliveryDecision2s(struct soap *soap, enum vd__DeliveryDecision n)
{
	const char *s = soap_code_str(soap_codes_vd__DeliveryDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryDecision(struct soap *soap, const char *tag, int id, const enum vd__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryDecision), type) || soap_send(soap, soap_vd__DeliveryDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__DeliveryDecision(struct soap *soap, const char *s, enum vd__DeliveryDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__DeliveryDecision, s);
	if(map)
		*a = (enum vd__DeliveryDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__DeliveryDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__DeliveryDecision * FASTCALL soap_in_vd__DeliveryDecision(struct soap *soap, const char *tag, enum vd__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__DeliveryDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryDecision, sizeof(enum vd__DeliveryDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__DeliveryDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__DeliveryDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryDecision, 0, sizeof(enum vd__DeliveryDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__DeliveryDecision(struct soap *soap, const enum vd__DeliveryDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__DeliveryDecision);
	return soap_out_vd__DeliveryDecision(soap, tag?tag:"vd:DeliveryDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__DeliveryDecision * SOAP_FMAC4 soap_get_vd__DeliveryDecision(struct soap *soap, enum vd__DeliveryDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__ProductMarkingClass(struct soap *soap, enum dic__ProductMarkingClass *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__ProductMarkingClass
	*a = SOAP_DEFAULT_dic__ProductMarkingClass;
#else
	*a = (enum dic__ProductMarkingClass)0;
#endif
}

static const struct soap_code_map soap_codes_dic__ProductMarkingClass[] =
{	{ (long)dic__ProductMarkingClass__UNDEFINED, "UNDEFINED" },
	{ (long)dic__ProductMarkingClass__BN, "BN" },
	{ (long)dic__ProductMarkingClass__SSCC, "SSCC" },
	{ (long)dic__ProductMarkingClass__EAN8, "EAN8" },
	{ (long)dic__ProductMarkingClass__EAN13, "EAN13" },
	{ (long)dic__ProductMarkingClass__EAN128, "EAN128" },
	{ (long)dic__ProductMarkingClass__BUNDLE, "BUNDLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__ProductMarkingClass2s(struct soap *soap, enum dic__ProductMarkingClass n)
{
	const char *s = soap_code_str(soap_codes_dic__ProductMarkingClass, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductMarkingClass(struct soap *soap, const char *tag, int id, const enum dic__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductMarkingClass), type) || soap_send(soap, soap_dic__ProductMarkingClass2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__ProductMarkingClass(struct soap *soap, const char *s, enum dic__ProductMarkingClass *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__ProductMarkingClass, s);
	if(map)
		*a = (enum dic__ProductMarkingClass)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__ProductMarkingClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__ProductMarkingClass * FASTCALL soap_in_dic__ProductMarkingClass(struct soap *soap, const char *tag, enum dic__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__ProductMarkingClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductMarkingClass, sizeof(enum dic__ProductMarkingClass), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__ProductMarkingClass(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__ProductMarkingClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductMarkingClass, 0, sizeof(enum dic__ProductMarkingClass), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ProductMarkingClass(struct soap *soap, const enum dic__ProductMarkingClass *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ProductMarkingClass);
	return soap_out_dic__ProductMarkingClass(soap, tag?tag:"dic:ProductMarkingClass", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ProductMarkingClass * SOAP_FMAC4 soap_get_dic__ProductMarkingClass(struct soap *soap, enum dic__ProductMarkingClass *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductMarkingClass(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__TransportationStorageType(struct soap *soap, enum dic__TransportationStorageType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__TransportationStorageType
	*a = SOAP_DEFAULT_dic__TransportationStorageType;
#else
	*a = (enum dic__TransportationStorageType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__TransportationStorageType[] =
{	{ (long)dic__TransportationStorageType__FROZEN, "FROZEN" },
	{ (long)dic__TransportationStorageType__CHILLED, "CHILLED" },
	{ (long)dic__TransportationStorageType__COOLED, "COOLED" },
	{ (long)dic__TransportationStorageType__VENTILATED, "VENTILATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__TransportationStorageType2s(struct soap *soap, enum dic__TransportationStorageType n)
{
	const char *s = soap_code_str(soap_codes_dic__TransportationStorageType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__TransportationStorageType(struct soap *soap, const char *tag, int id, const enum dic__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__TransportationStorageType), type) || soap_send(soap, soap_dic__TransportationStorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__TransportationStorageType(struct soap *soap, const char *s, enum dic__TransportationStorageType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__TransportationStorageType, s);
	if(map)
		*a = (enum dic__TransportationStorageType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__TransportationStorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__TransportationStorageType * FASTCALL soap_in_dic__TransportationStorageType(struct soap *soap, const char *tag, enum dic__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__TransportationStorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__TransportationStorageType, sizeof(enum dic__TransportationStorageType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__TransportationStorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__TransportationStorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__TransportationStorageType, 0, sizeof(enum dic__TransportationStorageType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__TransportationStorageType(struct soap *soap, const enum dic__TransportationStorageType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__TransportationStorageType);
	return soap_out_dic__TransportationStorageType(soap, tag?tag:"dic:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__TransportationStorageType * SOAP_FMAC4 soap_get_dic__TransportationStorageType(struct soap *soap, enum dic__TransportationStorageType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__DocumentNature(struct soap *soap, enum dic__DocumentNature *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__DocumentNature
	*a = SOAP_DEFAULT_dic__DocumentNature;
#else
	*a = (enum dic__DocumentNature)0;
#endif
}

static const struct soap_code_map soap_codes_dic__DocumentNature[] =
{	{ (long)dic__DocumentNature__ELECTRONIC, "ELECTRONIC" },
	{ (long)dic__DocumentNature__PAPER, "PAPER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__DocumentNature2s(struct soap *soap, enum dic__DocumentNature n)
{
	const char *s = soap_code_str(soap_codes_dic__DocumentNature, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__DocumentNature(struct soap *soap, const char *tag, int id, const enum dic__DocumentNature *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__DocumentNature), type) || soap_send(soap, soap_dic__DocumentNature2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__DocumentNature(struct soap *soap, const char *s, enum dic__DocumentNature *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__DocumentNature, s);
	if(map)
		*a = (enum dic__DocumentNature)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__DocumentNature)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__DocumentNature * FASTCALL soap_in_dic__DocumentNature(struct soap *soap, const char *tag, enum dic__DocumentNature *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__DocumentNature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__DocumentNature, sizeof(enum dic__DocumentNature), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__DocumentNature(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__DocumentNature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__DocumentNature, 0, sizeof(enum dic__DocumentNature), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__DocumentNature(struct soap *soap, const enum dic__DocumentNature *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__DocumentNature);
	return soap_out_dic__DocumentNature(soap, tag?tag:"dic:DocumentNature", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__DocumentNature * SOAP_FMAC4 soap_get_dic__DocumentNature(struct soap *soap, enum dic__DocumentNature *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__DocumentNature(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__EnterpriseRole(struct soap *soap, enum dic__EnterpriseRole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__EnterpriseRole
	*a = SOAP_DEFAULT_dic__EnterpriseRole;
#else
	*a = (enum dic__EnterpriseRole)0;
#endif
}

static const struct soap_code_map soap_codes_dic__EnterpriseRole[] =
{	{ (long)dic__EnterpriseRole__UNKNOWN, "UNKNOWN" },
	{ (long)dic__EnterpriseRole__PRODUCER, "PRODUCER" },
	{ (long)dic__EnterpriseRole__SLAUGHTER_USCOREHOUSE, "SLAUGHTER_HOUSE" },
	{ (long)dic__EnterpriseRole__CUTTING_USCOREPLANT, "CUTTING_PLANT" },
	{ (long)dic__EnterpriseRole__COLD_USCORESTORE, "COLD_STORE" },
	{ (long)dic__EnterpriseRole__PACKAGING_USCOREPLANT, "PACKAGING_PLANT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__EnterpriseRole2s(struct soap *soap, enum dic__EnterpriseRole n)
{
	const char *s = soap_code_str(soap_codes_dic__EnterpriseRole, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseRole(struct soap *soap, const char *tag, int id, const enum dic__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseRole), type) || soap_send(soap, soap_dic__EnterpriseRole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__EnterpriseRole(struct soap *soap, const char *s, enum dic__EnterpriseRole *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__EnterpriseRole, s);
	if(map)
		*a = (enum dic__EnterpriseRole)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__EnterpriseRole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__EnterpriseRole * FASTCALL soap_in_dic__EnterpriseRole(struct soap *soap, const char *tag, enum dic__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__EnterpriseRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseRole, sizeof(enum dic__EnterpriseRole), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__EnterpriseRole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__EnterpriseRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseRole, 0, sizeof(enum dic__EnterpriseRole), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__EnterpriseRole(struct soap *soap, const enum dic__EnterpriseRole *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseRole);
	return soap_out_dic__EnterpriseRole(soap, tag?tag:"dic:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__EnterpriseRole * SOAP_FMAC4 soap_get_dic__EnterpriseRole(struct soap *soap, enum dic__EnterpriseRole *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__ProcessingProcedureType(struct soap *soap, enum vd__ProcessingProcedureType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__ProcessingProcedureType
	*a = SOAP_DEFAULT_vd__ProcessingProcedureType;
#else
	*a = (enum vd__ProcessingProcedureType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__ProcessingProcedureType[] =
{	{ (long)vd__ProcessingProcedureType__7, "7" },
	{ (long)vd__ProcessingProcedureType__12, "12" },
	{ (long)vd__ProcessingProcedureType__13, "13" },
	{ (long)vd__ProcessingProcedureType__34, "34" },
	{ (long)vd__ProcessingProcedureType__35, "35" },
	{ (long)vd__ProcessingProcedureType__37, "37" },
	{ (long)vd__ProcessingProcedureType__39, "39" },
	{ (long)vd__ProcessingProcedureType__40, "40" },
	{ (long)vd__ProcessingProcedureType__43, "43" },
	{ (long)vd__ProcessingProcedureType__51, "51" },
	{ (long)vd__ProcessingProcedureType__73, "73" },
	{ (long)vd__ProcessingProcedureType__95, "95" },
	{ (long)vd__ProcessingProcedureType__101, "101" },
	{ (long)vd__ProcessingProcedureType__102, "102" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__ProcessingProcedureType2s(struct soap *soap, enum vd__ProcessingProcedureType n)
{
	const char *s = soap_code_str(soap_codes_vd__ProcessingProcedureType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProcessingProcedureType(struct soap *soap, const char *tag, int id, const enum vd__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProcessingProcedureType), type) || soap_send(soap, soap_vd__ProcessingProcedureType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__ProcessingProcedureType(struct soap *soap, const char *s, enum vd__ProcessingProcedureType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__ProcessingProcedureType, s);
	if(map)
		*a = (enum vd__ProcessingProcedureType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 102)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__ProcessingProcedureType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__ProcessingProcedureType * FASTCALL soap_in_vd__ProcessingProcedureType(struct soap *soap, const char *tag, enum vd__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__ProcessingProcedureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProcessingProcedureType, sizeof(enum vd__ProcessingProcedureType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__ProcessingProcedureType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__ProcessingProcedureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProcessingProcedureType, 0, sizeof(enum vd__ProcessingProcedureType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__ProcessingProcedureType(struct soap *soap, const enum vd__ProcessingProcedureType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__ProcessingProcedureType);
	return soap_out_vd__ProcessingProcedureType(soap, tag?tag:"vd:ProcessingProcedureType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__ProcessingProcedureType * SOAP_FMAC4 soap_get_vd__ProcessingProcedureType(struct soap *soap, enum vd__ProcessingProcedureType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProcessingProcedureType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VeterinaryEventType
	*a = SOAP_DEFAULT_vd__VeterinaryEventType;
#else
	*a = (enum vd__VeterinaryEventType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VeterinaryEventType[] =
{	{ (long)vd__VeterinaryEventType__UND, "UND" },
	{ (long)vd__VeterinaryEventType__LBR, "LBR" },
	{ (long)vd__VeterinaryEventType__VSE, "VSE" },
	{ (long)vd__VeterinaryEventType__IMM, "IMM" },
	{ (long)vd__VeterinaryEventType__MED, "MED" },
	{ (long)vd__VeterinaryEventType__QRT, "QRT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VeterinaryEventType2s(struct soap *soap, enum vd__VeterinaryEventType n)
{
	const char *s = soap_code_str(soap_codes_vd__VeterinaryEventType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryEventType(struct soap *soap, const char *tag, int id, const enum vd__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryEventType), type) || soap_send(soap, soap_vd__VeterinaryEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VeterinaryEventType(struct soap *soap, const char *s, enum vd__VeterinaryEventType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VeterinaryEventType, s);
	if(map)
		*a = (enum vd__VeterinaryEventType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VeterinaryEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VeterinaryEventType * FASTCALL soap_in_vd__VeterinaryEventType(struct soap *soap, const char *tag, enum vd__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VeterinaryEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryEventType, sizeof(enum vd__VeterinaryEventType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VeterinaryEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VeterinaryEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryEventType, 0, sizeof(enum vd__VeterinaryEventType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VeterinaryEventType(struct soap *soap, const enum vd__VeterinaryEventType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryEventType);
	return soap_out_vd__VeterinaryEventType(soap, tag?tag:"vd:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VeterinaryEventType * SOAP_FMAC4 soap_get_vd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__StockEntryBlankFilter
	*a = SOAP_DEFAULT_vd__StockEntryBlankFilter;
#else
	*a = (enum vd__StockEntryBlankFilter)0;
#endif
}

static const struct soap_code_map soap_codes_vd__StockEntryBlankFilter[] =
{	{ (long)vd__StockEntryBlankFilter__ALL, "ALL" },
	{ (long)vd__StockEntryBlankFilter__BLANK, "BLANK" },
	{ (long)vd__StockEntryBlankFilter__NOT_USCOREBLANK, "NOT_BLANK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__StockEntryBlankFilter2s(struct soap *soap, enum vd__StockEntryBlankFilter n)
{
	const char *s = soap_code_str(soap_codes_vd__StockEntryBlankFilter, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, const enum vd__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryBlankFilter), type) || soap_send(soap, soap_vd__StockEntryBlankFilter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__StockEntryBlankFilter(struct soap *soap, const char *s, enum vd__StockEntryBlankFilter *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__StockEntryBlankFilter, s);
	if(map)
		*a = (enum vd__StockEntryBlankFilter)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__StockEntryBlankFilter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter * FASTCALL soap_in_vd__StockEntryBlankFilter(struct soap *soap, const char *tag, enum vd__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__StockEntryBlankFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryBlankFilter, sizeof(enum vd__StockEntryBlankFilter), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__StockEntryBlankFilter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__StockEntryBlankFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryBlankFilter, 0, sizeof(enum vd__StockEntryBlankFilter), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__StockEntryBlankFilter(struct soap *soap, const enum vd__StockEntryBlankFilter *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__StockEntryBlankFilter);
	return soap_out_vd__StockEntryBlankFilter(soap, tag?tag:"vd:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter * SOAP_FMAC4 soap_get_vd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__VaccinationType(struct soap *soap, enum dic__VaccinationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__VaccinationType
	*a = SOAP_DEFAULT_dic__VaccinationType;
#else
	*a = (enum dic__VaccinationType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__VaccinationType[] =
{	{ (long)dic__VaccinationType__UNDEFINED, "UNDEFINED" },
	{ (long)dic__VaccinationType__APPLIED, "APPLIED" },
	{ (long)dic__VaccinationType__UNVACCINATED, "UNVACCINATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__VaccinationType2s(struct soap *soap, enum dic__VaccinationType n)
{
	const char *s = soap_code_str(soap_codes_dic__VaccinationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__VaccinationType(struct soap *soap, const char *tag, int id, const enum dic__VaccinationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__VaccinationType), type) || soap_send(soap, soap_dic__VaccinationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__VaccinationType(struct soap *soap, const char *s, enum dic__VaccinationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__VaccinationType, s);
	if(map)
		*a = (enum dic__VaccinationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__VaccinationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__VaccinationType * FASTCALL soap_in_dic__VaccinationType(struct soap *soap, const char *tag, enum dic__VaccinationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__VaccinationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__VaccinationType, sizeof(enum dic__VaccinationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__VaccinationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__VaccinationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__VaccinationType, 0, sizeof(enum dic__VaccinationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__VaccinationType(struct soap *soap, const enum dic__VaccinationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__VaccinationType);
	return soap_out_dic__VaccinationType(soap, tag?tag:"dic:VaccinationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__VaccinationType * SOAP_FMAC4 soap_get_dic__VaccinationType(struct soap *soap, enum dic__VaccinationType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__VaccinationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__ProsperityType(struct soap *soap, enum dic__ProsperityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__ProsperityType
	*a = SOAP_DEFAULT_dic__ProsperityType;
#else
	*a = (enum dic__ProsperityType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__ProsperityType[] =
{	{ (long)dic__ProsperityType__UNDEFINED, "UNDEFINED" },
	{ (long)dic__ProsperityType__UNKNOWN, "UNKNOWN" },
	{ (long)dic__ProsperityType__SAFE, "SAFE" },
	{ (long)dic__ProsperityType__UNSAFE, "UNSAFE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__ProsperityType2s(struct soap *soap, enum dic__ProsperityType n)
{
	const char *s = soap_code_str(soap_codes_dic__ProsperityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProsperityType(struct soap *soap, const char *tag, int id, const enum dic__ProsperityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProsperityType), type) || soap_send(soap, soap_dic__ProsperityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__ProsperityType(struct soap *soap, const char *s, enum dic__ProsperityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__ProsperityType, s);
	if(map)
		*a = (enum dic__ProsperityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__ProsperityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__ProsperityType * FASTCALL soap_in_dic__ProsperityType(struct soap *soap, const char *tag, enum dic__ProsperityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__ProsperityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProsperityType, sizeof(enum dic__ProsperityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__ProsperityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__ProsperityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProsperityType, 0, sizeof(enum dic__ProsperityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ProsperityType(struct soap *soap, const enum dic__ProsperityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ProsperityType);
	return soap_out_dic__ProsperityType(soap, tag?tag:"dic:ProsperityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ProsperityType * SOAP_FMAC4 soap_get_dic__ProsperityType(struct soap *soap, enum dic__ProsperityType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProsperityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__RegionalizationDecision(struct soap *soap, enum dic__RegionalizationDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__RegionalizationDecision
	*a = SOAP_DEFAULT_dic__RegionalizationDecision;
#else
	*a = (enum dic__RegionalizationDecision)0;
#endif
}

static const struct soap_code_map soap_codes_dic__RegionalizationDecision[] =
{	{ (long)dic__RegionalizationDecision__1, "1" },
	{ (long)dic__RegionalizationDecision__2, "2" },
	{ (long)dic__RegionalizationDecision__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__RegionalizationDecision2s(struct soap *soap, enum dic__RegionalizationDecision n)
{
	const char *s = soap_code_str(soap_codes_dic__RegionalizationDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationDecision(struct soap *soap, const char *tag, int id, const enum dic__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationDecision), type) || soap_send(soap, soap_dic__RegionalizationDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__RegionalizationDecision(struct soap *soap, const char *s, enum dic__RegionalizationDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__RegionalizationDecision, s);
	if(map)
		*a = (enum dic__RegionalizationDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__RegionalizationDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__RegionalizationDecision * FASTCALL soap_in_dic__RegionalizationDecision(struct soap *soap, const char *tag, enum dic__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__RegionalizationDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationDecision, sizeof(enum dic__RegionalizationDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__RegionalizationDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__RegionalizationDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationDecision, 0, sizeof(enum dic__RegionalizationDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__RegionalizationDecision(struct soap *soap, const enum dic__RegionalizationDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationDecision);
	return soap_out_dic__RegionalizationDecision(soap, tag?tag:"dic:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__RegionalizationDecision * SOAP_FMAC4 soap_get_dic__RegionalizationDecision(struct soap *soap, enum dic__RegionalizationDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__ResearchResult(struct soap *soap, enum dic__ResearchResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__ResearchResult
	*a = SOAP_DEFAULT_dic__ResearchResult;
#else
	*a = (enum dic__ResearchResult)0;
#endif
}

static const struct soap_code_map soap_codes_dic__ResearchResult[] =
{	{ (long)dic__ResearchResult__UNKNOWN, "UNKNOWN" },
	{ (long)dic__ResearchResult__UNDEFINED, "UNDEFINED" },
	{ (long)dic__ResearchResult__POSITIVE, "POSITIVE" },
	{ (long)dic__ResearchResult__NEGATIVE, "NEGATIVE" },
	{ (long)dic__ResearchResult__UNFULFILLED, "UNFULFILLED" },
	{ (long)dic__ResearchResult__VSERAW, "VSERAW" },
	{ (long)dic__ResearchResult__VSEFULL, "VSEFULL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__ResearchResult2s(struct soap *soap, enum dic__ResearchResult n)
{
	const char *s = soap_code_str(soap_codes_dic__ResearchResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ResearchResult(struct soap *soap, const char *tag, int id, const enum dic__ResearchResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ResearchResult), type) || soap_send(soap, soap_dic__ResearchResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__ResearchResult(struct soap *soap, const char *s, enum dic__ResearchResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__ResearchResult, s);
	if(map)
		*a = (enum dic__ResearchResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__ResearchResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__ResearchResult * FASTCALL soap_in_dic__ResearchResult(struct soap *soap, const char *tag, enum dic__ResearchResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__ResearchResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ResearchResult, sizeof(enum dic__ResearchResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__ResearchResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__ResearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ResearchResult, 0, sizeof(enum dic__ResearchResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ResearchResult(struct soap *soap, const enum dic__ResearchResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ResearchResult);
	return soap_out_dic__ResearchResult(soap, tag?tag:"dic:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ResearchResult * SOAP_FMAC4 soap_get_dic__ResearchResult(struct soap *soap, enum dic__ResearchResult *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__TransportType(struct soap *soap, enum dic__TransportType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__TransportType
	*a = SOAP_DEFAULT_dic__TransportType;
#else
	*a = (enum dic__TransportType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__TransportType[] =
{	{ (long)dic__TransportType__1, "1" },
	{ (long)dic__TransportType__2, "2" },
	{ (long)dic__TransportType__3, "3" },
	{ (long)dic__TransportType__4, "4" },
	{ (long)dic__TransportType__5, "5" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__TransportType2s(struct soap *soap, enum dic__TransportType n)
{
	const char *s = soap_code_str(soap_codes_dic__TransportType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__TransportType(struct soap *soap, const char *tag, int id, const enum dic__TransportType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__TransportType), type) || soap_send(soap, soap_dic__TransportType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__TransportType(struct soap *soap, const char *s, enum dic__TransportType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__TransportType, s);
	if(map)
		*a = (enum dic__TransportType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__TransportType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__TransportType * FASTCALL soap_in_dic__TransportType(struct soap *soap, const char *tag, enum dic__TransportType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__TransportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__TransportType, sizeof(enum dic__TransportType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__TransportType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__TransportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__TransportType, 0, sizeof(enum dic__TransportType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__TransportType(struct soap *soap, const enum dic__TransportType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__TransportType);
	return soap_out_dic__TransportType(soap, tag?tag:"dic:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__TransportType * SOAP_FMAC4 soap_get_dic__TransportType(struct soap *soap, enum dic__TransportType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__ReferenceType(struct soap *soap, enum dic__ReferenceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__ReferenceType
	*a = SOAP_DEFAULT_dic__ReferenceType;
#else
	*a = (enum dic__ReferenceType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__ReferenceType[] =
{	{ (long)dic__ReferenceType__1, "1" },
	{ (long)dic__ReferenceType__2, "2" },
	{ (long)dic__ReferenceType__3, "3" },
	{ (long)dic__ReferenceType__4, "4" },
	{ (long)dic__ReferenceType__5, "5" },
	{ (long)dic__ReferenceType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__ReferenceType2s(struct soap *soap, enum dic__ReferenceType n)
{
	const char *s = soap_code_str(soap_codes_dic__ReferenceType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ReferenceType(struct soap *soap, const char *tag, int id, const enum dic__ReferenceType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ReferenceType), type) || soap_send(soap, soap_dic__ReferenceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__ReferenceType(struct soap *soap, const char *s, enum dic__ReferenceType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__ReferenceType, s);
	if(map)
		*a = (enum dic__ReferenceType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__ReferenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__ReferenceType * FASTCALL soap_in_dic__ReferenceType(struct soap *soap, const char *tag, enum dic__ReferenceType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ReferenceType, sizeof(enum dic__ReferenceType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__ReferenceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ReferenceType, 0, sizeof(enum dic__ReferenceType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ReferenceType(struct soap *soap, const enum dic__ReferenceType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ReferenceType);
	return soap_out_dic__ReferenceType(soap, tag?tag:"dic:ReferenceType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ReferenceType * SOAP_FMAC4 soap_get_dic__ReferenceType(struct soap *soap, enum dic__ReferenceType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ReferenceType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__DocumentType(struct soap *soap, enum dic__DocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__DocumentType
	*a = SOAP_DEFAULT_dic__DocumentType;
#else
	*a = (enum dic__DocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__DocumentType[] =
{	{ (long)dic__DocumentType__1, "1" },
	{ (long)dic__DocumentType__2, "2" },
	{ (long)dic__DocumentType__3, "3" },
	{ (long)dic__DocumentType__4, "4" },
	{ (long)dic__DocumentType__5, "5" },
	{ (long)dic__DocumentType__6, "6" },
	{ (long)dic__DocumentType__7, "7" },
	{ (long)dic__DocumentType__8, "8" },
	{ (long)dic__DocumentType__9, "9" },
	{ (long)dic__DocumentType__10, "10" },
	{ (long)dic__DocumentType__11, "11" },
	{ (long)dic__DocumentType__12, "12" },
	{ (long)dic__DocumentType__13, "13" },
	{ (long)dic__DocumentType__14, "14" },
	{ (long)dic__DocumentType__15, "15" },
	{ (long)dic__DocumentType__16, "16" },
	{ (long)dic__DocumentType__17, "17" },
	{ (long)dic__DocumentType__18, "18" },
	{ (long)dic__DocumentType__19, "19" },
	{ (long)dic__DocumentType__20, "20" },
	{ (long)dic__DocumentType__21, "21" },
	{ (long)dic__DocumentType__22, "22" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__DocumentType2s(struct soap *soap, enum dic__DocumentType n)
{
	const char *s = soap_code_str(soap_codes_dic__DocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__DocumentType(struct soap *soap, const char *tag, int id, const enum dic__DocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__DocumentType), type) || soap_send(soap, soap_dic__DocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__DocumentType(struct soap *soap, const char *s, enum dic__DocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__DocumentType, s);
	if(map)
		*a = (enum dic__DocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 22)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__DocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__DocumentType * FASTCALL soap_in_dic__DocumentType(struct soap *soap, const char *tag, enum dic__DocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__DocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__DocumentType, sizeof(enum dic__DocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__DocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__DocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__DocumentType, 0, sizeof(enum dic__DocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__DocumentType(struct soap *soap, const enum dic__DocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__DocumentType);
	return soap_out_dic__DocumentType(soap, tag?tag:"dic:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__DocumentType * SOAP_FMAC4 soap_get_dic__DocumentType(struct soap *soap, enum dic__DocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__ProductType(struct soap *soap, enum dic__ProductType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__ProductType
	*a = SOAP_DEFAULT_dic__ProductType;
#else
	*a = (enum dic__ProductType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__ProductType[] =
{	{ (long)dic__ProductType__1, "1" },
	{ (long)dic__ProductType__2, "2" },
	{ (long)dic__ProductType__3, "3" },
	{ (long)dic__ProductType__4, "4" },
	{ (long)dic__ProductType__5, "5" },
	{ (long)dic__ProductType__6, "6" },
	{ (long)dic__ProductType__7, "7" },
	{ (long)dic__ProductType__8, "8" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__ProductType2s(struct soap *soap, enum dic__ProductType n)
{
	const char *s = soap_code_str(soap_codes_dic__ProductType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductType(struct soap *soap, const char *tag, int id, const enum dic__ProductType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductType), type) || soap_send(soap, soap_dic__ProductType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__ProductType(struct soap *soap, const char *s, enum dic__ProductType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__ProductType, s);
	if(map)
		*a = (enum dic__ProductType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__ProductType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__ProductType * FASTCALL soap_in_dic__ProductType(struct soap *soap, const char *tag, enum dic__ProductType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__ProductType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductType, sizeof(enum dic__ProductType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__ProductType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__ProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductType, 0, sizeof(enum dic__ProductType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ProductType(struct soap *soap, const enum dic__ProductType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ProductType);
	return soap_out_dic__ProductType(soap, tag?tag:"dic:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ProductType * SOAP_FMAC4 soap_get_dic__ProductType(struct soap *soap, enum dic__ProductType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__BusinessEntityType(struct soap *soap, enum dic__BusinessEntityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__BusinessEntityType
	*a = SOAP_DEFAULT_dic__BusinessEntityType;
#else
	*a = (enum dic__BusinessEntityType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__BusinessEntityType[] =
{	{ (long)dic__BusinessEntityType__1, "1" },
	{ (long)dic__BusinessEntityType__2, "2" },
	{ (long)dic__BusinessEntityType__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__BusinessEntityType2s(struct soap *soap, enum dic__BusinessEntityType n)
{
	const char *s = soap_code_str(soap_codes_dic__BusinessEntityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__BusinessEntityType(struct soap *soap, const char *tag, int id, const enum dic__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__BusinessEntityType), type) || soap_send(soap, soap_dic__BusinessEntityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__BusinessEntityType(struct soap *soap, const char *s, enum dic__BusinessEntityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__BusinessEntityType, s);
	if(map)
		*a = (enum dic__BusinessEntityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__BusinessEntityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__BusinessEntityType * FASTCALL soap_in_dic__BusinessEntityType(struct soap *soap, const char *tag, enum dic__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__BusinessEntityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__BusinessEntityType, sizeof(enum dic__BusinessEntityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__BusinessEntityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__BusinessEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__BusinessEntityType, 0, sizeof(enum dic__BusinessEntityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__BusinessEntityType(struct soap *soap, const enum dic__BusinessEntityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__BusinessEntityType);
	return soap_out_dic__BusinessEntityType(soap, tag?tag:"dic:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__BusinessEntityType * SOAP_FMAC4 soap_get_dic__BusinessEntityType(struct soap *soap, enum dic__BusinessEntityType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__EnterpriseGroup(struct soap *soap, enum dic__EnterpriseGroup *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__EnterpriseGroup
	*a = SOAP_DEFAULT_dic__EnterpriseGroup;
#else
	*a = (enum dic__EnterpriseGroup)0;
#endif
}

static const struct soap_code_map soap_codes_dic__EnterpriseGroup[] =
{	{ (long)dic__EnterpriseGroup__0, "0" },
	{ (long)dic__EnterpriseGroup__1, "1" },
	{ (long)dic__EnterpriseGroup__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__EnterpriseGroup2s(struct soap *soap, enum dic__EnterpriseGroup n)
{
	const char *s = soap_code_str(soap_codes_dic__EnterpriseGroup, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseGroup(struct soap *soap, const char *tag, int id, const enum dic__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseGroup), type) || soap_send(soap, soap_dic__EnterpriseGroup2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__EnterpriseGroup(struct soap *soap, const char *s, enum dic__EnterpriseGroup *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__EnterpriseGroup, s);
	if(map)
		*a = (enum dic__EnterpriseGroup)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__EnterpriseGroup)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__EnterpriseGroup * FASTCALL soap_in_dic__EnterpriseGroup(struct soap *soap, const char *tag, enum dic__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__EnterpriseGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseGroup, sizeof(enum dic__EnterpriseGroup), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__EnterpriseGroup(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__EnterpriseGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseGroup, 0, sizeof(enum dic__EnterpriseGroup), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__EnterpriseGroup(struct soap *soap, const enum dic__EnterpriseGroup *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseGroup);
	return soap_out_dic__EnterpriseGroup(soap, tag?tag:"dic:EnterpriseGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__EnterpriseGroup * SOAP_FMAC4 soap_get_dic__EnterpriseGroup(struct soap *soap, enum dic__EnterpriseGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__PackingCodeType(struct soap *soap, enum dic__PackingCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__PackingCodeType
	*a = SOAP_DEFAULT_dic__PackingCodeType;
#else
	*a = (enum dic__PackingCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__PackingCodeType[] =
{	{ (long)dic__PackingCodeType__1A, "1A" },
	{ (long)dic__PackingCodeType__1B, "1B" },
	{ (long)dic__PackingCodeType__1D, "1D" },
	{ (long)dic__PackingCodeType__1F, "1F" },
	{ (long)dic__PackingCodeType__1G, "1G" },
	{ (long)dic__PackingCodeType__1W, "1W" },
	{ (long)dic__PackingCodeType__2C, "2C" },
	{ (long)dic__PackingCodeType__3A, "3A" },
	{ (long)dic__PackingCodeType__3H, "3H" },
	{ (long)dic__PackingCodeType__43, "43" },
	{ (long)dic__PackingCodeType__44, "44" },
	{ (long)dic__PackingCodeType__4A, "4A" },
	{ (long)dic__PackingCodeType__4B, "4B" },
	{ (long)dic__PackingCodeType__4C, "4C" },
	{ (long)dic__PackingCodeType__4D, "4D" },
	{ (long)dic__PackingCodeType__4F, "4F" },
	{ (long)dic__PackingCodeType__4G, "4G" },
	{ (long)dic__PackingCodeType__4H, "4H" },
	{ (long)dic__PackingCodeType__5H, "5H" },
	{ (long)dic__PackingCodeType__5L, "5L" },
	{ (long)dic__PackingCodeType__5M, "5M" },
	{ (long)dic__PackingCodeType__6H, "6H" },
	{ (long)dic__PackingCodeType__6P, "6P" },
	{ (long)dic__PackingCodeType__7A, "7A" },
	{ (long)dic__PackingCodeType__7B, "7B" },
	{ (long)dic__PackingCodeType__8A, "8A" },
	{ (long)dic__PackingCodeType__8B, "8B" },
	{ (long)dic__PackingCodeType__8C, "8C" },
	{ (long)dic__PackingCodeType__AA, "AA" },
	{ (long)dic__PackingCodeType__AB, "AB" },
	{ (long)dic__PackingCodeType__AC, "AC" },
	{ (long)dic__PackingCodeType__AD, "AD" },
	{ (long)dic__PackingCodeType__AE, "AE" },
	{ (long)dic__PackingCodeType__AF, "AF" },
	{ (long)dic__PackingCodeType__AG, "AG" },
	{ (long)dic__PackingCodeType__AH, "AH" },
	{ (long)dic__PackingCodeType__AI, "AI" },
	{ (long)dic__PackingCodeType__AJ, "AJ" },
	{ (long)dic__PackingCodeType__AL, "AL" },
	{ (long)dic__PackingCodeType__AM, "AM" },
	{ (long)dic__PackingCodeType__AP, "AP" },
	{ (long)dic__PackingCodeType__AT, "AT" },
	{ (long)dic__PackingCodeType__AV, "AV" },
	{ (long)dic__PackingCodeType__B4, "B4" },
	{ (long)dic__PackingCodeType__BA, "BA" },
	{ (long)dic__PackingCodeType__BB, "BB" },
	{ (long)dic__PackingCodeType__BC, "BC" },
	{ (long)dic__PackingCodeType__BD, "BD" },
	{ (long)dic__PackingCodeType__BE, "BE" },
	{ (long)dic__PackingCodeType__BF, "BF" },
	{ (long)dic__PackingCodeType__BG, "BG" },
	{ (long)dic__PackingCodeType__BH, "BH" },
	{ (long)dic__PackingCodeType__BI, "BI" },
	{ (long)dic__PackingCodeType__BJ, "BJ" },
	{ (long)dic__PackingCodeType__BK, "BK" },
	{ (long)dic__PackingCodeType__BL, "BL" },
	{ (long)dic__PackingCodeType__BM, "BM" },
	{ (long)dic__PackingCodeType__BN, "BN" },
	{ (long)dic__PackingCodeType__BO, "BO" },
	{ (long)dic__PackingCodeType__BP, "BP" },
	{ (long)dic__PackingCodeType__BQ, "BQ" },
	{ (long)dic__PackingCodeType__BR, "BR" },
	{ (long)dic__PackingCodeType__BS, "BS" },
	{ (long)dic__PackingCodeType__BT, "BT" },
	{ (long)dic__PackingCodeType__BU, "BU" },
	{ (long)dic__PackingCodeType__BV, "BV" },
	{ (long)dic__PackingCodeType__BW, "BW" },
	{ (long)dic__PackingCodeType__BX, "BX" },
	{ (long)dic__PackingCodeType__BY, "BY" },
	{ (long)dic__PackingCodeType__BZ, "BZ" },
	{ (long)dic__PackingCodeType__CA, "CA" },
	{ (long)dic__PackingCodeType__CB, "CB" },
	{ (long)dic__PackingCodeType__CC, "CC" },
	{ (long)dic__PackingCodeType__CD, "CD" },
	{ (long)dic__PackingCodeType__CE, "CE" },
	{ (long)dic__PackingCodeType__CF, "CF" },
	{ (long)dic__PackingCodeType__CG, "CG" },
	{ (long)dic__PackingCodeType__CH, "CH" },
	{ (long)dic__PackingCodeType__CI, "CI" },
	{ (long)dic__PackingCodeType__CJ, "CJ" },
	{ (long)dic__PackingCodeType__CK, "CK" },
	{ (long)dic__PackingCodeType__CL, "CL" },
	{ (long)dic__PackingCodeType__CM, "CM" },
	{ (long)dic__PackingCodeType__CN, "CN" },
	{ (long)dic__PackingCodeType__CO, "CO" },
	{ (long)dic__PackingCodeType__CP, "CP" },
	{ (long)dic__PackingCodeType__CQ, "CQ" },
	{ (long)dic__PackingCodeType__CR, "CR" },
	{ (long)dic__PackingCodeType__CS, "CS" },
	{ (long)dic__PackingCodeType__CT, "CT" },
	{ (long)dic__PackingCodeType__CU, "CU" },
	{ (long)dic__PackingCodeType__CV, "CV" },
	{ (long)dic__PackingCodeType__CW, "CW" },
	{ (long)dic__PackingCodeType__CX, "CX" },
	{ (long)dic__PackingCodeType__CY, "CY" },
	{ (long)dic__PackingCodeType__CZ, "CZ" },
	{ (long)dic__PackingCodeType__DA, "DA" },
	{ (long)dic__PackingCodeType__DB, "DB" },
	{ (long)dic__PackingCodeType__DC, "DC" },
	{ (long)dic__PackingCodeType__DG, "DG" },
	{ (long)dic__PackingCodeType__DH, "DH" },
	{ (long)dic__PackingCodeType__DI, "DI" },
	{ (long)dic__PackingCodeType__DJ, "DJ" },
	{ (long)dic__PackingCodeType__DK, "DK" },
	{ (long)dic__PackingCodeType__DL, "DL" },
	{ (long)dic__PackingCodeType__DM, "DM" },
	{ (long)dic__PackingCodeType__DN, "DN" },
	{ (long)dic__PackingCodeType__DP, "DP" },
	{ (long)dic__PackingCodeType__DR, "DR" },
	{ (long)dic__PackingCodeType__DS, "DS" },
	{ (long)dic__PackingCodeType__DT, "DT" },
	{ (long)dic__PackingCodeType__DU, "DU" },
	{ (long)dic__PackingCodeType__DV, "DV" },
	{ (long)dic__PackingCodeType__DW, "DW" },
	{ (long)dic__PackingCodeType__DX, "DX" },
	{ (long)dic__PackingCodeType__DY, "DY" },
	{ (long)dic__PackingCodeType__EC, "EC" },
	{ (long)dic__PackingCodeType__ED, "ED" },
	{ (long)dic__PackingCodeType__EE, "EE" },
	{ (long)dic__PackingCodeType__EF, "EF" },
	{ (long)dic__PackingCodeType__EG, "EG" },
	{ (long)dic__PackingCodeType__EH, "EH" },
	{ (long)dic__PackingCodeType__EI, "EI" },
	{ (long)dic__PackingCodeType__EN, "EN" },
	{ (long)dic__PackingCodeType__FC, "FC" },
	{ (long)dic__PackingCodeType__FD, "FD" },
	{ (long)dic__PackingCodeType__FE, "FE" },
	{ (long)dic__PackingCodeType__FI, "FI" },
	{ (long)dic__PackingCodeType__FL, "FL" },
	{ (long)dic__PackingCodeType__FO, "FO" },
	{ (long)dic__PackingCodeType__FP, "FP" },
	{ (long)dic__PackingCodeType__FR, "FR" },
	{ (long)dic__PackingCodeType__FT, "FT" },
	{ (long)dic__PackingCodeType__FX, "FX" },
	{ (long)dic__PackingCodeType__GB, "GB" },
	{ (long)dic__PackingCodeType__GI, "GI" },
	{ (long)dic__PackingCodeType__GL, "GL" },
	{ (long)dic__PackingCodeType__GR, "GR" },
	{ (long)dic__PackingCodeType__GY, "GY" },
	{ (long)dic__PackingCodeType__GZ, "GZ" },
	{ (long)dic__PackingCodeType__HA, "HA" },
	{ (long)dic__PackingCodeType__HB, "HB" },
	{ (long)dic__PackingCodeType__HC, "HC" },
	{ (long)dic__PackingCodeType__HG, "HG" },
	{ (long)dic__PackingCodeType__HN, "HN" },
	{ (long)dic__PackingCodeType__HR, "HR" },
	{ (long)dic__PackingCodeType__IA, "IA" },
	{ (long)dic__PackingCodeType__IB, "IB" },
	{ (long)dic__PackingCodeType__IC, "IC" },
	{ (long)dic__PackingCodeType__ID, "ID" },
	{ (long)dic__PackingCodeType__IE, "IE" },
	{ (long)dic__PackingCodeType__IF, "IF" },
	{ (long)dic__PackingCodeType__IG, "IG" },
	{ (long)dic__PackingCodeType__IH, "IH" },
	{ (long)dic__PackingCodeType__IK, "IK" },
	{ (long)dic__PackingCodeType__IN, "IN" },
	{ (long)dic__PackingCodeType__IZ, "IZ" },
	{ (long)dic__PackingCodeType__JB, "JB" },
	{ (long)dic__PackingCodeType__JC, "JC" },
	{ (long)dic__PackingCodeType__JG, "JG" },
	{ (long)dic__PackingCodeType__JR, "JR" },
	{ (long)dic__PackingCodeType__JT, "JT" },
	{ (long)dic__PackingCodeType__JY, "JY" },
	{ (long)dic__PackingCodeType__KG, "KG" },
	{ (long)dic__PackingCodeType__KI, "KI" },
	{ (long)dic__PackingCodeType__LE, "LE" },
	{ (long)dic__PackingCodeType__LG, "LG" },
	{ (long)dic__PackingCodeType__LT, "LT" },
	{ (long)dic__PackingCodeType__LU, "LU" },
	{ (long)dic__PackingCodeType__LV, "LV" },
	{ (long)dic__PackingCodeType__LZ, "LZ" },
	{ (long)dic__PackingCodeType__MA, "MA" },
	{ (long)dic__PackingCodeType__MB, "MB" },
	{ (long)dic__PackingCodeType__MC, "MC" },
	{ (long)dic__PackingCodeType__ME, "ME" },
	{ (long)dic__PackingCodeType__MR, "MR" },
	{ (long)dic__PackingCodeType__MS, "MS" },
	{ (long)dic__PackingCodeType__MT, "MT" },
	{ (long)dic__PackingCodeType__MW, "MW" },
	{ (long)dic__PackingCodeType__MX, "MX" },
	{ (long)dic__PackingCodeType__NA, "NA" },
	{ (long)dic__PackingCodeType__NE, "NE" },
	{ (long)dic__PackingCodeType__NF, "NF" },
	{ (long)dic__PackingCodeType__NG, "NG" },
	{ (long)dic__PackingCodeType__NS, "NS" },
	{ (long)dic__PackingCodeType__NT, "NT" },
	{ (long)dic__PackingCodeType__NU, "NU" },
	{ (long)dic__PackingCodeType__NV, "NV" },
	{ (long)dic__PackingCodeType__OT, "OT" },
	{ (long)dic__PackingCodeType__OU, "OU" },
	{ (long)dic__PackingCodeType__P2, "P2" },
	{ (long)dic__PackingCodeType__PA, "PA" },
	{ (long)dic__PackingCodeType__PB, "PB" },
	{ (long)dic__PackingCodeType__PC, "PC" },
	{ (long)dic__PackingCodeType__PD, "PD" },
	{ (long)dic__PackingCodeType__PE, "PE" },
	{ (long)dic__PackingCodeType__PF, "PF" },
	{ (long)dic__PackingCodeType__PG, "PG" },
	{ (long)dic__PackingCodeType__PH, "PH" },
	{ (long)dic__PackingCodeType__PI, "PI" },
	{ (long)dic__PackingCodeType__PJ, "PJ" },
	{ (long)dic__PackingCodeType__PK, "PK" },
	{ (long)dic__PackingCodeType__PL, "PL" },
	{ (long)dic__PackingCodeType__PN, "PN" },
	{ (long)dic__PackingCodeType__PO, "PO" },
	{ (long)dic__PackingCodeType__PP, "PP" },
	{ (long)dic__PackingCodeType__PR, "PR" },
	{ (long)dic__PackingCodeType__PT, "PT" },
	{ (long)dic__PackingCodeType__PU, "PU" },
	{ (long)dic__PackingCodeType__PV, "PV" },
	{ (long)dic__PackingCodeType__PX, "PX" },
	{ (long)dic__PackingCodeType__PY, "PY" },
	{ (long)dic__PackingCodeType__PZ, "PZ" },
	{ (long)dic__PackingCodeType__QA, "QA" },
	{ (long)dic__PackingCodeType__QB, "QB" },
	{ (long)dic__PackingCodeType__QC, "QC" },
	{ (long)dic__PackingCodeType__QD, "QD" },
	{ (long)dic__PackingCodeType__QF, "QF" },
	{ (long)dic__PackingCodeType__QG, "QG" },
	{ (long)dic__PackingCodeType__QH, "QH" },
	{ (long)dic__PackingCodeType__QJ, "QJ" },
	{ (long)dic__PackingCodeType__QK, "QK" },
	{ (long)dic__PackingCodeType__QL, "QL" },
	{ (long)dic__PackingCodeType__QM, "QM" },
	{ (long)dic__PackingCodeType__QN, "QN" },
	{ (long)dic__PackingCodeType__QP, "QP" },
	{ (long)dic__PackingCodeType__QQ, "QQ" },
	{ (long)dic__PackingCodeType__QR, "QR" },
	{ (long)dic__PackingCodeType__QS, "QS" },
	{ (long)dic__PackingCodeType__RD, "RD" },
	{ (long)dic__PackingCodeType__RG, "RG" },
	{ (long)dic__PackingCodeType__RJ, "RJ" },
	{ (long)dic__PackingCodeType__RK, "RK" },
	{ (long)dic__PackingCodeType__RL, "RL" },
	{ (long)dic__PackingCodeType__RO, "RO" },
	{ (long)dic__PackingCodeType__RT, "RT" },
	{ (long)dic__PackingCodeType__RZ, "RZ" },
	{ (long)dic__PackingCodeType__SA, "SA" },
	{ (long)dic__PackingCodeType__SB, "SB" },
	{ (long)dic__PackingCodeType__SC, "SC" },
	{ (long)dic__PackingCodeType__SD, "SD" },
	{ (long)dic__PackingCodeType__SE, "SE" },
	{ (long)dic__PackingCodeType__SH, "SH" },
	{ (long)dic__PackingCodeType__SI, "SI" },
	{ (long)dic__PackingCodeType__SK, "SK" },
	{ (long)dic__PackingCodeType__SL, "SL" },
	{ (long)dic__PackingCodeType__SM, "SM" },
	{ (long)dic__PackingCodeType__SO, "SO" },
	{ (long)dic__PackingCodeType__SP, "SP" },
	{ (long)dic__PackingCodeType__SS, "SS" },
	{ (long)dic__PackingCodeType__ST, "ST" },
	{ (long)dic__PackingCodeType__SU, "SU" },
	{ (long)dic__PackingCodeType__SV, "SV" },
	{ (long)dic__PackingCodeType__SW, "SW" },
	{ (long)dic__PackingCodeType__SX, "SX" },
	{ (long)dic__PackingCodeType__SY, "SY" },
	{ (long)dic__PackingCodeType__SZ, "SZ" },
	{ (long)dic__PackingCodeType__T1, "T1" },
	{ (long)dic__PackingCodeType__TB, "TB" },
	{ (long)dic__PackingCodeType__TC, "TC" },
	{ (long)dic__PackingCodeType__TD, "TD" },
	{ (long)dic__PackingCodeType__TE, "TE" },
	{ (long)dic__PackingCodeType__TG, "TG" },
	{ (long)dic__PackingCodeType__TI, "TI" },
	{ (long)dic__PackingCodeType__TK, "TK" },
	{ (long)dic__PackingCodeType__TL, "TL" },
	{ (long)dic__PackingCodeType__TN, "TN" },
	{ (long)dic__PackingCodeType__TO, "TO" },
	{ (long)dic__PackingCodeType__TR, "TR" },
	{ (long)dic__PackingCodeType__TS, "TS" },
	{ (long)dic__PackingCodeType__TT, "TT" },
	{ (long)dic__PackingCodeType__TU, "TU" },
	{ (long)dic__PackingCodeType__TV, "TV" },
	{ (long)dic__PackingCodeType__TW, "TW" },
	{ (long)dic__PackingCodeType__TY, "TY" },
	{ (long)dic__PackingCodeType__TZ, "TZ" },
	{ (long)dic__PackingCodeType__UC, "UC" },
	{ (long)dic__PackingCodeType__UN, "UN" },
	{ (long)dic__PackingCodeType__VA, "VA" },
	{ (long)dic__PackingCodeType__VG, "VG" },
	{ (long)dic__PackingCodeType__VI, "VI" },
	{ (long)dic__PackingCodeType__VK, "VK" },
	{ (long)dic__PackingCodeType__VL, "VL" },
	{ (long)dic__PackingCodeType__VO, "VO" },
	{ (long)dic__PackingCodeType__VP, "VP" },
	{ (long)dic__PackingCodeType__VQ, "VQ" },
	{ (long)dic__PackingCodeType__VR, "VR" },
	{ (long)dic__PackingCodeType__VS, "VS" },
	{ (long)dic__PackingCodeType__VY, "VY" },
	{ (long)dic__PackingCodeType__WA, "WA" },
	{ (long)dic__PackingCodeType__WB, "WB" },
	{ (long)dic__PackingCodeType__WC, "WC" },
	{ (long)dic__PackingCodeType__WD, "WD" },
	{ (long)dic__PackingCodeType__WF, "WF" },
	{ (long)dic__PackingCodeType__WG, "WG" },
	{ (long)dic__PackingCodeType__WH, "WH" },
	{ (long)dic__PackingCodeType__WJ, "WJ" },
	{ (long)dic__PackingCodeType__WK, "WK" },
	{ (long)dic__PackingCodeType__WL, "WL" },
	{ (long)dic__PackingCodeType__WM, "WM" },
	{ (long)dic__PackingCodeType__WN, "WN" },
	{ (long)dic__PackingCodeType__WP, "WP" },
	{ (long)dic__PackingCodeType__WQ, "WQ" },
	{ (long)dic__PackingCodeType__WR, "WR" },
	{ (long)dic__PackingCodeType__WS, "WS" },
	{ (long)dic__PackingCodeType__WT, "WT" },
	{ (long)dic__PackingCodeType__WU, "WU" },
	{ (long)dic__PackingCodeType__WV, "WV" },
	{ (long)dic__PackingCodeType__WW, "WW" },
	{ (long)dic__PackingCodeType__WX, "WX" },
	{ (long)dic__PackingCodeType__WY, "WY" },
	{ (long)dic__PackingCodeType__WZ, "WZ" },
	{ (long)dic__PackingCodeType__XA, "XA" },
	{ (long)dic__PackingCodeType__XB, "XB" },
	{ (long)dic__PackingCodeType__XC, "XC" },
	{ (long)dic__PackingCodeType__XD, "XD" },
	{ (long)dic__PackingCodeType__XF, "XF" },
	{ (long)dic__PackingCodeType__XG, "XG" },
	{ (long)dic__PackingCodeType__XH, "XH" },
	{ (long)dic__PackingCodeType__XJ, "XJ" },
	{ (long)dic__PackingCodeType__XK, "XK" },
	{ (long)dic__PackingCodeType__YA, "YA" },
	{ (long)dic__PackingCodeType__YB, "YB" },
	{ (long)dic__PackingCodeType__YC, "YC" },
	{ (long)dic__PackingCodeType__YD, "YD" },
	{ (long)dic__PackingCodeType__YF, "YF" },
	{ (long)dic__PackingCodeType__YH, "YH" },
	{ (long)dic__PackingCodeType__YJ, "YJ" },
	{ (long)dic__PackingCodeType__YK, "YK" },
	{ (long)dic__PackingCodeType__YL, "YL" },
	{ (long)dic__PackingCodeType__YM, "YM" },
	{ (long)dic__PackingCodeType__YN, "YN" },
	{ (long)dic__PackingCodeType__YP, "YP" },
	{ (long)dic__PackingCodeType__YQ, "YQ" },
	{ (long)dic__PackingCodeType__YR, "YR" },
	{ (long)dic__PackingCodeType__YS, "YS" },
	{ (long)dic__PackingCodeType__YT, "YT" },
	{ (long)dic__PackingCodeType__YV, "YV" },
	{ (long)dic__PackingCodeType__YW, "YW" },
	{ (long)dic__PackingCodeType__YX, "YX" },
	{ (long)dic__PackingCodeType__YY, "YY" },
	{ (long)dic__PackingCodeType__YZ, "YZ" },
	{ (long)dic__PackingCodeType__ZA, "ZA" },
	{ (long)dic__PackingCodeType__ZB, "ZB" },
	{ (long)dic__PackingCodeType__ZC, "ZC" },
	{ (long)dic__PackingCodeType__ZD, "ZD" },
	{ (long)dic__PackingCodeType__ZF, "ZF" },
	{ (long)dic__PackingCodeType__ZG, "ZG" },
	{ (long)dic__PackingCodeType__ZH, "ZH" },
	{ (long)dic__PackingCodeType__ZJ, "ZJ" },
	{ (long)dic__PackingCodeType__ZK, "ZK" },
	{ (long)dic__PackingCodeType__ZL, "ZL" },
	{ (long)dic__PackingCodeType__ZM, "ZM" },
	{ (long)dic__PackingCodeType__ZN, "ZN" },
	{ (long)dic__PackingCodeType__ZP, "ZP" },
	{ (long)dic__PackingCodeType__ZQ, "ZQ" },
	{ (long)dic__PackingCodeType__ZR, "ZR" },
	{ (long)dic__PackingCodeType__ZS, "ZS" },
	{ (long)dic__PackingCodeType__ZT, "ZT" },
	{ (long)dic__PackingCodeType__ZU, "ZU" },
	{ (long)dic__PackingCodeType__ZV, "ZV" },
	{ (long)dic__PackingCodeType__ZW, "ZW" },
	{ (long)dic__PackingCodeType__ZX, "ZX" },
	{ (long)dic__PackingCodeType__ZY, "ZY" },
	{ (long)dic__PackingCodeType__ZZ, "ZZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__PackingCodeType2s(struct soap *soap, enum dic__PackingCodeType n)
{
	const char *s = soap_code_str(soap_codes_dic__PackingCodeType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__PackingCodeType(struct soap *soap, const char *tag, int id, const enum dic__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__PackingCodeType), type) || soap_send(soap, soap_dic__PackingCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__PackingCodeType(struct soap *soap, const char *s, enum dic__PackingCodeType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__PackingCodeType, s);
	if(map)
		*a = (enum dic__PackingCodeType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 364)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__PackingCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__PackingCodeType * FASTCALL soap_in_dic__PackingCodeType(struct soap *soap, const char *tag, enum dic__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__PackingCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__PackingCodeType, sizeof(enum dic__PackingCodeType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__PackingCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__PackingCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__PackingCodeType, 0, sizeof(enum dic__PackingCodeType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__PackingCodeType(struct soap *soap, const enum dic__PackingCodeType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__PackingCodeType);
	return soap_out_dic__PackingCodeType(soap, tag?tag:"dic:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__PackingCodeType * SOAP_FMAC4 soap_get_dic__PackingCodeType(struct soap *soap, enum dic__PackingCodeType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dic__PackageLevelType(struct soap *soap, enum dic__PackageLevelType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dic__PackageLevelType
	*a = SOAP_DEFAULT_dic__PackageLevelType;
#else
	*a = (enum dic__PackageLevelType)0;
#endif
}

static const struct soap_code_map soap_codes_dic__PackageLevelType[] =
{	{ (long)dic__PackageLevelType__1, "1" },
	{ (long)dic__PackageLevelType__2, "2" },
	{ (long)dic__PackageLevelType__3, "3" },
	{ (long)dic__PackageLevelType__4, "4" },
	{ (long)dic__PackageLevelType__5, "5" },
	{ (long)dic__PackageLevelType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_dic__PackageLevelType2s(struct soap *soap, enum dic__PackageLevelType n)
{
	const char *s = soap_code_str(soap_codes_dic__PackageLevelType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__PackageLevelType(struct soap *soap, const char *tag, int id, const enum dic__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__PackageLevelType), type) || soap_send(soap, soap_dic__PackageLevelType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2dic__PackageLevelType(struct soap *soap, const char *s, enum dic__PackageLevelType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_dic__PackageLevelType, s);
	if(map)
		*a = (enum dic__PackageLevelType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum dic__PackageLevelType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum dic__PackageLevelType * FASTCALL soap_in_dic__PackageLevelType(struct soap *soap, const char *tag, enum dic__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum dic__PackageLevelType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dic__PackageLevelType, sizeof(enum dic__PackageLevelType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2dic__PackageLevelType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum dic__PackageLevelType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__PackageLevelType, 0, sizeof(enum dic__PackageLevelType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__PackageLevelType(struct soap *soap, const enum dic__PackageLevelType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__PackageLevelType);
	return soap_out_dic__PackageLevelType(soap, tag?tag:"dic:PackageLevelType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__PackageLevelType * SOAP_FMAC4 soap_get_dic__PackageLevelType(struct soap *soap, enum dic__PackageLevelType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__PackageLevelType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__ContentEncoding(struct soap *soap, enum app__ContentEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_app__ContentEncoding
	*a = SOAP_DEFAULT_app__ContentEncoding;
#else
	*a = (enum app__ContentEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_app__ContentEncoding[] =
{	{ (long)app__ContentEncoding__plain, "plain" },
	{ (long)app__ContentEncoding__gzip, "gzip" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_app__ContentEncoding2s(struct soap *soap, enum app__ContentEncoding n)
{
	const char *s = soap_code_str(soap_codes_app__ContentEncoding, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ContentEncoding(struct soap *soap, const char *tag, int id, const enum app__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ContentEncoding), type) || soap_send(soap, soap_app__ContentEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2app__ContentEncoding(struct soap *soap, const char *s, enum app__ContentEncoding *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_app__ContentEncoding, s);
	if(map)
		*a = (enum app__ContentEncoding)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum app__ContentEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum app__ContentEncoding * FASTCALL soap_in_app__ContentEncoding(struct soap *soap, const char *tag, enum app__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum app__ContentEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__ContentEncoding, sizeof(enum app__ContentEncoding), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2app__ContentEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum app__ContentEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ContentEncoding, 0, sizeof(enum app__ContentEncoding), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__ContentEncoding(struct soap *soap, const enum app__ContentEncoding *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__ContentEncoding);
	return soap_out_app__ContentEncoding(soap, tag?tag:"app:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ContentEncoding * SOAP_FMAC4 soap_get_app__ContentEncoding(struct soap *soap, enum app__ContentEncoding *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_app__ApplicationStatus
	*a = SOAP_DEFAULT_app__ApplicationStatus;
#else
	*a = (enum app__ApplicationStatus)0;
#endif
}

static const struct soap_code_map soap_codes_app__ApplicationStatus[] =
{	{ (long)app__ApplicationStatus__ACCEPTED, "ACCEPTED" },
	{ (long)app__ApplicationStatus__IN_USCOREPROCESS, "IN_PROCESS" },
	{ (long)app__ApplicationStatus__COMPLETED, "COMPLETED" },
	{ (long)app__ApplicationStatus__REJECTED, "REJECTED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_app__ApplicationStatus2s(struct soap *soap, enum app__ApplicationStatus n)
{
	const char *s = soap_code_str(soap_codes_app__ApplicationStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationStatus(struct soap *soap, const char *tag, int id, const enum app__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationStatus), type) || soap_send(soap, soap_app__ApplicationStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2app__ApplicationStatus(struct soap *soap, const char *s, enum app__ApplicationStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_app__ApplicationStatus, s);
	if(map)
		*a = (enum app__ApplicationStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum app__ApplicationStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum app__ApplicationStatus * FASTCALL soap_in_app__ApplicationStatus(struct soap *soap, const char *tag, enum app__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum app__ApplicationStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationStatus, sizeof(enum app__ApplicationStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2app__ApplicationStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum app__ApplicationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationStatus, 0, sizeof(enum app__ApplicationStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__ApplicationStatus(struct soap *soap, const enum app__ApplicationStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__ApplicationStatus);
	return soap_out_app__ApplicationStatus(soap, tag?tag:"app:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ApplicationStatus * SOAP_FMAC4 soap_get_app__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_base__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_base__RegisterModificationType
	*a = SOAP_DEFAULT_base__RegisterModificationType;
#else
	*a = (enum base__RegisterModificationType)0;
#endif
}

static const struct soap_code_map soap_codes_base__RegisterModificationType[] =
{	{ (long)base__RegisterModificationType__CREATE, "CREATE" },
	{ (long)base__RegisterModificationType__FIND_USCOREOR_USCORECREATE, "FIND_OR_CREATE" },
	{ (long)base__RegisterModificationType__UPDATE, "UPDATE" },
	{ (long)base__RegisterModificationType__DELETE, "DELETE" },
	{ (long)base__RegisterModificationType__MERGE, "MERGE" },
	{ (long)base__RegisterModificationType__ATTACH, "ATTACH" },
	{ (long)base__RegisterModificationType__SPLIT, "SPLIT" },
	{ (long)base__RegisterModificationType__FORK, "FORK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_base__RegisterModificationType2s(struct soap *soap, enum base__RegisterModificationType n)
{
	const char *s = soap_code_str(soap_codes_base__RegisterModificationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_base__RegisterModificationType(struct soap *soap, const char *tag, int id, const enum base__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__RegisterModificationType), type) || soap_send(soap, soap_base__RegisterModificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2base__RegisterModificationType(struct soap *soap, const char *s, enum base__RegisterModificationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_base__RegisterModificationType, s);
	if(map)
		*a = (enum base__RegisterModificationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum base__RegisterModificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum base__RegisterModificationType * FASTCALL soap_in_base__RegisterModificationType(struct soap *soap, const char *tag, enum base__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum base__RegisterModificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_base__RegisterModificationType, sizeof(enum base__RegisterModificationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2base__RegisterModificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum base__RegisterModificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__RegisterModificationType, 0, sizeof(enum base__RegisterModificationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__RegisterModificationType(struct soap *soap, const enum base__RegisterModificationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__RegisterModificationType);
	return soap_out_base__RegisterModificationType(soap, tag?tag:"base:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum base__RegisterModificationType * SOAP_FMAC4 soap_get_base__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *p, const char *tag, const char *type)
{
	if((p = soap_in_base__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _dic__BusinessEntity_activityLocation::soap_default(struct soap *soap)
{
	this->_dic__BusinessEntity_activityLocation::__sizeglobalID = 0;
	this->_dic__BusinessEntity_activityLocation::globalID = NULL;
	this->_dic__BusinessEntity_activityLocation::enterprise = NULL;
}

void _dic__BusinessEntity_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_dic__BusinessEntity_activityLocation::globalID) {
		for(int i = 0; i < this->_dic__BusinessEntity_activityLocation::__sizeglobalID; i++) {
			soap_serialize_dic__GLNType(soap, this->_dic__BusinessEntity_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerTodic__Enterprise(soap, &this->_dic__BusinessEntity_activityLocation::enterprise);
}

int _dic__BusinessEntity_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__dic__BusinessEntity_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__dic__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, const _dic__BusinessEntity_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__dic__BusinessEntity_activityLocation), type))
		return soap->error;
	if(a->_dic__BusinessEntity_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_dic__BusinessEntity_activityLocation::__sizeglobalID; i++)
			if(soap_out_dic__GLNType(soap, "dic:globalID", -1, a->_dic__BusinessEntity_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_dic__BusinessEntity_activityLocation::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "dic:enterprise", -1, &a->_dic__BusinessEntity_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_dic__BusinessEntity_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__dic__BusinessEntity_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _dic__BusinessEntity_activityLocation * FASTCALL soap_in__dic__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _dic__BusinessEntity_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_dic__BusinessEntity_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__dic__BusinessEntity_activityLocation, sizeof(_dic__BusinessEntity_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__dic__BusinessEntity_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_dic__BusinessEntity_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:globalID", 1, NULL)) {
				if(a->_dic__BusinessEntity_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_dic__BusinessEntity_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_dic__BusinessEntity_activityLocation::globalID == NULL)
						return NULL;
					*a->_dic__BusinessEntity_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_dic__GLNType(soap, "dic:globalID", a->_dic__BusinessEntity_activityLocation::globalID, "dic:GLNType"))
				{	a->_dic__BusinessEntity_activityLocation::__sizeglobalID++;
					a->_dic__BusinessEntity_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "dic:enterprise", &(a->_dic__BusinessEntity_activityLocation::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_dic__BusinessEntity_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_dic__BusinessEntity_activityLocation::__sizeglobalID)
			a->_dic__BusinessEntity_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_dic__BusinessEntity_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_dic__BusinessEntity_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__dic__BusinessEntity_activityLocation, 0, sizeof(_dic__BusinessEntity_activityLocation), 0, soap_copy__dic__BusinessEntity_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _dic__BusinessEntity_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__dic__BusinessEntity_activityLocation);
	return this->soap_out(soap, tag?tag:"dic:BusinessEntity-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_dic__BusinessEntity_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__dic__BusinessEntity_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _dic__BusinessEntity_activityLocation * SOAP_FMAC4 soap_get__dic__BusinessEntity_activityLocation(struct soap *soap, _dic__BusinessEntity_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__dic__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _dic__BusinessEntity_activityLocation * FASTCALL soap_instantiate__dic__BusinessEntity_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__dic__BusinessEntity_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__dic__BusinessEntity_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_dic__BusinessEntity_activityLocation);
		ASSIGN_PTR(size, sizeof(_dic__BusinessEntity_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_dic__BusinessEntity_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_dic__BusinessEntity_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_dic__BusinessEntity_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__dic__BusinessEntity_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _dic__BusinessEntity_activityLocation %p -> %p\n", q, p));
	*(_dic__BusinessEntity_activityLocation*)p = *(_dic__BusinessEntity_activityLocation*)q;
}

void _vd__BEActivityLocationsModificationOperation_activityLocation::soap_default(struct soap *soap)
{
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID = 0;
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise = NULL;
}

void _vd__BEActivityLocationsModificationOperation_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		for(int i = 0; i < this->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++) {
			soap_serialize_dic__GLNType(soap, this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerTodic__Enterprise(soap, &this->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise);
}

int _vd__BEActivityLocationsModificationOperation_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, const _vd__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation), type))
		return soap->error;
	if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++)
			if(soap_out_dic__GLNType(soap, "vd:globalID", -1, a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "vd:enterprise", -1, &a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_vd__BEActivityLocationsModificationOperation_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _vd__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_vd__BEActivityLocationsModificationOperation_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:globalID", 1, NULL)) {
				if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL)
						return NULL;
					*a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_dic__GLNType(soap, "vd:globalID", a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID, "dic:GLNType"))
				{	a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID++;
					a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "vd:enterprise", &(a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID)
			a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, 0, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), 0, soap_copy__vd__BEActivityLocationsModificationOperation_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _vd__BEActivityLocationsModificationOperation_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
	return this->soap_out(soap, tag?tag:"vd:BEActivityLocationsModificationOperation-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_vd__BEActivityLocationsModificationOperation_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__vd__BEActivityLocationsModificationOperation_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation * SOAP_FMAC4 soap_get__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _vd__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_vd__BEActivityLocationsModificationOperation_activityLocation);
		ASSIGN_PTR(size, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_vd__BEActivityLocationsModificationOperation_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_vd__BEActivityLocationsModificationOperation_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _vd__BEActivityLocationsModificationOperation_activityLocation %p -> %p\n", q, p));
	*(_vd__BEActivityLocationsModificationOperation_activityLocation*)p = *(_vd__BEActivityLocationsModificationOperation_activityLocation*)q;
}

SOAP_FMAC3 int FASTCALL soap_out_app__BinaryContent(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_app__BinaryContent);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_app__BinaryContent);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_app__BinaryContent(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BinaryContent, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__BinaryContent, 0, sizeof(xsd__base64Binary), 0, soap_copy_app__BinaryContent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__BinaryContent(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_app__BinaryContent);
	return soap_out_app__BinaryContent(soap, tag?tag:"app:BinaryContent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_app__BinaryContent(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BinaryContent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _ws__receiveApplicationResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ws__receiveApplicationResultResponse::app__application = NULL;
	/* transient soap skipped */
}

void _ws__receiveApplicationResultResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToapp__Application(soap, &this->_ws__receiveApplicationResultResponse::app__application);
	/* transient soap skipped */
}

int _ws__receiveApplicationResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__receiveApplicationResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, const _ws__receiveApplicationResultResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__receiveApplicationResultResponse), type))
		return soap->error;
	if(a->app__application)
		soap_element_result(soap, "app:application");
	if(a->_ws__receiveApplicationResultResponse::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__receiveApplicationResultResponse::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__receiveApplicationResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__receiveApplicationResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse * FASTCALL soap_in__ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ws__receiveApplicationResultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__receiveApplicationResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__receiveApplicationResultResponse, sizeof(_ws__receiveApplicationResultResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__receiveApplicationResultResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__receiveApplicationResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__receiveApplicationResultResponse::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "app:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__receiveApplicationResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__receiveApplicationResultResponse, 0, sizeof(_ws__receiveApplicationResultResponse), 0, soap_copy__ws__receiveApplicationResultResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__receiveApplicationResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__receiveApplicationResultResponse);
	return this->soap_out(soap, tag?tag:"ws:receiveApplicationResultResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__receiveApplicationResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__receiveApplicationResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse * SOAP_FMAC4 soap_get__ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__receiveApplicationResultResponse * FASTCALL soap_instantiate__ws__receiveApplicationResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__receiveApplicationResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__receiveApplicationResultResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultResponse);
		ASSIGN_PTR(size, sizeof(_ws__receiveApplicationResultResponse));
		((_ws__receiveApplicationResultResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__receiveApplicationResultResponse));
		for(int i = 0; i < n; i++)
			((_ws__receiveApplicationResultResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__receiveApplicationResultResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__receiveApplicationResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__receiveApplicationResultResponse %p -> %p\n", q, p));
	*(_ws__receiveApplicationResultResponse*)p = *(_ws__receiveApplicationResultResponse*)q;
}

void _ws__receiveApplicationResultRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_app__APIKey(soap, &this->_ws__receiveApplicationResultRequest::apiKey);
	soap_default_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::issuerId);
	soap_default_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

void _ws__receiveApplicationResultRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_app__APIKey(soap, &this->_ws__receiveApplicationResultRequest::apiKey);
	soap_serialize_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::issuerId);
	soap_serialize_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

int _ws__receiveApplicationResultRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__receiveApplicationResultRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, const _ws__receiveApplicationResultRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__receiveApplicationResultRequest), type))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::apiKey) {
		if(soap_out_app__APIKey(soap, "ws:apiKey", -1, &a->_ws__receiveApplicationResultRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:apiKey"))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::issuerId) {
		if(soap_out_base__UUID(soap, "ws:issuerId", -1, &a->_ws__receiveApplicationResultRequest::issuerId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:issuerId"))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::applicationId) {
		if(soap_out_base__UUID(soap, "ws:applicationId", -1, &a->_ws__receiveApplicationResultRequest::applicationId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:applicationId"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__receiveApplicationResultRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__receiveApplicationResultRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest * FASTCALL soap_in__ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ws__receiveApplicationResultRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__receiveApplicationResultRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__receiveApplicationResultRequest, sizeof(_ws__receiveApplicationResultRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__receiveApplicationResultRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__receiveApplicationResultRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_app__APIKey(soap, "ws:apiKey", &(a->_ws__receiveApplicationResultRequest::apiKey), "app:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ws:issuerId", &(a->_ws__receiveApplicationResultRequest::issuerId), "base:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ws:applicationId", &(a->_ws__receiveApplicationResultRequest::applicationId), "base:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__receiveApplicationResultRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__receiveApplicationResultRequest, 0, sizeof(_ws__receiveApplicationResultRequest), 0, soap_copy__ws__receiveApplicationResultRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_issuerId1 > 0 || soap_flag_applicationId1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__receiveApplicationResultRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__receiveApplicationResultRequest);
	return this->soap_out(soap, tag?tag:"ws:receiveApplicationResultRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__receiveApplicationResultRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__receiveApplicationResultRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest * SOAP_FMAC4 soap_get__ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__receiveApplicationResultRequest * FASTCALL soap_instantiate__ws__receiveApplicationResultRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__receiveApplicationResultRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__receiveApplicationResultRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultRequest);
		ASSIGN_PTR(size, sizeof(_ws__receiveApplicationResultRequest));
		((_ws__receiveApplicationResultRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__receiveApplicationResultRequest));
		for(int i = 0; i < n; i++)
			((_ws__receiveApplicationResultRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__receiveApplicationResultRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__receiveApplicationResultRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__receiveApplicationResultRequest %p -> %p\n", q, p));
	*(_ws__receiveApplicationResultRequest*)p = *(_ws__receiveApplicationResultRequest*)q;
}

void _ws__submitApplicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ws__submitApplicationResponse::app__application = NULL;
	/* transient soap skipped */
}

void _ws__submitApplicationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToapp__Application(soap, &this->_ws__submitApplicationResponse::app__application);
	/* transient soap skipped */
}

int _ws__submitApplicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__submitApplicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__submitApplicationResponse(struct soap *soap, const char *tag, int id, const _ws__submitApplicationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__submitApplicationResponse), type))
		return soap->error;
	if(a->app__application)
		soap_element_result(soap, "app:application");
	if(a->_ws__submitApplicationResponse::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__submitApplicationResponse::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__submitApplicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__submitApplicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse * FASTCALL soap_in__ws__submitApplicationResponse(struct soap *soap, const char *tag, _ws__submitApplicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__submitApplicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__submitApplicationResponse, sizeof(_ws__submitApplicationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__submitApplicationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__submitApplicationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__submitApplicationResponse::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "app:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__submitApplicationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__submitApplicationResponse, 0, sizeof(_ws__submitApplicationResponse), 0, soap_copy__ws__submitApplicationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__submitApplicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__submitApplicationResponse);
	return this->soap_out(soap, tag?tag:"ws:submitApplicationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__submitApplicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__submitApplicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse * SOAP_FMAC4 soap_get__ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__submitApplicationResponse * FASTCALL soap_instantiate__ws__submitApplicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__submitApplicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__submitApplicationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationResponse);
		ASSIGN_PTR(size, sizeof(_ws__submitApplicationResponse));
		((_ws__submitApplicationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__submitApplicationResponse));
		for(int i = 0; i < n; i++)
			((_ws__submitApplicationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__submitApplicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__submitApplicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__submitApplicationResponse %p -> %p\n", q, p));
	*(_ws__submitApplicationResponse*)p = *(_ws__submitApplicationResponse*)q;
}

void _ws__submitApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_app__APIKey(soap, &this->_ws__submitApplicationRequest::apiKey);
	this->_ws__submitApplicationRequest::app__application = NULL;
	/* transient soap skipped */
}

void _ws__submitApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_app__APIKey(soap, &this->_ws__submitApplicationRequest::apiKey);
	soap_serialize_PointerToapp__Application(soap, &this->_ws__submitApplicationRequest::app__application);
	/* transient soap skipped */
}

int _ws__submitApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__submitApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__submitApplicationRequest(struct soap *soap, const char *tag, int id, const _ws__submitApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__submitApplicationRequest), type))
		return soap->error;
	if(a->_ws__submitApplicationRequest::apiKey) {
		if(soap_out_app__APIKey(soap, "ws:apiKey", -1, &a->_ws__submitApplicationRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:apiKey"))
		return soap->error;
	if(a->_ws__submitApplicationRequest::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__submitApplicationRequest::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__submitApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__submitApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest * FASTCALL soap_in__ws__submitApplicationRequest(struct soap *soap, const char *tag, _ws__submitApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__submitApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__submitApplicationRequest, sizeof(_ws__submitApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__submitApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__submitApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_app__APIKey(soap, "ws:apiKey", &(a->_ws__submitApplicationRequest::apiKey), "app:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__submitApplicationRequest::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__submitApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__submitApplicationRequest, 0, sizeof(_ws__submitApplicationRequest), 0, soap_copy__ws__submitApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__submitApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__submitApplicationRequest);
	return this->soap_out(soap, tag?tag:"ws:submitApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__submitApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__submitApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest * SOAP_FMAC4 soap_get__ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__submitApplicationRequest * FASTCALL soap_instantiate__ws__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(_ws__submitApplicationRequest));
		((_ws__submitApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__submitApplicationRequest));
		for(int i = 0; i < n; i++)
			((_ws__submitApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__submitApplicationRequest %p -> %p\n", q, p));
	*(_ws__submitApplicationRequest*)p = *(_ws__submitApplicationRequest*)q;
}

void vd__Citizenship::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Citizenship::country = NULL;
	/* transient soap skipped */
}

void vd__Citizenship::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Country(soap, &this->vd__Citizenship::country);
	/* transient soap skipped */
}

int vd__Citizenship::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Citizenship(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Citizenship(struct soap *soap, const char *tag, int id, const vd__Citizenship *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Citizenship), type))
		return soap->error;
	if(soap_out_PointerTodic__Country(soap, "vd:country", -1, &(a->vd__Citizenship::country), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__Citizenship::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Citizenship(soap, tag, this, type);
}

SOAP_FMAC3 vd__Citizenship * FASTCALL soap_in_vd__Citizenship(struct soap *soap, const char *tag, vd__Citizenship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Citizenship *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Citizenship, sizeof(vd__Citizenship), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Citizenship) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Citizenship *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Country(soap, "vd:country", &(a->vd__Citizenship::country), "dic:Country"))
				{	soap_flag_country1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Citizenship *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Citizenship, 0, sizeof(vd__Citizenship), 0, soap_copy_vd__Citizenship);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Citizenship::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Citizenship);
	return this->soap_out(soap, tag?tag:"vd:Citizenship", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Citizenship::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Citizenship(soap, this, tag, type);
}

SOAP_FMAC3 vd__Citizenship * SOAP_FMAC4 soap_get_vd__Citizenship(struct soap *soap, vd__Citizenship *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Citizenship(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Citizenship * FASTCALL soap_instantiate_vd__Citizenship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Citizenship(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Citizenship, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Citizenship);
		ASSIGN_PTR(size, sizeof(vd__Citizenship));
		((vd__Citizenship*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Citizenship[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Citizenship));
		for(int i = 0; i < n; i++)
			((vd__Citizenship*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Citizenship*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Citizenship(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Citizenship %p -> %p\n", q, p));
	*(vd__Citizenship*)p = *(vd__Citizenship*)q;
}

void vd__WorkingArea::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__WorkingArea::__union_WorkingArea = 0;
	/* transient soap skipped */
}

void vd__WorkingArea::soap_serialize(struct soap *soap) const
{
	soap_serialize__vd__union_WorkingArea(soap, this->vd__WorkingArea::__union_WorkingArea, &this->vd__WorkingArea::union_WorkingArea);
	/* transient soap skipped */
}

int vd__WorkingArea::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__WorkingArea(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__WorkingArea(struct soap *soap, const char *tag, int id, const vd__WorkingArea *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__WorkingArea), type))
		return soap->error;
	if(soap_out__vd__union_WorkingArea(soap, a->vd__WorkingArea::__union_WorkingArea, &a->vd__WorkingArea::union_WorkingArea))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__WorkingArea::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__WorkingArea(soap, tag, this, type);
}

SOAP_FMAC3 vd__WorkingArea * FASTCALL soap_in_vd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__WorkingArea *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__WorkingArea, sizeof(vd__WorkingArea), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	a->soap_default(soap);
	if(!tag || *tag == '-' || (soap->body && !*soap->href)) {
	
		if(!soap_in__vd__union_WorkingArea(soap, &a->__union_WorkingArea, &a->union_WorkingArea))
			return NULL;
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__WorkingArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__WorkingArea, 0, sizeof(vd__WorkingArea), 0, soap_copy_vd__WorkingArea);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__WorkingArea::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__WorkingArea);
	return this->soap_out(soap, tag?tag:"vd:WorkingArea", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__WorkingArea::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__WorkingArea(soap, this, tag, type);
}

SOAP_FMAC3 vd__WorkingArea * SOAP_FMAC4 soap_get_vd__WorkingArea(struct soap *soap, vd__WorkingArea *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__WorkingArea * FASTCALL soap_instantiate_vd__WorkingArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__WorkingArea(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__WorkingArea, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingArea);
		ASSIGN_PTR(size, sizeof(vd__WorkingArea));
		((vd__WorkingArea*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingArea[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__WorkingArea));
		for(int i = 0; i < n; i++)
			((vd__WorkingArea*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__WorkingArea*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__WorkingArea(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__WorkingArea %p -> %p\n", q, p));
	*(vd__WorkingArea*)p = *(vd__WorkingArea*)q;
}

void vd__UserAuthority::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->vd__UserAuthority::ID);
	soap_default_base__String255(soap, &this->vd__UserAuthority::name);
	this->vd__UserAuthority::granted = NULL;
	/* transient soap skipped */
}

void vd__UserAuthority::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->vd__UserAuthority::ID);
	soap_serialize_base__String255(soap, &this->vd__UserAuthority::name);
	soap_serialize_PointerTobool(soap, &this->vd__UserAuthority::granted);
	/* transient soap skipped */
}

int vd__UserAuthority::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__UserAuthority(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__UserAuthority(struct soap *soap, const char *tag, int id, const vd__UserAuthority *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__UserAuthority), type))
		return soap->error;
	if(a->vd__UserAuthority::ID) {
		if(soap_out_xsd__NCName(soap, "vd:ID", -1, &a->vd__UserAuthority::ID, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:ID"))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__UserAuthority::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:granted", -1, &(a->vd__UserAuthority::granted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__UserAuthority::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__UserAuthority(soap, tag, this, type);
}

SOAP_FMAC3 vd__UserAuthority * FASTCALL soap_in_vd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__UserAuthority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__UserAuthority, sizeof(vd__UserAuthority), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__UserAuthority) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__UserAuthority *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_granted1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "vd:ID", &(a->vd__UserAuthority::ID), "xsd:NCName"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__UserAuthority::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_granted1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:granted", &(a->vd__UserAuthority::granted), "xsd:boolean"))
				{	soap_flag_granted1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__UserAuthority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__UserAuthority, 0, sizeof(vd__UserAuthority), 0, soap_copy_vd__UserAuthority);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__UserAuthority::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__UserAuthority);
	return this->soap_out(soap, tag?tag:"vd:UserAuthority", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__UserAuthority::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__UserAuthority(soap, this, tag, type);
}

SOAP_FMAC3 vd__UserAuthority * SOAP_FMAC4 soap_get_vd__UserAuthority(struct soap *soap, vd__UserAuthority *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__UserAuthority * FASTCALL soap_instantiate_vd__UserAuthority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__UserAuthority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__UserAuthority, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__UserAuthority);
		ASSIGN_PTR(size, sizeof(vd__UserAuthority));
		((vd__UserAuthority*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__UserAuthority[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__UserAuthority));
		for(int i = 0; i < n; i++)
			((vd__UserAuthority*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__UserAuthority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__UserAuthority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__UserAuthority %p -> %p\n", q, p));
	*(vd__UserAuthority*)p = *(vd__UserAuthority*)q;
}

void vd__WorkingAreaList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__WorkingAreaList::__sizeworkingArea = 0;
	this->vd__WorkingAreaList::workingArea = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__WorkingAreaList::soap_serialize(struct soap *soap) const
{
	if(this->vd__WorkingAreaList::workingArea) {
		for(int i = 0; i < this->vd__WorkingAreaList::__sizeworkingArea; i++) {
			soap_serialize_PointerTovd__WorkingArea(soap, this->vd__WorkingAreaList::workingArea + i);
		}
	}
	/* transient soap skipped */
}

int vd__WorkingAreaList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__WorkingAreaList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__WorkingAreaList(struct soap *soap, const char *tag, int id, const vd__WorkingAreaList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__WorkingAreaList), "vd:WorkingAreaList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__WorkingAreaList::workingArea) {
		int i;
		for(i = 0; i < a->vd__WorkingAreaList::__sizeworkingArea; i++)
			if(soap_out_PointerTovd__WorkingArea(soap, "vd:workingArea", -1, a->vd__WorkingAreaList::workingArea + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__WorkingAreaList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__WorkingAreaList(soap, tag, this, type);
}

SOAP_FMAC3 vd__WorkingAreaList * FASTCALL soap_in_vd__WorkingAreaList(struct soap *soap, const char *tag, vd__WorkingAreaList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__WorkingAreaList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__WorkingAreaList, sizeof(vd__WorkingAreaList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__WorkingAreaList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__WorkingAreaList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_workingArea1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:workingArea", 1, NULL)) {
				if(a->vd__WorkingAreaList::workingArea == NULL) {
					if(soap_blist_workingArea1 == NULL)
						soap_blist_workingArea1 = soap_new_block(soap);
					a->vd__WorkingAreaList::workingArea = (vd__WorkingArea **)soap_push_block(soap, soap_blist_workingArea1, sizeof(vd__WorkingArea *));
					if(a->vd__WorkingAreaList::workingArea == NULL)
						return NULL;
					*a->vd__WorkingAreaList::workingArea = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__WorkingArea(soap, "vd:workingArea", a->vd__WorkingAreaList::workingArea, "vd:WorkingArea"))
				{	a->vd__WorkingAreaList::__sizeworkingArea++;
					a->vd__WorkingAreaList::workingArea = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__WorkingAreaList::workingArea)
			soap_pop_block(soap, soap_blist_workingArea1);
		if(a->vd__WorkingAreaList::__sizeworkingArea)
			a->vd__WorkingAreaList::workingArea = (vd__WorkingArea **)soap_save_block(soap, soap_blist_workingArea1, NULL, 1);
		else
		{	a->vd__WorkingAreaList::workingArea = NULL;
			if(soap_blist_workingArea1)
				soap_end_block(soap, soap_blist_workingArea1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__WorkingAreaList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__WorkingAreaList, 0, sizeof(vd__WorkingAreaList), 0, soap_copy_vd__WorkingAreaList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__WorkingAreaList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__WorkingAreaList);
	return this->soap_out(soap, tag?tag:"vd:WorkingAreaList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__WorkingAreaList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__WorkingAreaList(soap, this, tag, type);
}

SOAP_FMAC3 vd__WorkingAreaList * SOAP_FMAC4 soap_get_vd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__WorkingAreaList * FASTCALL soap_instantiate_vd__WorkingAreaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__WorkingAreaList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__WorkingAreaList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList);
		ASSIGN_PTR(size, sizeof(vd__WorkingAreaList));
		((vd__WorkingAreaList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__WorkingAreaList));
		for(int i = 0; i < n; i++)
			((vd__WorkingAreaList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__WorkingAreaList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__WorkingAreaList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__WorkingAreaList %p -> %p\n", q, p));
	*(vd__WorkingAreaList*)p = *(vd__WorkingAreaList*)q;
}

void vd__AuthorityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__AuthorityList::__sizeauthority = 0;
	this->vd__AuthorityList::authority = NULL;
	/* transient soap skipped */
}

void vd__AuthorityList::soap_serialize(struct soap *soap) const
{
	if(this->vd__AuthorityList::authority) {
		for(int i = 0; i < this->vd__AuthorityList::__sizeauthority; i++) {
			soap_serialize_PointerTovd__UserAuthority(soap, this->vd__AuthorityList::authority + i);
		}
	}
	/* transient soap skipped */
}

int vd__AuthorityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__AuthorityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AuthorityList(struct soap *soap, const char *tag, int id, const vd__AuthorityList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AuthorityList), type))
		return soap->error;
	if(a->vd__AuthorityList::authority) {
		int i;
		for(i = 0; i < a->vd__AuthorityList::__sizeauthority; i++)
			if(soap_out_PointerTovd__UserAuthority(soap, "vd:authority", -1, a->vd__AuthorityList::authority + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__AuthorityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__AuthorityList(soap, tag, this, type);
}

SOAP_FMAC3 vd__AuthorityList * FASTCALL soap_in_vd__AuthorityList(struct soap *soap, const char *tag, vd__AuthorityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__AuthorityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AuthorityList, sizeof(vd__AuthorityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__AuthorityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__AuthorityList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_authority1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:authority", 1, NULL)) {
				if(a->vd__AuthorityList::authority == NULL) {
					if(soap_blist_authority1 == NULL)
						soap_blist_authority1 = soap_new_block(soap);
					a->vd__AuthorityList::authority = (vd__UserAuthority **)soap_push_block(soap, soap_blist_authority1, sizeof(vd__UserAuthority *));
					if(a->vd__AuthorityList::authority == NULL)
						return NULL;
					*a->vd__AuthorityList::authority = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__UserAuthority(soap, "vd:authority", a->vd__AuthorityList::authority, "vd:UserAuthority"))
				{	a->vd__AuthorityList::__sizeauthority++;
					a->vd__AuthorityList::authority = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__AuthorityList::authority)
			soap_pop_block(soap, soap_blist_authority1);
		if(a->vd__AuthorityList::__sizeauthority)
			a->vd__AuthorityList::authority = (vd__UserAuthority **)soap_save_block(soap, soap_blist_authority1, NULL, 1);
		else
		{	a->vd__AuthorityList::authority = NULL;
			if(soap_blist_authority1)
				soap_end_block(soap, soap_blist_authority1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__AuthorityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AuthorityList, 0, sizeof(vd__AuthorityList), 0, soap_copy_vd__AuthorityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__AuthorityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__AuthorityList);
	return this->soap_out(soap, tag?tag:"vd:AuthorityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__AuthorityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__AuthorityList(soap, this, tag, type);
}

SOAP_FMAC3 vd__AuthorityList * SOAP_FMAC4 soap_get_vd__AuthorityList(struct soap *soap, vd__AuthorityList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__AuthorityList * FASTCALL soap_instantiate_vd__AuthorityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__AuthorityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__AuthorityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__AuthorityList);
		ASSIGN_PTR(size, sizeof(vd__AuthorityList));
		((vd__AuthorityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__AuthorityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__AuthorityList));
		for(int i = 0; i < n; i++)
			((vd__AuthorityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__AuthorityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__AuthorityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__AuthorityList %p -> %p\n", q, p));
	*(vd__AuthorityList*)p = *(vd__AuthorityList*)q;
}

void vd__UserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__UserList::__sizeuser = 0;
	this->vd__UserList::user = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__UserList::soap_serialize(struct soap *soap) const
{
	if(this->vd__UserList::user) {
		for(int i = 0; i < this->vd__UserList::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->vd__UserList::user + i);
		}
	}
	/* transient soap skipped */
}

int vd__UserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__UserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__UserList(struct soap *soap, const char *tag, int id, const vd__UserList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__UserList), "vd:UserList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__UserList::user) {
		int i;
		for(i = 0; i < a->vd__UserList::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->vd__UserList::user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__UserList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__UserList(soap, tag, this, type);
}

SOAP_FMAC3 vd__UserList * FASTCALL soap_in_vd__UserList(struct soap *soap, const char *tag, vd__UserList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__UserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__UserList, sizeof(vd__UserList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__UserList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__UserList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->vd__UserList::user == NULL) {
					if(soap_blist_user1 == NULL)
						soap_blist_user1 = soap_new_block(soap);
					a->vd__UserList::user = (vd__User **)soap_push_block(soap, soap_blist_user1, sizeof(vd__User *));
					if(a->vd__UserList::user == NULL)
						return NULL;
					*a->vd__UserList::user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->vd__UserList::user, "vd:User"))
				{	a->vd__UserList::__sizeuser++;
					a->vd__UserList::user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__UserList::user)
			soap_pop_block(soap, soap_blist_user1);
		if(a->vd__UserList::__sizeuser)
			a->vd__UserList::user = (vd__User **)soap_save_block(soap, soap_blist_user1, NULL, 1);
		else
		{	a->vd__UserList::user = NULL;
			if(soap_blist_user1)
				soap_end_block(soap, soap_blist_user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__UserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__UserList, 0, sizeof(vd__UserList), 0, soap_copy_vd__UserList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__UserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__UserList);
	return this->soap_out(soap, tag?tag:"vd:UserList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__UserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__UserList(soap, this, tag, type);
}

SOAP_FMAC3 vd__UserList * SOAP_FMAC4 soap_get_vd__UserList(struct soap *soap, vd__UserList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__UserList * FASTCALL soap_instantiate_vd__UserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__UserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__UserList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__UserList);
		ASSIGN_PTR(size, sizeof(vd__UserList));
		((vd__UserList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__UserList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__UserList));
		for(int i = 0; i < n; i++)
			((vd__UserList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__UserList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__UserList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__UserList %p -> %p\n", q, p));
	*(vd__UserList*)p = *(vd__UserList*)q;
}

void vd__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->vd__User::login);
	soap_default_base__String255(soap, &this->vd__User::firstName);
	soap_default_base__String255(soap, &this->vd__User::middleName);
	soap_default_base__String255(soap, &this->vd__User::lastName);
	soap_default_base__String255(soap, &this->vd__User::fio);
	soap_default_xsd__date(soap, &this->vd__User::birthDate);
	this->vd__User::identity = NULL;
	this->vd__User::citizenship = NULL;
	this->vd__User::snils = NULL;
	soap_default_base__String255(soap, &this->vd__User::phone);
	soap_default_base__String255(soap, &this->vd__User::workPhone);
	soap_default_base__String255(soap, &this->vd__User::email);
	soap_default_base__String255(soap, &this->vd__User::workEmail);
	this->vd__User::__union_User = 0;
	soap_default_base__String255(soap, &this->vd__User::post);
	this->vd__User::enabled = NULL;
	this->vd__User::nonExpired = NULL;
	this->vd__User::nonLocked = NULL;
	this->vd__User::authorityList = NULL;
	this->vd__User::workingAreaList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__User::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->vd__User::login);
	soap_serialize_base__String255(soap, &this->vd__User::firstName);
	soap_serialize_base__String255(soap, &this->vd__User::middleName);
	soap_serialize_base__String255(soap, &this->vd__User::lastName);
	soap_serialize_base__String255(soap, &this->vd__User::fio);
	soap_serialize_xsd__date(soap, &this->vd__User::birthDate);
	soap_serialize_PointerTovd__Document(soap, &this->vd__User::identity);
	soap_serialize_PointerTovd__Citizenship(soap, &this->vd__User::citizenship);
	soap_serialize_PointerTovd__SNILSType(soap, &this->vd__User::snils);
	soap_serialize_base__String255(soap, &this->vd__User::phone);
	soap_serialize_base__String255(soap, &this->vd__User::workPhone);
	soap_serialize_base__String255(soap, &this->vd__User::email);
	soap_serialize_base__String255(soap, &this->vd__User::workEmail);
	soap_serialize__vd__union_User(soap, this->vd__User::__union_User, &this->vd__User::union_User);
	soap_serialize_base__String255(soap, &this->vd__User::post);
	soap_serialize_PointerTobool(soap, &this->vd__User::enabled);
	soap_serialize_PointerTobool(soap, &this->vd__User::nonExpired);
	soap_serialize_PointerTobool(soap, &this->vd__User::nonLocked);
	soap_serialize_PointerTovd__AuthorityList(soap, &this->vd__User::authorityList);
	soap_serialize_PointerTovd__WorkingAreaList(soap, &this->vd__User::workingAreaList);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__User(struct soap *soap, const char *tag, int id, const vd__User *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__User), "vd:User"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__NCName(soap, "vd:login", -1, &(a->vd__User::login), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:firstName", -1, &(a->vd__User::firstName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:middleName", -1, &(a->vd__User::middleName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:lastName", -1, &(a->vd__User::lastName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:fio", -1, &(a->vd__User::fio), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:birthDate", -1, &(a->vd__User::birthDate), ""))
		return soap->error;
	if(soap_out_PointerTovd__Document(soap, "vd:identity", -1, &(a->vd__User::identity), ""))
		return soap->error;
	if(soap_out_PointerTovd__Citizenship(soap, "vd:citizenship", -1, &(a->vd__User::citizenship), ""))
		return soap->error;
	if(soap_out_PointerTovd__SNILSType(soap, "vd:snils", -1, &(a->vd__User::snils), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:phone", -1, &(a->vd__User::phone), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:workPhone", -1, &(a->vd__User::workPhone), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:email", -1, &(a->vd__User::email), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:workEmail", -1, &(a->vd__User::workEmail), ""))
		return soap->error;
	if(soap_out__vd__union_User(soap, a->vd__User::__union_User, &a->vd__User::union_User))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:post", -1, &(a->vd__User::post), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:enabled", -1, &(a->vd__User::enabled), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:nonExpired", -1, &(a->vd__User::nonExpired), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:nonLocked", -1, &(a->vd__User::nonLocked), ""))
		return soap->error;
	if(soap_out_PointerTovd__AuthorityList(soap, "vd:authorityList", -1, &(a->vd__User::authorityList), ""))
		return soap->error;
	if(soap_out_PointerTovd__WorkingAreaList(soap, "vd:workingAreaList", -1, &(a->vd__User::workingAreaList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__User(soap, tag, this, type);
}

SOAP_FMAC3 vd__User * FASTCALL soap_in_vd__User(struct soap *soap, const char *tag, vd__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__User, sizeof(vd__User), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__User) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__User *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_middleName1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_birthDate1 = 1;
	size_t soap_flag_identity1 = 1;
	size_t soap_flag_citizenship1 = 1;
	size_t soap_flag_snils1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_workPhone1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_workEmail1 = 1;
	size_t soap_flag_union_User1 = 1;
	size_t soap_flag_post1 = 1;
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_nonExpired1 = 1;
	size_t soap_flag_nonLocked1 = 1;
	size_t soap_flag_authorityList1 = 1;
	size_t soap_flag_workingAreaList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "vd:login", &(a->vd__User::login), "xsd:NCName"))
				{	soap_flag_login1--;
					continue;
				}
			if(soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:firstName", &(a->vd__User::firstName), "base:String255"))
				{	soap_flag_firstName1--;
					continue;
				}
			if(soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:middleName", &(a->vd__User::middleName), "base:String255"))
				{	soap_flag_middleName1--;
					continue;
				}
			if(soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:lastName", &(a->vd__User::lastName), "base:String255"))
				{	soap_flag_lastName1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:fio", &(a->vd__User::fio), "base:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_birthDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:birthDate", &(a->vd__User::birthDate), "xsd:date"))
				{	soap_flag_birthDate1--;
					continue;
				}
			if(soap_flag_identity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Document(soap, "vd:identity", &(a->vd__User::identity), "vd:Document"))
				{	soap_flag_identity1--;
					continue;
				}
			if(soap_flag_citizenship1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Citizenship(soap, "vd:citizenship", &(a->vd__User::citizenship), "vd:Citizenship"))
				{	soap_flag_citizenship1--;
					continue;
				}
			if(soap_flag_snils1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__SNILSType(soap, "vd:snils", &(a->vd__User::snils), "vd:SNILSType"))
				{	soap_flag_snils1--;
					continue;
				}
			if(soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:phone", &(a->vd__User::phone), "base:String255"))
				{	soap_flag_phone1--;
					continue;
				}
			if(soap_flag_workPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:workPhone", &(a->vd__User::workPhone), "base:String255"))
				{	soap_flag_workPhone1--;
					continue;
				}
			if(soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:email", &(a->vd__User::email), "base:String255"))
				{	soap_flag_email1--;
					continue;
				}
			if(soap_flag_workEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:workEmail", &(a->vd__User::workEmail), "base:String255"))
				{	soap_flag_workEmail1--;
					continue;
				}
			if(soap_flag_union_User1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_User(soap, &a->vd__User::__union_User, &a->vd__User::union_User))
				{	soap_flag_union_User1 = 0;
					continue;
				}
			if(soap_flag_post1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:post", &(a->vd__User::post), "base:String255"))
				{	soap_flag_post1--;
					continue;
				}
			if(soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:enabled", &(a->vd__User::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if(soap_flag_nonExpired1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:nonExpired", &(a->vd__User::nonExpired), "xsd:boolean"))
				{	soap_flag_nonExpired1--;
					continue;
				}
			if(soap_flag_nonLocked1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:nonLocked", &(a->vd__User::nonLocked), "xsd:boolean"))
				{	soap_flag_nonLocked1--;
					continue;
				}
			if(soap_flag_authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AuthorityList(soap, "vd:authorityList", &(a->vd__User::authorityList), "vd:AuthorityList"))
				{	soap_flag_authorityList1--;
					continue;
				}
			if(soap_flag_workingAreaList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__WorkingAreaList(soap, "vd:workingAreaList", &(a->vd__User::workingAreaList), "vd:WorkingAreaList"))
				{	soap_flag_workingAreaList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__User, 0, sizeof(vd__User), 0, soap_copy_vd__User);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_User1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__User);
	return this->soap_out(soap, tag?tag:"vd:User", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__User(soap, this, tag, type);
}

SOAP_FMAC3 vd__User * SOAP_FMAC4 soap_get_vd__User(struct soap *soap, vd__User *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__User * FASTCALL soap_instantiate_vd__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__User, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__User);
		ASSIGN_PTR(size, sizeof(vd__User));
		((vd__User*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__User[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__User));
		for(int i = 0; i < n; i++)
			((vd__User*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__User %p -> %p\n", q, p));
	*(vd__User*)p = *(vd__User*)q;
}

void vd__ProcessingProcedure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__ProcessingProcedureType(soap, &this->vd__ProcessingProcedure::type);
	this->vd__ProcessingProcedure::startDateTime = NULL;
	this->vd__ProcessingProcedure::endDateTime = NULL;
	/* transient soap skipped */
}

void vd__ProcessingProcedure::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->vd__ProcessingProcedure::startDateTime);
	soap_serialize_PointerTotime(soap, &this->vd__ProcessingProcedure::endDateTime);
	/* transient soap skipped */
}

int vd__ProcessingProcedure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProcessingProcedure(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProcessingProcedure(struct soap *soap, const char *tag, int id, const vd__ProcessingProcedure *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProcessingProcedure), type))
		return soap->error;
	if(soap_out_vd__ProcessingProcedureType(soap, "vd:type", -1, &(a->vd__ProcessingProcedure::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:startDateTime", -1, &(a->vd__ProcessingProcedure::startDateTime), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:endDateTime", -1, &(a->vd__ProcessingProcedure::endDateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProcessingProcedure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProcessingProcedure(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProcessingProcedure * FASTCALL soap_in_vd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProcessingProcedure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProcessingProcedure, sizeof(vd__ProcessingProcedure), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProcessingProcedure) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProcessingProcedure *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_startDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__ProcessingProcedureType(soap, "vd:type", &(a->vd__ProcessingProcedure::type), "vd:ProcessingProcedureType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_startDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:startDateTime", &(a->vd__ProcessingProcedure::startDateTime), "xsd:dateTime"))
				{	soap_flag_startDateTime1--;
					continue;
				}
			if(soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:endDateTime", &(a->vd__ProcessingProcedure::endDateTime), "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProcessingProcedure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProcessingProcedure, 0, sizeof(vd__ProcessingProcedure), 0, soap_copy_vd__ProcessingProcedure);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ProcessingProcedure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProcessingProcedure);
	return this->soap_out(soap, tag?tag:"vd:ProcessingProcedure", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProcessingProcedure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProcessingProcedure(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProcessingProcedure * SOAP_FMAC4 soap_get_vd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProcessingProcedure * FASTCALL soap_instantiate_vd__ProcessingProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProcessingProcedure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProcessingProcedure, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProcessingProcedure);
		ASSIGN_PTR(size, sizeof(vd__ProcessingProcedure));
		((vd__ProcessingProcedure*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProcessingProcedure[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProcessingProcedure));
		for(int i = 0; i < n; i++)
			((vd__ProcessingProcedure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProcessingProcedure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProcessingProcedure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProcessingProcedure %p -> %p\n", q, p));
	*(vd__ProcessingProcedure*)p = *(vd__ProcessingProcedure*)q;
}

void vd__RouteSectionR13nRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RouteSectionR13nRules::sqnId = NULL;
	this->vd__RouteSectionR13nRules::__sizeappliedR13nRule = 0;
	this->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
	/* transient soap skipped */
}

void vd__RouteSectionR13nRules::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__SequenceNumber(soap, &this->vd__RouteSectionR13nRules::sqnId);
	if(this->vd__RouteSectionR13nRules::appliedR13nRule) {
		for(int i = 0; i < this->vd__RouteSectionR13nRules::__sizeappliedR13nRule; i++) {
			soap_serialize_PointerTodic__RegionalizationShippingRule(soap, this->vd__RouteSectionR13nRules::appliedR13nRule + i);
		}
	}
	/* transient soap skipped */
}

int vd__RouteSectionR13nRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RouteSectionR13nRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, const vd__RouteSectionR13nRules *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RouteSectionR13nRules), type))
		return soap->error;
	if(soap_out_PointerTobase__SequenceNumber(soap, "vd:sqnId", -1, &(a->vd__RouteSectionR13nRules::sqnId), ""))
		return soap->error;
	if(a->vd__RouteSectionR13nRules::appliedR13nRule) {
		int i;
		for(i = 0; i < a->vd__RouteSectionR13nRules::__sizeappliedR13nRule; i++)
			if(soap_out_PointerTodic__RegionalizationShippingRule(soap, "vd:appliedR13nRule", -1, a->vd__RouteSectionR13nRules::appliedR13nRule + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RouteSectionR13nRules::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RouteSectionR13nRules(soap, tag, this, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules * FASTCALL soap_in_vd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RouteSectionR13nRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RouteSectionR13nRules) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RouteSectionR13nRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sqnId1 = 1;
	struct soap_blist *soap_blist_appliedR13nRule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__SequenceNumber(soap, "vd:sqnId", &(a->vd__RouteSectionR13nRules::sqnId), "base:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:appliedR13nRule", 1, NULL)) {
				if(a->vd__RouteSectionR13nRules::appliedR13nRule == NULL) {
					if(soap_blist_appliedR13nRule1 == NULL)
						soap_blist_appliedR13nRule1 = soap_new_block(soap);
					a->vd__RouteSectionR13nRules::appliedR13nRule = (dic__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_appliedR13nRule1, sizeof(dic__RegionalizationShippingRule *));
					if(a->vd__RouteSectionR13nRules::appliedR13nRule == NULL)
						return NULL;
					*a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationShippingRule(soap, "vd:appliedR13nRule", a->vd__RouteSectionR13nRules::appliedR13nRule, "dic:RegionalizationShippingRule"))
				{	a->vd__RouteSectionR13nRules::__sizeappliedR13nRule++;
					a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__RouteSectionR13nRules::appliedR13nRule)
			soap_pop_block(soap, soap_blist_appliedR13nRule1);
		if(a->vd__RouteSectionR13nRules::__sizeappliedR13nRule)
			a->vd__RouteSectionR13nRules::appliedR13nRule = (dic__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_appliedR13nRule1, NULL, 1);
		else
		{	a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
			if(soap_blist_appliedR13nRule1)
				soap_end_block(soap, soap_blist_appliedR13nRule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RouteSectionR13nRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RouteSectionR13nRules, 0, sizeof(vd__RouteSectionR13nRules), 0, soap_copy_vd__RouteSectionR13nRules);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__RouteSectionR13nRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RouteSectionR13nRules);
	return this->soap_out(soap, tag?tag:"vd:RouteSectionR13nRules", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RouteSectionR13nRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RouteSectionR13nRules(soap, this, tag, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules * SOAP_FMAC4 soap_get_vd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RouteSectionR13nRules * FASTCALL soap_instantiate_vd__RouteSectionR13nRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RouteSectionR13nRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RouteSectionR13nRules, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RouteSectionR13nRules);
		ASSIGN_PTR(size, sizeof(vd__RouteSectionR13nRules));
		((vd__RouteSectionR13nRules*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RouteSectionR13nRules[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RouteSectionR13nRules));
		for(int i = 0; i < n; i++)
			((vd__RouteSectionR13nRules*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RouteSectionR13nRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RouteSectionR13nRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RouteSectionR13nRules %p -> %p\n", q, p));
	*(vd__RouteSectionR13nRules*)p = *(vd__RouteSectionR13nRules*)q;
}

void vd__RegionalizationClause::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RegionalizationClause::condition = NULL;
	soap_default_base__Text(soap, &this->vd__RegionalizationClause::text);
	/* transient soap skipped */
}

void vd__RegionalizationClause::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__RegionalizationCondition(soap, &this->vd__RegionalizationClause::condition);
	soap_serialize_base__Text(soap, &this->vd__RegionalizationClause::text);
	/* transient soap skipped */
}

int vd__RegionalizationClause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RegionalizationClause(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RegionalizationClause(struct soap *soap, const char *tag, int id, const vd__RegionalizationClause *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RegionalizationClause), type))
		return soap->error;
	if(a->vd__RegionalizationClause::condition) {
		if(soap_out_PointerTodic__RegionalizationCondition(soap, "vd:condition", -1, &a->vd__RegionalizationClause::condition, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:condition"))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:text", -1, &(a->vd__RegionalizationClause::text), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RegionalizationClause::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RegionalizationClause(soap, tag, this, type);
}

SOAP_FMAC3 vd__RegionalizationClause * FASTCALL soap_in_vd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RegionalizationClause *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RegionalizationClause, sizeof(vd__RegionalizationClause), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RegionalizationClause) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RegionalizationClause *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_text1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_condition1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__RegionalizationCondition(soap, "vd:condition", &(a->vd__RegionalizationClause::condition), "dic:RegionalizationCondition"))
				{	soap_flag_condition1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:text", &(a->vd__RegionalizationClause::text), "base:Text"))
				{	soap_flag_text1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RegionalizationClause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RegionalizationClause, 0, sizeof(vd__RegionalizationClause), 0, soap_copy_vd__RegionalizationClause);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_condition1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__RegionalizationClause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RegionalizationClause);
	return this->soap_out(soap, tag?tag:"vd:RegionalizationClause", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RegionalizationClause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RegionalizationClause(soap, this, tag, type);
}

SOAP_FMAC3 vd__RegionalizationClause * SOAP_FMAC4 soap_get_vd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RegionalizationClause * FASTCALL soap_instantiate_vd__RegionalizationClause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RegionalizationClause(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RegionalizationClause, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RegionalizationClause);
		ASSIGN_PTR(size, sizeof(vd__RegionalizationClause));
		((vd__RegionalizationClause*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RegionalizationClause[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RegionalizationClause));
		for(int i = 0; i < n; i++)
			((vd__RegionalizationClause*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RegionalizationClause*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RegionalizationClause(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RegionalizationClause %p -> %p\n", q, p));
	*(vd__RegionalizationClause*)p = *(vd__RegionalizationClause*)q;
}

void vd__VetDocumentStatusChange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__VetDocumentStatus(soap, &this->vd__VetDocumentStatusChange::status);
	this->vd__VetDocumentStatusChange::specifiedPerson = NULL;
	soap_default_time(soap, &this->vd__VetDocumentStatusChange::actualDateTime);
	soap_default_vd__VetDocumentStatusChangeReason(soap, &this->vd__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

void vd__VetDocumentStatusChange::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__VetDocumentStatusChange::status, SOAP_TYPE_vd__VetDocumentStatus);
	soap_serialize_PointerTovd__User(soap, &this->vd__VetDocumentStatusChange::specifiedPerson);
	soap_embedded(soap, &this->vd__VetDocumentStatusChange::actualDateTime, SOAP_TYPE_time);
	soap_serialize_vd__VetDocumentStatusChangeReason(soap, &this->vd__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

int vd__VetDocumentStatusChange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocumentStatusChange(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, const vd__VetDocumentStatusChange *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentStatusChange), type))
		return soap->error;
	if(soap_out_vd__VetDocumentStatus(soap, "vd:status", -1, &(a->vd__VetDocumentStatusChange::status), ""))
		return soap->error;
	if(a->vd__VetDocumentStatusChange::specifiedPerson) {
		if(soap_out_PointerTovd__User(soap, "vd:specifiedPerson", -1, &a->vd__VetDocumentStatusChange::specifiedPerson, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:specifiedPerson"))
		return soap->error;
	if(soap_out_time(soap, "vd:actualDateTime", -1, &(a->vd__VetDocumentStatusChange::actualDateTime), ""))
		return soap->error;
	if(soap_out_vd__VetDocumentStatusChangeReason(soap, "vd:reason", -1, &(a->vd__VetDocumentStatusChange::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocumentStatusChange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocumentStatusChange(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange * FASTCALL soap_in_vd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocumentStatusChange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocumentStatusChange) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocumentStatusChange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__VetDocumentStatus(soap, "vd:status", &(a->vd__VetDocumentStatusChange::status), "vd:VetDocumentStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:specifiedPerson", &(a->vd__VetDocumentStatusChange::specifiedPerson), "vd:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "vd:actualDateTime", &(a->vd__VetDocumentStatusChange::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__VetDocumentStatusChangeReason(soap, "vd:reason", &(a->vd__VetDocumentStatusChange::reason), "vd:VetDocumentStatusChangeReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocumentStatusChange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentStatusChange, 0, sizeof(vd__VetDocumentStatusChange), 0, soap_copy_vd__VetDocumentStatusChange);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0 || soap_flag_specifiedPerson1 > 0 || soap_flag_actualDateTime1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VetDocumentStatusChange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatusChange);
	return this->soap_out(soap, tag?tag:"vd:VetDocumentStatusChange", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocumentStatusChange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocumentStatusChange(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange * SOAP_FMAC4 soap_get_vd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocumentStatusChange * FASTCALL soap_instantiate_vd__VetDocumentStatusChange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocumentStatusChange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocumentStatusChange, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentStatusChange);
		ASSIGN_PTR(size, sizeof(vd__VetDocumentStatusChange));
		((vd__VetDocumentStatusChange*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentStatusChange[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocumentStatusChange));
		for(int i = 0; i < n; i++)
			((vd__VetDocumentStatusChange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocumentStatusChange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocumentStatusChange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocumentStatusChange %p -> %p\n", q, p));
	*(vd__VetDocumentStatusChange*)p = *(vd__VetDocumentStatusChange*)q;
}

void vd__StockEntryEventList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntryEventList::__sizelaboratoryResearch = 0;
	this->vd__StockEntryEventList::laboratoryResearch = NULL;
	this->vd__StockEntryEventList::__sizequarantine = 0;
	this->vd__StockEntryEventList::quarantine = NULL;
	this->vd__StockEntryEventList::__sizeimmunization = 0;
	this->vd__StockEntryEventList::immunization = NULL;
	this->vd__StockEntryEventList::__sizeveterinaryEvent = 0;
	this->vd__StockEntryEventList::veterinaryEvent = NULL;
	/* transient soap skipped */
}

void vd__StockEntryEventList::soap_serialize(struct soap *soap) const
{
	if(this->vd__StockEntryEventList::laboratoryResearch) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, this->vd__StockEntryEventList::laboratoryResearch + i);
		}
	}
	if(this->vd__StockEntryEventList::quarantine) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizequarantine; i++) {
			soap_serialize_PointerTovd__QuarantineEvent(soap, this->vd__StockEntryEventList::quarantine + i);
		}
	}
	if(this->vd__StockEntryEventList::immunization) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizeimmunization; i++) {
			soap_serialize_PointerTovd__AnimalMedicationEvent(soap, this->vd__StockEntryEventList::immunization + i);
		}
	}
	if(this->vd__StockEntryEventList::veterinaryEvent) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTovd__VeterinaryEvent(soap, this->vd__StockEntryEventList::veterinaryEvent + i);
		}
	}
	/* transient soap skipped */
}

int vd__StockEntryEventList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntryEventList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryEventList(struct soap *soap, const char *tag, int id, const vd__StockEntryEventList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryEventList), type))
		return soap->error;
	if(a->vd__StockEntryEventList::laboratoryResearch) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", -1, a->vd__StockEntryEventList::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::quarantine) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizequarantine; i++)
			if(soap_out_PointerTovd__QuarantineEvent(soap, "vd:quarantine", -1, a->vd__StockEntryEventList::quarantine + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::immunization) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizeimmunization; i++)
			if(soap_out_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", -1, a->vd__StockEntryEventList::immunization + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::veterinaryEvent) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", -1, a->vd__StockEntryEventList::veterinaryEvent + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntryEventList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntryEventList(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntryEventList * FASTCALL soap_in_vd__StockEntryEventList(struct soap *soap, const char *tag, vd__StockEntryEventList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntryEventList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryEventList, sizeof(vd__StockEntryEventList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntryEventList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntryEventList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	struct soap_blist *soap_blist_quarantine1 = NULL;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:laboratoryResearch", 1, NULL)) {
				if(a->vd__StockEntryEventList::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->vd__StockEntryEventList::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(vd__LaboratoryResearchEvent *));
					if(a->vd__StockEntryEventList::laboratoryResearch == NULL)
						return NULL;
					*a->vd__StockEntryEventList::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", a->vd__StockEntryEventList::laboratoryResearch, "vd:LaboratoryResearchEvent"))
				{	a->vd__StockEntryEventList::__sizelaboratoryResearch++;
					a->vd__StockEntryEventList::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:quarantine", 1, NULL)) {
				if(a->vd__StockEntryEventList::quarantine == NULL) {
					if(soap_blist_quarantine1 == NULL)
						soap_blist_quarantine1 = soap_new_block(soap);
					a->vd__StockEntryEventList::quarantine = (vd__QuarantineEvent **)soap_push_block(soap, soap_blist_quarantine1, sizeof(vd__QuarantineEvent *));
					if(a->vd__StockEntryEventList::quarantine == NULL)
						return NULL;
					*a->vd__StockEntryEventList::quarantine = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__QuarantineEvent(soap, "vd:quarantine", a->vd__StockEntryEventList::quarantine, "vd:QuarantineEvent"))
				{	a->vd__StockEntryEventList::__sizequarantine++;
					a->vd__StockEntryEventList::quarantine = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:immunization", 1, NULL)) {
				if(a->vd__StockEntryEventList::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->vd__StockEntryEventList::immunization = (vd__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(vd__AnimalMedicationEvent *));
					if(a->vd__StockEntryEventList::immunization == NULL)
						return NULL;
					*a->vd__StockEntryEventList::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", a->vd__StockEntryEventList::immunization, "vd:AnimalMedicationEvent"))
				{	a->vd__StockEntryEventList::__sizeimmunization++;
					a->vd__StockEntryEventList::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:veterinaryEvent", 1, NULL)) {
				if(a->vd__StockEntryEventList::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->vd__StockEntryEventList::veterinaryEvent = (vd__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(vd__VeterinaryEvent *));
					if(a->vd__StockEntryEventList::veterinaryEvent == NULL)
						return NULL;
					*a->vd__StockEntryEventList::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", a->vd__StockEntryEventList::veterinaryEvent, "vd:VeterinaryEvent"))
				{	a->vd__StockEntryEventList::__sizeveterinaryEvent++;
					a->vd__StockEntryEventList::veterinaryEvent = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntryEventList::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->vd__StockEntryEventList::__sizelaboratoryResearch)
			a->vd__StockEntryEventList::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->vd__StockEntryEventList::quarantine)
			soap_pop_block(soap, soap_blist_quarantine1);
		if(a->vd__StockEntryEventList::__sizequarantine)
			a->vd__StockEntryEventList::quarantine = (vd__QuarantineEvent **)soap_save_block(soap, soap_blist_quarantine1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::quarantine = NULL;
			if(soap_blist_quarantine1)
				soap_end_block(soap, soap_blist_quarantine1);
		}
		if(a->vd__StockEntryEventList::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->vd__StockEntryEventList::__sizeimmunization)
			a->vd__StockEntryEventList::immunization = (vd__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->vd__StockEntryEventList::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->vd__StockEntryEventList::__sizeveterinaryEvent)
			a->vd__StockEntryEventList::veterinaryEvent = (vd__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntryEventList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryEventList, 0, sizeof(vd__StockEntryEventList), 0, soap_copy_vd__StockEntryEventList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntryEventList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntryEventList);
	return this->soap_out(soap, tag?tag:"vd:StockEntryEventList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntryEventList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntryEventList(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntryEventList * SOAP_FMAC4 soap_get_vd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntryEventList * FASTCALL soap_instantiate_vd__StockEntryEventList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntryEventList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntryEventList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryEventList);
		ASSIGN_PTR(size, sizeof(vd__StockEntryEventList));
		((vd__StockEntryEventList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryEventList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntryEventList));
		for(int i = 0; i < n; i++)
			((vd__StockEntryEventList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntryEventList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntryEventList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntryEventList %p -> %p\n", q, p));
	*(vd__StockEntryEventList*)p = *(vd__StockEntryEventList*)q;
}

void vd__BatchOrigin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__BatchOrigin::productItem = NULL;
	this->vd__BatchOrigin::country = NULL;
	this->vd__BatchOrigin::__sizeproducer = 0;
	this->vd__BatchOrigin::producer = NULL;
	/* transient soap skipped */
}

void vd__BatchOrigin::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__ProductItem(soap, &this->vd__BatchOrigin::productItem);
	soap_serialize_PointerTodic__Country(soap, &this->vd__BatchOrigin::country);
	if(this->vd__BatchOrigin::producer) {
		for(int i = 0; i < this->vd__BatchOrigin::__sizeproducer; i++) {
			soap_serialize_PointerTodic__Producer(soap, this->vd__BatchOrigin::producer + i);
		}
	}
	/* transient soap skipped */
}

int vd__BatchOrigin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BatchOrigin(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BatchOrigin(struct soap *soap, const char *tag, int id, const vd__BatchOrigin *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BatchOrigin), type))
		return soap->error;
	if(soap_out_PointerTodic__ProductItem(soap, "vd:productItem", -1, &(a->vd__BatchOrigin::productItem), ""))
		return soap->error;
	if(soap_out_PointerTodic__Country(soap, "vd:country", -1, &(a->vd__BatchOrigin::country), ""))
		return soap->error;
	if(a->vd__BatchOrigin::producer) {
		int i;
		for(i = 0; i < a->vd__BatchOrigin::__sizeproducer; i++)
			if(soap_out_PointerTodic__Producer(soap, "vd:producer", -1, a->vd__BatchOrigin::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BatchOrigin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BatchOrigin(soap, tag, this, type);
}

SOAP_FMAC3 vd__BatchOrigin * FASTCALL soap_in_vd__BatchOrigin(struct soap *soap, const char *tag, vd__BatchOrigin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BatchOrigin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BatchOrigin, sizeof(vd__BatchOrigin), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BatchOrigin) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BatchOrigin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_country1 = 1;
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItem(soap, "vd:productItem", &(a->vd__BatchOrigin::productItem), "dic:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Country(soap, "vd:country", &(a->vd__BatchOrigin::country), "dic:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:producer", 1, NULL)) {
				if(a->vd__BatchOrigin::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->vd__BatchOrigin::producer = (dic__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(dic__Producer *));
					if(a->vd__BatchOrigin::producer == NULL)
						return NULL;
					*a->vd__BatchOrigin::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Producer(soap, "vd:producer", a->vd__BatchOrigin::producer, "dic:Producer"))
				{	a->vd__BatchOrigin::__sizeproducer++;
					a->vd__BatchOrigin::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__BatchOrigin::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->vd__BatchOrigin::__sizeproducer)
			a->vd__BatchOrigin::producer = (dic__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->vd__BatchOrigin::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BatchOrigin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BatchOrigin, 0, sizeof(vd__BatchOrigin), 0, soap_copy_vd__BatchOrigin);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__BatchOrigin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BatchOrigin);
	return this->soap_out(soap, tag?tag:"vd:BatchOrigin", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BatchOrigin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BatchOrigin(soap, this, tag, type);
}

SOAP_FMAC3 vd__BatchOrigin * SOAP_FMAC4 soap_get_vd__BatchOrigin(struct soap *soap, vd__BatchOrigin *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BatchOrigin * FASTCALL soap_instantiate_vd__BatchOrigin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BatchOrigin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BatchOrigin, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BatchOrigin);
		ASSIGN_PTR(size, sizeof(vd__BatchOrigin));
		((vd__BatchOrigin*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BatchOrigin[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BatchOrigin));
		for(int i = 0; i < n; i++)
			((vd__BatchOrigin*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BatchOrigin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BatchOrigin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BatchOrigin %p -> %p\n", q, p));
	*(vd__BatchOrigin*)p = *(vd__BatchOrigin*)q;
}

void vd__VeterinaryAuthentication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VeterinaryAuthentication::purpose = NULL;
	this->vd__VeterinaryAuthentication::cargoInspected = NULL;
	this->vd__VeterinaryAuthentication::cargoExpertized = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryAuthentication::locationProsperity);
	this->vd__VeterinaryAuthentication::animalSpentPeriod = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryAuthentication::monthsSpent);
	this->vd__VeterinaryAuthentication::__sizelaboratoryResearch = 0;
	this->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
	this->vd__VeterinaryAuthentication::quarantine = NULL;
	this->vd__VeterinaryAuthentication::__sizeimmunization = 0;
	this->vd__VeterinaryAuthentication::immunization = NULL;
	this->vd__VeterinaryAuthentication::__sizeveterinaryEvent = 0;
	this->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
	this->vd__VeterinaryAuthentication::__sizer13nClause = 0;
	this->vd__VeterinaryAuthentication::r13nClause = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

void vd__VeterinaryAuthentication::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Purpose(soap, &this->vd__VeterinaryAuthentication::purpose);
	soap_serialize_PointerTobool(soap, &this->vd__VeterinaryAuthentication::cargoInspected);
	soap_serialize_PointerTodic__ResearchResult(soap, &this->vd__VeterinaryAuthentication::cargoExpertized);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryAuthentication::locationProsperity);
	soap_serialize_PointerTovd__AnimalSpentPeriod(soap, &this->vd__VeterinaryAuthentication::animalSpentPeriod);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryAuthentication::monthsSpent);
	if(this->vd__VeterinaryAuthentication::laboratoryResearch) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, this->vd__VeterinaryAuthentication::laboratoryResearch + i);
		}
	}
	soap_serialize_PointerTovd__QuarantineEvent(soap, &this->vd__VeterinaryAuthentication::quarantine);
	if(this->vd__VeterinaryAuthentication::immunization) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizeimmunization; i++) {
			soap_serialize_PointerTovd__AnimalMedicationEvent(soap, this->vd__VeterinaryAuthentication::immunization + i);
		}
	}
	if(this->vd__VeterinaryAuthentication::veterinaryEvent) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTovd__VeterinaryEvent(soap, this->vd__VeterinaryAuthentication::veterinaryEvent + i);
		}
	}
	if(this->vd__VeterinaryAuthentication::r13nClause) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizer13nClause; i++) {
			soap_serialize_PointerTovd__RegionalizationClause(soap, this->vd__VeterinaryAuthentication::r13nClause + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

int vd__VeterinaryAuthentication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VeterinaryAuthentication(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, const vd__VeterinaryAuthentication *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryAuthentication), type))
		return soap->error;
	if(soap_out_PointerTodic__Purpose(soap, "vd:purpose", -1, &(a->vd__VeterinaryAuthentication::purpose), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:cargoInspected", -1, &(a->vd__VeterinaryAuthentication::cargoInspected), ""))
		return soap->error;
	if(soap_out_PointerTodic__ResearchResult(soap, "vd:cargoExpertized", -1, &(a->vd__VeterinaryAuthentication::cargoExpertized), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:locationProsperity", -1, &(a->vd__VeterinaryAuthentication::locationProsperity), ""))
		return soap->error;
	if(soap_out_PointerTovd__AnimalSpentPeriod(soap, "vd:animalSpentPeriod", -1, &(a->vd__VeterinaryAuthentication::animalSpentPeriod), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:monthsSpent", -1, &(a->vd__VeterinaryAuthentication::monthsSpent), ""))
		return soap->error;
	if(a->vd__VeterinaryAuthentication::laboratoryResearch) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", -1, a->vd__VeterinaryAuthentication::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__QuarantineEvent(soap, "vd:quarantine", -1, &(a->vd__VeterinaryAuthentication::quarantine), ""))
		return soap->error;
	if(a->vd__VeterinaryAuthentication::immunization) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizeimmunization; i++)
			if(soap_out_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", -1, a->vd__VeterinaryAuthentication::immunization + i, ""))
				return soap->error;
	}
	if(a->vd__VeterinaryAuthentication::veterinaryEvent) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", -1, a->vd__VeterinaryAuthentication::veterinaryEvent + i, ""))
				return soap->error;
	}
	if(a->vd__VeterinaryAuthentication::r13nClause) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizer13nClause; i++)
			if(soap_out_PointerTovd__RegionalizationClause(soap, "vd:r13nClause", -1, a->vd__VeterinaryAuthentication::r13nClause + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:specialMarks", -1, &(a->vd__VeterinaryAuthentication::specialMarks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VeterinaryAuthentication::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VeterinaryAuthentication(soap, tag, this, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication * FASTCALL soap_in_vd__VeterinaryAuthentication(struct soap *soap, const char *tag, vd__VeterinaryAuthentication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VeterinaryAuthentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryAuthentication, sizeof(vd__VeterinaryAuthentication), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VeterinaryAuthentication) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VeterinaryAuthentication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_purpose1 = 1;
	size_t soap_flag_cargoInspected1 = 1;
	size_t soap_flag_cargoExpertized1 = 1;
	size_t soap_flag_locationProsperity1 = 1;
	size_t soap_flag_animalSpentPeriod1 = 1;
	size_t soap_flag_monthsSpent1 = 1;
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	size_t soap_flag_quarantine1 = 1;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	struct soap_blist *soap_blist_r13nClause1 = NULL;
	size_t soap_flag_specialMarks1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Purpose(soap, "vd:purpose", &(a->vd__VeterinaryAuthentication::purpose), "dic:Purpose"))
				{	soap_flag_purpose1--;
					continue;
				}
			if(soap_flag_cargoInspected1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:cargoInspected", &(a->vd__VeterinaryAuthentication::cargoInspected), "xsd:boolean"))
				{	soap_flag_cargoInspected1--;
					continue;
				}
			if(soap_flag_cargoExpertized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ResearchResult(soap, "vd:cargoExpertized", &(a->vd__VeterinaryAuthentication::cargoExpertized), "dic:ResearchResult"))
				{	soap_flag_cargoExpertized1--;
					continue;
				}
			if(soap_flag_locationProsperity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:locationProsperity", &(a->vd__VeterinaryAuthentication::locationProsperity), "base:String255"))
				{	soap_flag_locationProsperity1--;
					continue;
				}
			if(soap_flag_animalSpentPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AnimalSpentPeriod(soap, "vd:animalSpentPeriod", &(a->vd__VeterinaryAuthentication::animalSpentPeriod), "vd:AnimalSpentPeriod"))
				{	soap_flag_animalSpentPeriod1--;
					continue;
				}
			if(soap_flag_monthsSpent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:monthsSpent", &(a->vd__VeterinaryAuthentication::monthsSpent), "base:String255"))
				{	soap_flag_monthsSpent1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:laboratoryResearch", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(vd__LaboratoryResearchEvent *));
					if(a->vd__VeterinaryAuthentication::laboratoryResearch == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", a->vd__VeterinaryAuthentication::laboratoryResearch, "vd:LaboratoryResearchEvent"))
				{	a->vd__VeterinaryAuthentication::__sizelaboratoryResearch++;
					a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap_flag_quarantine1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__QuarantineEvent(soap, "vd:quarantine", &(a->vd__VeterinaryAuthentication::quarantine), "vd:QuarantineEvent"))
				{	soap_flag_quarantine1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:immunization", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::immunization = (vd__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(vd__AnimalMedicationEvent *));
					if(a->vd__VeterinaryAuthentication::immunization == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", a->vd__VeterinaryAuthentication::immunization, "vd:AnimalMedicationEvent"))
				{	a->vd__VeterinaryAuthentication::__sizeimmunization++;
					a->vd__VeterinaryAuthentication::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:veterinaryEvent", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::veterinaryEvent = (vd__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(vd__VeterinaryEvent *));
					if(a->vd__VeterinaryAuthentication::veterinaryEvent == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", a->vd__VeterinaryAuthentication::veterinaryEvent, "vd:VeterinaryEvent"))
				{	a->vd__VeterinaryAuthentication::__sizeveterinaryEvent++;
					a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:r13nClause", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::r13nClause == NULL) {
					if(soap_blist_r13nClause1 == NULL)
						soap_blist_r13nClause1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::r13nClause = (vd__RegionalizationClause **)soap_push_block(soap, soap_blist_r13nClause1, sizeof(vd__RegionalizationClause *));
					if(a->vd__VeterinaryAuthentication::r13nClause == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::r13nClause = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RegionalizationClause(soap, "vd:r13nClause", a->vd__VeterinaryAuthentication::r13nClause, "vd:RegionalizationClause"))
				{	a->vd__VeterinaryAuthentication::__sizer13nClause++;
					a->vd__VeterinaryAuthentication::r13nClause = NULL;
					continue;
				}
			}
			if(soap_flag_specialMarks1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:specialMarks", &(a->vd__VeterinaryAuthentication::specialMarks), "base:Text"))
				{	soap_flag_specialMarks1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryAuthentication::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->vd__VeterinaryAuthentication::__sizelaboratoryResearch)
			a->vd__VeterinaryAuthentication::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->vd__VeterinaryAuthentication::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->vd__VeterinaryAuthentication::__sizeimmunization)
			a->vd__VeterinaryAuthentication::immunization = (vd__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->vd__VeterinaryAuthentication::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->vd__VeterinaryAuthentication::__sizeveterinaryEvent)
			a->vd__VeterinaryAuthentication::veterinaryEvent = (vd__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(a->vd__VeterinaryAuthentication::r13nClause)
			soap_pop_block(soap, soap_blist_r13nClause1);
		if(a->vd__VeterinaryAuthentication::__sizer13nClause)
			a->vd__VeterinaryAuthentication::r13nClause = (vd__RegionalizationClause **)soap_save_block(soap, soap_blist_r13nClause1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::r13nClause = NULL;
			if(soap_blist_r13nClause1)
				soap_end_block(soap, soap_blist_r13nClause1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VeterinaryAuthentication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryAuthentication, 0, sizeof(vd__VeterinaryAuthentication), 0, soap_copy_vd__VeterinaryAuthentication);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__VeterinaryAuthentication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryAuthentication);
	return this->soap_out(soap, tag?tag:"vd:VeterinaryAuthentication", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VeterinaryAuthentication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VeterinaryAuthentication(soap, this, tag, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication * SOAP_FMAC4 soap_get_vd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VeterinaryAuthentication * FASTCALL soap_instantiate_vd__VeterinaryAuthentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VeterinaryAuthentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VeterinaryAuthentication, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryAuthentication);
		ASSIGN_PTR(size, sizeof(vd__VeterinaryAuthentication));
		((vd__VeterinaryAuthentication*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryAuthentication[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VeterinaryAuthentication));
		for(int i = 0; i < n; i++)
			((vd__VeterinaryAuthentication*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VeterinaryAuthentication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VeterinaryAuthentication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VeterinaryAuthentication %p -> %p\n", q, p));
	*(vd__VeterinaryAuthentication*)p = *(vd__VeterinaryAuthentication*)q;
}

void vd__QuarantineEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->vd__QuarantineEvent::duration);
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__QuarantineEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__positiveInteger(soap, &this->vd__QuarantineEvent::duration);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__QuarantineEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__QuarantineEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__QuarantineEvent(struct soap *soap, const char *tag, int id, const vd__QuarantineEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__QuarantineEvent), "vd:QuarantineEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__positiveInteger(soap, "vd:duration", -1, &(a->vd__QuarantineEvent::duration), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__QuarantineEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__QuarantineEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__QuarantineEvent * FASTCALL soap_in_vd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__QuarantineEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__QuarantineEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__QuarantineEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_duration1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "dic:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_duration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__positiveInteger(soap, "vd:duration", &(a->vd__QuarantineEvent::duration), "xsd:positiveInteger"))
				{	soap_flag_duration1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__QuarantineEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__QuarantineEvent, 0, sizeof(vd__QuarantineEvent), 0, soap_copy_vd__QuarantineEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__QuarantineEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__QuarantineEvent);
	return this->soap_out(soap, tag?tag:"vd:QuarantineEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__QuarantineEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__QuarantineEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__QuarantineEvent * SOAP_FMAC4 soap_get_vd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__QuarantineEvent * FASTCALL soap_instantiate_vd__QuarantineEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__QuarantineEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__QuarantineEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent);
		ASSIGN_PTR(size, sizeof(vd__QuarantineEvent));
		((vd__QuarantineEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__QuarantineEvent));
		for(int i = 0; i < n; i++)
			((vd__QuarantineEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__QuarantineEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__QuarantineEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__QuarantineEvent %p -> %p\n", q, p));
	*(vd__QuarantineEvent*)p = *(vd__QuarantineEvent*)q;
}

void vd__AnimalMedicationEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__AnimalMedicationEvent::disease = NULL;
	this->vd__AnimalMedicationEvent::medicinalDrug = NULL;
	this->vd__AnimalMedicationEvent::effectiveBeforeDate = NULL;
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__AnimalMedicationEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__AnimalDisease(soap, &this->vd__AnimalMedicationEvent::disease);
	soap_serialize_PointerTodic__MedicinalDrug(soap, &this->vd__AnimalMedicationEvent::medicinalDrug);
	soap_serialize_PointerTotime(soap, &this->vd__AnimalMedicationEvent::effectiveBeforeDate);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__AnimalMedicationEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__AnimalMedicationEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, const vd__AnimalMedicationEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AnimalMedicationEvent), "vd:AnimalMedicationEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTodic__AnimalDisease(soap, "vd:disease", -1, &(a->vd__AnimalMedicationEvent::disease), ""))
		return soap->error;
	if(soap_out_PointerTodic__MedicinalDrug(soap, "vd:medicinalDrug", -1, &(a->vd__AnimalMedicationEvent::medicinalDrug), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:effectiveBeforeDate", -1, &(a->vd__AnimalMedicationEvent::effectiveBeforeDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__AnimalMedicationEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__AnimalMedicationEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent * FASTCALL soap_in_vd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__AnimalMedicationEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__AnimalMedicationEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__AnimalMedicationEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_disease1 = 1;
	size_t soap_flag_medicinalDrug1 = 1;
	size_t soap_flag_effectiveBeforeDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "dic:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__AnimalDisease(soap, "vd:disease", &(a->vd__AnimalMedicationEvent::disease), "dic:AnimalDisease"))
				{	soap_flag_disease1--;
					continue;
				}
			if(soap_flag_medicinalDrug1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__MedicinalDrug(soap, "vd:medicinalDrug", &(a->vd__AnimalMedicationEvent::medicinalDrug), "dic:MedicinalDrug"))
				{	soap_flag_medicinalDrug1--;
					continue;
				}
			if(soap_flag_effectiveBeforeDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:effectiveBeforeDate", &(a->vd__AnimalMedicationEvent::effectiveBeforeDate), "xsd:dateTime"))
				{	soap_flag_effectiveBeforeDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__AnimalMedicationEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AnimalMedicationEvent, 0, sizeof(vd__AnimalMedicationEvent), 0, soap_copy_vd__AnimalMedicationEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__AnimalMedicationEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__AnimalMedicationEvent);
	return this->soap_out(soap, tag?tag:"vd:AnimalMedicationEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__AnimalMedicationEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__AnimalMedicationEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent * SOAP_FMAC4 soap_get_vd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__AnimalMedicationEvent * FASTCALL soap_instantiate_vd__AnimalMedicationEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__AnimalMedicationEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__AnimalMedicationEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent);
		ASSIGN_PTR(size, sizeof(vd__AnimalMedicationEvent));
		((vd__AnimalMedicationEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__AnimalMedicationEvent));
		for(int i = 0; i < n; i++)
			((vd__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__AnimalMedicationEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__AnimalMedicationEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__AnimalMedicationEvent %p -> %p\n", q, p));
	*(vd__AnimalMedicationEvent*)p = *(vd__AnimalMedicationEvent*)q;
}

void vd__LaboratoryResearchEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__LaboratoryResearchEvent::__sizebatchID = 0;
	this->vd__LaboratoryResearchEvent::batchID = NULL;
	soap_default_base__String255(soap, &this->vd__LaboratoryResearchEvent::expertiseID);
	this->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_ = 0;
	this->vd__LaboratoryResearchEvent::method = NULL;
	this->vd__LaboratoryResearchEvent::result = NULL;
	soap_default_base__Text(soap, &this->vd__LaboratoryResearchEvent::conclusion);
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__LaboratoryResearchEvent::soap_serialize(struct soap *soap) const
{
	if(this->vd__LaboratoryResearchEvent::batchID) {
		for(int i = 0; i < this->vd__LaboratoryResearchEvent::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__LaboratoryResearchEvent::batchID + i);
		}
	}
	soap_serialize_base__String255(soap, &this->vd__LaboratoryResearchEvent::expertiseID);
	soap_serialize__vd__union_LaboratoryResearchEvent_(soap, this->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &this->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_);
	soap_serialize_PointerTodic__ResearchMethod(soap, &this->vd__LaboratoryResearchEvent::method);
	soap_serialize_PointerTodic__ResearchResult(soap, &this->vd__LaboratoryResearchEvent::result);
	soap_serialize_base__Text(soap, &this->vd__LaboratoryResearchEvent::conclusion);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__LaboratoryResearchEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__LaboratoryResearchEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, const vd__LaboratoryResearchEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__LaboratoryResearchEvent), "vd:LaboratoryResearchEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__LaboratoryResearchEvent::batchID) {
		int i;
		for(i = 0; i < a->vd__LaboratoryResearchEvent::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__LaboratoryResearchEvent::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_base__String255(soap, "vd:expertiseID", -1, &(a->vd__LaboratoryResearchEvent::expertiseID), ""))
		return soap->error;
	if(soap_out__vd__union_LaboratoryResearchEvent_(soap, a->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
		return soap->error;
	if(soap_out_PointerTodic__ResearchMethod(soap, "vd:method", -1, &(a->vd__LaboratoryResearchEvent::method), ""))
		return soap->error;
	if(soap_out_PointerTodic__ResearchResult(soap, "vd:result", -1, &(a->vd__LaboratoryResearchEvent::result), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:conclusion", -1, &(a->vd__LaboratoryResearchEvent::conclusion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__LaboratoryResearchEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__LaboratoryResearchEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent * FASTCALL soap_in_vd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__LaboratoryResearchEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__LaboratoryResearchEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__LaboratoryResearchEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_expertiseID1 = 1;
	size_t soap_flag_union_LaboratoryResearchEvent_1 = 1;
	size_t soap_flag_method1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_conclusion1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "dic:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__LaboratoryResearchEvent::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->vd__LaboratoryResearchEvent::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->vd__LaboratoryResearchEvent::batchID == NULL)
						return NULL;
					*a->vd__LaboratoryResearchEvent::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__LaboratoryResearchEvent::batchID, "base:Identifier"))
				{	a->vd__LaboratoryResearchEvent::__sizebatchID++;
					a->vd__LaboratoryResearchEvent::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_expertiseID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:expertiseID", &(a->vd__LaboratoryResearchEvent::expertiseID), "base:String255"))
				{	soap_flag_expertiseID1--;
					continue;
				}
			if(soap_flag_union_LaboratoryResearchEvent_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_LaboratoryResearchEvent_(soap, &a->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
				{	soap_flag_union_LaboratoryResearchEvent_1 = 0;
					continue;
				}
			if(soap_flag_method1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ResearchMethod(soap, "vd:method", &(a->vd__LaboratoryResearchEvent::method), "dic:ResearchMethod"))
				{	soap_flag_method1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ResearchResult(soap, "vd:result", &(a->vd__LaboratoryResearchEvent::result), "dic:ResearchResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_conclusion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:conclusion", &(a->vd__LaboratoryResearchEvent::conclusion), "base:Text"))
				{	soap_flag_conclusion1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(a->vd__LaboratoryResearchEvent::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->vd__LaboratoryResearchEvent::__sizebatchID)
			a->vd__LaboratoryResearchEvent::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->vd__LaboratoryResearchEvent::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__LaboratoryResearchEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__LaboratoryResearchEvent, 0, sizeof(vd__LaboratoryResearchEvent), 0, soap_copy_vd__LaboratoryResearchEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2 || soap_flag_union_LaboratoryResearchEvent_1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__LaboratoryResearchEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__LaboratoryResearchEvent);
	return this->soap_out(soap, tag?tag:"vd:LaboratoryResearchEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__LaboratoryResearchEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__LaboratoryResearchEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent * SOAP_FMAC4 soap_get_vd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__LaboratoryResearchEvent * FASTCALL soap_instantiate_vd__LaboratoryResearchEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__LaboratoryResearchEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__LaboratoryResearchEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent);
		ASSIGN_PTR(size, sizeof(vd__LaboratoryResearchEvent));
		((vd__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__LaboratoryResearchEvent));
		for(int i = 0; i < n; i++)
			((vd__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__LaboratoryResearchEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__LaboratoryResearchEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__LaboratoryResearchEvent %p -> %p\n", q, p));
	*(vd__LaboratoryResearchEvent*)p = *(vd__LaboratoryResearchEvent*)q;
}

void vd__VeterinaryEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__VeterinaryEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__VeterinaryEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VeterinaryEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryEvent(struct soap *soap, const char *tag, int id, const vd__VeterinaryEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryEvent), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VeterinaryEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VeterinaryEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__VeterinaryEvent * FASTCALL soap_in_vd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VeterinaryEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryEvent, sizeof(vd__VeterinaryEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VeterinaryEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VeterinaryEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_union_VeterinaryEvent1 = 1;
	size_t soap_flag_operator_1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	size_t soap_flag_notes1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent1 = 0;
					continue;
				}
			if(soap_flag_operator_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "dic:Organization"))
				{	soap_flag_operator_1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VeterinaryEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryEvent, 0, sizeof(vd__VeterinaryEvent), 0, soap_copy_vd__VeterinaryEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VeterinaryEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryEvent);
	return this->soap_out(soap, tag?tag:"vd:VeterinaryEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VeterinaryEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VeterinaryEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__VeterinaryEvent * SOAP_FMAC4 soap_get_vd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VeterinaryEvent * FASTCALL soap_instantiate_vd__VeterinaryEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VeterinaryEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VeterinaryEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:LaboratoryResearchEvent")) {
		cp->type = SOAP_TYPE_vd__LaboratoryResearchEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__LaboratoryResearchEvent));
			((vd__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__LaboratoryResearchEvent));
			for(int i = 0; i < n; i++)
				((vd__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__LaboratoryResearchEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:AnimalMedicationEvent")) {
		cp->type = SOAP_TYPE_vd__AnimalMedicationEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__AnimalMedicationEvent));
			((vd__AnimalMedicationEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__AnimalMedicationEvent));
			for(int i = 0; i < n; i++)
				((vd__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__AnimalMedicationEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:QuarantineEvent")) {
		cp->type = SOAP_TYPE_vd__QuarantineEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__QuarantineEvent));
			((vd__QuarantineEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__QuarantineEvent));
			for(int i = 0; i < n; i++)
				((vd__QuarantineEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__QuarantineEvent*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryEvent);
		ASSIGN_PTR(size, sizeof(vd__VeterinaryEvent));
		((vd__VeterinaryEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VeterinaryEvent));
		for(int i = 0; i < n; i++)
			((vd__VeterinaryEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VeterinaryEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VeterinaryEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VeterinaryEvent %p -> %p\n", q, p));
	*(vd__VeterinaryEvent*)p = *(vd__VeterinaryEvent*)q;
}

void vd__ReferencedDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dic__ReferenceType(soap, &this->vd__ReferencedDocument::relationshipType);
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__ReferencedDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerTodic__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__ReferencedDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ReferencedDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ReferencedDocument(struct soap *soap, const char *tag, int id, const vd__ReferencedDocument *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ReferencedDocument), "vd:ReferencedDocument"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_dic__ReferenceType(soap, "vd:relationshipType", -1, &(a->vd__ReferencedDocument::relationshipType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__ReferencedDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ReferencedDocument(soap, tag, this, type);
}

SOAP_FMAC3 vd__ReferencedDocument * FASTCALL soap_in_vd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ReferencedDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ReferencedDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ReferencedDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_relationshipType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__DocumentType(soap, "vd:type", &(a->vd__Document::type), "dic:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "dic:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_relationshipType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__ReferenceType(soap, "vd:relationshipType", &(a->vd__ReferencedDocument::relationshipType), "dic:ReferenceType"))
				{	soap_flag_relationshipType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ReferencedDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ReferencedDocument, 0, sizeof(vd__ReferencedDocument), 0, soap_copy_vd__ReferencedDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relationshipType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ReferencedDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ReferencedDocument);
	return this->soap_out(soap, tag?tag:"vd:ReferencedDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ReferencedDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ReferencedDocument(soap, this, tag, type);
}

SOAP_FMAC3 vd__ReferencedDocument * SOAP_FMAC4 soap_get_vd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ReferencedDocument * FASTCALL soap_instantiate_vd__ReferencedDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ReferencedDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ReferencedDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
		ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
		((vd__ReferencedDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
		for(int i = 0; i < n; i++)
			((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ReferencedDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ReferencedDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ReferencedDocument %p -> %p\n", q, p));
	*(vd__ReferencedDocument*)p = *(vd__ReferencedDocument*)q;
}

void vd__CertifiedConsignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__CertifiedConsignment::consignor = NULL;
	this->vd__CertifiedConsignment::consignee = NULL;
	this->vd__CertifiedConsignment::broker = NULL;
	this->vd__CertifiedConsignment::transportInfo = NULL;
	this->vd__CertifiedConsignment::transportStorageType = NULL;
	this->vd__CertifiedConsignment::shipmentRoute = NULL;
	this->vd__CertifiedConsignment::batch = NULL;
	/* transient soap skipped */
}

void vd__CertifiedConsignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__CertifiedConsignment::consignor);
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__CertifiedConsignment::consignee);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__CertifiedConsignment::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__CertifiedConsignment::transportInfo);
	soap_serialize_PointerTodic__TransportationStorageType(soap, &this->vd__CertifiedConsignment::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__CertifiedConsignment::shipmentRoute);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__CertifiedConsignment::batch);
	/* transient soap skipped */
}

int vd__CertifiedConsignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__CertifiedConsignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__CertifiedConsignment(struct soap *soap, const char *tag, int id, const vd__CertifiedConsignment *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__CertifiedConsignment), type))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignor", -1, &(a->vd__CertifiedConsignment::consignor), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignee", -1, &(a->vd__CertifiedConsignment::consignee), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:broker", -1, &(a->vd__CertifiedConsignment::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__CertifiedConsignment::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__CertifiedConsignment::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__CertifiedConsignment::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__CertifiedConsignment::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__CertifiedConsignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__CertifiedConsignment(soap, tag, this, type);
}

SOAP_FMAC3 vd__CertifiedConsignment * FASTCALL soap_in_vd__CertifiedConsignment(struct soap *soap, const char *tag, vd__CertifiedConsignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__CertifiedConsignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__CertifiedConsignment, sizeof(vd__CertifiedConsignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__CertifiedConsignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__CertifiedConsignment *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignor", &(a->vd__CertifiedConsignment::consignor), "dic:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignee", &(a->vd__CertifiedConsignment::consignee), "dic:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:broker", &(a->vd__CertifiedConsignment::broker), "dic:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__CertifiedConsignment::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__CertifiedConsignment::transportStorageType), "dic:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__CertifiedConsignment::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__CertifiedConsignment::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__CertifiedConsignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__CertifiedConsignment, 0, sizeof(vd__CertifiedConsignment), 0, soap_copy_vd__CertifiedConsignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__CertifiedConsignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__CertifiedConsignment);
	return this->soap_out(soap, tag?tag:"vd:CertifiedConsignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__CertifiedConsignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__CertifiedConsignment(soap, this, tag, type);
}

SOAP_FMAC3 vd__CertifiedConsignment * SOAP_FMAC4 soap_get_vd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__CertifiedConsignment * FASTCALL soap_instantiate_vd__CertifiedConsignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__CertifiedConsignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__CertifiedConsignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedConsignment);
		ASSIGN_PTR(size, sizeof(vd__CertifiedConsignment));
		((vd__CertifiedConsignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedConsignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__CertifiedConsignment));
		for(int i = 0; i < n; i++)
			((vd__CertifiedConsignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__CertifiedConsignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__CertifiedConsignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__CertifiedConsignment %p -> %p\n", q, p));
	*(vd__CertifiedConsignment*)p = *(vd__CertifiedConsignment*)q;
}

void vd__CertifiedBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__CertifiedBatch::producer = NULL;
	this->vd__CertifiedBatch::batch = NULL;
	/* transient soap skipped */
}

void vd__CertifiedBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__CertifiedBatch::producer);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__CertifiedBatch::batch);
	/* transient soap skipped */
}

int vd__CertifiedBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__CertifiedBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__CertifiedBatch(struct soap *soap, const char *tag, int id, const vd__CertifiedBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__CertifiedBatch), type))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:producer", -1, &(a->vd__CertifiedBatch::producer), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__CertifiedBatch::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__CertifiedBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__CertifiedBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__CertifiedBatch * FASTCALL soap_in_vd__CertifiedBatch(struct soap *soap, const char *tag, vd__CertifiedBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__CertifiedBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__CertifiedBatch, sizeof(vd__CertifiedBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__CertifiedBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__CertifiedBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:producer", &(a->vd__CertifiedBatch::producer), "dic:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__CertifiedBatch::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__CertifiedBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__CertifiedBatch, 0, sizeof(vd__CertifiedBatch), 0, soap_copy_vd__CertifiedBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__CertifiedBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__CertifiedBatch);
	return this->soap_out(soap, tag?tag:"vd:CertifiedBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__CertifiedBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__CertifiedBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__CertifiedBatch * SOAP_FMAC4 soap_get_vd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__CertifiedBatch * FASTCALL soap_instantiate_vd__CertifiedBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__CertifiedBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__CertifiedBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedBatch);
		ASSIGN_PTR(size, sizeof(vd__CertifiedBatch));
		((vd__CertifiedBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__CertifiedBatch));
		for(int i = 0; i < n; i++)
			((vd__CertifiedBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__CertifiedBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__CertifiedBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__CertifiedBatch %p -> %p\n", q, p));
	*(vd__CertifiedBatch*)p = *(vd__CertifiedBatch*)q;
}

void vd__ENTModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__ENTModificationOperation::type);
	this->vd__ENTModificationOperation::affectedList = NULL;
	this->vd__ENTModificationOperation::resultingList = NULL;
	soap_default_dic__ENTModificationReason(soap, &this->vd__ENTModificationOperation::reason);
	/* transient soap skipped */
}

void vd__ENTModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__ENTModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerTodic__EnterpriseList(soap, &this->vd__ENTModificationOperation::affectedList);
	soap_serialize_PointerTodic__EnterpriseList(soap, &this->vd__ENTModificationOperation::resultingList);
	soap_serialize_dic__ENTModificationReason(soap, &this->vd__ENTModificationOperation::reason);
	/* transient soap skipped */
}

int vd__ENTModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ENTModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ENTModificationOperation(struct soap *soap, const char *tag, int id, const vd__ENTModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ENTModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__ENTModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseList(soap, "vd:affectedList", -1, &(a->vd__ENTModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseList(soap, "vd:resultingList", -1, &(a->vd__ENTModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_dic__ENTModificationReason(soap, "vd:reason", -1, &(a->vd__ENTModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ENTModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ENTModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__ENTModificationOperation * FASTCALL soap_in_vd__ENTModificationOperation(struct soap *soap, const char *tag, vd__ENTModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ENTModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ENTModificationOperation, sizeof(vd__ENTModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ENTModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ENTModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__ENTModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseList(soap, "vd:affectedList", &(a->vd__ENTModificationOperation::affectedList), "dic:EnterpriseList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseList(soap, "vd:resultingList", &(a->vd__ENTModificationOperation::resultingList), "dic:EnterpriseList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__ENTModificationReason(soap, "vd:reason", &(a->vd__ENTModificationOperation::reason), "dic:ENTModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ENTModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ENTModificationOperation, 0, sizeof(vd__ENTModificationOperation), 0, soap_copy_vd__ENTModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ENTModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ENTModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:ENTModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ENTModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ENTModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__ENTModificationOperation * SOAP_FMAC4 soap_get_vd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ENTModificationOperation * FASTCALL soap_instantiate_vd__ENTModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ENTModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ENTModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ENTModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__ENTModificationOperation));
		((vd__ENTModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ENTModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ENTModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__ENTModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ENTModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ENTModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ENTModificationOperation %p -> %p\n", q, p));
	*(vd__ENTModificationOperation*)p = *(vd__ENTModificationOperation*)q;
}

void vd__BEActivityLocationsModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__BEActivityLocationsModificationOperation::type);
	this->vd__BEActivityLocationsModificationOperation::businessEntity = NULL;
	this->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation = 0;
	this->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
	/* transient soap skipped */
}

void vd__BEActivityLocationsModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__BEActivityLocationsModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__BEActivityLocationsModificationOperation::businessEntity);
	if(this->vd__BEActivityLocationsModificationOperation::activityLocation) {
		for(int i = 0; i < this->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->vd__BEActivityLocationsModificationOperation::activityLocation + i, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
			this->vd__BEActivityLocationsModificationOperation::activityLocation[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int vd__BEActivityLocationsModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BEActivityLocationsModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, const vd__BEActivityLocationsModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__BEActivityLocationsModificationOperation::type), ""))
		return soap->error;
	if(a->vd__BEActivityLocationsModificationOperation::businessEntity) {
		if(soap_out_PointerTodic__BusinessEntity(soap, "vd:businessEntity", -1, &a->vd__BEActivityLocationsModificationOperation::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:businessEntity"))
		return soap->error;
	if(a->vd__BEActivityLocationsModificationOperation::activityLocation) {
		int i;
		for(i = 0; i < a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++)
			if(a->vd__BEActivityLocationsModificationOperation::activityLocation[i].soap_out(soap, "vd:activityLocation", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BEActivityLocationsModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BEActivityLocationsModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation * FASTCALL soap_in_vd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, vd__BEActivityLocationsModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BEActivityLocationsModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, sizeof(vd__BEActivityLocationsModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BEActivityLocationsModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BEActivityLocationsModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__BEActivityLocationsModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:businessEntity", &(a->vd__BEActivityLocationsModificationOperation::businessEntity), "dic:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:activityLocation", 1, NULL)) {
				if(a->vd__BEActivityLocationsModificationOperation::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->vd__BEActivityLocationsModificationOperation::activityLocation = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
					if(a->vd__BEActivityLocationsModificationOperation::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->vd__BEActivityLocationsModificationOperation::activityLocation, _vd__BEActivityLocationsModificationOperation_activityLocation);
					a->vd__BEActivityLocationsModificationOperation::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, "vd:activityLocation", a->vd__BEActivityLocationsModificationOperation::activityLocation, ""))
				{	a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation++;
					a->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__BEActivityLocationsModificationOperation::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation)
			a->vd__BEActivityLocationsModificationOperation::activityLocation = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BEActivityLocationsModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, 0, sizeof(vd__BEActivityLocationsModificationOperation), 0, soap_copy_vd__BEActivityLocationsModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_businessEntity1 > 0 || a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__BEActivityLocationsModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BEActivityLocationsModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:BEActivityLocationsModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BEActivityLocationsModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BEActivityLocationsModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation * SOAP_FMAC4 soap_get_vd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BEActivityLocationsModificationOperation * FASTCALL soap_instantiate_vd__BEActivityLocationsModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BEActivityLocationsModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BEActivityLocationsModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__BEActivityLocationsModificationOperation));
		((vd__BEActivityLocationsModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BEActivityLocationsModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BEActivityLocationsModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__BEActivityLocationsModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BEActivityLocationsModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BEActivityLocationsModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BEActivityLocationsModificationOperation %p -> %p\n", q, p));
	*(vd__BEActivityLocationsModificationOperation*)p = *(vd__BEActivityLocationsModificationOperation*)q;
}

void vd__BEModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__BEModificationOperation::type);
	this->vd__BEModificationOperation::affectedList = NULL;
	this->vd__BEModificationOperation::resultingList = NULL;
	soap_default_dic__BEModificationReason(soap, &this->vd__BEModificationOperation::reason);
	/* transient soap skipped */
}

void vd__BEModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__BEModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerTodic__BusinessEntityList(soap, &this->vd__BEModificationOperation::affectedList);
	soap_serialize_PointerTodic__BusinessEntityList(soap, &this->vd__BEModificationOperation::resultingList);
	soap_serialize_dic__BEModificationReason(soap, &this->vd__BEModificationOperation::reason);
	/* transient soap skipped */
}

int vd__BEModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BEModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BEModificationOperation(struct soap *soap, const char *tag, int id, const vd__BEModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BEModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__BEModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntityList(soap, "vd:affectedList", -1, &(a->vd__BEModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntityList(soap, "vd:resultingList", -1, &(a->vd__BEModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_dic__BEModificationReason(soap, "vd:reason", -1, &(a->vd__BEModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BEModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BEModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__BEModificationOperation * FASTCALL soap_in_vd__BEModificationOperation(struct soap *soap, const char *tag, vd__BEModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BEModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BEModificationOperation, sizeof(vd__BEModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BEModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BEModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__BEModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntityList(soap, "vd:affectedList", &(a->vd__BEModificationOperation::affectedList), "dic:BusinessEntityList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntityList(soap, "vd:resultingList", &(a->vd__BEModificationOperation::resultingList), "dic:BusinessEntityList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__BEModificationReason(soap, "vd:reason", &(a->vd__BEModificationOperation::reason), "dic:BEModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BEModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BEModificationOperation, 0, sizeof(vd__BEModificationOperation), 0, soap_copy_vd__BEModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__BEModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BEModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:BEModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BEModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BEModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__BEModificationOperation * SOAP_FMAC4 soap_get_vd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BEModificationOperation * FASTCALL soap_instantiate_vd__BEModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BEModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BEModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BEModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__BEModificationOperation));
		((vd__BEModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BEModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BEModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__BEModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BEModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BEModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BEModificationOperation %p -> %p\n", q, p));
	*(vd__BEModificationOperation*)p = *(vd__BEModificationOperation*)q;
}

void vd__PSLModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__PSLModificationOperation::type);
	this->vd__PSLModificationOperation::affectedList = NULL;
	this->vd__PSLModificationOperation::resultingList = NULL;
	/* transient soap skipped */
}

void vd__PSLModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__PSLModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerTodic__ProductItemList(soap, &this->vd__PSLModificationOperation::affectedList);
	soap_serialize_PointerTodic__ProductItemList(soap, &this->vd__PSLModificationOperation::resultingList);
	/* transient soap skipped */
}

int vd__PSLModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__PSLModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__PSLModificationOperation(struct soap *soap, const char *tag, int id, const vd__PSLModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__PSLModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__PSLModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductItemList(soap, "vd:affectedList", -1, &(a->vd__PSLModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductItemList(soap, "vd:resultingList", -1, &(a->vd__PSLModificationOperation::resultingList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__PSLModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__PSLModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__PSLModificationOperation * FASTCALL soap_in_vd__PSLModificationOperation(struct soap *soap, const char *tag, vd__PSLModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__PSLModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__PSLModificationOperation, sizeof(vd__PSLModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__PSLModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__PSLModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__PSLModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItemList(soap, "vd:affectedList", &(a->vd__PSLModificationOperation::affectedList), "dic:ProductItemList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItemList(soap, "vd:resultingList", &(a->vd__PSLModificationOperation::resultingList), "dic:ProductItemList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__PSLModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__PSLModificationOperation, 0, sizeof(vd__PSLModificationOperation), 0, soap_copy_vd__PSLModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__PSLModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__PSLModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:PSLModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__PSLModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__PSLModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__PSLModificationOperation * SOAP_FMAC4 soap_get_vd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__PSLModificationOperation * FASTCALL soap_instantiate_vd__PSLModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__PSLModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__PSLModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__PSLModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__PSLModificationOperation));
		((vd__PSLModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__PSLModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__PSLModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__PSLModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__PSLModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__PSLModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__PSLModificationOperation %p -> %p\n", q, p));
	*(vd__PSLModificationOperation*)p = *(vd__PSLModificationOperation*)q;
}

void vd__MergeStockEntriesOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__MergeStockEntriesOperation::type = NULL;
	this->vd__MergeStockEntriesOperation::__sizesourceStockEntry = 0;
	this->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
	this->vd__MergeStockEntriesOperation::__sizeresultStockEntry = 0;
	this->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
	/* transient soap skipped */
}

void vd__MergeStockEntriesOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__RegisterModificationType(soap, &this->vd__MergeStockEntriesOperation::type);
	if(this->vd__MergeStockEntriesOperation::sourceStockEntry) {
		for(int i = 0; i < this->vd__MergeStockEntriesOperation::__sizesourceStockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__MergeStockEntriesOperation::sourceStockEntry + i);
		}
	}
	if(this->vd__MergeStockEntriesOperation::resultStockEntry) {
		for(int i = 0; i < this->vd__MergeStockEntriesOperation::__sizeresultStockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__MergeStockEntriesOperation::resultStockEntry + i);
		}
	}
	/* transient soap skipped */
}

int vd__MergeStockEntriesOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__MergeStockEntriesOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, const vd__MergeStockEntriesOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__MergeStockEntriesOperation), type))
		return soap->error;
	if(soap_out_PointerTobase__RegisterModificationType(soap, "vd:type", -1, &(a->vd__MergeStockEntriesOperation::type), ""))
		return soap->error;
	if(a->vd__MergeStockEntriesOperation::sourceStockEntry) {
		int i;
		for(i = 0; i < a->vd__MergeStockEntriesOperation::__sizesourceStockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, a->vd__MergeStockEntriesOperation::sourceStockEntry + i, ""))
				return soap->error;
	}
	if(a->vd__MergeStockEntriesOperation::resultStockEntry) {
		int i;
		for(i = 0; i < a->vd__MergeStockEntriesOperation::__sizeresultStockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:resultStockEntry", -1, a->vd__MergeStockEntriesOperation::resultStockEntry + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__MergeStockEntriesOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__MergeStockEntriesOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation * FASTCALL soap_in_vd__MergeStockEntriesOperation(struct soap *soap, const char *tag, vd__MergeStockEntriesOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__MergeStockEntriesOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__MergeStockEntriesOperation, sizeof(vd__MergeStockEntriesOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__MergeStockEntriesOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__MergeStockEntriesOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_sourceStockEntry1 = NULL;
	struct soap_blist *soap_blist_resultStockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__RegisterModificationType(soap, "vd:type", &(a->vd__MergeStockEntriesOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:sourceStockEntry", 1, NULL)) {
				if(a->vd__MergeStockEntriesOperation::sourceStockEntry == NULL) {
					if(soap_blist_sourceStockEntry1 == NULL)
						soap_blist_sourceStockEntry1 = soap_new_block(soap);
					a->vd__MergeStockEntriesOperation::sourceStockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_sourceStockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__MergeStockEntriesOperation::sourceStockEntry == NULL)
						return NULL;
					*a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", a->vd__MergeStockEntriesOperation::sourceStockEntry, "vd:StockEntry"))
				{	a->vd__MergeStockEntriesOperation::__sizesourceStockEntry++;
					a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:resultStockEntry", 1, NULL)) {
				if(a->vd__MergeStockEntriesOperation::resultStockEntry == NULL) {
					if(soap_blist_resultStockEntry1 == NULL)
						soap_blist_resultStockEntry1 = soap_new_block(soap);
					a->vd__MergeStockEntriesOperation::resultStockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_resultStockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__MergeStockEntriesOperation::resultStockEntry == NULL)
						return NULL;
					*a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:resultStockEntry", a->vd__MergeStockEntriesOperation::resultStockEntry, "vd:StockEntry"))
				{	a->vd__MergeStockEntriesOperation::__sizeresultStockEntry++;
					a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__MergeStockEntriesOperation::sourceStockEntry)
			soap_pop_block(soap, soap_blist_sourceStockEntry1);
		if(a->vd__MergeStockEntriesOperation::__sizesourceStockEntry)
			a->vd__MergeStockEntriesOperation::sourceStockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_sourceStockEntry1, NULL, 1);
		else
		{	a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
			if(soap_blist_sourceStockEntry1)
				soap_end_block(soap, soap_blist_sourceStockEntry1);
		}
		if(a->vd__MergeStockEntriesOperation::resultStockEntry)
			soap_pop_block(soap, soap_blist_resultStockEntry1);
		if(a->vd__MergeStockEntriesOperation::__sizeresultStockEntry)
			a->vd__MergeStockEntriesOperation::resultStockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_resultStockEntry1, NULL, 1);
		else
		{	a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
			if(soap_blist_resultStockEntry1)
				soap_end_block(soap, soap_blist_resultStockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__MergeStockEntriesOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__MergeStockEntriesOperation, 0, sizeof(vd__MergeStockEntriesOperation), 0, soap_copy_vd__MergeStockEntriesOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (a->vd__MergeStockEntriesOperation::__sizesourceStockEntry < 2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__MergeStockEntriesOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__MergeStockEntriesOperation);
	return this->soap_out(soap, tag?tag:"vd:MergeStockEntriesOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__MergeStockEntriesOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__MergeStockEntriesOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation * SOAP_FMAC4 soap_get_vd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__MergeStockEntriesOperation * FASTCALL soap_instantiate_vd__MergeStockEntriesOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__MergeStockEntriesOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__MergeStockEntriesOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__MergeStockEntriesOperation);
		ASSIGN_PTR(size, sizeof(vd__MergeStockEntriesOperation));
		((vd__MergeStockEntriesOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__MergeStockEntriesOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__MergeStockEntriesOperation));
		for(int i = 0; i < n; i++)
			((vd__MergeStockEntriesOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__MergeStockEntriesOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__MergeStockEntriesOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__MergeStockEntriesOperation %p -> %p\n", q, p));
	*(vd__MergeStockEntriesOperation*)p = *(vd__MergeStockEntriesOperation*)q;
}

void vd__ProductionOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ProductionOperation::operationId = NULL;
	this->vd__ProductionOperation::__sizerawBatch = 0;
	this->vd__ProductionOperation::rawBatch = NULL;
	this->vd__ProductionOperation::__sizeproductiveBatch = 0;
	this->vd__ProductionOperation::productiveBatch = NULL;
	this->vd__ProductionOperation::finalizeOperation = NULL;
	this->vd__ProductionOperation::__sizeappliedProcess = 0;
	this->vd__ProductionOperation::appliedProcess = NULL;
	/* transient soap skipped */
}

void vd__ProductionOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__ProductionOperation::operationId);
	if(this->vd__ProductionOperation::rawBatch) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizerawBatch; i++) {
			soap_serialize_PointerTovd__RawBatch(soap, this->vd__ProductionOperation::rawBatch + i);
		}
	}
	if(this->vd__ProductionOperation::productiveBatch) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizeproductiveBatch; i++) {
			soap_serialize_PointerTovd__ProductiveBatch(soap, this->vd__ProductionOperation::productiveBatch + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__ProductionOperation::finalizeOperation);
	if(this->vd__ProductionOperation::appliedProcess) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizeappliedProcess; i++) {
			soap_serialize_PointerTovd__ProcessingProcedure(soap, this->vd__ProductionOperation::appliedProcess + i);
		}
	}
	/* transient soap skipped */
}

int vd__ProductionOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProductionOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProductionOperation(struct soap *soap, const char *tag, int id, const vd__ProductionOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProductionOperation), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:operationId", -1, &(a->vd__ProductionOperation::operationId), ""))
		return soap->error;
	if(a->vd__ProductionOperation::rawBatch) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizerawBatch; i++)
			if(soap_out_PointerTovd__RawBatch(soap, "vd:rawBatch", -1, a->vd__ProductionOperation::rawBatch + i, ""))
				return soap->error;
	}
	if(a->vd__ProductionOperation::productiveBatch) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizeproductiveBatch; i++)
			if(soap_out_PointerTovd__ProductiveBatch(soap, "vd:productiveBatch", -1, a->vd__ProductionOperation::productiveBatch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:finalizeOperation", -1, &(a->vd__ProductionOperation::finalizeOperation), ""))
		return soap->error;
	if(a->vd__ProductionOperation::appliedProcess) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizeappliedProcess; i++)
			if(soap_out_PointerTovd__ProcessingProcedure(soap, "vd:appliedProcess", -1, a->vd__ProductionOperation::appliedProcess + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProductionOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProductionOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProductionOperation * FASTCALL soap_in_vd__ProductionOperation(struct soap *soap, const char *tag, vd__ProductionOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProductionOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProductionOperation, sizeof(vd__ProductionOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProductionOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProductionOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_operationId1 = 1;
	struct soap_blist *soap_blist_rawBatch1 = NULL;
	struct soap_blist *soap_blist_productiveBatch1 = NULL;
	size_t soap_flag_finalizeOperation1 = 1;
	struct soap_blist *soap_blist_appliedProcess1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_operationId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:operationId", &(a->vd__ProductionOperation::operationId), "base:Identifier"))
				{	soap_flag_operationId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:rawBatch", 1, NULL)) {
				if(a->vd__ProductionOperation::rawBatch == NULL) {
					if(soap_blist_rawBatch1 == NULL)
						soap_blist_rawBatch1 = soap_new_block(soap);
					a->vd__ProductionOperation::rawBatch = (vd__RawBatch **)soap_push_block(soap, soap_blist_rawBatch1, sizeof(vd__RawBatch *));
					if(a->vd__ProductionOperation::rawBatch == NULL)
						return NULL;
					*a->vd__ProductionOperation::rawBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RawBatch(soap, "vd:rawBatch", a->vd__ProductionOperation::rawBatch, "vd:RawBatch"))
				{	a->vd__ProductionOperation::__sizerawBatch++;
					a->vd__ProductionOperation::rawBatch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:productiveBatch", 1, NULL)) {
				if(a->vd__ProductionOperation::productiveBatch == NULL) {
					if(soap_blist_productiveBatch1 == NULL)
						soap_blist_productiveBatch1 = soap_new_block(soap);
					a->vd__ProductionOperation::productiveBatch = (vd__ProductiveBatch **)soap_push_block(soap, soap_blist_productiveBatch1, sizeof(vd__ProductiveBatch *));
					if(a->vd__ProductionOperation::productiveBatch == NULL)
						return NULL;
					*a->vd__ProductionOperation::productiveBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ProductiveBatch(soap, "vd:productiveBatch", a->vd__ProductionOperation::productiveBatch, "vd:ProductiveBatch"))
				{	a->vd__ProductionOperation::__sizeproductiveBatch++;
					a->vd__ProductionOperation::productiveBatch = NULL;
					continue;
				}
			}
			if(soap_flag_finalizeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:finalizeOperation", &(a->vd__ProductionOperation::finalizeOperation), "xsd:boolean"))
				{	soap_flag_finalizeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:appliedProcess", 1, NULL)) {
				if(a->vd__ProductionOperation::appliedProcess == NULL) {
					if(soap_blist_appliedProcess1 == NULL)
						soap_blist_appliedProcess1 = soap_new_block(soap);
					a->vd__ProductionOperation::appliedProcess = (vd__ProcessingProcedure **)soap_push_block(soap, soap_blist_appliedProcess1, sizeof(vd__ProcessingProcedure *));
					if(a->vd__ProductionOperation::appliedProcess == NULL)
						return NULL;
					*a->vd__ProductionOperation::appliedProcess = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ProcessingProcedure(soap, "vd:appliedProcess", a->vd__ProductionOperation::appliedProcess, "vd:ProcessingProcedure"))
				{	a->vd__ProductionOperation::__sizeappliedProcess++;
					a->vd__ProductionOperation::appliedProcess = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ProductionOperation::rawBatch)
			soap_pop_block(soap, soap_blist_rawBatch1);
		if(a->vd__ProductionOperation::__sizerawBatch)
			a->vd__ProductionOperation::rawBatch = (vd__RawBatch **)soap_save_block(soap, soap_blist_rawBatch1, NULL, 1);
		else
		{	a->vd__ProductionOperation::rawBatch = NULL;
			if(soap_blist_rawBatch1)
				soap_end_block(soap, soap_blist_rawBatch1);
		}
		if(a->vd__ProductionOperation::productiveBatch)
			soap_pop_block(soap, soap_blist_productiveBatch1);
		if(a->vd__ProductionOperation::__sizeproductiveBatch)
			a->vd__ProductionOperation::productiveBatch = (vd__ProductiveBatch **)soap_save_block(soap, soap_blist_productiveBatch1, NULL, 1);
		else
		{	a->vd__ProductionOperation::productiveBatch = NULL;
			if(soap_blist_productiveBatch1)
				soap_end_block(soap, soap_blist_productiveBatch1);
		}
		if(a->vd__ProductionOperation::appliedProcess)
			soap_pop_block(soap, soap_blist_appliedProcess1);
		if(a->vd__ProductionOperation::__sizeappliedProcess)
			a->vd__ProductionOperation::appliedProcess = (vd__ProcessingProcedure **)soap_save_block(soap, soap_blist_appliedProcess1, NULL, 1);
		else
		{	a->vd__ProductionOperation::appliedProcess = NULL;
			if(soap_blist_appliedProcess1)
				soap_end_block(soap, soap_blist_appliedProcess1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProductionOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProductionOperation, 0, sizeof(vd__ProductionOperation), 0, soap_copy_vd__ProductionOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ProductionOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProductionOperation);
	return this->soap_out(soap, tag?tag:"vd:ProductionOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProductionOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProductionOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProductionOperation * SOAP_FMAC4 soap_get_vd__ProductionOperation(struct soap *soap, vd__ProductionOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProductionOperation * FASTCALL soap_instantiate_vd__ProductionOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProductionOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProductionOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProductionOperation);
		ASSIGN_PTR(size, sizeof(vd__ProductionOperation));
		((vd__ProductionOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProductionOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProductionOperation));
		for(int i = 0; i < n; i++)
			((vd__ProductionOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProductionOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProductionOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProductionOperation %p -> %p\n", q, p));
	*(vd__ProductionOperation*)p = *(vd__ProductionOperation*)q;
}

void vd__ShipmentRoute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ShipmentRoute::__sizeroutePoint = 0;
	this->vd__ShipmentRoute::routePoint = NULL;
	/* transient soap skipped */
}

void vd__ShipmentRoute::soap_serialize(struct soap *soap) const
{
	if(this->vd__ShipmentRoute::routePoint) {
		for(int i = 0; i < this->vd__ShipmentRoute::__sizeroutePoint; i++) {
			soap_serialize_PointerTovd__ShipmentRoutePoint(soap, this->vd__ShipmentRoute::routePoint + i);
		}
	}
	/* transient soap skipped */
}

int vd__ShipmentRoute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ShipmentRoute(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ShipmentRoute(struct soap *soap, const char *tag, int id, const vd__ShipmentRoute *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ShipmentRoute), type))
		return soap->error;
	if(a->vd__ShipmentRoute::routePoint) {
		int i;
		for(i = 0; i < a->vd__ShipmentRoute::__sizeroutePoint; i++)
			if(soap_out_PointerTovd__ShipmentRoutePoint(soap, "vd:routePoint", -1, a->vd__ShipmentRoute::routePoint + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ShipmentRoute::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ShipmentRoute(soap, tag, this, type);
}

SOAP_FMAC3 vd__ShipmentRoute * FASTCALL soap_in_vd__ShipmentRoute(struct soap *soap, const char *tag, vd__ShipmentRoute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ShipmentRoute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ShipmentRoute, sizeof(vd__ShipmentRoute), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ShipmentRoute) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ShipmentRoute *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_routePoint1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:routePoint", 1, NULL)) {
				if(a->vd__ShipmentRoute::routePoint == NULL) {
					if(soap_blist_routePoint1 == NULL)
						soap_blist_routePoint1 = soap_new_block(soap);
					a->vd__ShipmentRoute::routePoint = (vd__ShipmentRoutePoint **)soap_push_block(soap, soap_blist_routePoint1, sizeof(vd__ShipmentRoutePoint *));
					if(a->vd__ShipmentRoute::routePoint == NULL)
						return NULL;
					*a->vd__ShipmentRoute::routePoint = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ShipmentRoutePoint(soap, "vd:routePoint", a->vd__ShipmentRoute::routePoint, "vd:ShipmentRoutePoint"))
				{	a->vd__ShipmentRoute::__sizeroutePoint++;
					a->vd__ShipmentRoute::routePoint = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ShipmentRoute::routePoint)
			soap_pop_block(soap, soap_blist_routePoint1);
		if(a->vd__ShipmentRoute::__sizeroutePoint)
			a->vd__ShipmentRoute::routePoint = (vd__ShipmentRoutePoint **)soap_save_block(soap, soap_blist_routePoint1, NULL, 1);
		else
		{	a->vd__ShipmentRoute::routePoint = NULL;
			if(soap_blist_routePoint1)
				soap_end_block(soap, soap_blist_routePoint1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ShipmentRoute, 0, sizeof(vd__ShipmentRoute), 0, soap_copy_vd__ShipmentRoute);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ShipmentRoute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ShipmentRoute);
	return this->soap_out(soap, tag?tag:"vd:ShipmentRoute", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ShipmentRoute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ShipmentRoute(soap, this, tag, type);
}

SOAP_FMAC3 vd__ShipmentRoute * SOAP_FMAC4 soap_get_vd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ShipmentRoute * FASTCALL soap_instantiate_vd__ShipmentRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ShipmentRoute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ShipmentRoute, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoute);
		ASSIGN_PTR(size, sizeof(vd__ShipmentRoute));
		((vd__ShipmentRoute*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoute[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoute));
		for(int i = 0; i < n; i++)
			((vd__ShipmentRoute*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ShipmentRoute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ShipmentRoute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ShipmentRoute %p -> %p\n", q, p));
	*(vd__ShipmentRoute*)p = *(vd__ShipmentRoute*)q;
}

void vd__ShipmentRoutePoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ShipmentRoutePoint::sqnId = NULL;
	this->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint = 0;
	this->vd__ShipmentRoutePoint::transshipment = NULL;
	this->vd__ShipmentRoutePoint::nextTransport = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__ShipmentRoutePoint::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__SequenceNumber(soap, &this->vd__ShipmentRoutePoint::sqnId);
	soap_serialize__vd__union_ShipmentRoutePoint(soap, this->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &this->vd__ShipmentRoutePoint::union_ShipmentRoutePoint);
	soap_serialize_PointerTobool(soap, &this->vd__ShipmentRoutePoint::transshipment);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__ShipmentRoutePoint::nextTransport);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__ShipmentRoutePoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ShipmentRoutePoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, const vd__ShipmentRoutePoint *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ShipmentRoutePoint), "vd:ShipmentRoutePoint"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTobase__SequenceNumber(soap, "vd:sqnId", -1, &(a->vd__ShipmentRoutePoint::sqnId), ""))
		return soap->error;
	if(soap_out__vd__union_ShipmentRoutePoint(soap, a->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->vd__ShipmentRoutePoint::union_ShipmentRoutePoint))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:transshipment", -1, &(a->vd__ShipmentRoutePoint::transshipment), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:nextTransport", -1, &(a->vd__ShipmentRoutePoint::nextTransport), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__ShipmentRoutePoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ShipmentRoutePoint(soap, tag, this, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint * FASTCALL soap_in_vd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ShipmentRoutePoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ShipmentRoutePoint) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ShipmentRoutePoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_sqnId1 = 1;
	size_t soap_flag_union_ShipmentRoutePoint1 = 1;
	size_t soap_flag_transshipment1 = 1;
	size_t soap_flag_nextTransport1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__SequenceNumber(soap, "vd:sqnId", &(a->vd__ShipmentRoutePoint::sqnId), "base:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap_flag_union_ShipmentRoutePoint1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_ShipmentRoutePoint(soap, &a->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->vd__ShipmentRoutePoint::union_ShipmentRoutePoint))
				{	soap_flag_union_ShipmentRoutePoint1 = 0;
					continue;
				}
			if(soap_flag_transshipment1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:transshipment", &(a->vd__ShipmentRoutePoint::transshipment), "xsd:boolean"))
				{	soap_flag_transshipment1--;
					continue;
				}
			if(soap_flag_nextTransport1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:nextTransport", &(a->vd__ShipmentRoutePoint::nextTransport), "vd:TransportInfo"))
				{	soap_flag_nextTransport1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoutePoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ShipmentRoutePoint, 0, sizeof(vd__ShipmentRoutePoint), 0, soap_copy_vd__ShipmentRoutePoint);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ShipmentRoutePoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ShipmentRoutePoint);
	return this->soap_out(soap, tag?tag:"vd:ShipmentRoutePoint", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ShipmentRoutePoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ShipmentRoutePoint(soap, this, tag, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint * SOAP_FMAC4 soap_get_vd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ShipmentRoutePoint * FASTCALL soap_instantiate_vd__ShipmentRoutePoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ShipmentRoutePoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ShipmentRoutePoint, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint);
		ASSIGN_PTR(size, sizeof(vd__ShipmentRoutePoint));
		((vd__ShipmentRoutePoint*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoutePoint));
		for(int i = 0; i < n; i++)
			((vd__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ShipmentRoutePoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ShipmentRoutePoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ShipmentRoutePoint %p -> %p\n", q, p));
	*(vd__ShipmentRoutePoint*)p = *(vd__ShipmentRoutePoint*)q;
}

void vd__TransportNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__TransportNumber::containerNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::wagonNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::vehicleNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::trailerNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::shipName);
	soap_default_base__String255(soap, &this->vd__TransportNumber::flightNumber);
	/* transient soap skipped */
}

void vd__TransportNumber::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::containerNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::wagonNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::vehicleNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::trailerNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::shipName);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::flightNumber);
	/* transient soap skipped */
}

int vd__TransportNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__TransportNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__TransportNumber(struct soap *soap, const char *tag, int id, const vd__TransportNumber *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__TransportNumber), type))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:containerNumber", -1, &(a->vd__TransportNumber::containerNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:wagonNumber", -1, &(a->vd__TransportNumber::wagonNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:vehicleNumber", -1, &(a->vd__TransportNumber::vehicleNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:trailerNumber", -1, &(a->vd__TransportNumber::trailerNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:shipName", -1, &(a->vd__TransportNumber::shipName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:flightNumber", -1, &(a->vd__TransportNumber::flightNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__TransportNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__TransportNumber(soap, tag, this, type);
}

SOAP_FMAC3 vd__TransportNumber * FASTCALL soap_in_vd__TransportNumber(struct soap *soap, const char *tag, vd__TransportNumber *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__TransportNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__TransportNumber, sizeof(vd__TransportNumber), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__TransportNumber) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__TransportNumber *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_containerNumber1 = 1;
	size_t soap_flag_wagonNumber1 = 1;
	size_t soap_flag_vehicleNumber1 = 1;
	size_t soap_flag_trailerNumber1 = 1;
	size_t soap_flag_shipName1 = 1;
	size_t soap_flag_flightNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_containerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:containerNumber", &(a->vd__TransportNumber::containerNumber), "base:String255"))
				{	soap_flag_containerNumber1--;
					continue;
				}
			if(soap_flag_wagonNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:wagonNumber", &(a->vd__TransportNumber::wagonNumber), "base:String255"))
				{	soap_flag_wagonNumber1--;
					continue;
				}
			if(soap_flag_vehicleNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:vehicleNumber", &(a->vd__TransportNumber::vehicleNumber), "base:String255"))
				{	soap_flag_vehicleNumber1--;
					continue;
				}
			if(soap_flag_trailerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:trailerNumber", &(a->vd__TransportNumber::trailerNumber), "base:String255"))
				{	soap_flag_trailerNumber1--;
					continue;
				}
			if(soap_flag_shipName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:shipName", &(a->vd__TransportNumber::shipName), "base:String255"))
				{	soap_flag_shipName1--;
					continue;
				}
			if(soap_flag_flightNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:flightNumber", &(a->vd__TransportNumber::flightNumber), "base:String255"))
				{	soap_flag_flightNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__TransportNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__TransportNumber, 0, sizeof(vd__TransportNumber), 0, soap_copy_vd__TransportNumber);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__TransportNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__TransportNumber);
	return this->soap_out(soap, tag?tag:"vd:TransportNumber", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__TransportNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__TransportNumber(soap, this, tag, type);
}

SOAP_FMAC3 vd__TransportNumber * SOAP_FMAC4 soap_get_vd__TransportNumber(struct soap *soap, vd__TransportNumber *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__TransportNumber * FASTCALL soap_instantiate_vd__TransportNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__TransportNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__TransportNumber, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__TransportNumber);
		ASSIGN_PTR(size, sizeof(vd__TransportNumber));
		((vd__TransportNumber*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__TransportNumber[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__TransportNumber));
		for(int i = 0; i < n; i++)
			((vd__TransportNumber*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__TransportNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__TransportNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__TransportNumber %p -> %p\n", q, p));
	*(vd__TransportNumber*)p = *(vd__TransportNumber*)q;
}

void vd__TransportInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__TransportInfo::transportType = NULL;
	this->vd__TransportInfo::transportNumber = NULL;
	/* transient soap skipped */
}

void vd__TransportInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__TransportType(soap, &this->vd__TransportInfo::transportType);
	soap_serialize_PointerTovd__TransportNumber(soap, &this->vd__TransportInfo::transportNumber);
	/* transient soap skipped */
}

int vd__TransportInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__TransportInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__TransportInfo(struct soap *soap, const char *tag, int id, const vd__TransportInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__TransportInfo), type))
		return soap->error;
	if(soap_out_PointerTodic__TransportType(soap, "vd:transportType", -1, &(a->vd__TransportInfo::transportType), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportNumber(soap, "vd:transportNumber", -1, &(a->vd__TransportInfo::transportNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__TransportInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__TransportInfo(soap, tag, this, type);
}

SOAP_FMAC3 vd__TransportInfo * FASTCALL soap_in_vd__TransportInfo(struct soap *soap, const char *tag, vd__TransportInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__TransportInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__TransportInfo, sizeof(vd__TransportInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__TransportInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__TransportInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_transportType1 = 1;
	size_t soap_flag_transportNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_transportType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__TransportType(soap, "vd:transportType", &(a->vd__TransportInfo::transportType), "dic:TransportType"))
				{	soap_flag_transportType1--;
					continue;
				}
			if(soap_flag_transportNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportNumber(soap, "vd:transportNumber", &(a->vd__TransportInfo::transportNumber), "vd:TransportNumber"))
				{	soap_flag_transportNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__TransportInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__TransportInfo, 0, sizeof(vd__TransportInfo), 0, soap_copy_vd__TransportInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__TransportInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__TransportInfo);
	return this->soap_out(soap, tag?tag:"vd:TransportInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__TransportInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__TransportInfo(soap, this, tag, type);
}

SOAP_FMAC3 vd__TransportInfo * SOAP_FMAC4 soap_get_vd__TransportInfo(struct soap *soap, vd__TransportInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__TransportInfo * FASTCALL soap_instantiate_vd__TransportInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__TransportInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__TransportInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__TransportInfo);
		ASSIGN_PTR(size, sizeof(vd__TransportInfo));
		((vd__TransportInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__TransportInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__TransportInfo));
		for(int i = 0; i < n; i++)
			((vd__TransportInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__TransportInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__TransportInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__TransportInfo %p -> %p\n", q, p));
	*(vd__TransportInfo*)p = *(vd__TransportInfo*)q;
}

void vd__Waybill::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Waybill::consignor = NULL;
	this->vd__Waybill::consignee = NULL;
	this->vd__Waybill::broker = NULL;
	this->vd__Waybill::transportInfo = NULL;
	this->vd__Waybill::transportStorageType = NULL;
	this->vd__Waybill::shipmentRoute = NULL;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Waybill::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__Waybill::consignor);
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__Waybill::consignee);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__Waybill::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__Waybill::transportInfo);
	soap_serialize_PointerTodic__TransportationStorageType(soap, &this->vd__Waybill::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__Waybill::shipmentRoute);
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerTodic__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Waybill::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Waybill(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Waybill(struct soap *soap, const char *tag, int id, const vd__Waybill *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Waybill), "vd:Waybill"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignor", -1, &(a->vd__Waybill::consignor), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignee", -1, &(a->vd__Waybill::consignee), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:broker", -1, &(a->vd__Waybill::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__Waybill::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__Waybill::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__Waybill::shipmentRoute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Waybill::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Waybill(soap, tag, this, type);
}

SOAP_FMAC3 vd__Waybill * FASTCALL soap_in_vd__Waybill(struct soap *soap, const char *tag, vd__Waybill *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Waybill *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Waybill) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Waybill *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__DocumentType(soap, "vd:type", &(a->vd__Document::type), "dic:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "dic:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignor", &(a->vd__Waybill::consignor), "dic:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignee", &(a->vd__Waybill::consignee), "dic:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:broker", &(a->vd__Waybill::broker), "dic:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__Waybill::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__Waybill::transportStorageType), "dic:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__Waybill::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Waybill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Waybill, 0, sizeof(vd__Waybill), 0, soap_copy_vd__Waybill);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Waybill::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Waybill);
	return this->soap_out(soap, tag?tag:"vd:Waybill", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Waybill::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Waybill(soap, this, tag, type);
}

SOAP_FMAC3 vd__Waybill * SOAP_FMAC4 soap_get_vd__Waybill(struct soap *soap, vd__Waybill *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Waybill * FASTCALL soap_instantiate_vd__Waybill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Waybill(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Waybill, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Waybill);
		ASSIGN_PTR(size, sizeof(vd__Waybill));
		((vd__Waybill*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Waybill));
		for(int i = 0; i < n; i++)
			((vd__Waybill*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Waybill*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Waybill(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Waybill %p -> %p\n", q, p));
	*(vd__Waybill*)p = *(vd__Waybill*)q;
}

void vd__Document::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Document::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerTodic__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Document::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Document(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Document(struct soap *soap, const char *tag, int id, const vd__Document *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Document), "vd:Document"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Document::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Document(soap, tag, this, type);
}

SOAP_FMAC3 vd__Document * FASTCALL soap_in_vd__Document(struct soap *soap, const char *tag, vd__Document *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Document *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Document, sizeof(vd__Document), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Document) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Document *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_form1 = 1;
	size_t soap_flag_issueSeries1 = 1;
	size_t soap_flag_issueNumber1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_issuer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_form1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form1--;
					continue;
				}
			if(soap_flag_issueSeries1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries1--;
					continue;
				}
			if(soap_flag_issueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber1--;
					continue;
				}
			if(soap_flag_issueDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__DocumentType(soap, "vd:type", &(a->vd__Document::type), "dic:DocumentType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_issuer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "dic:Organization"))
				{	soap_flag_issuer1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Document *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Document, 0, sizeof(vd__Document), 0, soap_copy_vd__Document);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Document::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Document);
	return this->soap_out(soap, tag?tag:"vd:Document", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Document::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Document(soap, this, tag, type);
}

SOAP_FMAC3 vd__Document * SOAP_FMAC4 soap_get_vd__Document(struct soap *soap, vd__Document *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Document * FASTCALL soap_instantiate_vd__Document(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Document(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Document, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:VetDocument")) {
		cp->type = SOAP_TYPE_vd__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocument));
			((vd__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
			for(int i = 0; i < n; i++)
				((vd__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
			((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Waybill")) {
		cp->type = SOAP_TYPE_vd__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Waybill));
			((vd__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Waybill));
			for(int i = 0; i < n; i++)
				((vd__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ReferencedDocument")) {
		cp->type = SOAP_TYPE_vd__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
			((vd__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ReferencedDocument*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Document);
		ASSIGN_PTR(size, sizeof(vd__Document));
		((vd__Document*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Document[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Document));
		for(int i = 0; i < n; i++)
			((vd__Document*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Document*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Document(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Document %p -> %p\n", q, p));
	*(vd__Document*)p = *(vd__Document*)q;
}

void vd__StockEntrySearchPattern::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntrySearchPattern::blankFilter = NULL;
	soap_default_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	this->vd__StockEntry::batch = NULL;
	this->vd__StockEntry::__sizevetDocument = 0;
	this->vd__StockEntry::vetDocument = NULL;
	this->vd__StockEntry::vetEventList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__StockEntrySearchPattern::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryBlankFilter(soap, &this->vd__StockEntrySearchPattern::blankFilter);
	soap_serialize_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__StockEntry::batch);
	if(this->vd__StockEntry::vetDocument) {
		for(int i = 0; i < this->vd__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTovd__StockEntryEventList(soap, &this->vd__StockEntry::vetEventList);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__StockEntrySearchPattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntrySearchPattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, const vd__StockEntrySearchPattern *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntrySearchPattern), "vd:StockEntrySearchPattern"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_vd__StockEntryNumber(soap, "vd:entryNumber", -1, &(a->vd__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__StockEntry::batch), ""))
		return soap->error;
	if(a->vd__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->vd__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", -1, &(a->vd__StockEntry::vetEventList), ""))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryBlankFilter(soap, "vd:blankFilter", -1, &(a->vd__StockEntrySearchPattern::blankFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntrySearchPattern::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntrySearchPattern(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern * FASTCALL soap_in_vd__StockEntrySearchPattern(struct soap *soap, const char *tag, vd__StockEntrySearchPattern *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntrySearchPattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntrySearchPattern) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntrySearchPattern *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_entryNumber2 = 1;
	size_t soap_flag_batch2 = 1;
	struct soap_blist *soap_blist_vetDocument2 = NULL;
	size_t soap_flag_vetEventList2 = 1;
	size_t soap_flag_blankFilter1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_entryNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__StockEntryNumber(soap, "vd:entryNumber", &(a->vd__StockEntry::entryNumber), "vd:StockEntryNumber"))
				{	soap_flag_entryNumber2--;
					continue;
				}
			if(soap_flag_batch2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__StockEntry::batch), "vd:Batch"))
				{	soap_flag_batch2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument2 == NULL)
						soap_blist_vetDocument2 = soap_new_block(soap);
					a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument2, sizeof(vd__VetDocument *));
					if(a->vd__StockEntry::vetDocument == NULL)
						return NULL;
					*a->vd__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__StockEntry::vetDocument, "vd:VetDocument"))
				{	a->vd__StockEntry::__sizevetDocument++;
					a->vd__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", &(a->vd__StockEntry::vetEventList), "vd:StockEntryEventList"))
				{	soap_flag_vetEventList2--;
					continue;
				}
			if(soap_flag_blankFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryBlankFilter(soap, "vd:blankFilter", &(a->vd__StockEntrySearchPattern::blankFilter), "vd:StockEntryBlankFilter"))
				{	soap_flag_blankFilter1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument2);
		if(a->vd__StockEntry::__sizevetDocument)
			a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument2, NULL, 1);
		else
		{	a->vd__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument2)
				soap_end_block(soap, soap_blist_vetDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntrySearchPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntrySearchPattern, 0, sizeof(vd__StockEntrySearchPattern), 0, soap_copy_vd__StockEntrySearchPattern);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntrySearchPattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntrySearchPattern);
	return this->soap_out(soap, tag?tag:"vd:StockEntrySearchPattern", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntrySearchPattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntrySearchPattern(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern * SOAP_FMAC4 soap_get_vd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntrySearchPattern * FASTCALL soap_instantiate_vd__StockEntrySearchPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntrySearchPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntrySearchPattern, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
		ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
		((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
		for(int i = 0; i < n; i++)
			((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntrySearchPattern*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntrySearchPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntrySearchPattern %p -> %p\n", q, p));
	*(vd__StockEntrySearchPattern*)p = *(vd__StockEntrySearchPattern*)q;
}

void vd__StockDiscrepancy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockDiscrepancy::affectedList = NULL;
	this->vd__StockDiscrepancy::resultingList = NULL;
	soap_default_string(soap, &this->vd__StockDiscrepancy::reason);
	soap_default_xsd__ID(soap, &this->vd__StockDiscrepancy::id);
	/* transient soap skipped */
}

void vd__StockDiscrepancy::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->vd__StockDiscrepancy::affectedList);
	soap_serialize_PointerTovd__StockEntryList(soap, &this->vd__StockDiscrepancy::resultingList);
	soap_serialize_string(soap, &this->vd__StockDiscrepancy::reason);
	/* transient soap skipped */
}

int vd__StockDiscrepancy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockDiscrepancy(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockDiscrepancy(struct soap *soap, const char *tag, int id, const vd__StockDiscrepancy *a, const char *type)
{
	if(((vd__StockDiscrepancy*)a)->id)
		soap_set_attr(soap, "id", ((vd__StockDiscrepancy*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockDiscrepancy), type))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryList(soap, "vd:affectedList", -1, &(a->vd__StockDiscrepancy::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryList(soap, "vd:resultingList", -1, &(a->vd__StockDiscrepancy::resultingList), ""))
		return soap->error;
	if(soap_out_string(soap, "vd:reason", -1, &(a->vd__StockDiscrepancy::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__StockDiscrepancy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockDiscrepancy(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockDiscrepancy * FASTCALL soap_in_vd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockDiscrepancy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockDiscrepancy, sizeof(vd__StockDiscrepancy), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockDiscrepancy) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockDiscrepancy *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__StockDiscrepancy*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:affectedList", &(a->vd__StockDiscrepancy::affectedList), "vd:StockEntryList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:resultingList", &(a->vd__StockDiscrepancy::resultingList), "vd:StockEntryList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "vd:reason", &(a->vd__StockDiscrepancy::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockDiscrepancy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockDiscrepancy, 0, sizeof(vd__StockDiscrepancy), 0, soap_copy_vd__StockDiscrepancy);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockDiscrepancy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockDiscrepancy);
	return this->soap_out(soap, tag?tag:"vd:StockDiscrepancy", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockDiscrepancy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockDiscrepancy(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockDiscrepancy * SOAP_FMAC4 soap_get_vd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockDiscrepancy * FASTCALL soap_instantiate_vd__StockDiscrepancy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockDiscrepancy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockDiscrepancy, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockDiscrepancy);
		ASSIGN_PTR(size, sizeof(vd__StockDiscrepancy));
		((vd__StockDiscrepancy*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockDiscrepancy[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockDiscrepancy));
		for(int i = 0; i < n; i++)
			((vd__StockDiscrepancy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockDiscrepancy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockDiscrepancy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockDiscrepancy %p -> %p\n", q, p));
	*(vd__StockDiscrepancy*)p = *(vd__StockDiscrepancy*)q;
}

void vd__StockEntryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntryList::__sizestockEntry = 0;
	this->vd__StockEntryList::stockEntry = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__StockEntryList::soap_serialize(struct soap *soap) const
{
	if(this->vd__StockEntryList::stockEntry) {
		for(int i = 0; i < this->vd__StockEntryList::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__StockEntryList::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int vd__StockEntryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryList(struct soap *soap, const char *tag, int id, const vd__StockEntryList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryList), "vd:StockEntryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__StockEntryList::stockEntry) {
		int i;
		for(i = 0; i < a->vd__StockEntryList::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->vd__StockEntryList::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntryList(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntryList * FASTCALL soap_in_vd__StockEntryList(struct soap *soap, const char *tag, vd__StockEntryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryList, sizeof(vd__StockEntryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->vd__StockEntryList::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->vd__StockEntryList::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__StockEntryList::stockEntry == NULL)
						return NULL;
					*a->vd__StockEntryList::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->vd__StockEntryList::stockEntry, "vd:StockEntry"))
				{	a->vd__StockEntryList::__sizestockEntry++;
					a->vd__StockEntryList::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntryList::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->vd__StockEntryList::__sizestockEntry)
			a->vd__StockEntryList::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->vd__StockEntryList::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryList, 0, sizeof(vd__StockEntryList), 0, soap_copy_vd__StockEntryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntryList);
	return this->soap_out(soap, tag?tag:"vd:StockEntryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntryList(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntryList * SOAP_FMAC4 soap_get_vd__StockEntryList(struct soap *soap, vd__StockEntryList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntryList * FASTCALL soap_instantiate_vd__StockEntryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryList);
		ASSIGN_PTR(size, sizeof(vd__StockEntryList));
		((vd__StockEntryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntryList));
		for(int i = 0; i < n; i++)
			((vd__StockEntryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntryList %p -> %p\n", q, p));
	*(vd__StockEntryList*)p = *(vd__StockEntryList*)q;
}

void vd__StockEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	this->vd__StockEntry::batch = NULL;
	this->vd__StockEntry::__sizevetDocument = 0;
	this->vd__StockEntry::vetDocument = NULL;
	this->vd__StockEntry::vetEventList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__StockEntry::soap_serialize(struct soap *soap) const
{
	soap_serialize_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__StockEntry::batch);
	if(this->vd__StockEntry::vetDocument) {
		for(int i = 0; i < this->vd__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTovd__StockEntryEventList(soap, &this->vd__StockEntry::vetEventList);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__StockEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntry(struct soap *soap, const char *tag, int id, const vd__StockEntry *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntry), "vd:StockEntry"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_vd__StockEntryNumber(soap, "vd:entryNumber", -1, &(a->vd__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__StockEntry::batch), ""))
		return soap->error;
	if(a->vd__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->vd__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", -1, &(a->vd__StockEntry::vetEventList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntry(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntry * FASTCALL soap_in_vd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntry, sizeof(vd__StockEntry), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntry) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_entryNumber1 = 1;
	size_t soap_flag_batch1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	size_t soap_flag_vetEventList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_entryNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__StockEntryNumber(soap, "vd:entryNumber", &(a->vd__StockEntry::entryNumber), "vd:StockEntryNumber"))
				{	soap_flag_entryNumber1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__StockEntry::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->vd__StockEntry::vetDocument == NULL)
						return NULL;
					*a->vd__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__StockEntry::vetDocument, "vd:VetDocument"))
				{	a->vd__StockEntry::__sizevetDocument++;
					a->vd__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", &(a->vd__StockEntry::vetEventList), "vd:StockEntryEventList"))
				{	soap_flag_vetEventList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->vd__StockEntry::__sizevetDocument)
			a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->vd__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntry, 0, sizeof(vd__StockEntry), 0, soap_copy_vd__StockEntry);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntry);
	return this->soap_out(soap, tag?tag:"vd:StockEntry", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntry(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntry * SOAP_FMAC4 soap_get_vd__StockEntry(struct soap *soap, vd__StockEntry *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntry * FASTCALL soap_instantiate_vd__StockEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntry, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
		ASSIGN_PTR(size, sizeof(vd__StockEntry));
		((vd__StockEntry*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
		for(int i = 0; i < n; i++)
			((vd__StockEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntry %p -> %p\n", q, p));
	*(vd__StockEntry*)p = *(vd__StockEntry*)q;
}

void vd__DiscrepancyReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__DiscrepancyReason::name);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__DiscrepancyReason::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__DiscrepancyReason::name);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__DiscrepancyReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DiscrepancyReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DiscrepancyReason(struct soap *soap, const char *tag, int id, const vd__DiscrepancyReason *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DiscrepancyReason), "vd:DiscrepancyReason"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__DiscrepancyReason::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__DiscrepancyReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DiscrepancyReason(soap, tag, this, type);
}

SOAP_FMAC3 vd__DiscrepancyReason * FASTCALL soap_in_vd__DiscrepancyReason(struct soap *soap, const char *tag, vd__DiscrepancyReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DiscrepancyReason *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DiscrepancyReason, sizeof(vd__DiscrepancyReason), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DiscrepancyReason) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DiscrepancyReason *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__DiscrepancyReason::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DiscrepancyReason, 0, sizeof(vd__DiscrepancyReason), 0, soap_copy_vd__DiscrepancyReason);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__DiscrepancyReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DiscrepancyReason);
	return this->soap_out(soap, tag?tag:"vd:DiscrepancyReason", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DiscrepancyReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DiscrepancyReason(soap, this, tag, type);
}

SOAP_FMAC3 vd__DiscrepancyReason * SOAP_FMAC4 soap_get_vd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DiscrepancyReason * FASTCALL soap_instantiate_vd__DiscrepancyReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DiscrepancyReason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DiscrepancyReason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason);
		ASSIGN_PTR(size, sizeof(vd__DiscrepancyReason));
		((vd__DiscrepancyReason*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReason));
		for(int i = 0; i < n; i++)
			((vd__DiscrepancyReason*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DiscrepancyReason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DiscrepancyReason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DiscrepancyReason %p -> %p\n", q, p));
	*(vd__DiscrepancyReason*)p = *(vd__DiscrepancyReason*)q;
}

void vd__DiscrepancyReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__DiscrepancyReport::reason = NULL;
	soap_default_string(soap, &this->vd__DiscrepancyReport::description);
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__DiscrepancyReport::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__DiscrepancyReason(soap, &this->vd__DiscrepancyReport::reason);
	soap_serialize_string(soap, &this->vd__DiscrepancyReport::description);
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerTodic__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__DiscrepancyReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DiscrepancyReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DiscrepancyReport(struct soap *soap, const char *tag, int id, const vd__DiscrepancyReport *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DiscrepancyReport), "vd:DiscrepancyReport"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTovd__DiscrepancyReason(soap, "vd:reason", -1, &(a->vd__DiscrepancyReport::reason), ""))
		return soap->error;
	if(soap_out_string(soap, "vd:description", -1, &(a->vd__DiscrepancyReport::description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__DiscrepancyReport::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DiscrepancyReport(soap, tag, this, type);
}

SOAP_FMAC3 vd__DiscrepancyReport * FASTCALL soap_in_vd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DiscrepancyReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DiscrepancyReport) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DiscrepancyReport *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_description1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__DocumentType(soap, "vd:type", &(a->vd__Document::type), "dic:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "dic:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_reason1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DiscrepancyReason(soap, "vd:reason", &(a->vd__DiscrepancyReport::reason), "vd:DiscrepancyReason"))
				{	soap_flag_reason1--;
					continue;
				}
			if(soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "vd:description", &(a->vd__DiscrepancyReport::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DiscrepancyReport, 0, sizeof(vd__DiscrepancyReport), 0, soap_copy_vd__DiscrepancyReport);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__DiscrepancyReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DiscrepancyReport);
	return this->soap_out(soap, tag?tag:"vd:DiscrepancyReport", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DiscrepancyReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DiscrepancyReport(soap, this, tag, type);
}

SOAP_FMAC3 vd__DiscrepancyReport * SOAP_FMAC4 soap_get_vd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DiscrepancyReport * FASTCALL soap_instantiate_vd__DiscrepancyReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DiscrepancyReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DiscrepancyReport, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
		ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
		((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
		for(int i = 0; i < n; i++)
			((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DiscrepancyReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DiscrepancyReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DiscrepancyReport %p -> %p\n", q, p));
	*(vd__DiscrepancyReport*)p = *(vd__DiscrepancyReport*)q;
}

void vd__VetDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VetDocumentList::__sizevetDocument = 0;
	this->vd__VetDocumentList::vetDocument = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__VetDocumentList::soap_serialize(struct soap *soap) const
{
	if(this->vd__VetDocumentList::vetDocument) {
		for(int i = 0; i < this->vd__VetDocumentList::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__VetDocumentList::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int vd__VetDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentList(struct soap *soap, const char *tag, int id, const vd__VetDocumentList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentList), "vd:VetDocumentList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__VetDocumentList::vetDocument) {
		int i;
		for(i = 0; i < a->vd__VetDocumentList::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__VetDocumentList::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocumentList * FASTCALL soap_in_vd__VetDocumentList(struct soap *soap, const char *tag, vd__VetDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentList, sizeof(vd__VetDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__VetDocumentList::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->vd__VetDocumentList::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->vd__VetDocumentList::vetDocument == NULL)
						return NULL;
					*a->vd__VetDocumentList::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__VetDocumentList::vetDocument, "vd:VetDocument"))
				{	a->vd__VetDocumentList::__sizevetDocument++;
					a->vd__VetDocumentList::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VetDocumentList::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->vd__VetDocumentList::__sizevetDocument)
			a->vd__VetDocumentList::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->vd__VetDocumentList::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentList, 0, sizeof(vd__VetDocumentList), 0, soap_copy_vd__VetDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__VetDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentList);
	return this->soap_out(soap, tag?tag:"vd:VetDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocumentList * SOAP_FMAC4 soap_get_vd__VetDocumentList(struct soap *soap, vd__VetDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocumentList * FASTCALL soap_instantiate_vd__VetDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList);
		ASSIGN_PTR(size, sizeof(vd__VetDocumentList));
		((vd__VetDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocumentList));
		for(int i = 0; i < n; i++)
			((vd__VetDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocumentList %p -> %p\n", q, p));
	*(vd__VetDocumentList*)p = *(vd__VetDocumentList*)q;
}

void vd__GoodsDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__GoodsDate::firstDate = NULL;
	this->vd__GoodsDate::secondDate = NULL;
	soap_default_base__String255(soap, &this->vd__GoodsDate::informalDate);
	/* transient soap skipped */
}

void vd__GoodsDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__ComplexDate(soap, &this->vd__GoodsDate::firstDate);
	soap_serialize_PointerTodic__ComplexDate(soap, &this->vd__GoodsDate::secondDate);
	soap_serialize_base__String255(soap, &this->vd__GoodsDate::informalDate);
	/* transient soap skipped */
}

int vd__GoodsDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__GoodsDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__GoodsDate(struct soap *soap, const char *tag, int id, const vd__GoodsDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__GoodsDate), type))
		return soap->error;
	if(soap_out_PointerTodic__ComplexDate(soap, "vd:firstDate", -1, &(a->vd__GoodsDate::firstDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__ComplexDate(soap, "vd:secondDate", -1, &(a->vd__GoodsDate::secondDate), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:informalDate", -1, &(a->vd__GoodsDate::informalDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__GoodsDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__GoodsDate(soap, tag, this, type);
}

SOAP_FMAC3 vd__GoodsDate * FASTCALL soap_in_vd__GoodsDate(struct soap *soap, const char *tag, vd__GoodsDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__GoodsDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__GoodsDate, sizeof(vd__GoodsDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__GoodsDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__GoodsDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_firstDate1 = 1;
	size_t soap_flag_secondDate1 = 1;
	size_t soap_flag_informalDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_firstDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ComplexDate(soap, "vd:firstDate", &(a->vd__GoodsDate::firstDate), "dic:ComplexDate"))
				{	soap_flag_firstDate1--;
					continue;
				}
			if(soap_flag_secondDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ComplexDate(soap, "vd:secondDate", &(a->vd__GoodsDate::secondDate), "dic:ComplexDate"))
				{	soap_flag_secondDate1--;
					continue;
				}
			if(soap_flag_informalDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:informalDate", &(a->vd__GoodsDate::informalDate), "base:String255"))
				{	soap_flag_informalDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__GoodsDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__GoodsDate, 0, sizeof(vd__GoodsDate), 0, soap_copy_vd__GoodsDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__GoodsDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__GoodsDate);
	return this->soap_out(soap, tag?tag:"vd:GoodsDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__GoodsDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__GoodsDate(soap, this, tag, type);
}

SOAP_FMAC3 vd__GoodsDate * SOAP_FMAC4 soap_get_vd__GoodsDate(struct soap *soap, vd__GoodsDate *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__GoodsDate * FASTCALL soap_instantiate_vd__GoodsDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__GoodsDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__GoodsDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__GoodsDate);
		ASSIGN_PTR(size, sizeof(vd__GoodsDate));
		((vd__GoodsDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__GoodsDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__GoodsDate));
		for(int i = 0; i < n; i++)
			((vd__GoodsDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__GoodsDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__GoodsDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__GoodsDate %p -> %p\n", q, p));
	*(vd__GoodsDate*)p = *(vd__GoodsDate*)q;
}

void vd__ConsignmentDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ConsignmentDocumentList::waybill = NULL;
	this->vd__ConsignmentDocumentList::__sizevetCertificate = 0;
	this->vd__ConsignmentDocumentList::vetCertificate = NULL;
	this->vd__ConsignmentDocumentList::__sizerelatedDocument = 0;
	this->vd__ConsignmentDocumentList::relatedDocument = NULL;
	/* transient soap skipped */
}

void vd__ConsignmentDocumentList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__Waybill(soap, &this->vd__ConsignmentDocumentList::waybill);
	if(this->vd__ConsignmentDocumentList::vetCertificate) {
		for(int i = 0; i < this->vd__ConsignmentDocumentList::__sizevetCertificate; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__ConsignmentDocumentList::vetCertificate + i);
		}
	}
	if(this->vd__ConsignmentDocumentList::relatedDocument) {
		for(int i = 0; i < this->vd__ConsignmentDocumentList::__sizerelatedDocument; i++) {
			soap_serialize_PointerTovd__ReferencedDocument(soap, this->vd__ConsignmentDocumentList::relatedDocument + i);
		}
	}
	/* transient soap skipped */
}

int vd__ConsignmentDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ConsignmentDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, const vd__ConsignmentDocumentList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ConsignmentDocumentList), type))
		return soap->error;
	if(soap_out_PointerTovd__Waybill(soap, "vd:waybill", -1, &(a->vd__ConsignmentDocumentList::waybill), ""))
		return soap->error;
	if(a->vd__ConsignmentDocumentList::vetCertificate) {
		int i;
		for(i = 0; i < a->vd__ConsignmentDocumentList::__sizevetCertificate; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetCertificate", -1, a->vd__ConsignmentDocumentList::vetCertificate + i, ""))
				return soap->error;
	}
	if(a->vd__ConsignmentDocumentList::relatedDocument) {
		int i;
		for(i = 0; i < a->vd__ConsignmentDocumentList::__sizerelatedDocument; i++)
			if(soap_out_PointerTovd__ReferencedDocument(soap, "vd:relatedDocument", -1, a->vd__ConsignmentDocumentList::relatedDocument + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ConsignmentDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ConsignmentDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList * FASTCALL soap_in_vd__ConsignmentDocumentList(struct soap *soap, const char *tag, vd__ConsignmentDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ConsignmentDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ConsignmentDocumentList, sizeof(vd__ConsignmentDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ConsignmentDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ConsignmentDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_waybill1 = 1;
	struct soap_blist *soap_blist_vetCertificate1 = NULL;
	struct soap_blist *soap_blist_relatedDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_waybill1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Waybill(soap, "vd:waybill", &(a->vd__ConsignmentDocumentList::waybill), "vd:Waybill"))
				{	soap_flag_waybill1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetCertificate", 1, NULL)) {
				if(a->vd__ConsignmentDocumentList::vetCertificate == NULL) {
					if(soap_blist_vetCertificate1 == NULL)
						soap_blist_vetCertificate1 = soap_new_block(soap);
					a->vd__ConsignmentDocumentList::vetCertificate = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetCertificate1, sizeof(vd__VetDocument *));
					if(a->vd__ConsignmentDocumentList::vetCertificate == NULL)
						return NULL;
					*a->vd__ConsignmentDocumentList::vetCertificate = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetCertificate", a->vd__ConsignmentDocumentList::vetCertificate, "vd:VetDocument"))
				{	a->vd__ConsignmentDocumentList::__sizevetCertificate++;
					a->vd__ConsignmentDocumentList::vetCertificate = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:relatedDocument", 1, NULL)) {
				if(a->vd__ConsignmentDocumentList::relatedDocument == NULL) {
					if(soap_blist_relatedDocument1 == NULL)
						soap_blist_relatedDocument1 = soap_new_block(soap);
					a->vd__ConsignmentDocumentList::relatedDocument = (vd__ReferencedDocument **)soap_push_block(soap, soap_blist_relatedDocument1, sizeof(vd__ReferencedDocument *));
					if(a->vd__ConsignmentDocumentList::relatedDocument == NULL)
						return NULL;
					*a->vd__ConsignmentDocumentList::relatedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ReferencedDocument(soap, "vd:relatedDocument", a->vd__ConsignmentDocumentList::relatedDocument, "vd:ReferencedDocument"))
				{	a->vd__ConsignmentDocumentList::__sizerelatedDocument++;
					a->vd__ConsignmentDocumentList::relatedDocument = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ConsignmentDocumentList::vetCertificate)
			soap_pop_block(soap, soap_blist_vetCertificate1);
		if(a->vd__ConsignmentDocumentList::__sizevetCertificate)
			a->vd__ConsignmentDocumentList::vetCertificate = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetCertificate1, NULL, 1);
		else
		{	a->vd__ConsignmentDocumentList::vetCertificate = NULL;
			if(soap_blist_vetCertificate1)
				soap_end_block(soap, soap_blist_vetCertificate1);
		}
		if(a->vd__ConsignmentDocumentList::relatedDocument)
			soap_pop_block(soap, soap_blist_relatedDocument1);
		if(a->vd__ConsignmentDocumentList::__sizerelatedDocument)
			a->vd__ConsignmentDocumentList::relatedDocument = (vd__ReferencedDocument **)soap_save_block(soap, soap_blist_relatedDocument1, NULL, 1);
		else
		{	a->vd__ConsignmentDocumentList::relatedDocument = NULL;
			if(soap_blist_relatedDocument1)
				soap_end_block(soap, soap_blist_relatedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ConsignmentDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ConsignmentDocumentList, 0, sizeof(vd__ConsignmentDocumentList), 0, soap_copy_vd__ConsignmentDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ConsignmentDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ConsignmentDocumentList);
	return this->soap_out(soap, tag?tag:"vd:ConsignmentDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ConsignmentDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ConsignmentDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList * SOAP_FMAC4 soap_get_vd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ConsignmentDocumentList * FASTCALL soap_instantiate_vd__ConsignmentDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ConsignmentDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ConsignmentDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ConsignmentDocumentList);
		ASSIGN_PTR(size, sizeof(vd__ConsignmentDocumentList));
		((vd__ConsignmentDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ConsignmentDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ConsignmentDocumentList));
		for(int i = 0; i < n; i++)
			((vd__ConsignmentDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ConsignmentDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ConsignmentDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ConsignmentDocumentList %p -> %p\n", q, p));
	*(vd__ConsignmentDocumentList*)p = *(vd__ConsignmentDocumentList*)q;
}

void vd__DeliveryInspection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__DeliveryInspection::responsible = NULL;
	soap_default_vd__DeliveryInspectionResult(soap, &this->vd__DeliveryInspection::result);
	soap_default_base__Text(soap, &this->vd__DeliveryInspection::info);
	/* transient soap skipped */
}

void vd__DeliveryInspection::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->vd__DeliveryInspection::responsible);
	soap_serialize_base__Text(soap, &this->vd__DeliveryInspection::info);
	/* transient soap skipped */
}

int vd__DeliveryInspection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DeliveryInspection(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryInspection(struct soap *soap, const char *tag, int id, const vd__DeliveryInspection *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryInspection), type))
		return soap->error;
	if(soap_out_PointerTovd__User(soap, "vd:responsible", -1, &(a->vd__DeliveryInspection::responsible), ""))
		return soap->error;
	if(soap_out_vd__DeliveryInspectionResult(soap, "vd:result", -1, &(a->vd__DeliveryInspection::result), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:info", -1, &(a->vd__DeliveryInspection::info), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__DeliveryInspection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DeliveryInspection(soap, tag, this, type);
}

SOAP_FMAC3 vd__DeliveryInspection * FASTCALL soap_in_vd__DeliveryInspection(struct soap *soap, const char *tag, vd__DeliveryInspection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DeliveryInspection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryInspection, sizeof(vd__DeliveryInspection), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DeliveryInspection) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DeliveryInspection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_responsible1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_info1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:responsible", &(a->vd__DeliveryInspection::responsible), "vd:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__DeliveryInspectionResult(soap, "vd:result", &(a->vd__DeliveryInspection::result), "vd:DeliveryInspectionResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_info1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:info", &(a->vd__DeliveryInspection::info), "base:Text"))
				{	soap_flag_info1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DeliveryInspection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryInspection, 0, sizeof(vd__DeliveryInspection), 0, soap_copy_vd__DeliveryInspection);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__DeliveryInspection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DeliveryInspection);
	return this->soap_out(soap, tag?tag:"vd:DeliveryInspection", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DeliveryInspection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DeliveryInspection(soap, this, tag, type);
}

SOAP_FMAC3 vd__DeliveryInspection * SOAP_FMAC4 soap_get_vd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DeliveryInspection * FASTCALL soap_instantiate_vd__DeliveryInspection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DeliveryInspection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DeliveryInspection, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryInspection);
		ASSIGN_PTR(size, sizeof(vd__DeliveryInspection));
		((vd__DeliveryInspection*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryInspection[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DeliveryInspection));
		for(int i = 0; i < n; i++)
			((vd__DeliveryInspection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DeliveryInspection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DeliveryInspection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DeliveryInspection %p -> %p\n", q, p));
	*(vd__DeliveryInspection*)p = *(vd__DeliveryInspection*)q;
}

void vd__DeliveryFactList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dic__DocumentNature(soap, &this->vd__DeliveryFactList::vetCertificatePresence);
	this->vd__DeliveryFactList::docInspection = NULL;
	this->vd__DeliveryFactList::vetInspection = NULL;
	soap_default_vd__DeliveryDecision(soap, &this->vd__DeliveryFactList::decision);
	/* transient soap skipped */
}

void vd__DeliveryFactList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__DeliveryInspection(soap, &this->vd__DeliveryFactList::docInspection);
	soap_serialize_PointerTovd__DeliveryInspection(soap, &this->vd__DeliveryFactList::vetInspection);
	/* transient soap skipped */
}

int vd__DeliveryFactList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DeliveryFactList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryFactList(struct soap *soap, const char *tag, int id, const vd__DeliveryFactList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryFactList), type))
		return soap->error;
	if(soap_out_dic__DocumentNature(soap, "vd:vetCertificatePresence", -1, &(a->vd__DeliveryFactList::vetCertificatePresence), ""))
		return soap->error;
	if(a->vd__DeliveryFactList::docInspection) {
		if(soap_out_PointerTovd__DeliveryInspection(soap, "vd:docInspection", -1, &a->vd__DeliveryFactList::docInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:docInspection"))
		return soap->error;
	if(a->vd__DeliveryFactList::vetInspection) {
		if(soap_out_PointerTovd__DeliveryInspection(soap, "vd:vetInspection", -1, &a->vd__DeliveryFactList::vetInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetInspection"))
		return soap->error;
	if(soap_out_vd__DeliveryDecision(soap, "vd:decision", -1, &(a->vd__DeliveryFactList::decision), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__DeliveryFactList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DeliveryFactList(soap, tag, this, type);
}

SOAP_FMAC3 vd__DeliveryFactList * FASTCALL soap_in_vd__DeliveryFactList(struct soap *soap, const char *tag, vd__DeliveryFactList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DeliveryFactList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryFactList, sizeof(vd__DeliveryFactList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DeliveryFactList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DeliveryFactList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetCertificatePresence1 = 1;
	size_t soap_flag_docInspection1 = 1;
	size_t soap_flag_vetInspection1 = 1;
	size_t soap_flag_decision1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_vetCertificatePresence1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__DocumentNature(soap, "vd:vetCertificatePresence", &(a->vd__DeliveryFactList::vetCertificatePresence), "dic:DocumentNature"))
				{	soap_flag_vetCertificatePresence1--;
					continue;
				}
			if(soap_flag_docInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryInspection(soap, "vd:docInspection", &(a->vd__DeliveryFactList::docInspection), "vd:DeliveryInspection"))
				{	soap_flag_docInspection1--;
					continue;
				}
			if(soap_flag_vetInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryInspection(soap, "vd:vetInspection", &(a->vd__DeliveryFactList::vetInspection), "vd:DeliveryInspection"))
				{	soap_flag_vetInspection1--;
					continue;
				}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__DeliveryDecision(soap, "vd:decision", &(a->vd__DeliveryFactList::decision), "vd:DeliveryDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DeliveryFactList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryFactList, 0, sizeof(vd__DeliveryFactList), 0, soap_copy_vd__DeliveryFactList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vetCertificatePresence1 > 0 || soap_flag_docInspection1 > 0 || soap_flag_vetInspection1 > 0 || soap_flag_decision1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__DeliveryFactList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DeliveryFactList);
	return this->soap_out(soap, tag?tag:"vd:DeliveryFactList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DeliveryFactList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DeliveryFactList(soap, this, tag, type);
}

SOAP_FMAC3 vd__DeliveryFactList * SOAP_FMAC4 soap_get_vd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DeliveryFactList * FASTCALL soap_instantiate_vd__DeliveryFactList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DeliveryFactList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DeliveryFactList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryFactList);
		ASSIGN_PTR(size, sizeof(vd__DeliveryFactList));
		((vd__DeliveryFactList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryFactList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DeliveryFactList));
		for(int i = 0; i < n; i++)
			((vd__DeliveryFactList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DeliveryFactList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DeliveryFactList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DeliveryFactList %p -> %p\n", q, p));
	*(vd__DeliveryFactList*)p = *(vd__DeliveryFactList*)q;
}

void vd__Delivery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Delivery::deliveryDate = NULL;
	this->vd__Delivery::consignor = NULL;
	this->vd__Delivery::consignee = NULL;
	this->vd__Delivery::__sizeconsignment = 0;
	this->vd__Delivery::consignment = NULL;
	this->vd__Delivery::broker = NULL;
	this->vd__Delivery::transportInfo = NULL;
	this->vd__Delivery::transportStorageType = NULL;
	this->vd__Delivery::shipmentRoute = NULL;
	this->vd__Delivery::accompanyingForms = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Delivery::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->vd__Delivery::deliveryDate);
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__Delivery::consignor);
	soap_serialize_PointerTodic__BusinessMember(soap, &this->vd__Delivery::consignee);
	if(this->vd__Delivery::consignment) {
		for(int i = 0; i < this->vd__Delivery::__sizeconsignment; i++) {
			soap_serialize_PointerTovd__Consignment(soap, this->vd__Delivery::consignment + i);
		}
	}
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__Delivery::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__Delivery::transportInfo);
	soap_serialize_PointerTodic__TransportationStorageType(soap, &this->vd__Delivery::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__Delivery::shipmentRoute);
	soap_serialize_PointerTovd__ConsignmentDocumentList(soap, &this->vd__Delivery::accompanyingForms);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Delivery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Delivery(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Delivery(struct soap *soap, const char *tag, int id, const vd__Delivery *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Delivery), "vd:Delivery"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTotime(soap, "vd:deliveryDate", -1, &(a->vd__Delivery::deliveryDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignor", -1, &(a->vd__Delivery::consignor), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "vd:consignee", -1, &(a->vd__Delivery::consignee), ""))
		return soap->error;
	if(a->vd__Delivery::consignment) {
		int i;
		for(i = 0; i < a->vd__Delivery::__sizeconsignment; i++)
			if(soap_out_PointerTovd__Consignment(soap, "vd:consignment", -1, a->vd__Delivery::consignment + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:broker", -1, &(a->vd__Delivery::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__Delivery::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__Delivery::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__Delivery::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTovd__ConsignmentDocumentList(soap, "vd:accompanyingForms", -1, &(a->vd__Delivery::accompanyingForms), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Delivery::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Delivery(soap, tag, this, type);
}

SOAP_FMAC3 vd__Delivery * FASTCALL soap_in_vd__Delivery(struct soap *soap, const char *tag, vd__Delivery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Delivery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Delivery, sizeof(vd__Delivery), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Delivery) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Delivery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_deliveryDate1 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	struct soap_blist *soap_blist_consignment1 = NULL;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_accompanyingForms1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_deliveryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:deliveryDate", &(a->vd__Delivery::deliveryDate), "xsd:dateTime"))
				{	soap_flag_deliveryDate1--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignor", &(a->vd__Delivery::consignor), "dic:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:consignee", &(a->vd__Delivery::consignee), "dic:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:consignment", 1, NULL)) {
				if(a->vd__Delivery::consignment == NULL) {
					if(soap_blist_consignment1 == NULL)
						soap_blist_consignment1 = soap_new_block(soap);
					a->vd__Delivery::consignment = (vd__Consignment **)soap_push_block(soap, soap_blist_consignment1, sizeof(vd__Consignment *));
					if(a->vd__Delivery::consignment == NULL)
						return NULL;
					*a->vd__Delivery::consignment = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Consignment(soap, "vd:consignment", a->vd__Delivery::consignment, "vd:Consignment"))
				{	a->vd__Delivery::__sizeconsignment++;
					a->vd__Delivery::consignment = NULL;
					continue;
				}
			}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:broker", &(a->vd__Delivery::broker), "dic:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__Delivery::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__Delivery::transportStorageType), "dic:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__Delivery::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_accompanyingForms1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ConsignmentDocumentList(soap, "vd:accompanyingForms", &(a->vd__Delivery::accompanyingForms), "vd:ConsignmentDocumentList"))
				{	soap_flag_accompanyingForms1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Delivery::consignment)
			soap_pop_block(soap, soap_blist_consignment1);
		if(a->vd__Delivery::__sizeconsignment)
			a->vd__Delivery::consignment = (vd__Consignment **)soap_save_block(soap, soap_blist_consignment1, NULL, 1);
		else
		{	a->vd__Delivery::consignment = NULL;
			if(soap_blist_consignment1)
				soap_end_block(soap, soap_blist_consignment1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Delivery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Delivery, 0, sizeof(vd__Delivery), 0, soap_copy_vd__Delivery);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Delivery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Delivery);
	return this->soap_out(soap, tag?tag:"vd:Delivery", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Delivery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Delivery(soap, this, tag, type);
}

SOAP_FMAC3 vd__Delivery * SOAP_FMAC4 soap_get_vd__Delivery(struct soap *soap, vd__Delivery *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Delivery * FASTCALL soap_instantiate_vd__Delivery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Delivery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Delivery, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Delivery);
		ASSIGN_PTR(size, sizeof(vd__Delivery));
		((vd__Delivery*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Delivery[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Delivery));
		for(int i = 0; i < n; i++)
			((vd__Delivery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Delivery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Delivery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Delivery %p -> %p\n", q, p));
	*(vd__Delivery*)p = *(vd__Delivery*)q;
}

void vd__ProductiveBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__ID(soap, &this->vd__ProductiveBatch::id);
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__ProductiveBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerTodic__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerTodic__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerTodic__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerTodic__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerTodic__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__ProductiveBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProductiveBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProductiveBatch(struct soap *soap, const char *tag, int id, const vd__ProductiveBatch *a, const char *type)
{
	if(((vd__ProductiveBatch*)a)->id)
		soap_set_attr(soap, "id", ((vd__ProductiveBatch*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProductiveBatch), "vd:ProductiveBatch"))
		return soap->error;
	if(soap_out_PointerTodic__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTodic__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTodic__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTodic__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTodic__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProductiveBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProductiveBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProductiveBatch * FASTCALL soap_in_vd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProductiveBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProductiveBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProductiveBatch *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__ProductiveBatch*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "dic:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Product(soap, "vd:product", &(a->vd__Batch::product), "dic:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "dic:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "dic:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "dic:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "dic:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "dic:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProductiveBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProductiveBatch, 0, sizeof(vd__ProductiveBatch), 0, soap_copy_vd__ProductiveBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ProductiveBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProductiveBatch);
	return this->soap_out(soap, tag?tag:"vd:ProductiveBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProductiveBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProductiveBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProductiveBatch * SOAP_FMAC4 soap_get_vd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProductiveBatch * FASTCALL soap_instantiate_vd__ProductiveBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProductiveBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProductiveBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch);
		ASSIGN_PTR(size, sizeof(vd__ProductiveBatch));
		((vd__ProductiveBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProductiveBatch));
		for(int i = 0; i < n; i++)
			((vd__ProductiveBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProductiveBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProductiveBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProductiveBatch %p -> %p\n", q, p));
	*(vd__ProductiveBatch*)p = *(vd__ProductiveBatch*)q;
}

void vd__RawBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RawBatch::sourceStockEntry = NULL;
	this->vd__RawBatch::volume = NULL;
	this->vd__RawBatch::unit = NULL;
	this->vd__RawBatch::packageList = NULL;
	/* transient soap skipped */
}

void vd__RawBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->vd__RawBatch::sourceStockEntry);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__RawBatch::volume);
	soap_serialize_PointerTodic__Unit(soap, &this->vd__RawBatch::unit);
	soap_serialize_PointerTodic__PackageList(soap, &this->vd__RawBatch::packageList);
	/* transient soap skipped */
}

int vd__RawBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RawBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RawBatch(struct soap *soap, const char *tag, int id, const vd__RawBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RawBatch), type))
		return soap->error;
	if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, &(a->vd__RawBatch::sourceStockEntry), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__RawBatch::volume), ""))
		return soap->error;
	if(soap_out_PointerTodic__Unit(soap, "vd:unit", -1, &(a->vd__RawBatch::unit), ""))
		return soap->error;
	if(soap_out_PointerTodic__PackageList(soap, "vd:packageList", -1, &(a->vd__RawBatch::packageList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RawBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RawBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__RawBatch * FASTCALL soap_in_vd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RawBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RawBatch, sizeof(vd__RawBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RawBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RawBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sourceStockEntry1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_packageList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", &(a->vd__RawBatch::sourceStockEntry), "vd:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__RawBatch::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Unit(soap, "vd:unit", &(a->vd__RawBatch::unit), "dic:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackageList(soap, "vd:packageList", &(a->vd__RawBatch::packageList), "dic:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RawBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RawBatch, 0, sizeof(vd__RawBatch), 0, soap_copy_vd__RawBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__RawBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RawBatch);
	return this->soap_out(soap, tag?tag:"vd:RawBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RawBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RawBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__RawBatch * SOAP_FMAC4 soap_get_vd__RawBatch(struct soap *soap, vd__RawBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RawBatch * FASTCALL soap_instantiate_vd__RawBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RawBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RawBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RawBatch);
		ASSIGN_PTR(size, sizeof(vd__RawBatch));
		((vd__RawBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RawBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RawBatch));
		for(int i = 0; i < n; i++)
			((vd__RawBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RawBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RawBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RawBatch %p -> %p\n", q, p));
	*(vd__RawBatch*)p = *(vd__RawBatch*)q;
}

void vd__Consignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Consignment::sourceStockEntry = NULL;
	soap_default_xsd__ID(soap, &this->vd__Consignment::id);
	soap_default_xsd__IDREF(soap, &this->vd__Consignment::partOf);
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__Consignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->vd__Consignment::sourceStockEntry);
	soap_serialize_PointerTodic__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerTodic__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerTodic__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerTodic__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerTodic__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerTodic__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__Consignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Consignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Consignment(struct soap *soap, const char *tag, int id, const vd__Consignment *a, const char *type)
{
	if(((vd__Consignment*)a)->id)
		soap_set_attr(soap, "id", ((vd__Consignment*)a)->id, 1);
	if(((vd__Consignment*)a)->partOf)
		soap_set_attr(soap, "partOf", ((vd__Consignment*)a)->partOf, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Consignment), "vd:Consignment"))
		return soap->error;
	if(soap_out_PointerTodic__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTodic__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTodic__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTodic__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTodic__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, &(a->vd__Consignment::sourceStockEntry), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Consignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Consignment(soap, tag, this, type);
}

SOAP_FMAC3 vd__Consignment * FASTCALL soap_in_vd__Consignment(struct soap *soap, const char *tag, vd__Consignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Consignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Consignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Consignment *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__Consignment*)a)->id, 0, -1))
		return NULL;
	if(soap_s2string(soap, soap_attr_value(soap, "partOf", 0), &((vd__Consignment*)a)->partOf, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	size_t soap_flag_sourceStockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "dic:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Product(soap, "vd:product", &(a->vd__Batch::product), "dic:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "dic:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "dic:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "dic:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "dic:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "dic:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", &(a->vd__Consignment::sourceStockEntry), "vd:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Consignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Consignment, 0, sizeof(vd__Consignment), 0, soap_copy_vd__Consignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Consignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Consignment);
	return this->soap_out(soap, tag?tag:"vd:Consignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Consignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Consignment(soap, this, tag, type);
}

SOAP_FMAC3 vd__Consignment * SOAP_FMAC4 soap_get_vd__Consignment(struct soap *soap, vd__Consignment *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Consignment * FASTCALL soap_instantiate_vd__Consignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Consignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Consignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Consignment);
		ASSIGN_PTR(size, sizeof(vd__Consignment));
		((vd__Consignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Consignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Consignment));
		for(int i = 0; i < n; i++)
			((vd__Consignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Consignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Consignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Consignment %p -> %p\n", q, p));
	*(vd__Consignment*)p = *(vd__Consignment*)q;
}

void vd__Batch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__Batch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerTodic__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerTodic__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerTodic__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerTodic__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerTodic__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__Batch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Batch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Batch(struct soap *soap, const char *tag, int id, const vd__Batch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Batch), type))
		return soap->error;
	if(soap_out_PointerTodic__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTodic__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTodic__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTodic__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTodic__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__Batch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Batch(soap, tag, this, type);
}

SOAP_FMAC3 vd__Batch * FASTCALL soap_in_vd__Batch(struct soap *soap, const char *tag, vd__Batch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Batch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Batch, sizeof(vd__Batch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Batch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Batch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_dateOfProduction1 = 1;
	size_t soap_flag_expiryDate1 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_perishable1 = 1;
	size_t soap_flag_origin1 = 1;
	size_t soap_flag_lowGradeCargo1 = 1;
	size_t soap_flag_packageList1 = 1;
	size_t soap_flag_owner1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "dic:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Product(soap, "vd:product", &(a->vd__Batch::product), "dic:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "dic:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "dic:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "dic:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_dateOfProduction1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction1--;
					continue;
				}
			if(soap_flag_expiryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable1--;
					continue;
				}
			if(soap_flag_origin1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin1--;
					continue;
				}
			if(soap_flag_lowGradeCargo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "dic:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "dic:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Batch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Batch, 0, sizeof(vd__Batch), 0, soap_copy_vd__Batch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Batch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Batch);
	return this->soap_out(soap, tag?tag:"vd:Batch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Batch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Batch(soap, this, tag, type);
}

SOAP_FMAC3 vd__Batch * SOAP_FMAC4 soap_get_vd__Batch(struct soap *soap, vd__Batch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Batch * FASTCALL soap_instantiate_vd__Batch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Batch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Batch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:Consignment")) {
		cp->type = SOAP_TYPE_vd__Consignment;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Consignment);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Consignment));
			((vd__Consignment*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Consignment[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Consignment));
			for(int i = 0; i < n; i++)
				((vd__Consignment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Consignment*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ProductiveBatch")) {
		cp->type = SOAP_TYPE_vd__ProductiveBatch;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ProductiveBatch));
			((vd__ProductiveBatch*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ProductiveBatch));
			for(int i = 0; i < n; i++)
				((vd__ProductiveBatch*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ProductiveBatch*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Batch);
		ASSIGN_PTR(size, sizeof(vd__Batch));
		((vd__Batch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Batch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Batch));
		for(int i = 0; i < n; i++)
			((vd__Batch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Batch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Batch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Batch %p -> %p\n", q, p));
	*(vd__Batch*)p = *(vd__Batch*)q;
}

void vd__VetDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VetDocument::vetDForm = NULL;
	this->vd__VetDocument::vetDType = NULL;
	this->vd__VetDocument::vetDStatus = NULL;
	this->vd__VetDocument::finalized = NULL;
	this->vd__VetDocument::lastUpdateDate = NULL;
	this->vd__VetDocument::__union_VetDocument = 0;
	this->vd__VetDocument::authentication = NULL;
	soap_default_base__String255(soap, &this->vd__VetDocument::precedingVetDocuments);
	this->vd__VetDocument::__sizereferencedDocument = 0;
	this->vd__VetDocument::referencedDocument = NULL;
	this->vd__VetDocument::__sizestatusChange = 0;
	this->vd__VetDocument::statusChange = NULL;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__VetDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentForm(soap, &this->vd__VetDocument::vetDForm);
	soap_serialize_PointerTovd__VetDocumentType(soap, &this->vd__VetDocument::vetDType);
	soap_serialize_PointerTovd__VetDocumentStatus(soap, &this->vd__VetDocument::vetDStatus);
	soap_serialize_PointerTobool(soap, &this->vd__VetDocument::finalized);
	soap_serialize_PointerTotime(soap, &this->vd__VetDocument::lastUpdateDate);
	soap_serialize__vd__union_VetDocument(soap, this->vd__VetDocument::__union_VetDocument, &this->vd__VetDocument::union_VetDocument);
	soap_serialize_PointerTovd__VeterinaryAuthentication(soap, &this->vd__VetDocument::authentication);
	soap_serialize_base__String255(soap, &this->vd__VetDocument::precedingVetDocuments);
	if(this->vd__VetDocument::referencedDocument) {
		for(int i = 0; i < this->vd__VetDocument::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__ReferencedDocument(soap, this->vd__VetDocument::referencedDocument + i);
		}
	}
	if(this->vd__VetDocument::statusChange) {
		for(int i = 0; i < this->vd__VetDocument::__sizestatusChange; i++) {
			soap_serialize_PointerTovd__VetDocumentStatusChange(soap, this->vd__VetDocument::statusChange + i);
		}
	}
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerTodic__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerTodic__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__VetDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocument(struct soap *soap, const char *tag, int id, const vd__VetDocument *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocument), "vd:VetDocument"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTodic__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentForm(soap, "vd:vetDForm", -1, &(a->vd__VetDocument::vetDForm), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentType(soap, "vd:vetDType", -1, &(a->vd__VetDocument::vetDType), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentStatus(soap, "vd:vetDStatus", -1, &(a->vd__VetDocument::vetDStatus), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:finalized", -1, &(a->vd__VetDocument::finalized), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:lastUpdateDate", -1, &(a->vd__VetDocument::lastUpdateDate), ""))
		return soap->error;
	if(soap_out__vd__union_VetDocument(soap, a->vd__VetDocument::__union_VetDocument, &a->vd__VetDocument::union_VetDocument))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryAuthentication(soap, "vd:authentication", -1, &(a->vd__VetDocument::authentication), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:precedingVetDocuments", -1, &(a->vd__VetDocument::precedingVetDocuments), ""))
		return soap->error;
	if(a->vd__VetDocument::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VetDocument::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__ReferencedDocument(soap, "vd:referencedDocument", -1, a->vd__VetDocument::referencedDocument + i, ""))
				return soap->error;
	}
	if(a->vd__VetDocument::statusChange) {
		int i;
		for(i = 0; i < a->vd__VetDocument::__sizestatusChange; i++)
			if(soap_out_PointerTovd__VetDocumentStatusChange(soap, "vd:statusChange", -1, a->vd__VetDocument::statusChange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocument(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocument * FASTCALL soap_in_vd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_vetDForm1 = 1;
	size_t soap_flag_vetDType1 = 1;
	size_t soap_flag_vetDStatus1 = 1;
	size_t soap_flag_finalized1 = 1;
	size_t soap_flag_lastUpdateDate1 = 1;
	size_t soap_flag_union_VetDocument1 = 1;
	size_t soap_flag_authentication1 = 1;
	size_t soap_flag_precedingVetDocuments1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	struct soap_blist *soap_blist_statusChange1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__DocumentType(soap, "vd:type", &(a->vd__Document::type), "dic:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "dic:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_vetDForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentForm(soap, "vd:vetDForm", &(a->vd__VetDocument::vetDForm), "vd:VetDocumentForm"))
				{	soap_flag_vetDForm1--;
					continue;
				}
			if(soap_flag_vetDType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentType(soap, "vd:vetDType", &(a->vd__VetDocument::vetDType), "vd:VetDocumentType"))
				{	soap_flag_vetDType1--;
					continue;
				}
			if(soap_flag_vetDStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentStatus(soap, "vd:vetDStatus", &(a->vd__VetDocument::vetDStatus), "vd:VetDocumentStatus"))
				{	soap_flag_vetDStatus1--;
					continue;
				}
			if(soap_flag_finalized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:finalized", &(a->vd__VetDocument::finalized), "xsd:boolean"))
				{	soap_flag_finalized1--;
					continue;
				}
			if(soap_flag_lastUpdateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:lastUpdateDate", &(a->vd__VetDocument::lastUpdateDate), "xsd:dateTime"))
				{	soap_flag_lastUpdateDate1--;
					continue;
				}
			if(soap_flag_union_VetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VetDocument(soap, &a->vd__VetDocument::__union_VetDocument, &a->vd__VetDocument::union_VetDocument))
				{	soap_flag_union_VetDocument1 = 0;
					continue;
				}
			if(soap_flag_authentication1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryAuthentication(soap, "vd:authentication", &(a->vd__VetDocument::authentication), "vd:VeterinaryAuthentication"))
				{	soap_flag_authentication1--;
					continue;
				}
			if(soap_flag_precedingVetDocuments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:precedingVetDocuments", &(a->vd__VetDocument::precedingVetDocuments), "base:String255"))
				{	soap_flag_precedingVetDocuments1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VetDocument::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->vd__VetDocument::referencedDocument = (vd__ReferencedDocument **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(vd__ReferencedDocument *));
					if(a->vd__VetDocument::referencedDocument == NULL)
						return NULL;
					*a->vd__VetDocument::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ReferencedDocument(soap, "vd:referencedDocument", a->vd__VetDocument::referencedDocument, "vd:ReferencedDocument"))
				{	a->vd__VetDocument::__sizereferencedDocument++;
					a->vd__VetDocument::referencedDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:statusChange", 1, NULL)) {
				if(a->vd__VetDocument::statusChange == NULL) {
					if(soap_blist_statusChange1 == NULL)
						soap_blist_statusChange1 = soap_new_block(soap);
					a->vd__VetDocument::statusChange = (vd__VetDocumentStatusChange **)soap_push_block(soap, soap_blist_statusChange1, sizeof(vd__VetDocumentStatusChange *));
					if(a->vd__VetDocument::statusChange == NULL)
						return NULL;
					*a->vd__VetDocument::statusChange = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocumentStatusChange(soap, "vd:statusChange", a->vd__VetDocument::statusChange, "vd:VetDocumentStatusChange"))
				{	a->vd__VetDocument::__sizestatusChange++;
					a->vd__VetDocument::statusChange = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VetDocument::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->vd__VetDocument::__sizereferencedDocument)
			a->vd__VetDocument::referencedDocument = (vd__ReferencedDocument **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->vd__VetDocument::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(a->vd__VetDocument::statusChange)
			soap_pop_block(soap, soap_blist_statusChange1);
		if(a->vd__VetDocument::__sizestatusChange)
			a->vd__VetDocument::statusChange = (vd__VetDocumentStatusChange **)soap_save_block(soap, soap_blist_statusChange1, NULL, 1);
		else
		{	a->vd__VetDocument::statusChange = NULL;
			if(soap_blist_statusChange1)
				soap_end_block(soap, soap_blist_statusChange1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocument, 0, sizeof(vd__VetDocument), 0, soap_copy_vd__VetDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VetDocument1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VetDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocument);
	return this->soap_out(soap, tag?tag:"vd:VetDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocument(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocument * SOAP_FMAC4 soap_get_vd__VetDocument(struct soap *soap, vd__VetDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocument * FASTCALL soap_instantiate_vd__VetDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
		ASSIGN_PTR(size, sizeof(vd__VetDocument));
		((vd__VetDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
		for(int i = 0; i < n; i++)
			((vd__VetDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocument %p -> %p\n", q, p));
	*(vd__VetDocument*)p = *(vd__VetDocument*)q;
}

void dic__ActivityLocationList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ActivityLocationList::__sizelocation = 0;
	this->dic__ActivityLocationList::location = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__ActivityLocationList::soap_serialize(struct soap *soap) const
{
	if(this->dic__ActivityLocationList::location) {
		for(int i = 0; i < this->dic__ActivityLocationList::__sizelocation; i++) {
			soap_serialize_PointerTodic__BusinessMember(soap, this->dic__ActivityLocationList::location + i);
		}
	}
	/* transient soap skipped */
}

int dic__ActivityLocationList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ActivityLocationList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ActivityLocationList(struct soap *soap, const char *tag, int id, const dic__ActivityLocationList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ActivityLocationList), "dic:ActivityLocationList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__ActivityLocationList::location) {
		int i;
		for(i = 0; i < a->dic__ActivityLocationList::__sizelocation; i++)
			if(soap_out_PointerTodic__BusinessMember(soap, "dic:location", -1, a->dic__ActivityLocationList::location + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__ActivityLocationList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ActivityLocationList(soap, tag, this, type);
}

SOAP_FMAC3 dic__ActivityLocationList * FASTCALL soap_in_dic__ActivityLocationList(struct soap *soap, const char *tag, dic__ActivityLocationList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ActivityLocationList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ActivityLocationList, sizeof(dic__ActivityLocationList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ActivityLocationList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ActivityLocationList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_location1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:location", 1, NULL)) {
				if(a->dic__ActivityLocationList::location == NULL) {
					if(soap_blist_location1 == NULL)
						soap_blist_location1 = soap_new_block(soap);
					a->dic__ActivityLocationList::location = (dic__BusinessMember **)soap_push_block(soap, soap_blist_location1, sizeof(dic__BusinessMember *));
					if(a->dic__ActivityLocationList::location == NULL)
						return NULL;
					*a->dic__ActivityLocationList::location = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__BusinessMember(soap, "dic:location", a->dic__ActivityLocationList::location, "dic:BusinessMember"))
				{	a->dic__ActivityLocationList::__sizelocation++;
					a->dic__ActivityLocationList::location = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ActivityLocationList::location)
			soap_pop_block(soap, soap_blist_location1);
		if(a->dic__ActivityLocationList::__sizelocation)
			a->dic__ActivityLocationList::location = (dic__BusinessMember **)soap_save_block(soap, soap_blist_location1, NULL, 1);
		else
		{	a->dic__ActivityLocationList::location = NULL;
			if(soap_blist_location1)
				soap_end_block(soap, soap_blist_location1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ActivityLocationList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ActivityLocationList, 0, sizeof(dic__ActivityLocationList), 0, soap_copy_dic__ActivityLocationList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ActivityLocationList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ActivityLocationList);
	return this->soap_out(soap, tag?tag:"dic:ActivityLocationList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ActivityLocationList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ActivityLocationList(soap, this, tag, type);
}

SOAP_FMAC3 dic__ActivityLocationList * SOAP_FMAC4 soap_get_dic__ActivityLocationList(struct soap *soap, dic__ActivityLocationList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ActivityLocationList * FASTCALL soap_instantiate_dic__ActivityLocationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ActivityLocationList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ActivityLocationList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ActivityLocationList);
		ASSIGN_PTR(size, sizeof(dic__ActivityLocationList));
		((dic__ActivityLocationList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ActivityLocationList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ActivityLocationList));
		for(int i = 0; i < n; i++)
			((dic__ActivityLocationList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ActivityLocationList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ActivityLocationList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ActivityLocationList %p -> %p\n", q, p));
	*(dic__ActivityLocationList*)p = *(dic__ActivityLocationList*)q;
}

void dic__ResearchMethodList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ResearchMethodList::__sizemethod = 0;
	this->dic__ResearchMethodList::method = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__ResearchMethodList::soap_serialize(struct soap *soap) const
{
	if(this->dic__ResearchMethodList::method) {
		for(int i = 0; i < this->dic__ResearchMethodList::__sizemethod; i++) {
			soap_serialize_PointerTodic__ResearchMethod(soap, this->dic__ResearchMethodList::method + i);
		}
	}
	/* transient soap skipped */
}

int dic__ResearchMethodList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ResearchMethodList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ResearchMethodList(struct soap *soap, const char *tag, int id, const dic__ResearchMethodList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ResearchMethodList), "dic:ResearchMethodList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__ResearchMethodList::method) {
		int i;
		for(i = 0; i < a->dic__ResearchMethodList::__sizemethod; i++)
			if(soap_out_PointerTodic__ResearchMethod(soap, "dic:method", -1, a->dic__ResearchMethodList::method + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__ResearchMethodList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ResearchMethodList(soap, tag, this, type);
}

SOAP_FMAC3 dic__ResearchMethodList * FASTCALL soap_in_dic__ResearchMethodList(struct soap *soap, const char *tag, dic__ResearchMethodList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ResearchMethodList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ResearchMethodList, sizeof(dic__ResearchMethodList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ResearchMethodList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ResearchMethodList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_method1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:method", 1, NULL)) {
				if(a->dic__ResearchMethodList::method == NULL) {
					if(soap_blist_method1 == NULL)
						soap_blist_method1 = soap_new_block(soap);
					a->dic__ResearchMethodList::method = (dic__ResearchMethod **)soap_push_block(soap, soap_blist_method1, sizeof(dic__ResearchMethod *));
					if(a->dic__ResearchMethodList::method == NULL)
						return NULL;
					*a->dic__ResearchMethodList::method = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__ResearchMethod(soap, "dic:method", a->dic__ResearchMethodList::method, "dic:ResearchMethod"))
				{	a->dic__ResearchMethodList::__sizemethod++;
					a->dic__ResearchMethodList::method = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ResearchMethodList::method)
			soap_pop_block(soap, soap_blist_method1);
		if(a->dic__ResearchMethodList::__sizemethod)
			a->dic__ResearchMethodList::method = (dic__ResearchMethod **)soap_save_block(soap, soap_blist_method1, NULL, 1);
		else
		{	a->dic__ResearchMethodList::method = NULL;
			if(soap_blist_method1)
				soap_end_block(soap, soap_blist_method1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ResearchMethodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ResearchMethodList, 0, sizeof(dic__ResearchMethodList), 0, soap_copy_dic__ResearchMethodList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ResearchMethodList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ResearchMethodList);
	return this->soap_out(soap, tag?tag:"dic:ResearchMethodList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ResearchMethodList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ResearchMethodList(soap, this, tag, type);
}

SOAP_FMAC3 dic__ResearchMethodList * SOAP_FMAC4 soap_get_dic__ResearchMethodList(struct soap *soap, dic__ResearchMethodList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ResearchMethodList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ResearchMethodList * FASTCALL soap_instantiate_dic__ResearchMethodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ResearchMethodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ResearchMethodList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ResearchMethodList);
		ASSIGN_PTR(size, sizeof(dic__ResearchMethodList));
		((dic__ResearchMethodList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ResearchMethodList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ResearchMethodList));
		for(int i = 0; i < n; i++)
			((dic__ResearchMethodList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ResearchMethodList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ResearchMethodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ResearchMethodList %p -> %p\n", q, p));
	*(dic__ResearchMethodList*)p = *(dic__ResearchMethodList*)q;
}

void dic__AnimalDiseaseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__AnimalDiseaseList::__sizedisease = 0;
	this->dic__AnimalDiseaseList::disease = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__AnimalDiseaseList::soap_serialize(struct soap *soap) const
{
	if(this->dic__AnimalDiseaseList::disease) {
		for(int i = 0; i < this->dic__AnimalDiseaseList::__sizedisease; i++) {
			soap_serialize_PointerTodic__AnimalDisease(soap, this->dic__AnimalDiseaseList::disease + i);
		}
	}
	/* transient soap skipped */
}

int dic__AnimalDiseaseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__AnimalDiseaseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__AnimalDiseaseList(struct soap *soap, const char *tag, int id, const dic__AnimalDiseaseList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__AnimalDiseaseList), "dic:AnimalDiseaseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__AnimalDiseaseList::disease) {
		int i;
		for(i = 0; i < a->dic__AnimalDiseaseList::__sizedisease; i++)
			if(soap_out_PointerTodic__AnimalDisease(soap, "dic:disease", -1, a->dic__AnimalDiseaseList::disease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__AnimalDiseaseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__AnimalDiseaseList(soap, tag, this, type);
}

SOAP_FMAC3 dic__AnimalDiseaseList * FASTCALL soap_in_dic__AnimalDiseaseList(struct soap *soap, const char *tag, dic__AnimalDiseaseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__AnimalDiseaseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__AnimalDiseaseList, sizeof(dic__AnimalDiseaseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__AnimalDiseaseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__AnimalDiseaseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_disease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:disease", 1, NULL)) {
				if(a->dic__AnimalDiseaseList::disease == NULL) {
					if(soap_blist_disease1 == NULL)
						soap_blist_disease1 = soap_new_block(soap);
					a->dic__AnimalDiseaseList::disease = (dic__AnimalDisease **)soap_push_block(soap, soap_blist_disease1, sizeof(dic__AnimalDisease *));
					if(a->dic__AnimalDiseaseList::disease == NULL)
						return NULL;
					*a->dic__AnimalDiseaseList::disease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__AnimalDisease(soap, "dic:disease", a->dic__AnimalDiseaseList::disease, "dic:AnimalDisease"))
				{	a->dic__AnimalDiseaseList::__sizedisease++;
					a->dic__AnimalDiseaseList::disease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__AnimalDiseaseList::disease)
			soap_pop_block(soap, soap_blist_disease1);
		if(a->dic__AnimalDiseaseList::__sizedisease)
			a->dic__AnimalDiseaseList::disease = (dic__AnimalDisease **)soap_save_block(soap, soap_blist_disease1, NULL, 1);
		else
		{	a->dic__AnimalDiseaseList::disease = NULL;
			if(soap_blist_disease1)
				soap_end_block(soap, soap_blist_disease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__AnimalDiseaseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__AnimalDiseaseList, 0, sizeof(dic__AnimalDiseaseList), 0, soap_copy_dic__AnimalDiseaseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__AnimalDiseaseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__AnimalDiseaseList);
	return this->soap_out(soap, tag?tag:"dic:AnimalDiseaseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__AnimalDiseaseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__AnimalDiseaseList(soap, this, tag, type);
}

SOAP_FMAC3 dic__AnimalDiseaseList * SOAP_FMAC4 soap_get_dic__AnimalDiseaseList(struct soap *soap, dic__AnimalDiseaseList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__AnimalDiseaseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__AnimalDiseaseList * FASTCALL soap_instantiate_dic__AnimalDiseaseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__AnimalDiseaseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__AnimalDiseaseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__AnimalDiseaseList);
		ASSIGN_PTR(size, sizeof(dic__AnimalDiseaseList));
		((dic__AnimalDiseaseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__AnimalDiseaseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__AnimalDiseaseList));
		for(int i = 0; i < n; i++)
			((dic__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__AnimalDiseaseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__AnimalDiseaseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__AnimalDiseaseList %p -> %p\n", q, p));
	*(dic__AnimalDiseaseList*)p = *(dic__AnimalDiseaseList*)q;
}

void dic__RegionalizationShippingRuleList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationShippingRuleList::__sizerule = 0;
	this->dic__RegionalizationShippingRuleList::rule = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__RegionalizationShippingRuleList::soap_serialize(struct soap *soap) const
{
	if(this->dic__RegionalizationShippingRuleList::rule) {
		for(int i = 0; i < this->dic__RegionalizationShippingRuleList::__sizerule; i++) {
			soap_serialize_PointerTodic__RegionalizationShippingRule(soap, this->dic__RegionalizationShippingRuleList::rule + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionalizationShippingRuleList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationShippingRuleList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationShippingRuleList(struct soap *soap, const char *tag, int id, const dic__RegionalizationShippingRuleList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationShippingRuleList), "dic:RegionalizationShippingRuleList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__RegionalizationShippingRuleList::rule) {
		int i;
		for(i = 0; i < a->dic__RegionalizationShippingRuleList::__sizerule; i++)
			if(soap_out_PointerTodic__RegionalizationShippingRule(soap, "dic:rule", -1, a->dic__RegionalizationShippingRuleList::rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationShippingRuleList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationShippingRuleList(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRuleList * FASTCALL soap_in_dic__RegionalizationShippingRuleList(struct soap *soap, const char *tag, dic__RegionalizationShippingRuleList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationShippingRuleList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationShippingRuleList, sizeof(dic__RegionalizationShippingRuleList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationShippingRuleList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationShippingRuleList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_rule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:rule", 1, NULL)) {
				if(a->dic__RegionalizationShippingRuleList::rule == NULL) {
					if(soap_blist_rule1 == NULL)
						soap_blist_rule1 = soap_new_block(soap);
					a->dic__RegionalizationShippingRuleList::rule = (dic__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_rule1, sizeof(dic__RegionalizationShippingRule *));
					if(a->dic__RegionalizationShippingRuleList::rule == NULL)
						return NULL;
					*a->dic__RegionalizationShippingRuleList::rule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationShippingRule(soap, "dic:rule", a->dic__RegionalizationShippingRuleList::rule, "dic:RegionalizationShippingRule"))
				{	a->dic__RegionalizationShippingRuleList::__sizerule++;
					a->dic__RegionalizationShippingRuleList::rule = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationShippingRuleList::rule)
			soap_pop_block(soap, soap_blist_rule1);
		if(a->dic__RegionalizationShippingRuleList::__sizerule)
			a->dic__RegionalizationShippingRuleList::rule = (dic__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_rule1, NULL, 1);
		else
		{	a->dic__RegionalizationShippingRuleList::rule = NULL;
			if(soap_blist_rule1)
				soap_end_block(soap, soap_blist_rule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationShippingRuleList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationShippingRuleList, 0, sizeof(dic__RegionalizationShippingRuleList), 0, soap_copy_dic__RegionalizationShippingRuleList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationShippingRuleList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationShippingRuleList);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationShippingRuleList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationShippingRuleList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationShippingRuleList(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRuleList * SOAP_FMAC4 soap_get_dic__RegionalizationShippingRuleList(struct soap *soap, dic__RegionalizationShippingRuleList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationShippingRuleList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationShippingRuleList * FASTCALL soap_instantiate_dic__RegionalizationShippingRuleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationShippingRuleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationShippingRuleList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRuleList);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationShippingRuleList));
		((dic__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRuleList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationShippingRuleList));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationShippingRuleList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationShippingRuleList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationShippingRuleList %p -> %p\n", q, p));
	*(dic__RegionalizationShippingRuleList*)p = *(dic__RegionalizationShippingRuleList*)q;
}

void dic__RegionalizationRegionStatusList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationRegionStatusList::__sizestatus = 0;
	this->dic__RegionalizationRegionStatusList::status = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__RegionalizationRegionStatusList::soap_serialize(struct soap *soap) const
{
	if(this->dic__RegionalizationRegionStatusList::status) {
		for(int i = 0; i < this->dic__RegionalizationRegionStatusList::__sizestatus; i++) {
			soap_serialize_PointerTodic__RegionalizationRegionStatus(soap, this->dic__RegionalizationRegionStatusList::status + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionalizationRegionStatusList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationRegionStatusList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationRegionStatusList(struct soap *soap, const char *tag, int id, const dic__RegionalizationRegionStatusList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationRegionStatusList), "dic:RegionalizationRegionStatusList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__RegionalizationRegionStatusList::status) {
		int i;
		for(i = 0; i < a->dic__RegionalizationRegionStatusList::__sizestatus; i++)
			if(soap_out_PointerTodic__RegionalizationRegionStatus(soap, "dic:status", -1, a->dic__RegionalizationRegionStatusList::status + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationRegionStatusList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationRegionStatusList(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatusList * FASTCALL soap_in_dic__RegionalizationRegionStatusList(struct soap *soap, const char *tag, dic__RegionalizationRegionStatusList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationRegionStatusList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationRegionStatusList, sizeof(dic__RegionalizationRegionStatusList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationRegionStatusList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationRegionStatusList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_status1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:status", 1, NULL)) {
				if(a->dic__RegionalizationRegionStatusList::status == NULL) {
					if(soap_blist_status1 == NULL)
						soap_blist_status1 = soap_new_block(soap);
					a->dic__RegionalizationRegionStatusList::status = (dic__RegionalizationRegionStatus **)soap_push_block(soap, soap_blist_status1, sizeof(dic__RegionalizationRegionStatus *));
					if(a->dic__RegionalizationRegionStatusList::status == NULL)
						return NULL;
					*a->dic__RegionalizationRegionStatusList::status = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationRegionStatus(soap, "dic:status", a->dic__RegionalizationRegionStatusList::status, "dic:RegionalizationRegionStatus"))
				{	a->dic__RegionalizationRegionStatusList::__sizestatus++;
					a->dic__RegionalizationRegionStatusList::status = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationRegionStatusList::status)
			soap_pop_block(soap, soap_blist_status1);
		if(a->dic__RegionalizationRegionStatusList::__sizestatus)
			a->dic__RegionalizationRegionStatusList::status = (dic__RegionalizationRegionStatus **)soap_save_block(soap, soap_blist_status1, NULL, 1);
		else
		{	a->dic__RegionalizationRegionStatusList::status = NULL;
			if(soap_blist_status1)
				soap_end_block(soap, soap_blist_status1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationRegionStatusList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationRegionStatusList, 0, sizeof(dic__RegionalizationRegionStatusList), 0, soap_copy_dic__RegionalizationRegionStatusList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationRegionStatusList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationRegionStatusList);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationRegionStatusList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationRegionStatusList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationRegionStatusList(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatusList * SOAP_FMAC4 soap_get_dic__RegionalizationRegionStatusList(struct soap *soap, dic__RegionalizationRegionStatusList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationRegionStatusList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationRegionStatusList * FASTCALL soap_instantiate_dic__RegionalizationRegionStatusList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationRegionStatusList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationRegionStatusList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatusList);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationRegionStatusList));
		((dic__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatusList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRegionStatusList));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationRegionStatusList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationRegionStatusList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationRegionStatusList %p -> %p\n", q, p));
	*(dic__RegionalizationRegionStatusList*)p = *(dic__RegionalizationRegionStatusList*)q;
}

void dic__RegionalizationConditionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationConditionList::__sizecondition = 0;
	this->dic__RegionalizationConditionList::condition = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__RegionalizationConditionList::soap_serialize(struct soap *soap) const
{
	if(this->dic__RegionalizationConditionList::condition) {
		for(int i = 0; i < this->dic__RegionalizationConditionList::__sizecondition; i++) {
			soap_serialize_PointerTodic__RegionalizationCondition(soap, this->dic__RegionalizationConditionList::condition + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionalizationConditionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationConditionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationConditionList(struct soap *soap, const char *tag, int id, const dic__RegionalizationConditionList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationConditionList), "dic:RegionalizationConditionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__RegionalizationConditionList::condition) {
		int i;
		for(i = 0; i < a->dic__RegionalizationConditionList::__sizecondition; i++)
			if(soap_out_PointerTodic__RegionalizationCondition(soap, "dic:condition", -1, a->dic__RegionalizationConditionList::condition + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationConditionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationConditionList(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationConditionList * FASTCALL soap_in_dic__RegionalizationConditionList(struct soap *soap, const char *tag, dic__RegionalizationConditionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationConditionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationConditionList, sizeof(dic__RegionalizationConditionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationConditionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationConditionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:condition", 1, NULL)) {
				if(a->dic__RegionalizationConditionList::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->dic__RegionalizationConditionList::condition = (dic__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(dic__RegionalizationCondition *));
					if(a->dic__RegionalizationConditionList::condition == NULL)
						return NULL;
					*a->dic__RegionalizationConditionList::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationCondition(soap, "dic:condition", a->dic__RegionalizationConditionList::condition, "dic:RegionalizationCondition"))
				{	a->dic__RegionalizationConditionList::__sizecondition++;
					a->dic__RegionalizationConditionList::condition = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationConditionList::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->dic__RegionalizationConditionList::__sizecondition)
			a->dic__RegionalizationConditionList::condition = (dic__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->dic__RegionalizationConditionList::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationConditionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationConditionList, 0, sizeof(dic__RegionalizationConditionList), 0, soap_copy_dic__RegionalizationConditionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationConditionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationConditionList);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationConditionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationConditionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationConditionList(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationConditionList * SOAP_FMAC4 soap_get_dic__RegionalizationConditionList(struct soap *soap, dic__RegionalizationConditionList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationConditionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationConditionList * FASTCALL soap_instantiate_dic__RegionalizationConditionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationConditionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationConditionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionList);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationConditionList));
		((dic__RegionalizationConditionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationConditionList));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationConditionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationConditionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationConditionList %p -> %p\n", q, p));
	*(dic__RegionalizationConditionList*)p = *(dic__RegionalizationConditionList*)q;
}

void dic__Area::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__Address::country = NULL;
	this->dic__Address::federalDistrict = NULL;
	this->dic__Address::region = NULL;
	this->dic__Address::district = NULL;
	this->dic__Address::locality = NULL;
	this->dic__Address::subLocality = NULL;
	this->dic__Address::street = NULL;
	soap_default_base__String255(soap, &this->dic__Address::house);
	soap_default_base__String255(soap, &this->dic__Address::building);
	soap_default_base__String255(soap, &this->dic__Address::room);
	soap_default_base__String255(soap, &this->dic__Address::postIndex);
	soap_default_base__String255(soap, &this->dic__Address::postBox);
	this->dic__Address::additionalInfo = NULL;
	this->dic__Address::addressView = NULL;
	this->dic__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void dic__Area::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Country(soap, &this->dic__Address::country);
	soap_serialize_PointerTodic__FederalDistrict(soap, &this->dic__Address::federalDistrict);
	soap_serialize_PointerTodic__Region(soap, &this->dic__Address::region);
	soap_serialize_PointerTodic__District(soap, &this->dic__Address::district);
	soap_serialize_PointerTodic__Locality(soap, &this->dic__Address::locality);
	soap_serialize_PointerTodic__Locality(soap, &this->dic__Address::subLocality);
	soap_serialize_PointerTodic__Street(soap, &this->dic__Address::street);
	soap_serialize_base__String255(soap, &this->dic__Address::house);
	soap_serialize_base__String255(soap, &this->dic__Address::building);
	soap_serialize_base__String255(soap, &this->dic__Address::room);
	soap_serialize_base__String255(soap, &this->dic__Address::postIndex);
	soap_serialize_base__String255(soap, &this->dic__Address::postBox);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::additionalInfo);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::addressView);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::enAddressView);
	/* transient soap skipped */
}

int dic__Area::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Area(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Area(struct soap *soap, const char *tag, int id, const dic__Area *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Area), "dic:Area"))
		return soap->error;
	if(soap_out_PointerTodic__Country(soap, "dic:country", -1, &(a->dic__Address::country), ""))
		return soap->error;
	if(soap_out_PointerTodic__FederalDistrict(soap, "dic:federalDistrict", -1, &(a->dic__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerTodic__Region(soap, "dic:region", -1, &(a->dic__Address::region), ""))
		return soap->error;
	if(soap_out_PointerTodic__District(soap, "dic:district", -1, &(a->dic__Address::district), ""))
		return soap->error;
	if(soap_out_PointerTodic__Locality(soap, "dic:locality", -1, &(a->dic__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerTodic__Locality(soap, "dic:subLocality", -1, &(a->dic__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerTodic__Street(soap, "dic:street", -1, &(a->dic__Address::street), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:house", -1, &(a->dic__Address::house), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:building", -1, &(a->dic__Address::building), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:room", -1, &(a->dic__Address::room), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:postIndex", -1, &(a->dic__Address::postIndex), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:postBox", -1, &(a->dic__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:additionalInfo", -1, &(a->dic__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:addressView", -1, &(a->dic__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:enAddressView", -1, &(a->dic__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Area::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Area(soap, tag, this, type);
}

SOAP_FMAC3 dic__Area * FASTCALL soap_in_dic__Area(struct soap *soap, const char *tag, dic__Area *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Area *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Area, sizeof(dic__Area), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Area) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Area *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country2 = 1;
	size_t soap_flag_federalDistrict2 = 1;
	size_t soap_flag_region2 = 1;
	size_t soap_flag_district2 = 1;
	size_t soap_flag_locality2 = 1;
	size_t soap_flag_subLocality2 = 1;
	size_t soap_flag_street2 = 1;
	size_t soap_flag_house2 = 1;
	size_t soap_flag_building2 = 1;
	size_t soap_flag_room2 = 1;
	size_t soap_flag_postIndex2 = 1;
	size_t soap_flag_postBox2 = 1;
	size_t soap_flag_additionalInfo2 = 1;
	size_t soap_flag_addressView2 = 1;
	size_t soap_flag_enAddressView2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Country(soap, "dic:country", &(a->dic__Address::country), "dic:Country"))
				{	soap_flag_country2--;
					continue;
				}
			if(soap_flag_federalDistrict2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__FederalDistrict(soap, "dic:federalDistrict", &(a->dic__Address::federalDistrict), "dic:FederalDistrict"))
				{	soap_flag_federalDistrict2--;
					continue;
				}
			if(soap_flag_region2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Region(soap, "dic:region", &(a->dic__Address::region), "dic:Region"))
				{	soap_flag_region2--;
					continue;
				}
			if(soap_flag_district2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__District(soap, "dic:district", &(a->dic__Address::district), "dic:District"))
				{	soap_flag_district2--;
					continue;
				}
			if(soap_flag_locality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Locality(soap, "dic:locality", &(a->dic__Address::locality), "dic:Locality"))
				{	soap_flag_locality2--;
					continue;
				}
			if(soap_flag_subLocality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Locality(soap, "dic:subLocality", &(a->dic__Address::subLocality), "dic:Locality"))
				{	soap_flag_subLocality2--;
					continue;
				}
			if(soap_flag_street2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Street(soap, "dic:street", &(a->dic__Address::street), "dic:Street"))
				{	soap_flag_street2--;
					continue;
				}
			if(soap_flag_house2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:house", &(a->dic__Address::house), "base:String255"))
				{	soap_flag_house2--;
					continue;
				}
			if(soap_flag_building2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:building", &(a->dic__Address::building), "base:String255"))
				{	soap_flag_building2--;
					continue;
				}
			if(soap_flag_room2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:room", &(a->dic__Address::room), "base:String255"))
				{	soap_flag_room2--;
					continue;
				}
			if(soap_flag_postIndex2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:postIndex", &(a->dic__Address::postIndex), "base:String255"))
				{	soap_flag_postIndex2--;
					continue;
				}
			if(soap_flag_postBox2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:postBox", &(a->dic__Address::postBox), "base:String255"))
				{	soap_flag_postBox2--;
					continue;
				}
			if(soap_flag_additionalInfo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:additionalInfo", &(a->dic__Address::additionalInfo), "base:NText"))
				{	soap_flag_additionalInfo2--;
					continue;
				}
			if(soap_flag_addressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:addressView", &(a->dic__Address::addressView), "base:NText"))
				{	soap_flag_addressView2--;
					continue;
				}
			if(soap_flag_enAddressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:enAddressView", &(a->dic__Address::enAddressView), "base:NText"))
				{	soap_flag_enAddressView2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Area *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Area, 0, sizeof(dic__Area), 0, soap_copy_dic__Area);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Area::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Area);
	return this->soap_out(soap, tag?tag:"dic:Area", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Area::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Area(soap, this, tag, type);
}

SOAP_FMAC3 dic__Area * SOAP_FMAC4 soap_get_dic__Area(struct soap *soap, dic__Area *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Area * FASTCALL soap_instantiate_dic__Area(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Area(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Area, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Area);
		ASSIGN_PTR(size, sizeof(dic__Area));
		((dic__Area*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Area[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Area));
		for(int i = 0; i < n; i++)
			((dic__Area*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Area*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Area(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Area %p -> %p\n", q, p));
	*(dic__Area*)p = *(dic__Area*)q;
}

void dic__RegionalizationRegionStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationRegionStatus::referenceNumber = NULL;
	this->dic__RegionalizationRegionStatus::r13nZone = NULL;
	this->dic__RegionalizationRegionStatus::__sizeexcludedR13nZone = 0;
	this->dic__RegionalizationRegionStatus::excludedR13nZone = NULL;
	this->dic__RegionalizationRegionStatus::__sizer13nStatus = 0;
	this->dic__RegionalizationRegionStatus::r13nStatus = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__RegionalizationRegionStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->dic__RegionalizationRegionStatus::referenceNumber);
	soap_serialize_PointerTodic__Area(soap, &this->dic__RegionalizationRegionStatus::r13nZone);
	if(this->dic__RegionalizationRegionStatus::excludedR13nZone) {
		for(int i = 0; i < this->dic__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++) {
			soap_serialize_PointerTodic__Area(soap, this->dic__RegionalizationRegionStatus::excludedR13nZone + i);
		}
	}
	if(this->dic__RegionalizationRegionStatus::r13nStatus) {
		for(int i = 0; i < this->dic__RegionalizationRegionStatus::__sizer13nStatus; i++) {
			soap_serialize_PointerTodic__RegionalizationStatus(soap, this->dic__RegionalizationRegionStatus::r13nStatus + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__RegionalizationRegionStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationRegionStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, const dic__RegionalizationRegionStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationRegionStatus), "dic:RegionalizationRegionStatus"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "dic:referenceNumber", -1, &(a->dic__RegionalizationRegionStatus::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerTodic__Area(soap, "dic:r13nZone", -1, &(a->dic__RegionalizationRegionStatus::r13nZone), ""))
		return soap->error;
	if(a->dic__RegionalizationRegionStatus::excludedR13nZone) {
		int i;
		for(i = 0; i < a->dic__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++)
			if(soap_out_PointerTodic__Area(soap, "dic:excludedR13nZone", -1, a->dic__RegionalizationRegionStatus::excludedR13nZone + i, ""))
				return soap->error;
	}
	if(a->dic__RegionalizationRegionStatus::r13nStatus) {
		int i;
		for(i = 0; i < a->dic__RegionalizationRegionStatus::__sizer13nStatus; i++)
			if(soap_out_PointerTodic__RegionalizationStatus(soap, "dic:r13nStatus", -1, a->dic__RegionalizationRegionStatus::r13nStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationRegionStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationRegionStatus(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus * FASTCALL soap_in_dic__RegionalizationRegionStatus(struct soap *soap, const char *tag, dic__RegionalizationRegionStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationRegionStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationRegionStatus, sizeof(dic__RegionalizationRegionStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationRegionStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationRegionStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_r13nZone1 = 1;
	struct soap_blist *soap_blist_excludedR13nZone1 = NULL;
	struct soap_blist *soap_blist_r13nStatus1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "dic:referenceNumber", &(a->dic__RegionalizationRegionStatus::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_r13nZone1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Area(soap, "dic:r13nZone", &(a->dic__RegionalizationRegionStatus::r13nZone), "dic:Area"))
				{	soap_flag_r13nZone1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:excludedR13nZone", 1, NULL)) {
				if(a->dic__RegionalizationRegionStatus::excludedR13nZone == NULL) {
					if(soap_blist_excludedR13nZone1 == NULL)
						soap_blist_excludedR13nZone1 = soap_new_block(soap);
					a->dic__RegionalizationRegionStatus::excludedR13nZone = (dic__Area **)soap_push_block(soap, soap_blist_excludedR13nZone1, sizeof(dic__Area *));
					if(a->dic__RegionalizationRegionStatus::excludedR13nZone == NULL)
						return NULL;
					*a->dic__RegionalizationRegionStatus::excludedR13nZone = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Area(soap, "dic:excludedR13nZone", a->dic__RegionalizationRegionStatus::excludedR13nZone, "dic:Area"))
				{	a->dic__RegionalizationRegionStatus::__sizeexcludedR13nZone++;
					a->dic__RegionalizationRegionStatus::excludedR13nZone = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:r13nStatus", 1, NULL)) {
				if(a->dic__RegionalizationRegionStatus::r13nStatus == NULL) {
					if(soap_blist_r13nStatus1 == NULL)
						soap_blist_r13nStatus1 = soap_new_block(soap);
					a->dic__RegionalizationRegionStatus::r13nStatus = (dic__RegionalizationStatus **)soap_push_block(soap, soap_blist_r13nStatus1, sizeof(dic__RegionalizationStatus *));
					if(a->dic__RegionalizationRegionStatus::r13nStatus == NULL)
						return NULL;
					*a->dic__RegionalizationRegionStatus::r13nStatus = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationStatus(soap, "dic:r13nStatus", a->dic__RegionalizationRegionStatus::r13nStatus, "dic:RegionalizationStatus"))
				{	a->dic__RegionalizationRegionStatus::__sizer13nStatus++;
					a->dic__RegionalizationRegionStatus::r13nStatus = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationRegionStatus::excludedR13nZone)
			soap_pop_block(soap, soap_blist_excludedR13nZone1);
		if(a->dic__RegionalizationRegionStatus::__sizeexcludedR13nZone)
			a->dic__RegionalizationRegionStatus::excludedR13nZone = (dic__Area **)soap_save_block(soap, soap_blist_excludedR13nZone1, NULL, 1);
		else
		{	a->dic__RegionalizationRegionStatus::excludedR13nZone = NULL;
			if(soap_blist_excludedR13nZone1)
				soap_end_block(soap, soap_blist_excludedR13nZone1);
		}
		if(a->dic__RegionalizationRegionStatus::r13nStatus)
			soap_pop_block(soap, soap_blist_r13nStatus1);
		if(a->dic__RegionalizationRegionStatus::__sizer13nStatus)
			a->dic__RegionalizationRegionStatus::r13nStatus = (dic__RegionalizationStatus **)soap_save_block(soap, soap_blist_r13nStatus1, NULL, 1);
		else
		{	a->dic__RegionalizationRegionStatus::r13nStatus = NULL;
			if(soap_blist_r13nStatus1)
				soap_end_block(soap, soap_blist_r13nStatus1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationRegionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationRegionStatus, 0, sizeof(dic__RegionalizationRegionStatus), 0, soap_copy_dic__RegionalizationRegionStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationRegionStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationRegionStatus);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationRegionStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationRegionStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationRegionStatus(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus * SOAP_FMAC4 soap_get_dic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationRegionStatus * FASTCALL soap_instantiate_dic__RegionalizationRegionStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationRegionStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationRegionStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationRegionStatus));
		((dic__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRegionStatus));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationRegionStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationRegionStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationRegionStatus %p -> %p\n", q, p));
	*(dic__RegionalizationRegionStatus*)p = *(dic__RegionalizationRegionStatus*)q;
}

void dic__RegionalizationStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationStatus::relatedDisease = NULL;
	soap_default_dic__ProsperityType(soap, &this->dic__RegionalizationStatus::prosperity);
	soap_default_dic__VaccinationType(soap, &this->dic__RegionalizationStatus::vaccination);
	/* transient soap skipped */
}

void dic__RegionalizationStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__AnimalDisease(soap, &this->dic__RegionalizationStatus::relatedDisease);
	/* transient soap skipped */
}

int dic__RegionalizationStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationStatus(struct soap *soap, const char *tag, int id, const dic__RegionalizationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationStatus), type))
		return soap->error;
	if(a->dic__RegionalizationStatus::relatedDisease) {
		if(soap_out_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", -1, &a->dic__RegionalizationStatus::relatedDisease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:relatedDisease"))
		return soap->error;
	if(soap_out_dic__ProsperityType(soap, "dic:prosperity", -1, &(a->dic__RegionalizationStatus::prosperity), ""))
		return soap->error;
	if(soap_out_dic__VaccinationType(soap, "dic:vaccination", -1, &(a->dic__RegionalizationStatus::vaccination), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationStatus(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationStatus * FASTCALL soap_in_dic__RegionalizationStatus(struct soap *soap, const char *tag, dic__RegionalizationStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationStatus, sizeof(dic__RegionalizationStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_prosperity1 = 1;
	size_t soap_flag_vaccination1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", &(a->dic__RegionalizationStatus::relatedDisease), "dic:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_prosperity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__ProsperityType(soap, "dic:prosperity", &(a->dic__RegionalizationStatus::prosperity), "dic:ProsperityType"))
				{	soap_flag_prosperity1--;
					continue;
				}
			if(soap_flag_vaccination1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__VaccinationType(soap, "dic:vaccination", &(a->dic__RegionalizationStatus::vaccination), "dic:VaccinationType"))
				{	soap_flag_vaccination1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationStatus, 0, sizeof(dic__RegionalizationStatus), 0, soap_copy_dic__RegionalizationStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relatedDisease1 > 0 || soap_flag_prosperity1 > 0 || soap_flag_vaccination1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__RegionalizationStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationStatus);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationStatus(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationStatus * SOAP_FMAC4 soap_get_dic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationStatus * FASTCALL soap_instantiate_dic__RegionalizationStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationStatus);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationStatus));
		((dic__RegionalizationStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationStatus));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationStatus %p -> %p\n", q, p));
	*(dic__RegionalizationStatus*)p = *(dic__RegionalizationStatus*)q;
}

void dic__RegionalizationShippingRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationShippingRule::referenceNumber = NULL;
	this->dic__RegionalizationShippingRule::fromR13nStatus = NULL;
	this->dic__RegionalizationShippingRule::toR13nStatus = NULL;
	this->dic__RegionalizationShippingRule::__sizecargoType = 0;
	this->dic__RegionalizationShippingRule::cargoType = NULL;
	this->dic__RegionalizationShippingRule::decision = NULL;
	this->dic__RegionalizationShippingRule::__sizerequirement = 0;
	this->dic__RegionalizationShippingRule::requirement = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__RegionalizationShippingRule::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->dic__RegionalizationShippingRule::referenceNumber);
	soap_serialize_PointerTodic__RegionalizationStatus(soap, &this->dic__RegionalizationShippingRule::fromR13nStatus);
	soap_serialize_PointerTodic__RegionalizationStatus(soap, &this->dic__RegionalizationShippingRule::toR13nStatus);
	if(this->dic__RegionalizationShippingRule::cargoType) {
		for(int i = 0; i < this->dic__RegionalizationShippingRule::__sizecargoType; i++) {
			soap_serialize_PointerTodic__SubProduct(soap, this->dic__RegionalizationShippingRule::cargoType + i);
		}
	}
	soap_serialize_PointerTodic__RegionalizationDecision(soap, &this->dic__RegionalizationShippingRule::decision);
	if(this->dic__RegionalizationShippingRule::requirement) {
		for(int i = 0; i < this->dic__RegionalizationShippingRule::__sizerequirement; i++) {
			soap_serialize_PointerTodic__RegionalizationRequirement(soap, this->dic__RegionalizationShippingRule::requirement + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__RegionalizationShippingRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationShippingRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, const dic__RegionalizationShippingRule *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationShippingRule), "dic:RegionalizationShippingRule"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "dic:referenceNumber", -1, &(a->dic__RegionalizationShippingRule::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerTodic__RegionalizationStatus(soap, "dic:fromR13nStatus", -1, &(a->dic__RegionalizationShippingRule::fromR13nStatus), ""))
		return soap->error;
	if(soap_out_PointerTodic__RegionalizationStatus(soap, "dic:toR13nStatus", -1, &(a->dic__RegionalizationShippingRule::toR13nStatus), ""))
		return soap->error;
	if(a->dic__RegionalizationShippingRule::cargoType) {
		int i;
		for(i = 0; i < a->dic__RegionalizationShippingRule::__sizecargoType; i++)
			if(soap_out_PointerTodic__SubProduct(soap, "dic:cargoType", -1, a->dic__RegionalizationShippingRule::cargoType + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTodic__RegionalizationDecision(soap, "dic:decision", -1, &(a->dic__RegionalizationShippingRule::decision), ""))
		return soap->error;
	if(a->dic__RegionalizationShippingRule::requirement) {
		int i;
		for(i = 0; i < a->dic__RegionalizationShippingRule::__sizerequirement; i++)
			if(soap_out_PointerTodic__RegionalizationRequirement(soap, "dic:requirement", -1, a->dic__RegionalizationShippingRule::requirement + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationShippingRule::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationShippingRule(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRule * FASTCALL soap_in_dic__RegionalizationShippingRule(struct soap *soap, const char *tag, dic__RegionalizationShippingRule *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationShippingRule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationShippingRule, sizeof(dic__RegionalizationShippingRule), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationShippingRule) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationShippingRule *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_fromR13nStatus1 = 1;
	size_t soap_flag_toR13nStatus1 = 1;
	struct soap_blist *soap_blist_cargoType1 = NULL;
	size_t soap_flag_decision1 = 1;
	struct soap_blist *soap_blist_requirement1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "dic:referenceNumber", &(a->dic__RegionalizationShippingRule::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_fromR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__RegionalizationStatus(soap, "dic:fromR13nStatus", &(a->dic__RegionalizationShippingRule::fromR13nStatus), "dic:RegionalizationStatus"))
				{	soap_flag_fromR13nStatus1--;
					continue;
				}
			if(soap_flag_toR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__RegionalizationStatus(soap, "dic:toR13nStatus", &(a->dic__RegionalizationShippingRule::toR13nStatus), "dic:RegionalizationStatus"))
				{	soap_flag_toR13nStatus1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:cargoType", 1, NULL)) {
				if(a->dic__RegionalizationShippingRule::cargoType == NULL) {
					if(soap_blist_cargoType1 == NULL)
						soap_blist_cargoType1 = soap_new_block(soap);
					a->dic__RegionalizationShippingRule::cargoType = (dic__SubProduct **)soap_push_block(soap, soap_blist_cargoType1, sizeof(dic__SubProduct *));
					if(a->dic__RegionalizationShippingRule::cargoType == NULL)
						return NULL;
					*a->dic__RegionalizationShippingRule::cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__SubProduct(soap, "dic:cargoType", a->dic__RegionalizationShippingRule::cargoType, "dic:SubProduct"))
				{	a->dic__RegionalizationShippingRule::__sizecargoType++;
					a->dic__RegionalizationShippingRule::cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__RegionalizationDecision(soap, "dic:decision", &(a->dic__RegionalizationShippingRule::decision), "dic:RegionalizationDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:requirement", 1, NULL)) {
				if(a->dic__RegionalizationShippingRule::requirement == NULL) {
					if(soap_blist_requirement1 == NULL)
						soap_blist_requirement1 = soap_new_block(soap);
					a->dic__RegionalizationShippingRule::requirement = (dic__RegionalizationRequirement **)soap_push_block(soap, soap_blist_requirement1, sizeof(dic__RegionalizationRequirement *));
					if(a->dic__RegionalizationShippingRule::requirement == NULL)
						return NULL;
					*a->dic__RegionalizationShippingRule::requirement = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationRequirement(soap, "dic:requirement", a->dic__RegionalizationShippingRule::requirement, "dic:RegionalizationRequirement"))
				{	a->dic__RegionalizationShippingRule::__sizerequirement++;
					a->dic__RegionalizationShippingRule::requirement = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationShippingRule::cargoType)
			soap_pop_block(soap, soap_blist_cargoType1);
		if(a->dic__RegionalizationShippingRule::__sizecargoType)
			a->dic__RegionalizationShippingRule::cargoType = (dic__SubProduct **)soap_save_block(soap, soap_blist_cargoType1, NULL, 1);
		else
		{	a->dic__RegionalizationShippingRule::cargoType = NULL;
			if(soap_blist_cargoType1)
				soap_end_block(soap, soap_blist_cargoType1);
		}
		if(a->dic__RegionalizationShippingRule::requirement)
			soap_pop_block(soap, soap_blist_requirement1);
		if(a->dic__RegionalizationShippingRule::__sizerequirement)
			a->dic__RegionalizationShippingRule::requirement = (dic__RegionalizationRequirement **)soap_save_block(soap, soap_blist_requirement1, NULL, 1);
		else
		{	a->dic__RegionalizationShippingRule::requirement = NULL;
			if(soap_blist_requirement1)
				soap_end_block(soap, soap_blist_requirement1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationShippingRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationShippingRule, 0, sizeof(dic__RegionalizationShippingRule), 0, soap_copy_dic__RegionalizationShippingRule);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationShippingRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationShippingRule);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationShippingRule", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationShippingRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationShippingRule(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRule * SOAP_FMAC4 soap_get_dic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationShippingRule * FASTCALL soap_instantiate_dic__RegionalizationShippingRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationShippingRule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationShippingRule, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationShippingRule));
		((dic__RegionalizationShippingRule*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationShippingRule));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationShippingRule*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationShippingRule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationShippingRule %p -> %p\n", q, p));
	*(dic__RegionalizationShippingRule*)p = *(dic__RegionalizationShippingRule*)q;
}

void dic__RegionalizationRequirement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationRequirement::relatedDisease = NULL;
	soap_default_dic__RegionalizationDecision(soap, &this->dic__RegionalizationRequirement::type);
	this->dic__RegionalizationRequirement::__sizeconditionGroup = 0;
	this->dic__RegionalizationRequirement::conditionGroup = NULL;
	/* transient soap skipped */
}

void dic__RegionalizationRequirement::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__AnimalDisease(soap, &this->dic__RegionalizationRequirement::relatedDisease);
	soap_embedded(soap, &this->dic__RegionalizationRequirement::type, SOAP_TYPE_dic__RegionalizationDecision);
	if(this->dic__RegionalizationRequirement::conditionGroup) {
		for(int i = 0; i < this->dic__RegionalizationRequirement::__sizeconditionGroup; i++) {
			soap_serialize_PointerTodic__RegionalizationConditionGroup(soap, this->dic__RegionalizationRequirement::conditionGroup + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionalizationRequirement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationRequirement(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationRequirement(struct soap *soap, const char *tag, int id, const dic__RegionalizationRequirement *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationRequirement), type))
		return soap->error;
	if(soap_out_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", -1, &(a->dic__RegionalizationRequirement::relatedDisease), ""))
		return soap->error;
	if(soap_out_dic__RegionalizationDecision(soap, "dic:type", -1, &(a->dic__RegionalizationRequirement::type), ""))
		return soap->error;
	if(a->dic__RegionalizationRequirement::conditionGroup) {
		int i;
		for(i = 0; i < a->dic__RegionalizationRequirement::__sizeconditionGroup; i++)
			if(soap_out_PointerTodic__RegionalizationConditionGroup(soap, "dic:conditionGroup", -1, a->dic__RegionalizationRequirement::conditionGroup + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationRequirement::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationRequirement(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationRequirement * FASTCALL soap_in_dic__RegionalizationRequirement(struct soap *soap, const char *tag, dic__RegionalizationRequirement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationRequirement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationRequirement, sizeof(dic__RegionalizationRequirement), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationRequirement) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationRequirement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_conditionGroup1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", &(a->dic__RegionalizationRequirement::relatedDisease), "dic:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__RegionalizationDecision(soap, "dic:type", &(a->dic__RegionalizationRequirement::type), "dic:RegionalizationDecision"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:conditionGroup", 1, NULL)) {
				if(a->dic__RegionalizationRequirement::conditionGroup == NULL) {
					if(soap_blist_conditionGroup1 == NULL)
						soap_blist_conditionGroup1 = soap_new_block(soap);
					a->dic__RegionalizationRequirement::conditionGroup = (dic__RegionalizationConditionGroup **)soap_push_block(soap, soap_blist_conditionGroup1, sizeof(dic__RegionalizationConditionGroup *));
					if(a->dic__RegionalizationRequirement::conditionGroup == NULL)
						return NULL;
					*a->dic__RegionalizationRequirement::conditionGroup = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationConditionGroup(soap, "dic:conditionGroup", a->dic__RegionalizationRequirement::conditionGroup, "dic:RegionalizationConditionGroup"))
				{	a->dic__RegionalizationRequirement::__sizeconditionGroup++;
					a->dic__RegionalizationRequirement::conditionGroup = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationRequirement::conditionGroup)
			soap_pop_block(soap, soap_blist_conditionGroup1);
		if(a->dic__RegionalizationRequirement::__sizeconditionGroup)
			a->dic__RegionalizationRequirement::conditionGroup = (dic__RegionalizationConditionGroup **)soap_save_block(soap, soap_blist_conditionGroup1, NULL, 1);
		else
		{	a->dic__RegionalizationRequirement::conditionGroup = NULL;
			if(soap_blist_conditionGroup1)
				soap_end_block(soap, soap_blist_conditionGroup1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationRequirement, 0, sizeof(dic__RegionalizationRequirement), 0, soap_copy_dic__RegionalizationRequirement);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__RegionalizationRequirement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationRequirement);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationRequirement", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationRequirement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationRequirement(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationRequirement * SOAP_FMAC4 soap_get_dic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationRequirement * FASTCALL soap_instantiate_dic__RegionalizationRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationRequirement, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRequirement);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationRequirement));
		((dic__RegionalizationRequirement*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRequirement[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRequirement));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationRequirement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationRequirement %p -> %p\n", q, p));
	*(dic__RegionalizationRequirement*)p = *(dic__RegionalizationRequirement*)q;
}

void dic__RegionalizationConditionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationConditionGroup::__sizecondition = 0;
	this->dic__RegionalizationConditionGroup::condition = NULL;
	/* transient soap skipped */
}

void dic__RegionalizationConditionGroup::soap_serialize(struct soap *soap) const
{
	if(this->dic__RegionalizationConditionGroup::condition) {
		for(int i = 0; i < this->dic__RegionalizationConditionGroup::__sizecondition; i++) {
			soap_serialize_PointerTodic__RegionalizationCondition(soap, this->dic__RegionalizationConditionGroup::condition + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionalizationConditionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationConditionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, const dic__RegionalizationConditionGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationConditionGroup), type))
		return soap->error;
	if(a->dic__RegionalizationConditionGroup::condition) {
		int i;
		for(i = 0; i < a->dic__RegionalizationConditionGroup::__sizecondition; i++)
			if(soap_out_PointerTodic__RegionalizationCondition(soap, "dic:condition", -1, a->dic__RegionalizationConditionGroup::condition + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationConditionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationConditionGroup(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup * FASTCALL soap_in_dic__RegionalizationConditionGroup(struct soap *soap, const char *tag, dic__RegionalizationConditionGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationConditionGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationConditionGroup, sizeof(dic__RegionalizationConditionGroup), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationConditionGroup) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationConditionGroup *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:condition", 1, NULL)) {
				if(a->dic__RegionalizationConditionGroup::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->dic__RegionalizationConditionGroup::condition = (dic__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(dic__RegionalizationCondition *));
					if(a->dic__RegionalizationConditionGroup::condition == NULL)
						return NULL;
					*a->dic__RegionalizationConditionGroup::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__RegionalizationCondition(soap, "dic:condition", a->dic__RegionalizationConditionGroup::condition, "dic:RegionalizationCondition"))
				{	a->dic__RegionalizationConditionGroup::__sizecondition++;
					a->dic__RegionalizationConditionGroup::condition = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationConditionGroup::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->dic__RegionalizationConditionGroup::__sizecondition)
			a->dic__RegionalizationConditionGroup::condition = (dic__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->dic__RegionalizationConditionGroup::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationConditionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationConditionGroup, 0, sizeof(dic__RegionalizationConditionGroup), 0, soap_copy_dic__RegionalizationConditionGroup);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationConditionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationConditionGroup);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationConditionGroup", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationConditionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationConditionGroup(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup * SOAP_FMAC4 soap_get_dic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationConditionGroup * FASTCALL soap_instantiate_dic__RegionalizationConditionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationConditionGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationConditionGroup, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionGroup);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationConditionGroup));
		((dic__RegionalizationConditionGroup*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionGroup[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationConditionGroup));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationConditionGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationConditionGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationConditionGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationConditionGroup %p -> %p\n", q, p));
	*(dic__RegionalizationConditionGroup*)p = *(dic__RegionalizationConditionGroup*)q;
}

void dic__RegionalizationCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionalizationCondition::referenceNumber = NULL;
	soap_default_base__Text(soap, &this->dic__RegionalizationCondition::text);
	this->dic__RegionalizationCondition::strict = NULL;
	this->dic__RegionalizationCondition::__sizerelatedDisease = 0;
	this->dic__RegionalizationCondition::relatedDisease = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__RegionalizationCondition::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->dic__RegionalizationCondition::referenceNumber);
	soap_serialize_base__Text(soap, &this->dic__RegionalizationCondition::text);
	soap_serialize_PointerTobool(soap, &this->dic__RegionalizationCondition::strict);
	if(this->dic__RegionalizationCondition::relatedDisease) {
		for(int i = 0; i < this->dic__RegionalizationCondition::__sizerelatedDisease; i++) {
			soap_serialize_PointerTodic__AnimalDisease(soap, this->dic__RegionalizationCondition::relatedDisease + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__RegionalizationCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionalizationCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionalizationCondition(struct soap *soap, const char *tag, int id, const dic__RegionalizationCondition *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionalizationCondition), "dic:RegionalizationCondition"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "dic:referenceNumber", -1, &(a->dic__RegionalizationCondition::referenceNumber), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "dic:text", -1, &(a->dic__RegionalizationCondition::text), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:strict", -1, &(a->dic__RegionalizationCondition::strict), ""))
		return soap->error;
	if(a->dic__RegionalizationCondition::relatedDisease) {
		int i;
		for(i = 0; i < a->dic__RegionalizationCondition::__sizerelatedDisease; i++)
			if(soap_out_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", -1, a->dic__RegionalizationCondition::relatedDisease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionalizationCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionalizationCondition(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionalizationCondition * FASTCALL soap_in_dic__RegionalizationCondition(struct soap *soap, const char *tag, dic__RegionalizationCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionalizationCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionalizationCondition, sizeof(dic__RegionalizationCondition), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionalizationCondition) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionalizationCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_strict1 = 1;
	struct soap_blist *soap_blist_relatedDisease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "dic:referenceNumber", &(a->dic__RegionalizationCondition::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "dic:text", &(a->dic__RegionalizationCondition::text), "base:Text"))
				{	soap_flag_text1--;
					continue;
				}
			if(soap_flag_strict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:strict", &(a->dic__RegionalizationCondition::strict), "xsd:boolean"))
				{	soap_flag_strict1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:relatedDisease", 1, NULL)) {
				if(a->dic__RegionalizationCondition::relatedDisease == NULL) {
					if(soap_blist_relatedDisease1 == NULL)
						soap_blist_relatedDisease1 = soap_new_block(soap);
					a->dic__RegionalizationCondition::relatedDisease = (dic__AnimalDisease **)soap_push_block(soap, soap_blist_relatedDisease1, sizeof(dic__AnimalDisease *));
					if(a->dic__RegionalizationCondition::relatedDisease == NULL)
						return NULL;
					*a->dic__RegionalizationCondition::relatedDisease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__AnimalDisease(soap, "dic:relatedDisease", a->dic__RegionalizationCondition::relatedDisease, "dic:AnimalDisease"))
				{	a->dic__RegionalizationCondition::__sizerelatedDisease++;
					a->dic__RegionalizationCondition::relatedDisease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionalizationCondition::relatedDisease)
			soap_pop_block(soap, soap_blist_relatedDisease1);
		if(a->dic__RegionalizationCondition::__sizerelatedDisease)
			a->dic__RegionalizationCondition::relatedDisease = (dic__AnimalDisease **)soap_save_block(soap, soap_blist_relatedDisease1, NULL, 1);
		else
		{	a->dic__RegionalizationCondition::relatedDisease = NULL;
			if(soap_blist_relatedDisease1)
				soap_end_block(soap, soap_blist_relatedDisease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionalizationCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionalizationCondition, 0, sizeof(dic__RegionalizationCondition), 0, soap_copy_dic__RegionalizationCondition);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionalizationCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionalizationCondition);
	return this->soap_out(soap, tag?tag:"dic:RegionalizationCondition", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionalizationCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionalizationCondition(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionalizationCondition * SOAP_FMAC4 soap_get_dic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionalizationCondition * FASTCALL soap_instantiate_dic__RegionalizationCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionalizationCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionalizationCondition, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition);
		ASSIGN_PTR(size, sizeof(dic__RegionalizationCondition));
		((dic__RegionalizationCondition*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionalizationCondition));
		for(int i = 0; i < n; i++)
			((dic__RegionalizationCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionalizationCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionalizationCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionalizationCondition %p -> %p\n", q, p));
	*(dic__RegionalizationCondition*)p = *(dic__RegionalizationCondition*)q;
}

void dic__MedicinalDrug::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__MedicinalDrug::ID = NULL;
	soap_default_base__String255(soap, &this->dic__MedicinalDrug::name);
	soap_default_base__String255(soap, &this->dic__MedicinalDrug::series);
	this->dic__MedicinalDrug::producer = NULL;
	/* transient soap skipped */
}

void dic__MedicinalDrug::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->dic__MedicinalDrug::ID);
	soap_serialize_base__String255(soap, &this->dic__MedicinalDrug::name);
	soap_serialize_base__String255(soap, &this->dic__MedicinalDrug::series);
	soap_serialize_PointerTodic__BusinessMember(soap, &this->dic__MedicinalDrug::producer);
	/* transient soap skipped */
}

int dic__MedicinalDrug::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__MedicinalDrug(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__MedicinalDrug(struct soap *soap, const char *tag, int id, const dic__MedicinalDrug *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__MedicinalDrug), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "dic:ID", -1, &(a->dic__MedicinalDrug::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__MedicinalDrug::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:series", -1, &(a->dic__MedicinalDrug::series), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessMember(soap, "dic:producer", -1, &(a->dic__MedicinalDrug::producer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__MedicinalDrug::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__MedicinalDrug(soap, tag, this, type);
}

SOAP_FMAC3 dic__MedicinalDrug * FASTCALL soap_in_dic__MedicinalDrug(struct soap *soap, const char *tag, dic__MedicinalDrug *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__MedicinalDrug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__MedicinalDrug, sizeof(dic__MedicinalDrug), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__MedicinalDrug) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__MedicinalDrug *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_series1 = 1;
	size_t soap_flag_producer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "dic:ID", &(a->dic__MedicinalDrug::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__MedicinalDrug::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_series1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:series", &(a->dic__MedicinalDrug::series), "base:String255"))
				{	soap_flag_series1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "dic:producer", &(a->dic__MedicinalDrug::producer), "dic:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__MedicinalDrug *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__MedicinalDrug, 0, sizeof(dic__MedicinalDrug), 0, soap_copy_dic__MedicinalDrug);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__MedicinalDrug::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__MedicinalDrug);
	return this->soap_out(soap, tag?tag:"dic:MedicinalDrug", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__MedicinalDrug::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__MedicinalDrug(soap, this, tag, type);
}

SOAP_FMAC3 dic__MedicinalDrug * SOAP_FMAC4 soap_get_dic__MedicinalDrug(struct soap *soap, dic__MedicinalDrug *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__MedicinalDrug * FASTCALL soap_instantiate_dic__MedicinalDrug(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__MedicinalDrug(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__MedicinalDrug, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__MedicinalDrug);
		ASSIGN_PTR(size, sizeof(dic__MedicinalDrug));
		((dic__MedicinalDrug*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__MedicinalDrug[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__MedicinalDrug));
		for(int i = 0; i < n; i++)
			((dic__MedicinalDrug*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__MedicinalDrug*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__MedicinalDrug(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__MedicinalDrug %p -> %p\n", q, p));
	*(dic__MedicinalDrug*)p = *(dic__MedicinalDrug*)q;
}

void dic__ResearchMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__ResearchMethod::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__ResearchMethod::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__ResearchMethod::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__ResearchMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ResearchMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ResearchMethod(struct soap *soap, const char *tag, int id, const dic__ResearchMethod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ResearchMethod), "dic:ResearchMethod"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__ResearchMethod::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__ResearchMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ResearchMethod(soap, tag, this, type);
}

SOAP_FMAC3 dic__ResearchMethod * FASTCALL soap_in_dic__ResearchMethod(struct soap *soap, const char *tag, dic__ResearchMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ResearchMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ResearchMethod, sizeof(dic__ResearchMethod), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ResearchMethod) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ResearchMethod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__ResearchMethod::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ResearchMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ResearchMethod, 0, sizeof(dic__ResearchMethod), 0, soap_copy_dic__ResearchMethod);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ResearchMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ResearchMethod);
	return this->soap_out(soap, tag?tag:"dic:ResearchMethod", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ResearchMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ResearchMethod(soap, this, tag, type);
}

SOAP_FMAC3 dic__ResearchMethod * SOAP_FMAC4 soap_get_dic__ResearchMethod(struct soap *soap, dic__ResearchMethod *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ResearchMethod * FASTCALL soap_instantiate_dic__ResearchMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ResearchMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ResearchMethod, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod);
		ASSIGN_PTR(size, sizeof(dic__ResearchMethod));
		((dic__ResearchMethod*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ResearchMethod));
		for(int i = 0; i < n; i++)
			((dic__ResearchMethod*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ResearchMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ResearchMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ResearchMethod %p -> %p\n", q, p));
	*(dic__ResearchMethod*)p = *(dic__ResearchMethod*)q;
}

void dic__AnimalDisease::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__AnimalDisease::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__AnimalDisease::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__AnimalDisease::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__AnimalDisease::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__AnimalDisease(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__AnimalDisease(struct soap *soap, const char *tag, int id, const dic__AnimalDisease *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__AnimalDisease), "dic:AnimalDisease"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AnimalDisease::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__AnimalDisease::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__AnimalDisease(soap, tag, this, type);
}

SOAP_FMAC3 dic__AnimalDisease * FASTCALL soap_in_dic__AnimalDisease(struct soap *soap, const char *tag, dic__AnimalDisease *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__AnimalDisease *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__AnimalDisease, sizeof(dic__AnimalDisease), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__AnimalDisease) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__AnimalDisease *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AnimalDisease::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__AnimalDisease *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__AnimalDisease, 0, sizeof(dic__AnimalDisease), 0, soap_copy_dic__AnimalDisease);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__AnimalDisease::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__AnimalDisease);
	return this->soap_out(soap, tag?tag:"dic:AnimalDisease", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__AnimalDisease::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__AnimalDisease(soap, this, tag, type);
}

SOAP_FMAC3 dic__AnimalDisease * SOAP_FMAC4 soap_get_dic__AnimalDisease(struct soap *soap, dic__AnimalDisease *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__AnimalDisease * FASTCALL soap_instantiate_dic__AnimalDisease(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__AnimalDisease(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__AnimalDisease, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease);
		ASSIGN_PTR(size, sizeof(dic__AnimalDisease));
		((dic__AnimalDisease*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__AnimalDisease));
		for(int i = 0; i < n; i++)
			((dic__AnimalDisease*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__AnimalDisease*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__AnimalDisease(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__AnimalDisease %p -> %p\n", q, p));
	*(dic__AnimalDisease*)p = *(dic__AnimalDisease*)q;
}

void dic__Indicator::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Indicator::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Indicator::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Indicator::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Indicator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Indicator(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Indicator(struct soap *soap, const char *tag, int id, const dic__Indicator *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Indicator), "dic:Indicator"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Indicator::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Indicator::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Indicator(soap, tag, this, type);
}

SOAP_FMAC3 dic__Indicator * FASTCALL soap_in_dic__Indicator(struct soap *soap, const char *tag, dic__Indicator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Indicator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Indicator, sizeof(dic__Indicator), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Indicator) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Indicator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Indicator::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Indicator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Indicator, 0, sizeof(dic__Indicator), 0, soap_copy_dic__Indicator);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Indicator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Indicator);
	return this->soap_out(soap, tag?tag:"dic:Indicator", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Indicator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Indicator(soap, this, tag, type);
}

SOAP_FMAC3 dic__Indicator * SOAP_FMAC4 soap_get_dic__Indicator(struct soap *soap, dic__Indicator *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Indicator * FASTCALL soap_instantiate_dic__Indicator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Indicator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Indicator, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Indicator);
		ASSIGN_PTR(size, sizeof(dic__Indicator));
		((dic__Indicator*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Indicator[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Indicator));
		for(int i = 0; i < n; i++)
			((dic__Indicator*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Indicator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Indicator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Indicator %p -> %p\n", q, p));
	*(dic__Indicator*)p = *(dic__Indicator*)q;
}

void dic__Organization::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__Organization::ID = NULL;
	soap_default_base__String255(soap, &this->dic__Organization::name);
	this->dic__Organization::address = NULL;
	/* transient soap skipped */
}

void dic__Organization::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->dic__Organization::ID);
	soap_serialize_base__String255(soap, &this->dic__Organization::name);
	soap_serialize_PointerTodic__Address(soap, &this->dic__Organization::address);
	/* transient soap skipped */
}

int dic__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Organization(struct soap *soap, const char *tag, int id, const dic__Organization *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Organization), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "dic:ID", -1, &(a->dic__Organization::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Organization::name), ""))
		return soap->error;
	if(soap_out_PointerTodic__Address(soap, "dic:address", -1, &(a->dic__Organization::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Organization(soap, tag, this, type);
}

SOAP_FMAC3 dic__Organization * FASTCALL soap_in_dic__Organization(struct soap *soap, const char *tag, dic__Organization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Organization, sizeof(dic__Organization), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Organization) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Organization *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "dic:ID", &(a->dic__Organization::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Organization::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Address(soap, "dic:address", &(a->dic__Organization::address), "dic:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Organization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Organization, 0, sizeof(dic__Organization), 0, soap_copy_dic__Organization);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Organization);
	return this->soap_out(soap, tag?tag:"dic:Organization", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Organization(soap, this, tag, type);
}

SOAP_FMAC3 dic__Organization * SOAP_FMAC4 soap_get_dic__Organization(struct soap *soap, dic__Organization *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Organization * FASTCALL soap_instantiate_dic__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Organization, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Organization);
		ASSIGN_PTR(size, sizeof(dic__Organization));
		((dic__Organization*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Organization[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Organization));
		for(int i = 0; i < n; i++)
			((dic__Organization*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Organization*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Organization(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Organization %p -> %p\n", q, p));
	*(dic__Organization*)p = *(dic__Organization*)q;
}

void dic__EnterpriseOfficialRegistration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dic__GRNType(soap, &this->dic__EnterpriseOfficialRegistration::ID);
	this->dic__EnterpriseOfficialRegistration::businessEntity = NULL;
	soap_default_base__String255(soap, &this->dic__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

void dic__EnterpriseOfficialRegistration::soap_serialize(struct soap *soap) const
{
	soap_serialize_dic__GRNType(soap, &this->dic__EnterpriseOfficialRegistration::ID);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->dic__EnterpriseOfficialRegistration::businessEntity);
	soap_serialize_base__String255(soap, &this->dic__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

int dic__EnterpriseOfficialRegistration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__EnterpriseOfficialRegistration(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, const dic__EnterpriseOfficialRegistration *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseOfficialRegistration), type))
		return soap->error;
	if(soap_out_dic__GRNType(soap, "dic:ID", -1, &(a->dic__EnterpriseOfficialRegistration::ID), ""))
		return soap->error;
	if(a->dic__EnterpriseOfficialRegistration::businessEntity) {
		if(soap_out_PointerTodic__BusinessEntity(soap, "dic:businessEntity", -1, &a->dic__EnterpriseOfficialRegistration::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:businessEntity"))
		return soap->error;
	if(a->dic__EnterpriseOfficialRegistration::kpp) {
		if(soap_out_base__String255(soap, "dic:kpp", -1, &a->dic__EnterpriseOfficialRegistration::kpp, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:kpp"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__EnterpriseOfficialRegistration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__EnterpriseOfficialRegistration(soap, tag, this, type);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration * FASTCALL soap_in_dic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, dic__EnterpriseOfficialRegistration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__EnterpriseOfficialRegistration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseOfficialRegistration, sizeof(dic__EnterpriseOfficialRegistration), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__EnterpriseOfficialRegistration) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__EnterpriseOfficialRegistration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_kpp1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__GRNType(soap, "dic:ID", &(a->dic__EnterpriseOfficialRegistration::ID), "dic:GRNType"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:businessEntity", &(a->dic__EnterpriseOfficialRegistration::businessEntity), "dic:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:kpp", &(a->dic__EnterpriseOfficialRegistration::kpp), "base:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__EnterpriseOfficialRegistration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseOfficialRegistration, 0, sizeof(dic__EnterpriseOfficialRegistration), 0, soap_copy_dic__EnterpriseOfficialRegistration);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_businessEntity1 > 0 || soap_flag_kpp1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__EnterpriseOfficialRegistration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseOfficialRegistration);
	return this->soap_out(soap, tag?tag:"dic:EnterpriseOfficialRegistration", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__EnterpriseOfficialRegistration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__EnterpriseOfficialRegistration(soap, this, tag, type);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration * SOAP_FMAC4 soap_get_dic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__EnterpriseOfficialRegistration * FASTCALL soap_instantiate_dic__EnterpriseOfficialRegistration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__EnterpriseOfficialRegistration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__EnterpriseOfficialRegistration, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseOfficialRegistration);
		ASSIGN_PTR(size, sizeof(dic__EnterpriseOfficialRegistration));
		((dic__EnterpriseOfficialRegistration*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseOfficialRegistration[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__EnterpriseOfficialRegistration));
		for(int i = 0; i < n; i++)
			((dic__EnterpriseOfficialRegistration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__EnterpriseOfficialRegistration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__EnterpriseOfficialRegistration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__EnterpriseOfficialRegistration %p -> %p\n", q, p));
	*(dic__EnterpriseOfficialRegistration*)p = *(dic__EnterpriseOfficialRegistration*)q;
}

void dic__Location::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Location::name);
	this->dic__Location::address = NULL;
	/* transient soap skipped */
}

void dic__Location::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Location::name);
	soap_serialize_PointerTodic__Address(soap, &this->dic__Location::address);
	/* transient soap skipped */
}

int dic__Location::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Location(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Location(struct soap *soap, const char *tag, int id, const dic__Location *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Location), type))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Location::name), ""))
		return soap->error;
	if(soap_out_PointerTodic__Address(soap, "dic:address", -1, &(a->dic__Location::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Location::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Location(soap, tag, this, type);
}

SOAP_FMAC3 dic__Location * FASTCALL soap_in_dic__Location(struct soap *soap, const char *tag, dic__Location *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Location *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Location, sizeof(dic__Location), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Location) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Location *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Location::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Address(soap, "dic:address", &(a->dic__Location::address), "dic:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Location *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Location, 0, sizeof(dic__Location), 0, soap_copy_dic__Location);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Location::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Location);
	return this->soap_out(soap, tag?tag:"dic:Location", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Location::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Location(soap, this, tag, type);
}

SOAP_FMAC3 dic__Location * SOAP_FMAC4 soap_get_dic__Location(struct soap *soap, dic__Location *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Location * FASTCALL soap_instantiate_dic__Location(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Location(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Location, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Location);
		ASSIGN_PTR(size, sizeof(dic__Location));
		((dic__Location*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Location[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Location));
		for(int i = 0; i < n; i++)
			((dic__Location*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Location*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Location(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Location %p -> %p\n", q, p));
	*(dic__Location*)p = *(dic__Location*)q;
}

void dic__Packaging::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__Packaging::packagingType = NULL;
	soap_default_xsd__integer(soap, &this->dic__Packaging::quantity);
	this->dic__Packaging::volume = NULL;
	this->dic__Packaging::unit = NULL;
	/* transient soap skipped */
}

void dic__Packaging::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__PackingType(soap, &this->dic__Packaging::packagingType);
	soap_serialize_xsd__integer(soap, &this->dic__Packaging::quantity);
	soap_serialize_PointerTobase__Decimal(soap, &this->dic__Packaging::volume);
	soap_serialize_PointerTodic__Unit(soap, &this->dic__Packaging::unit);
	/* transient soap skipped */
}

int dic__Packaging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Packaging(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Packaging(struct soap *soap, const char *tag, int id, const dic__Packaging *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Packaging), type))
		return soap->error;
	if(a->dic__Packaging::packagingType) {
		if(soap_out_PointerTodic__PackingType(soap, "dic:packagingType", -1, &a->dic__Packaging::packagingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:packagingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "dic:quantity", -1, &(a->dic__Packaging::quantity), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "dic:volume", -1, &(a->dic__Packaging::volume), ""))
		return soap->error;
	if(soap_out_PointerTodic__Unit(soap, "dic:unit", -1, &(a->dic__Packaging::unit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Packaging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Packaging(soap, tag, this, type);
}

SOAP_FMAC3 dic__Packaging * FASTCALL soap_in_dic__Packaging(struct soap *soap, const char *tag, dic__Packaging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Packaging *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Packaging, sizeof(dic__Packaging), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Packaging) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Packaging *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_packagingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_packagingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackingType(soap, "dic:packagingType", &(a->dic__Packaging::packagingType), "dic:PackingType"))
				{	soap_flag_packagingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "dic:quantity", &(a->dic__Packaging::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "dic:volume", &(a->dic__Packaging::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Unit(soap, "dic:unit", &(a->dic__Packaging::unit), "dic:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Packaging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Packaging, 0, sizeof(dic__Packaging), 0, soap_copy_dic__Packaging);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_packagingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__Packaging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Packaging);
	return this->soap_out(soap, tag?tag:"dic:Packaging", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Packaging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Packaging(soap, this, tag, type);
}

SOAP_FMAC3 dic__Packaging * SOAP_FMAC4 soap_get_dic__Packaging(struct soap *soap, dic__Packaging *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Packaging * FASTCALL soap_instantiate_dic__Packaging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Packaging(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Packaging, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Packaging);
		ASSIGN_PTR(size, sizeof(dic__Packaging));
		((dic__Packaging*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Packaging[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Packaging));
		for(int i = 0; i < n; i++)
			((dic__Packaging*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Packaging*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Packaging(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Packaging %p -> %p\n", q, p));
	*(dic__Packaging*)p = *(dic__Packaging*)q;
}

void dic__ProductItemProducing::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ProductItemProducing::location = NULL;
	/* transient soap skipped */
}

void dic__ProductItemProducing::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->dic__ProductItemProducing::location);
	/* transient soap skipped */
}

int dic__ProductItemProducing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProductItemProducing(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductItemProducing(struct soap *soap, const char *tag, int id, const dic__ProductItemProducing *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductItemProducing), type))
		return soap->error;
	if(a->dic__ProductItemProducing::location) {
		if(soap_out_PointerTodic__Enterprise(soap, "dic:location", -1, &a->dic__ProductItemProducing::location, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:location"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__ProductItemProducing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProductItemProducing(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProductItemProducing * FASTCALL soap_in_dic__ProductItemProducing(struct soap *soap, const char *tag, dic__ProductItemProducing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ProductItemProducing *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductItemProducing, sizeof(dic__ProductItemProducing), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProductItemProducing) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ProductItemProducing *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_location1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_location1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "dic:location", &(a->dic__ProductItemProducing::location), "dic:Enterprise"))
				{	soap_flag_location1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ProductItemProducing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductItemProducing, 0, sizeof(dic__ProductItemProducing), 0, soap_copy_dic__ProductItemProducing);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_location1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__ProductItemProducing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProductItemProducing);
	return this->soap_out(soap, tag?tag:"dic:ProductItemProducing", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProductItemProducing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProductItemProducing(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProductItemProducing * SOAP_FMAC4 soap_get_dic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProductItemProducing * FASTCALL soap_instantiate_dic__ProductItemProducing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProductItemProducing(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProductItemProducing, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItemProducing);
		ASSIGN_PTR(size, sizeof(dic__ProductItemProducing));
		((dic__ProductItemProducing*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItemProducing[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProductItemProducing));
		for(int i = 0; i < n; i++)
			((dic__ProductItemProducing*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProductItemProducing*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProductItemProducing(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProductItemProducing %p -> %p\n", q, p));
	*(dic__ProductItemProducing*)p = *(dic__ProductItemProducing*)q;
}

void dic__ComplexDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ComplexDate::year = NULL;
	this->dic__ComplexDate::month = NULL;
	this->dic__ComplexDate::day = NULL;
	this->dic__ComplexDate::hour = NULL;
	this->dic__ComplexDate::minute = NULL;
	/* transient soap skipped */
}

void dic__ComplexDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Year(soap, &this->dic__ComplexDate::year);
	soap_serialize_PointerTodic__Month(soap, &this->dic__ComplexDate::month);
	soap_serialize_PointerTodic__Day(soap, &this->dic__ComplexDate::day);
	soap_serialize_PointerTodic__Hour(soap, &this->dic__ComplexDate::hour);
	soap_serialize_PointerTodic__Minute(soap, &this->dic__ComplexDate::minute);
	/* transient soap skipped */
}

int dic__ComplexDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ComplexDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ComplexDate(struct soap *soap, const char *tag, int id, const dic__ComplexDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ComplexDate), type))
		return soap->error;
	if(soap_out_PointerTodic__Year(soap, "dic:year", -1, &(a->dic__ComplexDate::year), ""))
		return soap->error;
	if(soap_out_PointerTodic__Month(soap, "dic:month", -1, &(a->dic__ComplexDate::month), ""))
		return soap->error;
	if(soap_out_PointerTodic__Day(soap, "dic:day", -1, &(a->dic__ComplexDate::day), ""))
		return soap->error;
	if(soap_out_PointerTodic__Hour(soap, "dic:hour", -1, &(a->dic__ComplexDate::hour), ""))
		return soap->error;
	if(soap_out_PointerTodic__Minute(soap, "dic:minute", -1, &(a->dic__ComplexDate::minute), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__ComplexDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ComplexDate(soap, tag, this, type);
}

SOAP_FMAC3 dic__ComplexDate * FASTCALL soap_in_dic__ComplexDate(struct soap *soap, const char *tag, dic__ComplexDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ComplexDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ComplexDate, sizeof(dic__ComplexDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ComplexDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ComplexDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_year1 = 1;
	size_t soap_flag_month1 = 1;
	size_t soap_flag_day1 = 1;
	size_t soap_flag_hour1 = 1;
	size_t soap_flag_minute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Year(soap, "dic:year", &(a->dic__ComplexDate::year), "dic:Year"))
				{	soap_flag_year1--;
					continue;
				}
			if(soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Month(soap, "dic:month", &(a->dic__ComplexDate::month), "dic:Month"))
				{	soap_flag_month1--;
					continue;
				}
			if(soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Day(soap, "dic:day", &(a->dic__ComplexDate::day), "dic:Day"))
				{	soap_flag_day1--;
					continue;
				}
			if(soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Hour(soap, "dic:hour", &(a->dic__ComplexDate::hour), "dic:Hour"))
				{	soap_flag_hour1--;
					continue;
				}
			if(soap_flag_minute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Minute(soap, "dic:minute", &(a->dic__ComplexDate::minute), "dic:Minute"))
				{	soap_flag_minute1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ComplexDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ComplexDate, 0, sizeof(dic__ComplexDate), 0, soap_copy_dic__ComplexDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ComplexDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ComplexDate);
	return this->soap_out(soap, tag?tag:"dic:ComplexDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ComplexDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ComplexDate(soap, this, tag, type);
}

SOAP_FMAC3 dic__ComplexDate * SOAP_FMAC4 soap_get_dic__ComplexDate(struct soap *soap, dic__ComplexDate *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ComplexDate * FASTCALL soap_instantiate_dic__ComplexDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ComplexDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ComplexDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ComplexDate);
		ASSIGN_PTR(size, sizeof(dic__ComplexDate));
		((dic__ComplexDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ComplexDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ComplexDate));
		for(int i = 0; i < n; i++)
			((dic__ComplexDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ComplexDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ComplexDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ComplexDate %p -> %p\n", q, p));
	*(dic__ComplexDate*)p = *(dic__ComplexDate*)q;
}

void dic__PackageList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__PackageList::__sizepackage = 0;
	this->dic__PackageList::package = NULL;
	/* transient soap skipped */
}

void dic__PackageList::soap_serialize(struct soap *soap) const
{
	if(this->dic__PackageList::package) {
		for(int i = 0; i < this->dic__PackageList::__sizepackage; i++) {
			soap_serialize_PointerTodic__Package(soap, this->dic__PackageList::package + i);
		}
	}
	/* transient soap skipped */
}

int dic__PackageList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__PackageList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__PackageList(struct soap *soap, const char *tag, int id, const dic__PackageList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__PackageList), type))
		return soap->error;
	if(a->dic__PackageList::package) {
		int i;
		for(i = 0; i < a->dic__PackageList::__sizepackage; i++)
			if(soap_out_PointerTodic__Package(soap, "dic:package", -1, a->dic__PackageList::package + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__PackageList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__PackageList(soap, tag, this, type);
}

SOAP_FMAC3 dic__PackageList * FASTCALL soap_in_dic__PackageList(struct soap *soap, const char *tag, dic__PackageList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__PackageList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__PackageList, sizeof(dic__PackageList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__PackageList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__PackageList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_package1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:package", 1, NULL)) {
				if(a->dic__PackageList::package == NULL) {
					if(soap_blist_package1 == NULL)
						soap_blist_package1 = soap_new_block(soap);
					a->dic__PackageList::package = (dic__Package **)soap_push_block(soap, soap_blist_package1, sizeof(dic__Package *));
					if(a->dic__PackageList::package == NULL)
						return NULL;
					*a->dic__PackageList::package = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Package(soap, "dic:package", a->dic__PackageList::package, "dic:Package"))
				{	a->dic__PackageList::__sizepackage++;
					a->dic__PackageList::package = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__PackageList::package)
			soap_pop_block(soap, soap_blist_package1);
		if(a->dic__PackageList::__sizepackage)
			a->dic__PackageList::package = (dic__Package **)soap_save_block(soap, soap_blist_package1, NULL, 1);
		else
		{	a->dic__PackageList::package = NULL;
			if(soap_blist_package1)
				soap_end_block(soap, soap_blist_package1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__PackageList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__PackageList, 0, sizeof(dic__PackageList), 0, soap_copy_dic__PackageList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__PackageList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__PackageList);
	return this->soap_out(soap, tag?tag:"dic:PackageList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__PackageList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__PackageList(soap, this, tag, type);
}

SOAP_FMAC3 dic__PackageList * SOAP_FMAC4 soap_get_dic__PackageList(struct soap *soap, dic__PackageList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__PackageList * FASTCALL soap_instantiate_dic__PackageList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__PackageList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__PackageList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__PackageList);
		ASSIGN_PTR(size, sizeof(dic__PackageList));
		((dic__PackageList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__PackageList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__PackageList));
		for(int i = 0; i < n; i++)
			((dic__PackageList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__PackageList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__PackageList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__PackageList %p -> %p\n", q, p));
	*(dic__PackageList*)p = *(dic__PackageList*)q;
}

void dic__Package::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dic__PackageLevelType(soap, &this->dic__Package::level);
	this->dic__Package::packingType = NULL;
	soap_default_xsd__integer(soap, &this->dic__Package::quantity);
	this->dic__Package::__sizeproductMarks = 0;
	this->dic__Package::productMarks = NULL;
	/* transient soap skipped */
}

void dic__Package::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__PackingType(soap, &this->dic__Package::packingType);
	soap_serialize_xsd__integer(soap, &this->dic__Package::quantity);
	if(this->dic__Package::productMarks) {
		for(int i = 0; i < this->dic__Package::__sizeproductMarks; i++) {
			soap_serialize_PointerTodic__ProductMarks(soap, this->dic__Package::productMarks + i);
		}
	}
	/* transient soap skipped */
}

int dic__Package::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Package(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Package(struct soap *soap, const char *tag, int id, const dic__Package *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Package), type))
		return soap->error;
	if(soap_out_dic__PackageLevelType(soap, "dic:level", -1, &(a->dic__Package::level), ""))
		return soap->error;
	if(a->dic__Package::packingType) {
		if(soap_out_PointerTodic__PackingType(soap, "dic:packingType", -1, &a->dic__Package::packingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:packingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "dic:quantity", -1, &(a->dic__Package::quantity), ""))
		return soap->error;
	if(a->dic__Package::productMarks) {
		int i;
		for(i = 0; i < a->dic__Package::__sizeproductMarks; i++)
			if(soap_out_PointerTodic__ProductMarks(soap, "dic:productMarks", -1, a->dic__Package::productMarks + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Package::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Package(soap, tag, this, type);
}

SOAP_FMAC3 dic__Package * FASTCALL soap_in_dic__Package(struct soap *soap, const char *tag, dic__Package *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Package *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Package, sizeof(dic__Package), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Package) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Package *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_level1 = 1;
	size_t soap_flag_packingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	struct soap_blist *soap_blist_productMarks1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_dic__PackageLevelType(soap, "dic:level", &(a->dic__Package::level), "dic:PackageLevelType"))
				{	soap_flag_level1--;
					continue;
				}
			if(soap_flag_packingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackingType(soap, "dic:packingType", &(a->dic__Package::packingType), "dic:PackingType"))
				{	soap_flag_packingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "dic:quantity", &(a->dic__Package::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:productMarks", 1, NULL)) {
				if(a->dic__Package::productMarks == NULL) {
					if(soap_blist_productMarks1 == NULL)
						soap_blist_productMarks1 = soap_new_block(soap);
					a->dic__Package::productMarks = (dic__ProductMarks **)soap_push_block(soap, soap_blist_productMarks1, sizeof(dic__ProductMarks *));
					if(a->dic__Package::productMarks == NULL)
						return NULL;
					*a->dic__Package::productMarks = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__ProductMarks(soap, "dic:productMarks", a->dic__Package::productMarks, "dic:ProductMarks"))
				{	a->dic__Package::__sizeproductMarks++;
					a->dic__Package::productMarks = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__Package::productMarks)
			soap_pop_block(soap, soap_blist_productMarks1);
		if(a->dic__Package::__sizeproductMarks)
			a->dic__Package::productMarks = (dic__ProductMarks **)soap_save_block(soap, soap_blist_productMarks1, NULL, 1);
		else
		{	a->dic__Package::productMarks = NULL;
			if(soap_blist_productMarks1)
				soap_end_block(soap, soap_blist_productMarks1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Package *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Package, 0, sizeof(dic__Package), 0, soap_copy_dic__Package);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0 || soap_flag_packingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__Package::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Package);
	return this->soap_out(soap, tag?tag:"dic:Package", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Package::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Package(soap, this, tag, type);
}

SOAP_FMAC3 dic__Package * SOAP_FMAC4 soap_get_dic__Package(struct soap *soap, dic__Package *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Package * FASTCALL soap_instantiate_dic__Package(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Package(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Package, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Package);
		ASSIGN_PTR(size, sizeof(dic__Package));
		((dic__Package*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Package[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Package));
		for(int i = 0; i < n; i++)
			((dic__Package*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Package*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Package(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Package %p -> %p\n", q, p));
	*(dic__Package*)p = *(dic__Package*)q;
}

void dic__ProductMarks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__ProductMarks::__item);
	this->dic__ProductMarks::class_ = (enum dic__ProductMarkingClass)0;
	/* transient soap skipped */
}

void dic__ProductMarks::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__ProductMarks::__item);
	/* transient soap skipped */
}

int dic__ProductMarks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProductMarks(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductMarks(struct soap *soap, const char *tag, int id, const dic__ProductMarks *a, const char *type)
{
	soap_set_attr(soap, "class", soap_dic__ProductMarkingClass2s(soap, ((dic__ProductMarks*)a)->class_), 1);
	return soap_out_base__String255(soap, tag, id, &a->dic__ProductMarks::__item, "");
}

void *dic__ProductMarks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProductMarks(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProductMarks * FASTCALL soap_in_dic__ProductMarks(struct soap *soap, const char *tag, dic__ProductMarks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (dic__ProductMarks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductMarks, sizeof(dic__ProductMarks), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProductMarks)
			return (dic__ProductMarks *)a->soap_in(soap, tag, type);
	}
	if(soap_s2dic__ProductMarkingClass(soap, soap_attr_value(soap, "class", 0), &((dic__ProductMarks*)a)->class_))
		return NULL;
	if(!soap_in_base__String255(soap, tag, &(a->dic__ProductMarks::__item), "dic:ProductMarks"))
		return NULL;
	return a;
}

int dic__ProductMarks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProductMarks);
	return this->soap_out(soap, tag?tag:"dic:ProductMarks", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProductMarks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProductMarks(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProductMarks * SOAP_FMAC4 soap_get_dic__ProductMarks(struct soap *soap, dic__ProductMarks *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProductMarks * FASTCALL soap_instantiate_dic__ProductMarks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProductMarks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProductMarks, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProductMarks);
		ASSIGN_PTR(size, sizeof(dic__ProductMarks));
		((dic__ProductMarks*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProductMarks[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProductMarks));
		for(int i = 0; i < n; i++)
			((dic__ProductMarks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProductMarks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProductMarks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProductMarks %p -> %p\n", q, p));
	*(dic__ProductMarks*)p = *(dic__ProductMarks*)q;
}

void dic__ProductItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ProductItemList::__sizeproductItem = 0;
	this->dic__ProductItemList::productItem = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__ProductItemList::soap_serialize(struct soap *soap) const
{
	if(this->dic__ProductItemList::productItem) {
		for(int i = 0; i < this->dic__ProductItemList::__sizeproductItem; i++) {
			soap_serialize_PointerTodic__ProductItem(soap, this->dic__ProductItemList::productItem + i);
		}
	}
	/* transient soap skipped */
}

int dic__ProductItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProductItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductItemList(struct soap *soap, const char *tag, int id, const dic__ProductItemList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductItemList), "dic:ProductItemList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__ProductItemList::productItem) {
		int i;
		for(i = 0; i < a->dic__ProductItemList::__sizeproductItem; i++)
			if(soap_out_PointerTodic__ProductItem(soap, "dic:productItem", -1, a->dic__ProductItemList::productItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__ProductItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProductItemList(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProductItemList * FASTCALL soap_in_dic__ProductItemList(struct soap *soap, const char *tag, dic__ProductItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ProductItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductItemList, sizeof(dic__ProductItemList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProductItemList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ProductItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_productItem1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:productItem", 1, NULL)) {
				if(a->dic__ProductItemList::productItem == NULL) {
					if(soap_blist_productItem1 == NULL)
						soap_blist_productItem1 = soap_new_block(soap);
					a->dic__ProductItemList::productItem = (dic__ProductItem **)soap_push_block(soap, soap_blist_productItem1, sizeof(dic__ProductItem *));
					if(a->dic__ProductItemList::productItem == NULL)
						return NULL;
					*a->dic__ProductItemList::productItem = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__ProductItem(soap, "dic:productItem", a->dic__ProductItemList::productItem, "dic:ProductItem"))
				{	a->dic__ProductItemList::__sizeproductItem++;
					a->dic__ProductItemList::productItem = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ProductItemList::productItem)
			soap_pop_block(soap, soap_blist_productItem1);
		if(a->dic__ProductItemList::__sizeproductItem)
			a->dic__ProductItemList::productItem = (dic__ProductItem **)soap_save_block(soap, soap_blist_productItem1, NULL, 1);
		else
		{	a->dic__ProductItemList::productItem = NULL;
			if(soap_blist_productItem1)
				soap_end_block(soap, soap_blist_productItem1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ProductItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductItemList, 0, sizeof(dic__ProductItemList), 0, soap_copy_dic__ProductItemList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ProductItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProductItemList);
	return this->soap_out(soap, tag?tag:"dic:ProductItemList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProductItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProductItemList(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProductItemList * SOAP_FMAC4 soap_get_dic__ProductItemList(struct soap *soap, dic__ProductItemList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProductItemList * FASTCALL soap_instantiate_dic__ProductItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProductItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProductItemList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItemList);
		ASSIGN_PTR(size, sizeof(dic__ProductItemList));
		((dic__ProductItemList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItemList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProductItemList));
		for(int i = 0; i < n; i++)
			((dic__ProductItemList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProductItemList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProductItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProductItemList %p -> %p\n", q, p));
	*(dic__ProductItemList*)p = *(dic__ProductItemList*)q;
}

void dic__SubProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__SubProductList::__sizesubProduct = 0;
	this->dic__SubProductList::subProduct = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__SubProductList::soap_serialize(struct soap *soap) const
{
	if(this->dic__SubProductList::subProduct) {
		for(int i = 0; i < this->dic__SubProductList::__sizesubProduct; i++) {
			soap_serialize_PointerTodic__SubProduct(soap, this->dic__SubProductList::subProduct + i);
		}
	}
	/* transient soap skipped */
}

int dic__SubProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__SubProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__SubProductList(struct soap *soap, const char *tag, int id, const dic__SubProductList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__SubProductList), "dic:SubProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__SubProductList::subProduct) {
		int i;
		for(i = 0; i < a->dic__SubProductList::__sizesubProduct; i++)
			if(soap_out_PointerTodic__SubProduct(soap, "dic:subProduct", -1, a->dic__SubProductList::subProduct + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__SubProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__SubProductList(soap, tag, this, type);
}

SOAP_FMAC3 dic__SubProductList * FASTCALL soap_in_dic__SubProductList(struct soap *soap, const char *tag, dic__SubProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__SubProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__SubProductList, sizeof(dic__SubProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__SubProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__SubProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_subProduct1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:subProduct", 1, NULL)) {
				if(a->dic__SubProductList::subProduct == NULL) {
					if(soap_blist_subProduct1 == NULL)
						soap_blist_subProduct1 = soap_new_block(soap);
					a->dic__SubProductList::subProduct = (dic__SubProduct **)soap_push_block(soap, soap_blist_subProduct1, sizeof(dic__SubProduct *));
					if(a->dic__SubProductList::subProduct == NULL)
						return NULL;
					*a->dic__SubProductList::subProduct = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__SubProduct(soap, "dic:subProduct", a->dic__SubProductList::subProduct, "dic:SubProduct"))
				{	a->dic__SubProductList::__sizesubProduct++;
					a->dic__SubProductList::subProduct = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__SubProductList::subProduct)
			soap_pop_block(soap, soap_blist_subProduct1);
		if(a->dic__SubProductList::__sizesubProduct)
			a->dic__SubProductList::subProduct = (dic__SubProduct **)soap_save_block(soap, soap_blist_subProduct1, NULL, 1);
		else
		{	a->dic__SubProductList::subProduct = NULL;
			if(soap_blist_subProduct1)
				soap_end_block(soap, soap_blist_subProduct1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__SubProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__SubProductList, 0, sizeof(dic__SubProductList), 0, soap_copy_dic__SubProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__SubProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__SubProductList);
	return this->soap_out(soap, tag?tag:"dic:SubProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__SubProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__SubProductList(soap, this, tag, type);
}

SOAP_FMAC3 dic__SubProductList * SOAP_FMAC4 soap_get_dic__SubProductList(struct soap *soap, dic__SubProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__SubProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__SubProductList * FASTCALL soap_instantiate_dic__SubProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__SubProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__SubProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__SubProductList);
		ASSIGN_PTR(size, sizeof(dic__SubProductList));
		((dic__SubProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__SubProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__SubProductList));
		for(int i = 0; i < n; i++)
			((dic__SubProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__SubProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__SubProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__SubProductList %p -> %p\n", q, p));
	*(dic__SubProductList*)p = *(dic__SubProductList*)q;
}

void dic__ProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ProductList::__sizeproduct = 0;
	this->dic__ProductList::product = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__ProductList::soap_serialize(struct soap *soap) const
{
	if(this->dic__ProductList::product) {
		for(int i = 0; i < this->dic__ProductList::__sizeproduct; i++) {
			soap_serialize_PointerTodic__Product(soap, this->dic__ProductList::product + i);
		}
	}
	/* transient soap skipped */
}

int dic__ProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductList(struct soap *soap, const char *tag, int id, const dic__ProductList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductList), "dic:ProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__ProductList::product) {
		int i;
		for(i = 0; i < a->dic__ProductList::__sizeproduct; i++)
			if(soap_out_PointerTodic__Product(soap, "dic:product", -1, a->dic__ProductList::product + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__ProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProductList(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProductList * FASTCALL soap_in_dic__ProductList(struct soap *soap, const char *tag, dic__ProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductList, sizeof(dic__ProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_product1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:product", 1, NULL)) {
				if(a->dic__ProductList::product == NULL) {
					if(soap_blist_product1 == NULL)
						soap_blist_product1 = soap_new_block(soap);
					a->dic__ProductList::product = (dic__Product **)soap_push_block(soap, soap_blist_product1, sizeof(dic__Product *));
					if(a->dic__ProductList::product == NULL)
						return NULL;
					*a->dic__ProductList::product = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Product(soap, "dic:product", a->dic__ProductList::product, "dic:Product"))
				{	a->dic__ProductList::__sizeproduct++;
					a->dic__ProductList::product = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ProductList::product)
			soap_pop_block(soap, soap_blist_product1);
		if(a->dic__ProductList::__sizeproduct)
			a->dic__ProductList::product = (dic__Product **)soap_save_block(soap, soap_blist_product1, NULL, 1);
		else
		{	a->dic__ProductList::product = NULL;
			if(soap_blist_product1)
				soap_end_block(soap, soap_blist_product1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductList, 0, sizeof(dic__ProductList), 0, soap_copy_dic__ProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProductList);
	return this->soap_out(soap, tag?tag:"dic:ProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProductList(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProductList * SOAP_FMAC4 soap_get_dic__ProductList(struct soap *soap, dic__ProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProductList * FASTCALL soap_instantiate_dic__ProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProductList);
		ASSIGN_PTR(size, sizeof(dic__ProductList));
		((dic__ProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProductList));
		for(int i = 0; i < n; i++)
			((dic__ProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProductList %p -> %p\n", q, p));
	*(dic__ProductList*)p = *(dic__ProductList*)q;
}

void dic__SubProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__SubProduct::name);
	soap_default_base__String255(soap, &this->dic__SubProduct::code);
	soap_default_base__String255(soap, &this->dic__SubProduct::englishName);
	soap_default_base__UUID(soap, &this->dic__SubProduct::productGuid);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__SubProduct::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__SubProduct::name);
	soap_serialize_base__String255(soap, &this->dic__SubProduct::code);
	soap_serialize_base__String255(soap, &this->dic__SubProduct::englishName);
	soap_serialize_base__UUID(soap, &this->dic__SubProduct::productGuid);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__SubProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__SubProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__SubProduct(struct soap *soap, const char *tag, int id, const dic__SubProduct *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__SubProduct), "dic:SubProduct"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__SubProduct::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:code", -1, &(a->dic__SubProduct::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__SubProduct::englishName), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:productGuid", -1, &(a->dic__SubProduct::productGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__SubProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__SubProduct(soap, tag, this, type);
}

SOAP_FMAC3 dic__SubProduct * FASTCALL soap_in_dic__SubProduct(struct soap *soap, const char *tag, dic__SubProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__SubProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__SubProduct, sizeof(dic__SubProduct), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__SubProduct) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__SubProduct *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__SubProduct::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:code", &(a->dic__SubProduct::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__SubProduct::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:productGuid", &(a->dic__SubProduct::productGuid), "base:UUID"))
				{	soap_flag_productGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__SubProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__SubProduct, 0, sizeof(dic__SubProduct), 0, soap_copy_dic__SubProduct);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__SubProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__SubProduct);
	return this->soap_out(soap, tag?tag:"dic:SubProduct", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__SubProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__SubProduct(soap, this, tag, type);
}

SOAP_FMAC3 dic__SubProduct * SOAP_FMAC4 soap_get_dic__SubProduct(struct soap *soap, dic__SubProduct *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__SubProduct * FASTCALL soap_instantiate_dic__SubProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__SubProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__SubProduct, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__SubProduct);
		ASSIGN_PTR(size, sizeof(dic__SubProduct));
		((dic__SubProduct*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__SubProduct[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__SubProduct));
		for(int i = 0; i < n; i++)
			((dic__SubProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__SubProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__SubProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__SubProduct %p -> %p\n", q, p));
	*(dic__SubProduct*)p = *(dic__SubProduct*)q;
}

void dic__Product::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Product::name);
	soap_default_base__String255(soap, &this->dic__Product::code);
	soap_default_base__String255(soap, &this->dic__Product::englishName);
	this->dic__Product::productType = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Product::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Product::name);
	soap_serialize_base__String255(soap, &this->dic__Product::code);
	soap_serialize_base__String255(soap, &this->dic__Product::englishName);
	soap_serialize_PointerTodic__ProductType(soap, &this->dic__Product::productType);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Product::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Product(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Product(struct soap *soap, const char *tag, int id, const dic__Product *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Product), "dic:Product"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Product::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:code", -1, &(a->dic__Product::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__Product::englishName), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductType(soap, "dic:productType", -1, &(a->dic__Product::productType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Product::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Product(soap, tag, this, type);
}

SOAP_FMAC3 dic__Product * FASTCALL soap_in_dic__Product(struct soap *soap, const char *tag, dic__Product *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Product *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Product, sizeof(dic__Product), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Product) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Product *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Product::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:code", &(a->dic__Product::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__Product::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductType(soap, "dic:productType", &(a->dic__Product::productType), "dic:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Product, 0, sizeof(dic__Product), 0, soap_copy_dic__Product);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Product::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Product);
	return this->soap_out(soap, tag?tag:"dic:Product", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Product::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Product(soap, this, tag, type);
}

SOAP_FMAC3 dic__Product * SOAP_FMAC4 soap_get_dic__Product(struct soap *soap, dic__Product *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Product * FASTCALL soap_instantiate_dic__Product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Product(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Product, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Product);
		ASSIGN_PTR(size, sizeof(dic__Product));
		((dic__Product*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Product[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Product));
		for(int i = 0; i < n; i++)
			((dic__Product*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Product*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Product(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Product %p -> %p\n", q, p));
	*(dic__Product*)p = *(dic__Product*)q;
}

void dic__ProductItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dic__GTINType(soap, &this->dic__ProductItem::globalID);
	soap_default_base__String255(soap, &this->dic__ProductItem::name);
	soap_default_base__String255(soap, &this->dic__ProductItem::code);
	this->dic__ProductItem::productType = NULL;
	this->dic__ProductItem::product = NULL;
	this->dic__ProductItem::subProduct = NULL;
	this->dic__ProductItem::correspondsToGost = NULL;
	soap_default_base__String255(soap, &this->dic__ProductItem::gost);
	this->dic__ProductItem::producer = NULL;
	this->dic__ProductItem::tmOwner = NULL;
	this->dic__ProductItem::__sizeproducing = 0;
	this->dic__ProductItem::producing = NULL;
	this->dic__ProductItem::packaging = NULL;
	this->dic__ProductItem::isPublic = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__ProductItem::soap_serialize(struct soap *soap) const
{
	soap_serialize_dic__GTINType(soap, &this->dic__ProductItem::globalID);
	soap_serialize_base__String255(soap, &this->dic__ProductItem::name);
	soap_serialize_base__String255(soap, &this->dic__ProductItem::code);
	soap_serialize_PointerTodic__ProductType(soap, &this->dic__ProductItem::productType);
	soap_serialize_PointerTodic__Product(soap, &this->dic__ProductItem::product);
	soap_serialize_PointerTodic__SubProduct(soap, &this->dic__ProductItem::subProduct);
	soap_serialize_PointerTobool(soap, &this->dic__ProductItem::correspondsToGost);
	soap_serialize_base__String255(soap, &this->dic__ProductItem::gost);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->dic__ProductItem::producer);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->dic__ProductItem::tmOwner);
	if(this->dic__ProductItem::producing) {
		for(int i = 0; i < this->dic__ProductItem::__sizeproducing; i++) {
			soap_serialize_PointerTodic__ProductItemProducing(soap, this->dic__ProductItem::producing + i);
		}
	}
	soap_serialize_PointerTodic__Packaging(soap, &this->dic__ProductItem::packaging);
	soap_serialize_PointerTobool(soap, &this->dic__ProductItem::isPublic);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__ProductItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProductItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProductItem(struct soap *soap, const char *tag, int id, const dic__ProductItem *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProductItem), "dic:ProductItem"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_dic__GTINType(soap, "dic:globalID", -1, &(a->dic__ProductItem::globalID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__ProductItem::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:code", -1, &(a->dic__ProductItem::code), ""))
		return soap->error;
	if(soap_out_PointerTodic__ProductType(soap, "dic:productType", -1, &(a->dic__ProductItem::productType), ""))
		return soap->error;
	if(soap_out_PointerTodic__Product(soap, "dic:product", -1, &(a->dic__ProductItem::product), ""))
		return soap->error;
	if(soap_out_PointerTodic__SubProduct(soap, "dic:subProduct", -1, &(a->dic__ProductItem::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:correspondsToGost", -1, &(a->dic__ProductItem::correspondsToGost), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:gost", -1, &(a->dic__ProductItem::gost), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "dic:producer", -1, &(a->dic__ProductItem::producer), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "dic:tmOwner", -1, &(a->dic__ProductItem::tmOwner), ""))
		return soap->error;
	if(a->dic__ProductItem::producing) {
		int i;
		for(i = 0; i < a->dic__ProductItem::__sizeproducing; i++)
			if(soap_out_PointerTodic__ProductItemProducing(soap, "dic:producing", -1, a->dic__ProductItem::producing + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTodic__Packaging(soap, "dic:packaging", -1, &(a->dic__ProductItem::packaging), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:isPublic", -1, &(a->dic__ProductItem::isPublic), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__ProductItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProductItem(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProductItem * FASTCALL soap_in_dic__ProductItem(struct soap *soap, const char *tag, dic__ProductItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ProductItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProductItem, sizeof(dic__ProductItem), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProductItem) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ProductItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_correspondsToGost1 = 1;
	size_t soap_flag_gost1 = 1;
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_tmOwner1 = 1;
	struct soap_blist *soap_blist_producing1 = NULL;
	size_t soap_flag_packaging1 = 1;
	size_t soap_flag_isPublic1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__GTINType(soap, "dic:globalID", &(a->dic__ProductItem::globalID), "dic:GTINType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__ProductItem::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:code", &(a->dic__ProductItem::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductType(soap, "dic:productType", &(a->dic__ProductItem::productType), "dic:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Product(soap, "dic:product", &(a->dic__ProductItem::product), "dic:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__SubProduct(soap, "dic:subProduct", &(a->dic__ProductItem::subProduct), "dic:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_correspondsToGost1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:correspondsToGost", &(a->dic__ProductItem::correspondsToGost), "xsd:boolean"))
				{	soap_flag_correspondsToGost1--;
					continue;
				}
			if(soap_flag_gost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:gost", &(a->dic__ProductItem::gost), "base:String255"))
				{	soap_flag_gost1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:producer", &(a->dic__ProductItem::producer), "dic:BusinessEntity"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_tmOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:tmOwner", &(a->dic__ProductItem::tmOwner), "dic:BusinessEntity"))
				{	soap_flag_tmOwner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:producing", 1, NULL)) {
				if(a->dic__ProductItem::producing == NULL) {
					if(soap_blist_producing1 == NULL)
						soap_blist_producing1 = soap_new_block(soap);
					a->dic__ProductItem::producing = (dic__ProductItemProducing **)soap_push_block(soap, soap_blist_producing1, sizeof(dic__ProductItemProducing *));
					if(a->dic__ProductItem::producing == NULL)
						return NULL;
					*a->dic__ProductItem::producing = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__ProductItemProducing(soap, "dic:producing", a->dic__ProductItem::producing, "dic:ProductItemProducing"))
				{	a->dic__ProductItem::__sizeproducing++;
					a->dic__ProductItem::producing = NULL;
					continue;
				}
			}
			if(soap_flag_packaging1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Packaging(soap, "dic:packaging", &(a->dic__ProductItem::packaging), "dic:Packaging"))
				{	soap_flag_packaging1--;
					continue;
				}
			if(soap_flag_isPublic1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:isPublic", &(a->dic__ProductItem::isPublic), "xsd:boolean"))
				{	soap_flag_isPublic1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ProductItem::producing)
			soap_pop_block(soap, soap_blist_producing1);
		if(a->dic__ProductItem::__sizeproducing)
			a->dic__ProductItem::producing = (dic__ProductItemProducing **)soap_save_block(soap, soap_blist_producing1, NULL, 1);
		else
		{	a->dic__ProductItem::producing = NULL;
			if(soap_blist_producing1)
				soap_end_block(soap, soap_blist_producing1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ProductItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProductItem, 0, sizeof(dic__ProductItem), 0, soap_copy_dic__ProductItem);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ProductItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProductItem);
	return this->soap_out(soap, tag?tag:"dic:ProductItem", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProductItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProductItem(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProductItem * SOAP_FMAC4 soap_get_dic__ProductItem(struct soap *soap, dic__ProductItem *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProductItem * FASTCALL soap_instantiate_dic__ProductItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProductItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProductItem, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItem);
		ASSIGN_PTR(size, sizeof(dic__ProductItem));
		((dic__ProductItem*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProductItem[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProductItem));
		for(int i = 0; i < n; i++)
			((dic__ProductItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProductItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProductItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProductItem %p -> %p\n", q, p));
	*(dic__ProductItem*)p = *(dic__ProductItem*)q;
}

void dic__BusinessEntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__BusinessEntityList::__sizebusinessEntity = 0;
	this->dic__BusinessEntityList::businessEntity = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__BusinessEntityList::soap_serialize(struct soap *soap) const
{
	if(this->dic__BusinessEntityList::businessEntity) {
		for(int i = 0; i < this->dic__BusinessEntityList::__sizebusinessEntity; i++) {
			soap_serialize_PointerTodic__BusinessEntity(soap, this->dic__BusinessEntityList::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int dic__BusinessEntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__BusinessEntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__BusinessEntityList(struct soap *soap, const char *tag, int id, const dic__BusinessEntityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__BusinessEntityList), "dic:BusinessEntityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__BusinessEntityList::businessEntity) {
		int i;
		for(i = 0; i < a->dic__BusinessEntityList::__sizebusinessEntity; i++)
			if(soap_out_PointerTodic__BusinessEntity(soap, "dic:businessEntity", -1, a->dic__BusinessEntityList::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__BusinessEntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__BusinessEntityList(soap, tag, this, type);
}

SOAP_FMAC3 dic__BusinessEntityList * FASTCALL soap_in_dic__BusinessEntityList(struct soap *soap, const char *tag, dic__BusinessEntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__BusinessEntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__BusinessEntityList, sizeof(dic__BusinessEntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__BusinessEntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__BusinessEntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:businessEntity", 1, NULL)) {
				if(a->dic__BusinessEntityList::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->dic__BusinessEntityList::businessEntity = (dic__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(dic__BusinessEntity *));
					if(a->dic__BusinessEntityList::businessEntity == NULL)
						return NULL;
					*a->dic__BusinessEntityList::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:businessEntity", a->dic__BusinessEntityList::businessEntity, "dic:BusinessEntity"))
				{	a->dic__BusinessEntityList::__sizebusinessEntity++;
					a->dic__BusinessEntityList::businessEntity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__BusinessEntityList::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->dic__BusinessEntityList::__sizebusinessEntity)
			a->dic__BusinessEntityList::businessEntity = (dic__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->dic__BusinessEntityList::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__BusinessEntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__BusinessEntityList, 0, sizeof(dic__BusinessEntityList), 0, soap_copy_dic__BusinessEntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__BusinessEntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__BusinessEntityList);
	return this->soap_out(soap, tag?tag:"dic:BusinessEntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__BusinessEntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__BusinessEntityList(soap, this, tag, type);
}

SOAP_FMAC3 dic__BusinessEntityList * SOAP_FMAC4 soap_get_dic__BusinessEntityList(struct soap *soap, dic__BusinessEntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__BusinessEntityList * FASTCALL soap_instantiate_dic__BusinessEntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__BusinessEntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__BusinessEntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessEntityList);
		ASSIGN_PTR(size, sizeof(dic__BusinessEntityList));
		((dic__BusinessEntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessEntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__BusinessEntityList));
		for(int i = 0; i < n; i++)
			((dic__BusinessEntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__BusinessEntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__BusinessEntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__BusinessEntityList %p -> %p\n", q, p));
	*(dic__BusinessEntityList*)p = *(dic__BusinessEntityList*)q;
}

void dic__IncorporationForm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__IncorporationForm::name);
	soap_default_base__String255(soap, &this->dic__IncorporationForm::code);
	soap_default_base__String255(soap, &this->dic__IncorporationForm::shortName);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__IncorporationForm::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__IncorporationForm::name);
	soap_serialize_base__String255(soap, &this->dic__IncorporationForm::code);
	soap_serialize_base__String255(soap, &this->dic__IncorporationForm::shortName);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__IncorporationForm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__IncorporationForm(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__IncorporationForm(struct soap *soap, const char *tag, int id, const dic__IncorporationForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__IncorporationForm), "dic:IncorporationForm"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__IncorporationForm::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:code", -1, &(a->dic__IncorporationForm::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:shortName", -1, &(a->dic__IncorporationForm::shortName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__IncorporationForm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__IncorporationForm(soap, tag, this, type);
}

SOAP_FMAC3 dic__IncorporationForm * FASTCALL soap_in_dic__IncorporationForm(struct soap *soap, const char *tag, dic__IncorporationForm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__IncorporationForm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__IncorporationForm, sizeof(dic__IncorporationForm), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__IncorporationForm) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__IncorporationForm *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_shortName1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__IncorporationForm::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:code", &(a->dic__IncorporationForm::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:shortName", &(a->dic__IncorporationForm::shortName), "base:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__IncorporationForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__IncorporationForm, 0, sizeof(dic__IncorporationForm), 0, soap_copy_dic__IncorporationForm);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__IncorporationForm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__IncorporationForm);
	return this->soap_out(soap, tag?tag:"dic:IncorporationForm", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__IncorporationForm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__IncorporationForm(soap, this, tag, type);
}

SOAP_FMAC3 dic__IncorporationForm * SOAP_FMAC4 soap_get_dic__IncorporationForm(struct soap *soap, dic__IncorporationForm *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__IncorporationForm * FASTCALL soap_instantiate_dic__IncorporationForm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__IncorporationForm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__IncorporationForm, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__IncorporationForm);
		ASSIGN_PTR(size, sizeof(dic__IncorporationForm));
		((dic__IncorporationForm*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__IncorporationForm[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__IncorporationForm));
		for(int i = 0; i < n; i++)
			((dic__IncorporationForm*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__IncorporationForm*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__IncorporationForm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__IncorporationForm %p -> %p\n", q, p));
	*(dic__IncorporationForm*)p = *(dic__IncorporationForm*)q;
}

void dic__BusinessEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__BusinessEntity::type = NULL;
	soap_default_base__String255(soap, &this->dic__BusinessEntity::name);
	this->dic__BusinessEntity::incorporationForm = NULL;
	soap_default_base__String255(soap, &this->dic__BusinessEntity::fullName);
	soap_default_base__String255(soap, &this->dic__BusinessEntity::fio);
	soap_default_base__String255(soap, &this->dic__BusinessEntity::passport);
	soap_default_base__String255(soap, &this->dic__BusinessEntity::inn);
	soap_default_base__String255(soap, &this->dic__BusinessEntity::kpp);
	soap_default_base__String255(soap, &this->dic__BusinessEntity::ogrn);
	this->dic__BusinessEntity::juridicalAddress = NULL;
	this->dic__BusinessEntity::__sizeactivityLocation = 0;
	this->dic__BusinessEntity::activityLocation = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__BusinessEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessEntityType(soap, &this->dic__BusinessEntity::type);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::name);
	soap_serialize_PointerTodic__IncorporationForm(soap, &this->dic__BusinessEntity::incorporationForm);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::fullName);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::fio);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::passport);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::inn);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::kpp);
	soap_serialize_base__String255(soap, &this->dic__BusinessEntity::ogrn);
	soap_serialize_PointerTodic__Address(soap, &this->dic__BusinessEntity::juridicalAddress);
	if(this->dic__BusinessEntity::activityLocation) {
		for(int i = 0; i < this->dic__BusinessEntity::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->dic__BusinessEntity::activityLocation + i, SOAP_TYPE__dic__BusinessEntity_activityLocation);
			this->dic__BusinessEntity::activityLocation[i].soap_serialize(soap);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__BusinessEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__BusinessEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__BusinessEntity(struct soap *soap, const char *tag, int id, const dic__BusinessEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__BusinessEntity), "dic:BusinessEntity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntityType(soap, "dic:type", -1, &(a->dic__BusinessEntity::type), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__BusinessEntity::name), ""))
		return soap->error;
	if(soap_out_PointerTodic__IncorporationForm(soap, "dic:incorporationForm", -1, &(a->dic__BusinessEntity::incorporationForm), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:fullName", -1, &(a->dic__BusinessEntity::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:fio", -1, &(a->dic__BusinessEntity::fio), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:passport", -1, &(a->dic__BusinessEntity::passport), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:inn", -1, &(a->dic__BusinessEntity::inn), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:kpp", -1, &(a->dic__BusinessEntity::kpp), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:ogrn", -1, &(a->dic__BusinessEntity::ogrn), ""))
		return soap->error;
	if(soap_out_PointerTodic__Address(soap, "dic:juridicalAddress", -1, &(a->dic__BusinessEntity::juridicalAddress), ""))
		return soap->error;
	if(a->dic__BusinessEntity::activityLocation) {
		int i;
		for(i = 0; i < a->dic__BusinessEntity::__sizeactivityLocation; i++)
			if(a->dic__BusinessEntity::activityLocation[i].soap_out(soap, "dic:activityLocation", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__BusinessEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__BusinessEntity(soap, tag, this, type);
}

SOAP_FMAC3 dic__BusinessEntity * FASTCALL soap_in_dic__BusinessEntity(struct soap *soap, const char *tag, dic__BusinessEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__BusinessEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__BusinessEntity, sizeof(dic__BusinessEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__BusinessEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__BusinessEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_incorporationForm1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_passport1 = 1;
	size_t soap_flag_inn1 = 1;
	size_t soap_flag_kpp1 = 1;
	size_t soap_flag_ogrn1 = 1;
	size_t soap_flag_juridicalAddress1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntityType(soap, "dic:type", &(a->dic__BusinessEntity::type), "dic:BusinessEntityType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__BusinessEntity::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_incorporationForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__IncorporationForm(soap, "dic:incorporationForm", &(a->dic__BusinessEntity::incorporationForm), "dic:IncorporationForm"))
				{	soap_flag_incorporationForm1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:fullName", &(a->dic__BusinessEntity::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:fio", &(a->dic__BusinessEntity::fio), "base:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_passport1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:passport", &(a->dic__BusinessEntity::passport), "base:String255"))
				{	soap_flag_passport1--;
					continue;
				}
			if(soap_flag_inn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:inn", &(a->dic__BusinessEntity::inn), "base:String255"))
				{	soap_flag_inn1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:kpp", &(a->dic__BusinessEntity::kpp), "base:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			if(soap_flag_ogrn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:ogrn", &(a->dic__BusinessEntity::ogrn), "base:String255"))
				{	soap_flag_ogrn1--;
					continue;
				}
			if(soap_flag_juridicalAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Address(soap, "dic:juridicalAddress", &(a->dic__BusinessEntity::juridicalAddress), "dic:Address"))
				{	soap_flag_juridicalAddress1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:activityLocation", 1, NULL)) {
				if(a->dic__BusinessEntity::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->dic__BusinessEntity::activityLocation = (_dic__BusinessEntity_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_dic__BusinessEntity_activityLocation));
					if(a->dic__BusinessEntity::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->dic__BusinessEntity::activityLocation, _dic__BusinessEntity_activityLocation);
					a->dic__BusinessEntity::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__dic__BusinessEntity_activityLocation(soap, "dic:activityLocation", a->dic__BusinessEntity::activityLocation, ""))
				{	a->dic__BusinessEntity::__sizeactivityLocation++;
					a->dic__BusinessEntity::activityLocation = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__BusinessEntity::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->dic__BusinessEntity::__sizeactivityLocation)
			a->dic__BusinessEntity::activityLocation = (_dic__BusinessEntity_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->dic__BusinessEntity::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__BusinessEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__BusinessEntity, 0, sizeof(dic__BusinessEntity), 0, soap_copy_dic__BusinessEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__BusinessEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__BusinessEntity);
	return this->soap_out(soap, tag?tag:"dic:BusinessEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__BusinessEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__BusinessEntity(soap, this, tag, type);
}

SOAP_FMAC3 dic__BusinessEntity * SOAP_FMAC4 soap_get_dic__BusinessEntity(struct soap *soap, dic__BusinessEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__BusinessEntity * FASTCALL soap_instantiate_dic__BusinessEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__BusinessEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__BusinessEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity);
		ASSIGN_PTR(size, sizeof(dic__BusinessEntity));
		((dic__BusinessEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__BusinessEntity));
		for(int i = 0; i < n; i++)
			((dic__BusinessEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__BusinessEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__BusinessEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__BusinessEntity %p -> %p\n", q, p));
	*(dic__BusinessEntity*)p = *(dic__BusinessEntity*)q;
}

void dic__BusinessMember::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__BusinessMember::businessEntity = NULL;
	this->dic__BusinessMember::enterprise = NULL;
	this->dic__BusinessMember::__sizeglobalID = 0;
	this->dic__BusinessMember::globalID = NULL;
	/* transient soap skipped */
}

void dic__BusinessMember::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->dic__BusinessMember::businessEntity);
	soap_serialize_PointerTodic__Enterprise(soap, &this->dic__BusinessMember::enterprise);
	if(this->dic__BusinessMember::globalID) {
		for(int i = 0; i < this->dic__BusinessMember::__sizeglobalID; i++) {
			soap_serialize_dic__GLNType(soap, this->dic__BusinessMember::globalID + i);
		}
	}
	/* transient soap skipped */
}

int dic__BusinessMember::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__BusinessMember(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__BusinessMember(struct soap *soap, const char *tag, int id, const dic__BusinessMember *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__BusinessMember), type))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "dic:businessEntity", -1, &(a->dic__BusinessMember::businessEntity), ""))
		return soap->error;
	if(soap_out_PointerTodic__Enterprise(soap, "dic:enterprise", -1, &(a->dic__BusinessMember::enterprise), ""))
		return soap->error;
	if(a->dic__BusinessMember::globalID) {
		int i;
		for(i = 0; i < a->dic__BusinessMember::__sizeglobalID; i++)
			if(soap_out_dic__GLNType(soap, "dic:globalID", -1, a->dic__BusinessMember::globalID + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__BusinessMember::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__BusinessMember(soap, tag, this, type);
}

SOAP_FMAC3 dic__BusinessMember * FASTCALL soap_in_dic__BusinessMember(struct soap *soap, const char *tag, dic__BusinessMember *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__BusinessMember *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__BusinessMember, sizeof(dic__BusinessMember), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__BusinessMember) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__BusinessMember *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_enterprise1 = 1;
	struct soap_blist *soap_blist_globalID1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:businessEntity", &(a->dic__BusinessMember::businessEntity), "dic:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "dic:enterprise", &(a->dic__BusinessMember::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:globalID", 1, NULL)) {
				if(a->dic__BusinessMember::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->dic__BusinessMember::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->dic__BusinessMember::globalID == NULL)
						return NULL;
					*a->dic__BusinessMember::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_dic__GLNType(soap, "dic:globalID", a->dic__BusinessMember::globalID, "dic:GLNType"))
				{	a->dic__BusinessMember::__sizeglobalID++;
					a->dic__BusinessMember::globalID = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__BusinessMember::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->dic__BusinessMember::__sizeglobalID)
			a->dic__BusinessMember::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->dic__BusinessMember::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__BusinessMember *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__BusinessMember, 0, sizeof(dic__BusinessMember), 0, soap_copy_dic__BusinessMember);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__BusinessMember::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__BusinessMember);
	return this->soap_out(soap, tag?tag:"dic:BusinessMember", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__BusinessMember::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__BusinessMember(soap, this, tag, type);
}

SOAP_FMAC3 dic__BusinessMember * SOAP_FMAC4 soap_get_dic__BusinessMember(struct soap *soap, dic__BusinessMember *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__BusinessMember * FASTCALL soap_instantiate_dic__BusinessMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__BusinessMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__BusinessMember, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessMember);
		ASSIGN_PTR(size, sizeof(dic__BusinessMember));
		((dic__BusinessMember*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__BusinessMember[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__BusinessMember));
		for(int i = 0; i < n; i++)
			((dic__BusinessMember*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__BusinessMember*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__BusinessMember(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__BusinessMember %p -> %p\n", q, p));
	*(dic__BusinessMember*)p = *(dic__BusinessMember*)q;
}

void dic__EnterpriseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__EnterpriseList::__sizeenterprise = 0;
	this->dic__EnterpriseList::enterprise = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__EnterpriseList::soap_serialize(struct soap *soap) const
{
	if(this->dic__EnterpriseList::enterprise) {
		for(int i = 0; i < this->dic__EnterpriseList::__sizeenterprise; i++) {
			soap_serialize_PointerTodic__Enterprise(soap, this->dic__EnterpriseList::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int dic__EnterpriseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__EnterpriseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseList(struct soap *soap, const char *tag, int id, const dic__EnterpriseList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseList), "dic:EnterpriseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__EnterpriseList::enterprise) {
		int i;
		for(i = 0; i < a->dic__EnterpriseList::__sizeenterprise; i++)
			if(soap_out_PointerTodic__Enterprise(soap, "dic:enterprise", -1, a->dic__EnterpriseList::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__EnterpriseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__EnterpriseList(soap, tag, this, type);
}

SOAP_FMAC3 dic__EnterpriseList * FASTCALL soap_in_dic__EnterpriseList(struct soap *soap, const char *tag, dic__EnterpriseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__EnterpriseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseList, sizeof(dic__EnterpriseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__EnterpriseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__EnterpriseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:enterprise", 1, NULL)) {
				if(a->dic__EnterpriseList::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->dic__EnterpriseList::enterprise = (dic__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(dic__Enterprise *));
					if(a->dic__EnterpriseList::enterprise == NULL)
						return NULL;
					*a->dic__EnterpriseList::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Enterprise(soap, "dic:enterprise", a->dic__EnterpriseList::enterprise, "dic:Enterprise"))
				{	a->dic__EnterpriseList::__sizeenterprise++;
					a->dic__EnterpriseList::enterprise = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__EnterpriseList::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->dic__EnterpriseList::__sizeenterprise)
			a->dic__EnterpriseList::enterprise = (dic__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->dic__EnterpriseList::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__EnterpriseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseList, 0, sizeof(dic__EnterpriseList), 0, soap_copy_dic__EnterpriseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__EnterpriseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseList);
	return this->soap_out(soap, tag?tag:"dic:EnterpriseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__EnterpriseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__EnterpriseList(soap, this, tag, type);
}

SOAP_FMAC3 dic__EnterpriseList * SOAP_FMAC4 soap_get_dic__EnterpriseList(struct soap *soap, dic__EnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__EnterpriseList * FASTCALL soap_instantiate_dic__EnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__EnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__EnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseList);
		ASSIGN_PTR(size, sizeof(dic__EnterpriseList));
		((dic__EnterpriseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__EnterpriseList));
		for(int i = 0; i < n; i++)
			((dic__EnterpriseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__EnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__EnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__EnterpriseList %p -> %p\n", q, p));
	*(dic__EnterpriseList*)p = *(dic__EnterpriseList*)q;
}

void dic__EnterpriseNumberList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__EnterpriseNumberList::__sizeenterpriseNumber = 0;
	this->dic__EnterpriseNumberList::enterpriseNumber = NULL;
	/* transient soap skipped */
}

void dic__EnterpriseNumberList::soap_serialize(struct soap *soap) const
{
	if(this->dic__EnterpriseNumberList::enterpriseNumber) {
		for(int i = 0; i < this->dic__EnterpriseNumberList::__sizeenterpriseNumber; i++) {
			soap_serialize_base__String255(soap, this->dic__EnterpriseNumberList::enterpriseNumber + i);
		}
	}
	/* transient soap skipped */
}

int dic__EnterpriseNumberList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__EnterpriseNumberList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseNumberList(struct soap *soap, const char *tag, int id, const dic__EnterpriseNumberList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseNumberList), type))
		return soap->error;
	if(a->dic__EnterpriseNumberList::enterpriseNumber) {
		int i;
		for(i = 0; i < a->dic__EnterpriseNumberList::__sizeenterpriseNumber; i++)
			if(soap_out_base__String255(soap, "dic:enterpriseNumber", -1, a->dic__EnterpriseNumberList::enterpriseNumber + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__EnterpriseNumberList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__EnterpriseNumberList(soap, tag, this, type);
}

SOAP_FMAC3 dic__EnterpriseNumberList * FASTCALL soap_in_dic__EnterpriseNumberList(struct soap *soap, const char *tag, dic__EnterpriseNumberList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__EnterpriseNumberList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseNumberList, sizeof(dic__EnterpriseNumberList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__EnterpriseNumberList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__EnterpriseNumberList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterpriseNumber1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:enterpriseNumber", 1, NULL)) {
				if(a->dic__EnterpriseNumberList::enterpriseNumber == NULL) {
					if(soap_blist_enterpriseNumber1 == NULL)
						soap_blist_enterpriseNumber1 = soap_new_block(soap);
					a->dic__EnterpriseNumberList::enterpriseNumber = (char **)soap_push_block(soap, soap_blist_enterpriseNumber1, sizeof(char *));
					if(a->dic__EnterpriseNumberList::enterpriseNumber == NULL)
						return NULL;
					*a->dic__EnterpriseNumberList::enterpriseNumber = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__String255(soap, "dic:enterpriseNumber", a->dic__EnterpriseNumberList::enterpriseNumber, "base:String255"))
				{	a->dic__EnterpriseNumberList::__sizeenterpriseNumber++;
					a->dic__EnterpriseNumberList::enterpriseNumber = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__EnterpriseNumberList::enterpriseNumber)
			soap_pop_block(soap, soap_blist_enterpriseNumber1);
		if(a->dic__EnterpriseNumberList::__sizeenterpriseNumber)
			a->dic__EnterpriseNumberList::enterpriseNumber = (char **)soap_save_block(soap, soap_blist_enterpriseNumber1, NULL, 1);
		else
		{	a->dic__EnterpriseNumberList::enterpriseNumber = NULL;
			if(soap_blist_enterpriseNumber1)
				soap_end_block(soap, soap_blist_enterpriseNumber1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__EnterpriseNumberList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseNumberList, 0, sizeof(dic__EnterpriseNumberList), 0, soap_copy_dic__EnterpriseNumberList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__EnterpriseNumberList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseNumberList);
	return this->soap_out(soap, tag?tag:"dic:EnterpriseNumberList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__EnterpriseNumberList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__EnterpriseNumberList(soap, this, tag, type);
}

SOAP_FMAC3 dic__EnterpriseNumberList * SOAP_FMAC4 soap_get_dic__EnterpriseNumberList(struct soap *soap, dic__EnterpriseNumberList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__EnterpriseNumberList * FASTCALL soap_instantiate_dic__EnterpriseNumberList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__EnterpriseNumberList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__EnterpriseNumberList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseNumberList);
		ASSIGN_PTR(size, sizeof(dic__EnterpriseNumberList));
		((dic__EnterpriseNumberList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseNumberList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__EnterpriseNumberList));
		for(int i = 0; i < n; i++)
			((dic__EnterpriseNumberList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__EnterpriseNumberList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__EnterpriseNumberList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__EnterpriseNumberList %p -> %p\n", q, p));
	*(dic__EnterpriseNumberList*)p = *(dic__EnterpriseNumberList*)q;
}

void dic__ProducerList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__ProducerList::__sizeproducer = 0;
	this->dic__ProducerList::producer = NULL;
	/* transient soap skipped */
}

void dic__ProducerList::soap_serialize(struct soap *soap) const
{
	if(this->dic__ProducerList::producer) {
		for(int i = 0; i < this->dic__ProducerList::__sizeproducer; i++) {
			soap_serialize_PointerTodic__Producer(soap, this->dic__ProducerList::producer + i);
		}
	}
	/* transient soap skipped */
}

int dic__ProducerList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__ProducerList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ProducerList(struct soap *soap, const char *tag, int id, const dic__ProducerList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__ProducerList), type))
		return soap->error;
	if(a->dic__ProducerList::producer) {
		int i;
		for(i = 0; i < a->dic__ProducerList::__sizeproducer; i++)
			if(soap_out_PointerTodic__Producer(soap, "dic:producer", -1, a->dic__ProducerList::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__ProducerList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__ProducerList(soap, tag, this, type);
}

SOAP_FMAC3 dic__ProducerList * FASTCALL soap_in_dic__ProducerList(struct soap *soap, const char *tag, dic__ProducerList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__ProducerList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__ProducerList, sizeof(dic__ProducerList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__ProducerList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__ProducerList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:producer", 1, NULL)) {
				if(a->dic__ProducerList::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->dic__ProducerList::producer = (dic__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(dic__Producer *));
					if(a->dic__ProducerList::producer == NULL)
						return NULL;
					*a->dic__ProducerList::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Producer(soap, "dic:producer", a->dic__ProducerList::producer, "dic:Producer"))
				{	a->dic__ProducerList::__sizeproducer++;
					a->dic__ProducerList::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__ProducerList::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->dic__ProducerList::__sizeproducer)
			a->dic__ProducerList::producer = (dic__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->dic__ProducerList::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__ProducerList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__ProducerList, 0, sizeof(dic__ProducerList), 0, soap_copy_dic__ProducerList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__ProducerList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__ProducerList);
	return this->soap_out(soap, tag?tag:"dic:ProducerList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__ProducerList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__ProducerList(soap, this, tag, type);
}

SOAP_FMAC3 dic__ProducerList * SOAP_FMAC4 soap_get_dic__ProducerList(struct soap *soap, dic__ProducerList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ProducerList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__ProducerList * FASTCALL soap_instantiate_dic__ProducerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__ProducerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__ProducerList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__ProducerList);
		ASSIGN_PTR(size, sizeof(dic__ProducerList));
		((dic__ProducerList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__ProducerList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__ProducerList));
		for(int i = 0; i < n; i++)
			((dic__ProducerList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__ProducerList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__ProducerList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__ProducerList %p -> %p\n", q, p));
	*(dic__ProducerList*)p = *(dic__ProducerList*)q;
}

void dic__Producer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__Producer::enterprise = NULL;
	this->dic__Producer::role = NULL;
	/* transient soap skipped */
}

void dic__Producer::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->dic__Producer::enterprise);
	soap_serialize_PointerTodic__EnterpriseRole(soap, &this->dic__Producer::role);
	/* transient soap skipped */
}

int dic__Producer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Producer(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Producer(struct soap *soap, const char *tag, int id, const dic__Producer *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Producer), type))
		return soap->error;
	if(a->dic__Producer::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "dic:enterprise", -1, &a->dic__Producer::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterprise"))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseRole(soap, "dic:role", -1, &(a->dic__Producer::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Producer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Producer(soap, tag, this, type);
}

SOAP_FMAC3 dic__Producer * FASTCALL soap_in_dic__Producer(struct soap *soap, const char *tag, dic__Producer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Producer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Producer, sizeof(dic__Producer), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Producer) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Producer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_role1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "dic:enterprise", &(a->dic__Producer::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseRole(soap, "dic:role", &(a->dic__Producer::role), "dic:EnterpriseRole"))
				{	soap_flag_role1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Producer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Producer, 0, sizeof(dic__Producer), 0, soap_copy_dic__Producer);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dic__Producer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Producer);
	return this->soap_out(soap, tag?tag:"dic:Producer", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Producer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Producer(soap, this, tag, type);
}

SOAP_FMAC3 dic__Producer * SOAP_FMAC4 soap_get_dic__Producer(struct soap *soap, dic__Producer *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Producer * FASTCALL soap_instantiate_dic__Producer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Producer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Producer, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Producer);
		ASSIGN_PTR(size, sizeof(dic__Producer));
		((dic__Producer*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Producer[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Producer));
		for(int i = 0; i < n; i++)
			((dic__Producer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Producer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Producer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Producer %p -> %p\n", q, p));
	*(dic__Producer*)p = *(dic__Producer*)q;
}

void dic__EnterpriseActivity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__EnterpriseActivity::name = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__EnterpriseActivity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__NText(soap, &this->dic__EnterpriseActivity::name);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__EnterpriseActivity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__EnterpriseActivity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseActivity(struct soap *soap, const char *tag, int id, const dic__EnterpriseActivity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseActivity), "dic:EnterpriseActivity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTobase__NText(soap, "dic:name", -1, &(a->dic__EnterpriseActivity::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__EnterpriseActivity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__EnterpriseActivity(soap, tag, this, type);
}

SOAP_FMAC3 dic__EnterpriseActivity * FASTCALL soap_in_dic__EnterpriseActivity(struct soap *soap, const char *tag, dic__EnterpriseActivity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__EnterpriseActivity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseActivity, sizeof(dic__EnterpriseActivity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__EnterpriseActivity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__EnterpriseActivity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:name", &(a->dic__EnterpriseActivity::name), "base:NText"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__EnterpriseActivity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseActivity, 0, sizeof(dic__EnterpriseActivity), 0, soap_copy_dic__EnterpriseActivity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__EnterpriseActivity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseActivity);
	return this->soap_out(soap, tag?tag:"dic:EnterpriseActivity", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__EnterpriseActivity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__EnterpriseActivity(soap, this, tag, type);
}

SOAP_FMAC3 dic__EnterpriseActivity * SOAP_FMAC4 soap_get_dic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__EnterpriseActivity * FASTCALL soap_instantiate_dic__EnterpriseActivity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__EnterpriseActivity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__EnterpriseActivity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivity);
		ASSIGN_PTR(size, sizeof(dic__EnterpriseActivity));
		((dic__EnterpriseActivity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__EnterpriseActivity));
		for(int i = 0; i < n; i++)
			((dic__EnterpriseActivity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__EnterpriseActivity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__EnterpriseActivity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__EnterpriseActivity %p -> %p\n", q, p));
	*(dic__EnterpriseActivity*)p = *(dic__EnterpriseActivity*)q;
}

void dic__EnterpriseActivityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__EnterpriseActivityList::__sizeactivity = 0;
	this->dic__EnterpriseActivityList::activity = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__EnterpriseActivityList::soap_serialize(struct soap *soap) const
{
	if(this->dic__EnterpriseActivityList::activity) {
		for(int i = 0; i < this->dic__EnterpriseActivityList::__sizeactivity; i++) {
			soap_serialize_PointerTodic__EnterpriseActivity(soap, this->dic__EnterpriseActivityList::activity + i);
		}
	}
	/* transient soap skipped */
}

int dic__EnterpriseActivityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__EnterpriseActivityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseActivityList(struct soap *soap, const char *tag, int id, const dic__EnterpriseActivityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__EnterpriseActivityList), "dic:EnterpriseActivityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__EnterpriseActivityList::activity) {
		int i;
		for(i = 0; i < a->dic__EnterpriseActivityList::__sizeactivity; i++)
			if(soap_out_PointerTodic__EnterpriseActivity(soap, "dic:activity", -1, a->dic__EnterpriseActivityList::activity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__EnterpriseActivityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__EnterpriseActivityList(soap, tag, this, type);
}

SOAP_FMAC3 dic__EnterpriseActivityList * FASTCALL soap_in_dic__EnterpriseActivityList(struct soap *soap, const char *tag, dic__EnterpriseActivityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__EnterpriseActivityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__EnterpriseActivityList, sizeof(dic__EnterpriseActivityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__EnterpriseActivityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__EnterpriseActivityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_activity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:activity", 1, NULL)) {
				if(a->dic__EnterpriseActivityList::activity == NULL) {
					if(soap_blist_activity1 == NULL)
						soap_blist_activity1 = soap_new_block(soap);
					a->dic__EnterpriseActivityList::activity = (dic__EnterpriseActivity **)soap_push_block(soap, soap_blist_activity1, sizeof(dic__EnterpriseActivity *));
					if(a->dic__EnterpriseActivityList::activity == NULL)
						return NULL;
					*a->dic__EnterpriseActivityList::activity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__EnterpriseActivity(soap, "dic:activity", a->dic__EnterpriseActivityList::activity, "dic:EnterpriseActivity"))
				{	a->dic__EnterpriseActivityList::__sizeactivity++;
					a->dic__EnterpriseActivityList::activity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__EnterpriseActivityList::activity)
			soap_pop_block(soap, soap_blist_activity1);
		if(a->dic__EnterpriseActivityList::__sizeactivity)
			a->dic__EnterpriseActivityList::activity = (dic__EnterpriseActivity **)soap_save_block(soap, soap_blist_activity1, NULL, 1);
		else
		{	a->dic__EnterpriseActivityList::activity = NULL;
			if(soap_blist_activity1)
				soap_end_block(soap, soap_blist_activity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__EnterpriseActivityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__EnterpriseActivityList, 0, sizeof(dic__EnterpriseActivityList), 0, soap_copy_dic__EnterpriseActivityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__EnterpriseActivityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseActivityList);
	return this->soap_out(soap, tag?tag:"dic:EnterpriseActivityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__EnterpriseActivityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__EnterpriseActivityList(soap, this, tag, type);
}

SOAP_FMAC3 dic__EnterpriseActivityList * SOAP_FMAC4 soap_get_dic__EnterpriseActivityList(struct soap *soap, dic__EnterpriseActivityList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__EnterpriseActivityList * FASTCALL soap_instantiate_dic__EnterpriseActivityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__EnterpriseActivityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__EnterpriseActivityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivityList);
		ASSIGN_PTR(size, sizeof(dic__EnterpriseActivityList));
		((dic__EnterpriseActivityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__EnterpriseActivityList));
		for(int i = 0; i < n; i++)
			((dic__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__EnterpriseActivityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__EnterpriseActivityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__EnterpriseActivityList %p -> %p\n", q, p));
	*(dic__EnterpriseActivityList*)p = *(dic__EnterpriseActivityList*)q;
}

void dic__Enterprise::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Enterprise::name);
	soap_default_base__String255(soap, &this->dic__Enterprise::englishName);
	this->dic__Enterprise::type = NULL;
	this->dic__Enterprise::numberList = NULL;
	this->dic__Enterprise::address = NULL;
	this->dic__Enterprise::activityList = NULL;
	this->dic__Enterprise::owner = NULL;
	this->dic__Enterprise::__sizeofficialRegistration = 0;
	this->dic__Enterprise::officialRegistration = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Enterprise::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Enterprise::name);
	soap_serialize_base__String255(soap, &this->dic__Enterprise::englishName);
	soap_serialize_PointerTodic__EnterpriseType(soap, &this->dic__Enterprise::type);
	soap_serialize_PointerTodic__EnterpriseNumberList(soap, &this->dic__Enterprise::numberList);
	soap_serialize_PointerTodic__Address(soap, &this->dic__Enterprise::address);
	soap_serialize_PointerTodic__EnterpriseActivityList(soap, &this->dic__Enterprise::activityList);
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->dic__Enterprise::owner);
	if(this->dic__Enterprise::officialRegistration) {
		for(int i = 0; i < this->dic__Enterprise::__sizeofficialRegistration; i++) {
			soap_serialize_PointerTodic__EnterpriseOfficialRegistration(soap, this->dic__Enterprise::officialRegistration + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Enterprise::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Enterprise(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Enterprise(struct soap *soap, const char *tag, int id, const dic__Enterprise *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Enterprise), "dic:Enterprise"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Enterprise::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__Enterprise::englishName), ""))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseType(soap, "dic:type", -1, &(a->dic__Enterprise::type), ""))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseNumberList(soap, "dic:numberList", -1, &(a->dic__Enterprise::numberList), ""))
		return soap->error;
	if(soap_out_PointerTodic__Address(soap, "dic:address", -1, &(a->dic__Enterprise::address), ""))
		return soap->error;
	if(soap_out_PointerTodic__EnterpriseActivityList(soap, "dic:activityList", -1, &(a->dic__Enterprise::activityList), ""))
		return soap->error;
	if(soap_out_PointerTodic__BusinessEntity(soap, "dic:owner", -1, &(a->dic__Enterprise::owner), ""))
		return soap->error;
	if(a->dic__Enterprise::officialRegistration) {
		int i;
		for(i = 0; i < a->dic__Enterprise::__sizeofficialRegistration; i++)
			if(soap_out_PointerTodic__EnterpriseOfficialRegistration(soap, "dic:officialRegistration", -1, a->dic__Enterprise::officialRegistration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__Enterprise::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Enterprise(soap, tag, this, type);
}

SOAP_FMAC3 dic__Enterprise * FASTCALL soap_in_dic__Enterprise(struct soap *soap, const char *tag, dic__Enterprise *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Enterprise *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Enterprise, sizeof(dic__Enterprise), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Enterprise) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Enterprise *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_numberList1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_activityList1 = 1;
	size_t soap_flag_owner1 = 1;
	struct soap_blist *soap_blist_officialRegistration1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Enterprise::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__Enterprise::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseType(soap, "dic:type", &(a->dic__Enterprise::type), "dic:EnterpriseType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_numberList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseNumberList(soap, "dic:numberList", &(a->dic__Enterprise::numberList), "dic:EnterpriseNumberList"))
				{	soap_flag_numberList1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Address(soap, "dic:address", &(a->dic__Enterprise::address), "dic:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if(soap_flag_activityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__EnterpriseActivityList(soap, "dic:activityList", &(a->dic__Enterprise::activityList), "dic:EnterpriseActivityList"))
				{	soap_flag_activityList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "dic:owner", &(a->dic__Enterprise::owner), "dic:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:officialRegistration", 1, NULL)) {
				if(a->dic__Enterprise::officialRegistration == NULL) {
					if(soap_blist_officialRegistration1 == NULL)
						soap_blist_officialRegistration1 = soap_new_block(soap);
					a->dic__Enterprise::officialRegistration = (dic__EnterpriseOfficialRegistration **)soap_push_block(soap, soap_blist_officialRegistration1, sizeof(dic__EnterpriseOfficialRegistration *));
					if(a->dic__Enterprise::officialRegistration == NULL)
						return NULL;
					*a->dic__Enterprise::officialRegistration = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__EnterpriseOfficialRegistration(soap, "dic:officialRegistration", a->dic__Enterprise::officialRegistration, "dic:EnterpriseOfficialRegistration"))
				{	a->dic__Enterprise::__sizeofficialRegistration++;
					a->dic__Enterprise::officialRegistration = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__Enterprise::officialRegistration)
			soap_pop_block(soap, soap_blist_officialRegistration1);
		if(a->dic__Enterprise::__sizeofficialRegistration)
			a->dic__Enterprise::officialRegistration = (dic__EnterpriseOfficialRegistration **)soap_save_block(soap, soap_blist_officialRegistration1, NULL, 1);
		else
		{	a->dic__Enterprise::officialRegistration = NULL;
			if(soap_blist_officialRegistration1)
				soap_end_block(soap, soap_blist_officialRegistration1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Enterprise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Enterprise, 0, sizeof(dic__Enterprise), 0, soap_copy_dic__Enterprise);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Enterprise::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Enterprise);
	return this->soap_out(soap, tag?tag:"dic:Enterprise", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Enterprise::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Enterprise(soap, this, tag, type);
}

SOAP_FMAC3 dic__Enterprise * SOAP_FMAC4 soap_get_dic__Enterprise(struct soap *soap, dic__Enterprise *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Enterprise * FASTCALL soap_instantiate_dic__Enterprise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Enterprise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Enterprise, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Enterprise);
		ASSIGN_PTR(size, sizeof(dic__Enterprise));
		((dic__Enterprise*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Enterprise[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Enterprise));
		for(int i = 0; i < n; i++)
			((dic__Enterprise*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Enterprise*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Enterprise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Enterprise %p -> %p\n", q, p));
	*(dic__Enterprise*)p = *(dic__Enterprise*)q;
}

void dic__StreetList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__StreetList::__sizestreet = 0;
	this->dic__StreetList::street = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__StreetList::soap_serialize(struct soap *soap) const
{
	if(this->dic__StreetList::street) {
		for(int i = 0; i < this->dic__StreetList::__sizestreet; i++) {
			soap_serialize_PointerTodic__Street(soap, this->dic__StreetList::street + i);
		}
	}
	/* transient soap skipped */
}

int dic__StreetList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__StreetList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__StreetList(struct soap *soap, const char *tag, int id, const dic__StreetList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__StreetList), "dic:StreetList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__StreetList::street) {
		int i;
		for(i = 0; i < a->dic__StreetList::__sizestreet; i++)
			if(soap_out_PointerTodic__Street(soap, "dic:street", -1, a->dic__StreetList::street + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__StreetList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__StreetList(soap, tag, this, type);
}

SOAP_FMAC3 dic__StreetList * FASTCALL soap_in_dic__StreetList(struct soap *soap, const char *tag, dic__StreetList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__StreetList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__StreetList, sizeof(dic__StreetList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__StreetList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__StreetList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_street1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:street", 1, NULL)) {
				if(a->dic__StreetList::street == NULL) {
					if(soap_blist_street1 == NULL)
						soap_blist_street1 = soap_new_block(soap);
					a->dic__StreetList::street = (dic__Street **)soap_push_block(soap, soap_blist_street1, sizeof(dic__Street *));
					if(a->dic__StreetList::street == NULL)
						return NULL;
					*a->dic__StreetList::street = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Street(soap, "dic:street", a->dic__StreetList::street, "dic:Street"))
				{	a->dic__StreetList::__sizestreet++;
					a->dic__StreetList::street = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__StreetList::street)
			soap_pop_block(soap, soap_blist_street1);
		if(a->dic__StreetList::__sizestreet)
			a->dic__StreetList::street = (dic__Street **)soap_save_block(soap, soap_blist_street1, NULL, 1);
		else
		{	a->dic__StreetList::street = NULL;
			if(soap_blist_street1)
				soap_end_block(soap, soap_blist_street1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__StreetList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__StreetList, 0, sizeof(dic__StreetList), 0, soap_copy_dic__StreetList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__StreetList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__StreetList);
	return this->soap_out(soap, tag?tag:"dic:StreetList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__StreetList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__StreetList(soap, this, tag, type);
}

SOAP_FMAC3 dic__StreetList * SOAP_FMAC4 soap_get_dic__StreetList(struct soap *soap, dic__StreetList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__StreetList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__StreetList * FASTCALL soap_instantiate_dic__StreetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__StreetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__StreetList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__StreetList);
		ASSIGN_PTR(size, sizeof(dic__StreetList));
		((dic__StreetList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__StreetList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__StreetList));
		for(int i = 0; i < n; i++)
			((dic__StreetList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__StreetList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__StreetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__StreetList %p -> %p\n", q, p));
	*(dic__StreetList*)p = *(dic__StreetList*)q;
}

void dic__LocalityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__LocalityList::__sizelocality = 0;
	this->dic__LocalityList::locality = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__LocalityList::soap_serialize(struct soap *soap) const
{
	if(this->dic__LocalityList::locality) {
		for(int i = 0; i < this->dic__LocalityList::__sizelocality; i++) {
			soap_serialize_PointerTodic__Locality(soap, this->dic__LocalityList::locality + i);
		}
	}
	/* transient soap skipped */
}

int dic__LocalityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__LocalityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__LocalityList(struct soap *soap, const char *tag, int id, const dic__LocalityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__LocalityList), "dic:LocalityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__LocalityList::locality) {
		int i;
		for(i = 0; i < a->dic__LocalityList::__sizelocality; i++)
			if(soap_out_PointerTodic__Locality(soap, "dic:locality", -1, a->dic__LocalityList::locality + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__LocalityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__LocalityList(soap, tag, this, type);
}

SOAP_FMAC3 dic__LocalityList * FASTCALL soap_in_dic__LocalityList(struct soap *soap, const char *tag, dic__LocalityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__LocalityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__LocalityList, sizeof(dic__LocalityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__LocalityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__LocalityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_locality1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:locality", 1, NULL)) {
				if(a->dic__LocalityList::locality == NULL) {
					if(soap_blist_locality1 == NULL)
						soap_blist_locality1 = soap_new_block(soap);
					a->dic__LocalityList::locality = (dic__Locality **)soap_push_block(soap, soap_blist_locality1, sizeof(dic__Locality *));
					if(a->dic__LocalityList::locality == NULL)
						return NULL;
					*a->dic__LocalityList::locality = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Locality(soap, "dic:locality", a->dic__LocalityList::locality, "dic:Locality"))
				{	a->dic__LocalityList::__sizelocality++;
					a->dic__LocalityList::locality = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__LocalityList::locality)
			soap_pop_block(soap, soap_blist_locality1);
		if(a->dic__LocalityList::__sizelocality)
			a->dic__LocalityList::locality = (dic__Locality **)soap_save_block(soap, soap_blist_locality1, NULL, 1);
		else
		{	a->dic__LocalityList::locality = NULL;
			if(soap_blist_locality1)
				soap_end_block(soap, soap_blist_locality1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__LocalityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__LocalityList, 0, sizeof(dic__LocalityList), 0, soap_copy_dic__LocalityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__LocalityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__LocalityList);
	return this->soap_out(soap, tag?tag:"dic:LocalityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__LocalityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__LocalityList(soap, this, tag, type);
}

SOAP_FMAC3 dic__LocalityList * SOAP_FMAC4 soap_get_dic__LocalityList(struct soap *soap, dic__LocalityList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__LocalityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__LocalityList * FASTCALL soap_instantiate_dic__LocalityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__LocalityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__LocalityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__LocalityList);
		ASSIGN_PTR(size, sizeof(dic__LocalityList));
		((dic__LocalityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__LocalityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__LocalityList));
		for(int i = 0; i < n; i++)
			((dic__LocalityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__LocalityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__LocalityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__LocalityList %p -> %p\n", q, p));
	*(dic__LocalityList*)p = *(dic__LocalityList*)q;
}

void dic__DistrictList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__DistrictList::__sizedistrict = 0;
	this->dic__DistrictList::district = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__DistrictList::soap_serialize(struct soap *soap) const
{
	if(this->dic__DistrictList::district) {
		for(int i = 0; i < this->dic__DistrictList::__sizedistrict; i++) {
			soap_serialize_PointerTodic__District(soap, this->dic__DistrictList::district + i);
		}
	}
	/* transient soap skipped */
}

int dic__DistrictList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__DistrictList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__DistrictList(struct soap *soap, const char *tag, int id, const dic__DistrictList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__DistrictList), "dic:DistrictList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__DistrictList::district) {
		int i;
		for(i = 0; i < a->dic__DistrictList::__sizedistrict; i++)
			if(soap_out_PointerTodic__District(soap, "dic:district", -1, a->dic__DistrictList::district + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__DistrictList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__DistrictList(soap, tag, this, type);
}

SOAP_FMAC3 dic__DistrictList * FASTCALL soap_in_dic__DistrictList(struct soap *soap, const char *tag, dic__DistrictList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__DistrictList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__DistrictList, sizeof(dic__DistrictList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__DistrictList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__DistrictList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_district1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:district", 1, NULL)) {
				if(a->dic__DistrictList::district == NULL) {
					if(soap_blist_district1 == NULL)
						soap_blist_district1 = soap_new_block(soap);
					a->dic__DistrictList::district = (dic__District **)soap_push_block(soap, soap_blist_district1, sizeof(dic__District *));
					if(a->dic__DistrictList::district == NULL)
						return NULL;
					*a->dic__DistrictList::district = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__District(soap, "dic:district", a->dic__DistrictList::district, "dic:District"))
				{	a->dic__DistrictList::__sizedistrict++;
					a->dic__DistrictList::district = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__DistrictList::district)
			soap_pop_block(soap, soap_blist_district1);
		if(a->dic__DistrictList::__sizedistrict)
			a->dic__DistrictList::district = (dic__District **)soap_save_block(soap, soap_blist_district1, NULL, 1);
		else
		{	a->dic__DistrictList::district = NULL;
			if(soap_blist_district1)
				soap_end_block(soap, soap_blist_district1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__DistrictList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__DistrictList, 0, sizeof(dic__DistrictList), 0, soap_copy_dic__DistrictList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__DistrictList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__DistrictList);
	return this->soap_out(soap, tag?tag:"dic:DistrictList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__DistrictList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__DistrictList(soap, this, tag, type);
}

SOAP_FMAC3 dic__DistrictList * SOAP_FMAC4 soap_get_dic__DistrictList(struct soap *soap, dic__DistrictList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__DistrictList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__DistrictList * FASTCALL soap_instantiate_dic__DistrictList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__DistrictList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__DistrictList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__DistrictList);
		ASSIGN_PTR(size, sizeof(dic__DistrictList));
		((dic__DistrictList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__DistrictList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__DistrictList));
		for(int i = 0; i < n; i++)
			((dic__DistrictList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__DistrictList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__DistrictList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__DistrictList %p -> %p\n", q, p));
	*(dic__DistrictList*)p = *(dic__DistrictList*)q;
}

void dic__RegionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__RegionList::__sizeregion = 0;
	this->dic__RegionList::region = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__RegionList::soap_serialize(struct soap *soap) const
{
	if(this->dic__RegionList::region) {
		for(int i = 0; i < this->dic__RegionList::__sizeregion; i++) {
			soap_serialize_PointerTodic__Region(soap, this->dic__RegionList::region + i);
		}
	}
	/* transient soap skipped */
}

int dic__RegionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__RegionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__RegionList(struct soap *soap, const char *tag, int id, const dic__RegionList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__RegionList), "dic:RegionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__RegionList::region) {
		int i;
		for(i = 0; i < a->dic__RegionList::__sizeregion; i++)
			if(soap_out_PointerTodic__Region(soap, "dic:region", -1, a->dic__RegionList::region + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__RegionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__RegionList(soap, tag, this, type);
}

SOAP_FMAC3 dic__RegionList * FASTCALL soap_in_dic__RegionList(struct soap *soap, const char *tag, dic__RegionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__RegionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__RegionList, sizeof(dic__RegionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__RegionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__RegionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_region1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:region", 1, NULL)) {
				if(a->dic__RegionList::region == NULL) {
					if(soap_blist_region1 == NULL)
						soap_blist_region1 = soap_new_block(soap);
					a->dic__RegionList::region = (dic__Region **)soap_push_block(soap, soap_blist_region1, sizeof(dic__Region *));
					if(a->dic__RegionList::region == NULL)
						return NULL;
					*a->dic__RegionList::region = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Region(soap, "dic:region", a->dic__RegionList::region, "dic:Region"))
				{	a->dic__RegionList::__sizeregion++;
					a->dic__RegionList::region = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__RegionList::region)
			soap_pop_block(soap, soap_blist_region1);
		if(a->dic__RegionList::__sizeregion)
			a->dic__RegionList::region = (dic__Region **)soap_save_block(soap, soap_blist_region1, NULL, 1);
		else
		{	a->dic__RegionList::region = NULL;
			if(soap_blist_region1)
				soap_end_block(soap, soap_blist_region1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__RegionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__RegionList, 0, sizeof(dic__RegionList), 0, soap_copy_dic__RegionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__RegionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__RegionList);
	return this->soap_out(soap, tag?tag:"dic:RegionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__RegionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__RegionList(soap, this, tag, type);
}

SOAP_FMAC3 dic__RegionList * SOAP_FMAC4 soap_get_dic__RegionList(struct soap *soap, dic__RegionList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__RegionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__RegionList * FASTCALL soap_instantiate_dic__RegionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__RegionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__RegionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__RegionList);
		ASSIGN_PTR(size, sizeof(dic__RegionList));
		((dic__RegionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__RegionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__RegionList));
		for(int i = 0; i < n; i++)
			((dic__RegionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__RegionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__RegionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__RegionList %p -> %p\n", q, p));
	*(dic__RegionList*)p = *(dic__RegionList*)q;
}

void dic__CountryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__CountryList::__sizecountry = 0;
	this->dic__CountryList::country = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__CountryList::soap_serialize(struct soap *soap) const
{
	if(this->dic__CountryList::country) {
		for(int i = 0; i < this->dic__CountryList::__sizecountry; i++) {
			soap_serialize_PointerTodic__Country(soap, this->dic__CountryList::country + i);
		}
	}
	/* transient soap skipped */
}

int dic__CountryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__CountryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__CountryList(struct soap *soap, const char *tag, int id, const dic__CountryList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__CountryList), "dic:CountryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__CountryList::country) {
		int i;
		for(i = 0; i < a->dic__CountryList::__sizecountry; i++)
			if(soap_out_PointerTodic__Country(soap, "dic:country", -1, a->dic__CountryList::country + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__CountryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__CountryList(soap, tag, this, type);
}

SOAP_FMAC3 dic__CountryList * FASTCALL soap_in_dic__CountryList(struct soap *soap, const char *tag, dic__CountryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__CountryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__CountryList, sizeof(dic__CountryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__CountryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__CountryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_country1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:country", 1, NULL)) {
				if(a->dic__CountryList::country == NULL) {
					if(soap_blist_country1 == NULL)
						soap_blist_country1 = soap_new_block(soap);
					a->dic__CountryList::country = (dic__Country **)soap_push_block(soap, soap_blist_country1, sizeof(dic__Country *));
					if(a->dic__CountryList::country == NULL)
						return NULL;
					*a->dic__CountryList::country = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Country(soap, "dic:country", a->dic__CountryList::country, "dic:Country"))
				{	a->dic__CountryList::__sizecountry++;
					a->dic__CountryList::country = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__CountryList::country)
			soap_pop_block(soap, soap_blist_country1);
		if(a->dic__CountryList::__sizecountry)
			a->dic__CountryList::country = (dic__Country **)soap_save_block(soap, soap_blist_country1, NULL, 1);
		else
		{	a->dic__CountryList::country = NULL;
			if(soap_blist_country1)
				soap_end_block(soap, soap_blist_country1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__CountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__CountryList, 0, sizeof(dic__CountryList), 0, soap_copy_dic__CountryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__CountryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__CountryList);
	return this->soap_out(soap, tag?tag:"dic:CountryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__CountryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__CountryList(soap, this, tag, type);
}

SOAP_FMAC3 dic__CountryList * SOAP_FMAC4 soap_get_dic__CountryList(struct soap *soap, dic__CountryList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__CountryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__CountryList * FASTCALL soap_instantiate_dic__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__CountryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__CountryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__CountryList);
		ASSIGN_PTR(size, sizeof(dic__CountryList));
		((dic__CountryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__CountryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__CountryList));
		for(int i = 0; i < n; i++)
			((dic__CountryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__CountryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__CountryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__CountryList %p -> %p\n", q, p));
	*(dic__CountryList*)p = *(dic__CountryList*)q;
}

void dic__Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__Address::country = NULL;
	this->dic__Address::federalDistrict = NULL;
	this->dic__Address::region = NULL;
	this->dic__Address::district = NULL;
	this->dic__Address::locality = NULL;
	this->dic__Address::subLocality = NULL;
	this->dic__Address::street = NULL;
	soap_default_base__String255(soap, &this->dic__Address::house);
	soap_default_base__String255(soap, &this->dic__Address::building);
	soap_default_base__String255(soap, &this->dic__Address::room);
	soap_default_base__String255(soap, &this->dic__Address::postIndex);
	soap_default_base__String255(soap, &this->dic__Address::postBox);
	this->dic__Address::additionalInfo = NULL;
	this->dic__Address::addressView = NULL;
	this->dic__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void dic__Address::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Country(soap, &this->dic__Address::country);
	soap_serialize_PointerTodic__FederalDistrict(soap, &this->dic__Address::federalDistrict);
	soap_serialize_PointerTodic__Region(soap, &this->dic__Address::region);
	soap_serialize_PointerTodic__District(soap, &this->dic__Address::district);
	soap_serialize_PointerTodic__Locality(soap, &this->dic__Address::locality);
	soap_serialize_PointerTodic__Locality(soap, &this->dic__Address::subLocality);
	soap_serialize_PointerTodic__Street(soap, &this->dic__Address::street);
	soap_serialize_base__String255(soap, &this->dic__Address::house);
	soap_serialize_base__String255(soap, &this->dic__Address::building);
	soap_serialize_base__String255(soap, &this->dic__Address::room);
	soap_serialize_base__String255(soap, &this->dic__Address::postIndex);
	soap_serialize_base__String255(soap, &this->dic__Address::postBox);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::additionalInfo);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::addressView);
	soap_serialize_PointerTobase__NText(soap, &this->dic__Address::enAddressView);
	/* transient soap skipped */
}

int dic__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Address(struct soap *soap, const char *tag, int id, const dic__Address *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Address), type))
		return soap->error;
	if(soap_out_PointerTodic__Country(soap, "dic:country", -1, &(a->dic__Address::country), ""))
		return soap->error;
	if(soap_out_PointerTodic__FederalDistrict(soap, "dic:federalDistrict", -1, &(a->dic__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerTodic__Region(soap, "dic:region", -1, &(a->dic__Address::region), ""))
		return soap->error;
	if(soap_out_PointerTodic__District(soap, "dic:district", -1, &(a->dic__Address::district), ""))
		return soap->error;
	if(soap_out_PointerTodic__Locality(soap, "dic:locality", -1, &(a->dic__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerTodic__Locality(soap, "dic:subLocality", -1, &(a->dic__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerTodic__Street(soap, "dic:street", -1, &(a->dic__Address::street), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:house", -1, &(a->dic__Address::house), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:building", -1, &(a->dic__Address::building), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:room", -1, &(a->dic__Address::room), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:postIndex", -1, &(a->dic__Address::postIndex), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:postBox", -1, &(a->dic__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:additionalInfo", -1, &(a->dic__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:addressView", -1, &(a->dic__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "dic:enAddressView", -1, &(a->dic__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *dic__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Address(soap, tag, this, type);
}

SOAP_FMAC3 dic__Address * FASTCALL soap_in_dic__Address(struct soap *soap, const char *tag, dic__Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Address, sizeof(dic__Address), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Address) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country1 = 1;
	size_t soap_flag_federalDistrict1 = 1;
	size_t soap_flag_region1 = 1;
	size_t soap_flag_district1 = 1;
	size_t soap_flag_locality1 = 1;
	size_t soap_flag_subLocality1 = 1;
	size_t soap_flag_street1 = 1;
	size_t soap_flag_house1 = 1;
	size_t soap_flag_building1 = 1;
	size_t soap_flag_room1 = 1;
	size_t soap_flag_postIndex1 = 1;
	size_t soap_flag_postBox1 = 1;
	size_t soap_flag_additionalInfo1 = 1;
	size_t soap_flag_addressView1 = 1;
	size_t soap_flag_enAddressView1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Country(soap, "dic:country", &(a->dic__Address::country), "dic:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap_flag_federalDistrict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__FederalDistrict(soap, "dic:federalDistrict", &(a->dic__Address::federalDistrict), "dic:FederalDistrict"))
				{	soap_flag_federalDistrict1--;
					continue;
				}
			if(soap_flag_region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Region(soap, "dic:region", &(a->dic__Address::region), "dic:Region"))
				{	soap_flag_region1--;
					continue;
				}
			if(soap_flag_district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__District(soap, "dic:district", &(a->dic__Address::district), "dic:District"))
				{	soap_flag_district1--;
					continue;
				}
			if(soap_flag_locality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Locality(soap, "dic:locality", &(a->dic__Address::locality), "dic:Locality"))
				{	soap_flag_locality1--;
					continue;
				}
			if(soap_flag_subLocality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Locality(soap, "dic:subLocality", &(a->dic__Address::subLocality), "dic:Locality"))
				{	soap_flag_subLocality1--;
					continue;
				}
			if(soap_flag_street1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Street(soap, "dic:street", &(a->dic__Address::street), "dic:Street"))
				{	soap_flag_street1--;
					continue;
				}
			if(soap_flag_house1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:house", &(a->dic__Address::house), "base:String255"))
				{	soap_flag_house1--;
					continue;
				}
			if(soap_flag_building1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:building", &(a->dic__Address::building), "base:String255"))
				{	soap_flag_building1--;
					continue;
				}
			if(soap_flag_room1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:room", &(a->dic__Address::room), "base:String255"))
				{	soap_flag_room1--;
					continue;
				}
			if(soap_flag_postIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:postIndex", &(a->dic__Address::postIndex), "base:String255"))
				{	soap_flag_postIndex1--;
					continue;
				}
			if(soap_flag_postBox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:postBox", &(a->dic__Address::postBox), "base:String255"))
				{	soap_flag_postBox1--;
					continue;
				}
			if(soap_flag_additionalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:additionalInfo", &(a->dic__Address::additionalInfo), "base:NText"))
				{	soap_flag_additionalInfo1--;
					continue;
				}
			if(soap_flag_addressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:addressView", &(a->dic__Address::addressView), "base:NText"))
				{	soap_flag_addressView1--;
					continue;
				}
			if(soap_flag_enAddressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "dic:enAddressView", &(a->dic__Address::enAddressView), "base:NText"))
				{	soap_flag_enAddressView1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Address, 0, sizeof(dic__Address), 0, soap_copy_dic__Address);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Address);
	return this->soap_out(soap, tag?tag:"dic:Address", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Address(soap, this, tag, type);
}

SOAP_FMAC3 dic__Address * SOAP_FMAC4 soap_get_dic__Address(struct soap *soap, dic__Address *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Address * FASTCALL soap_instantiate_dic__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Address, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "dic:Area")) {
		cp->type = SOAP_TYPE_dic__Area;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Area);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Area));
			((dic__Area*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Area[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Area));
			for(int i = 0; i < n; i++)
				((dic__Area*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Area*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Address);
		ASSIGN_PTR(size, sizeof(dic__Address));
		((dic__Address*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Address[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Address));
		for(int i = 0; i < n; i++)
			((dic__Address*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Address %p -> %p\n", q, p));
	*(dic__Address*)p = *(dic__Address*)q;
}

void dic__Street::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->dic__Street::localityGuid);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_default_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	this->dic__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Street::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->dic__Street::localityGuid);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_serialize_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->dic__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Street::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Street(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Street(struct soap *soap, const char *tag, int id, const dic__Street *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Street), "dic:Street"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:view", -1, &(a->dic__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "dic:regionCode", -1, &(a->dic__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:type", -1, &(a->dic__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:countryGuid", -1, &(a->dic__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:hasStreets", -1, &(a->dic__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:localityGuid", -1, &(a->dic__Street::localityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Street::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Street(soap, tag, this, type);
}

SOAP_FMAC3 dic__Street * FASTCALL soap_in_dic__Street(struct soap *soap, const char *tag, dic__Street *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Street *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Street, sizeof(dic__Street), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Street) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Street *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:view", &(a->dic__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "dic:regionCode", &(a->dic__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:type", &(a->dic__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:countryGuid", &(a->dic__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:hasStreets", &(a->dic__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:localityGuid", &(a->dic__Street::localityGuid), "base:UUID"))
				{	soap_flag_localityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Street *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Street, 0, sizeof(dic__Street), 0, soap_copy_dic__Street);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Street::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Street);
	return this->soap_out(soap, tag?tag:"dic:Street", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Street::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Street(soap, this, tag, type);
}

SOAP_FMAC3 dic__Street * SOAP_FMAC4 soap_get_dic__Street(struct soap *soap, dic__Street *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Street * FASTCALL soap_instantiate_dic__Street(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Street(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Street, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Street);
		ASSIGN_PTR(size, sizeof(dic__Street));
		((dic__Street*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Street[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Street));
		for(int i = 0; i < n; i++)
			((dic__Street*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Street*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Street(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Street %p -> %p\n", q, p));
	*(dic__Street*)p = *(dic__Street*)q;
}

void dic__Locality::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->dic__Locality::regionGuid);
	soap_default_base__UUID(soap, &this->dic__Locality::districtGuid);
	soap_default_base__UUID(soap, &this->dic__Locality::cityGuid);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_default_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	this->dic__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Locality::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->dic__Locality::regionGuid);
	soap_serialize_base__UUID(soap, &this->dic__Locality::districtGuid);
	soap_serialize_base__UUID(soap, &this->dic__Locality::cityGuid);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_serialize_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->dic__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Locality::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Locality(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Locality(struct soap *soap, const char *tag, int id, const dic__Locality *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Locality), "dic:Locality"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:view", -1, &(a->dic__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "dic:regionCode", -1, &(a->dic__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:type", -1, &(a->dic__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:countryGuid", -1, &(a->dic__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:hasStreets", -1, &(a->dic__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:regionGuid", -1, &(a->dic__Locality::regionGuid), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:districtGuid", -1, &(a->dic__Locality::districtGuid), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:cityGuid", -1, &(a->dic__Locality::cityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Locality::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Locality(soap, tag, this, type);
}

SOAP_FMAC3 dic__Locality * FASTCALL soap_in_dic__Locality(struct soap *soap, const char *tag, dic__Locality *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Locality *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Locality, sizeof(dic__Locality), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Locality) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Locality *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	size_t soap_flag_districtGuid1 = 1;
	size_t soap_flag_cityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:view", &(a->dic__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "dic:regionCode", &(a->dic__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:type", &(a->dic__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:countryGuid", &(a->dic__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:hasStreets", &(a->dic__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:regionGuid", &(a->dic__Locality::regionGuid), "base:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap_flag_districtGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:districtGuid", &(a->dic__Locality::districtGuid), "base:UUID"))
				{	soap_flag_districtGuid1--;
					continue;
				}
			if(soap_flag_cityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:cityGuid", &(a->dic__Locality::cityGuid), "base:UUID"))
				{	soap_flag_cityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Locality *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Locality, 0, sizeof(dic__Locality), 0, soap_copy_dic__Locality);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Locality::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Locality);
	return this->soap_out(soap, tag?tag:"dic:Locality", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Locality::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Locality(soap, this, tag, type);
}

SOAP_FMAC3 dic__Locality * SOAP_FMAC4 soap_get_dic__Locality(struct soap *soap, dic__Locality *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Locality * FASTCALL soap_instantiate_dic__Locality(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Locality(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Locality, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Locality);
		ASSIGN_PTR(size, sizeof(dic__Locality));
		((dic__Locality*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Locality[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Locality));
		for(int i = 0; i < n; i++)
			((dic__Locality*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Locality*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Locality(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Locality %p -> %p\n", q, p));
	*(dic__Locality*)p = *(dic__Locality*)q;
}

void dic__District::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->dic__District::regionGuid);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_default_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	this->dic__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__District::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->dic__District::regionGuid);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_serialize_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->dic__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__District::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__District(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__District(struct soap *soap, const char *tag, int id, const dic__District *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__District), "dic:District"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:view", -1, &(a->dic__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "dic:regionCode", -1, &(a->dic__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:type", -1, &(a->dic__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:countryGuid", -1, &(a->dic__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:hasStreets", -1, &(a->dic__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:regionGuid", -1, &(a->dic__District::regionGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__District::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__District(soap, tag, this, type);
}

SOAP_FMAC3 dic__District * FASTCALL soap_in_dic__District(struct soap *soap, const char *tag, dic__District *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__District *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__District, sizeof(dic__District), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__District) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__District *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:view", &(a->dic__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "dic:regionCode", &(a->dic__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:type", &(a->dic__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:countryGuid", &(a->dic__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:hasStreets", &(a->dic__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:regionGuid", &(a->dic__District::regionGuid), "base:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__District *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__District, 0, sizeof(dic__District), 0, soap_copy_dic__District);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__District::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__District);
	return this->soap_out(soap, tag?tag:"dic:District", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__District::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__District(soap, this, tag, type);
}

SOAP_FMAC3 dic__District * SOAP_FMAC4 soap_get_dic__District(struct soap *soap, dic__District *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__District * FASTCALL soap_instantiate_dic__District(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__District(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__District, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__District);
		ASSIGN_PTR(size, sizeof(dic__District));
		((dic__District*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__District[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__District));
		for(int i = 0; i < n; i++)
			((dic__District*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__District*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__District(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__District %p -> %p\n", q, p));
	*(dic__District*)p = *(dic__District*)q;
}

void dic__Region::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_default_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	this->dic__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Region::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_serialize_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->dic__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Region::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Region(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Region(struct soap *soap, const char *tag, int id, const dic__Region *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Region), "dic:Region"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:view", -1, &(a->dic__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "dic:regionCode", -1, &(a->dic__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:type", -1, &(a->dic__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:countryGuid", -1, &(a->dic__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:hasStreets", -1, &(a->dic__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Region::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Region(soap, tag, this, type);
}

SOAP_FMAC3 dic__Region * FASTCALL soap_in_dic__Region(struct soap *soap, const char *tag, dic__Region *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Region *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Region, sizeof(dic__Region), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Region) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Region *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:view", &(a->dic__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "dic:regionCode", &(a->dic__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:type", &(a->dic__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:countryGuid", &(a->dic__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:hasStreets", &(a->dic__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Region *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Region, 0, sizeof(dic__Region), 0, soap_copy_dic__Region);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Region::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Region);
	return this->soap_out(soap, tag?tag:"dic:Region", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Region::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Region(soap, this, tag, type);
}

SOAP_FMAC3 dic__Region * SOAP_FMAC4 soap_get_dic__Region(struct soap *soap, dic__Region *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Region * FASTCALL soap_instantiate_dic__Region(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Region(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Region, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Region);
		ASSIGN_PTR(size, sizeof(dic__Region));
		((dic__Region*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Region[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Region));
		for(int i = 0; i < n; i++)
			((dic__Region*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Region*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Region(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Region %p -> %p\n", q, p));
	*(dic__Region*)p = *(dic__Region*)q;
}

void dic__AddressObjectView::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_default_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	this->dic__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__AddressObjectView::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::view);
	soap_serialize_string(soap, &this->dic__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->dic__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->dic__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->dic__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__AddressObjectView::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__AddressObjectView(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__AddressObjectView(struct soap *soap, const char *tag, int id, const dic__AddressObjectView *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__AddressObjectView), "dic:AddressObjectView"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:view", -1, &(a->dic__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "dic:regionCode", -1, &(a->dic__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:type", -1, &(a->dic__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:countryGuid", -1, &(a->dic__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:hasStreets", -1, &(a->dic__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__AddressObjectView::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__AddressObjectView(soap, tag, this, type);
}

SOAP_FMAC3 dic__AddressObjectView * FASTCALL soap_in_dic__AddressObjectView(struct soap *soap, const char *tag, dic__AddressObjectView *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__AddressObjectView *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__AddressObjectView, sizeof(dic__AddressObjectView), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__AddressObjectView) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__AddressObjectView *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_view1 = 1;
	size_t soap_flag_regionCode1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_countryGuid1 = 1;
	size_t soap_flag_hasStreets1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__AddressObjectView::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:view", &(a->dic__AddressObjectView::view), "base:String255"))
				{	soap_flag_view1--;
					continue;
				}
			if(soap_flag_regionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "dic:regionCode", &(a->dic__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode1--;
					continue;
				}
			if(soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:type", &(a->dic__AddressObjectView::type), "base:String255"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_countryGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:countryGuid", &(a->dic__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid1--;
					continue;
				}
			if(soap_flag_hasStreets1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:hasStreets", &(a->dic__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__AddressObjectView *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__AddressObjectView, 0, sizeof(dic__AddressObjectView), 0, soap_copy_dic__AddressObjectView);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__AddressObjectView::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__AddressObjectView);
	return this->soap_out(soap, tag?tag:"dic:AddressObjectView", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__AddressObjectView::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__AddressObjectView(soap, this, tag, type);
}

SOAP_FMAC3 dic__AddressObjectView * SOAP_FMAC4 soap_get_dic__AddressObjectView(struct soap *soap, dic__AddressObjectView *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__AddressObjectView(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__AddressObjectView * FASTCALL soap_instantiate_dic__AddressObjectView(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__AddressObjectView(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__AddressObjectView, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "dic:Region")) {
		cp->type = SOAP_TYPE_dic__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Region));
			((dic__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Region[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Region));
			for(int i = 0; i < n; i++)
				((dic__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:District")) {
		cp->type = SOAP_TYPE_dic__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__District));
			((dic__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__District[n]);
			ASSIGN_PTR(size, n * sizeof(dic__District));
			for(int i = 0; i < n; i++)
				((dic__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Locality")) {
		cp->type = SOAP_TYPE_dic__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Locality));
			((dic__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Locality));
			for(int i = 0; i < n; i++)
				((dic__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Street")) {
		cp->type = SOAP_TYPE_dic__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Street));
			((dic__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Street[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Street));
			for(int i = 0; i < n; i++)
				((dic__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Street*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView);
		ASSIGN_PTR(size, sizeof(dic__AddressObjectView));
		((dic__AddressObjectView*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__AddressObjectView));
		for(int i = 0; i < n; i++)
			((dic__AddressObjectView*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__AddressObjectView*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__AddressObjectView(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__AddressObjectView %p -> %p\n", q, p));
	*(dic__AddressObjectView*)p = *(dic__AddressObjectView*)q;
}

void dic__FederalDistrict::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__FederalDistrict::fullName);
	soap_default_base__String255(soap, &this->dic__FederalDistrict::shortName);
	soap_default_base__String255(soap, &this->dic__FederalDistrict::abbreviation);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__FederalDistrict::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__FederalDistrict::fullName);
	soap_serialize_base__String255(soap, &this->dic__FederalDistrict::shortName);
	soap_serialize_base__String255(soap, &this->dic__FederalDistrict::abbreviation);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__FederalDistrict::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__FederalDistrict(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__FederalDistrict(struct soap *soap, const char *tag, int id, const dic__FederalDistrict *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__FederalDistrict), "dic:FederalDistrict"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:fullName", -1, &(a->dic__FederalDistrict::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:shortName", -1, &(a->dic__FederalDistrict::shortName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:abbreviation", -1, &(a->dic__FederalDistrict::abbreviation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__FederalDistrict::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__FederalDistrict(soap, tag, this, type);
}

SOAP_FMAC3 dic__FederalDistrict * FASTCALL soap_in_dic__FederalDistrict(struct soap *soap, const char *tag, dic__FederalDistrict *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__FederalDistrict *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__FederalDistrict, sizeof(dic__FederalDistrict), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__FederalDistrict) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__FederalDistrict *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_abbreviation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:fullName", &(a->dic__FederalDistrict::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:shortName", &(a->dic__FederalDistrict::shortName), "base:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap_flag_abbreviation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:abbreviation", &(a->dic__FederalDistrict::abbreviation), "base:String255"))
				{	soap_flag_abbreviation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__FederalDistrict *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__FederalDistrict, 0, sizeof(dic__FederalDistrict), 0, soap_copy_dic__FederalDistrict);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__FederalDistrict::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__FederalDistrict);
	return this->soap_out(soap, tag?tag:"dic:FederalDistrict", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__FederalDistrict::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__FederalDistrict(soap, this, tag, type);
}

SOAP_FMAC3 dic__FederalDistrict * SOAP_FMAC4 soap_get_dic__FederalDistrict(struct soap *soap, dic__FederalDistrict *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__FederalDistrict * FASTCALL soap_instantiate_dic__FederalDistrict(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__FederalDistrict(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__FederalDistrict, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict);
		ASSIGN_PTR(size, sizeof(dic__FederalDistrict));
		((dic__FederalDistrict*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__FederalDistrict));
		for(int i = 0; i < n; i++)
			((dic__FederalDistrict*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__FederalDistrict*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__FederalDistrict(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__FederalDistrict %p -> %p\n", q, p));
	*(dic__FederalDistrict*)p = *(dic__FederalDistrict*)q;
}

void dic__Country::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Country::name);
	soap_default_base__String255(soap, &this->dic__Country::fullName);
	soap_default_base__String255(soap, &this->dic__Country::englishName);
	soap_default_dic__Code(soap, &this->dic__Country::code);
	soap_default_dic__Code3(soap, &this->dic__Country::code3);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Country::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Country::name);
	soap_serialize_base__String255(soap, &this->dic__Country::fullName);
	soap_serialize_base__String255(soap, &this->dic__Country::englishName);
	soap_serialize_dic__Code(soap, &this->dic__Country::code);
	soap_serialize_dic__Code3(soap, &this->dic__Country::code3);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Country(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Country(struct soap *soap, const char *tag, int id, const dic__Country *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Country), "dic:Country"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Country::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:fullName", -1, &(a->dic__Country::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:englishName", -1, &(a->dic__Country::englishName), ""))
		return soap->error;
	if(soap_out_dic__Code(soap, "dic:code", -1, &(a->dic__Country::code), ""))
		return soap->error;
	if(soap_out_dic__Code3(soap, "dic:code3", -1, &(a->dic__Country::code3), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Country::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Country(soap, tag, this, type);
}

SOAP_FMAC3 dic__Country * FASTCALL soap_in_dic__Country(struct soap *soap, const char *tag, dic__Country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Country *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Country, sizeof(dic__Country), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Country) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Country *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_code31 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Country::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:fullName", &(a->dic__Country::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:englishName", &(a->dic__Country::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__Code(soap, "dic:code", &(a->dic__Country::code), "dic:Code"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_code31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_dic__Code3(soap, "dic:code3", &(a->dic__Country::code3), "dic:Code3"))
				{	soap_flag_code31--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Country, 0, sizeof(dic__Country), 0, soap_copy_dic__Country);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Country);
	return this->soap_out(soap, tag?tag:"dic:Country", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Country(soap, this, tag, type);
}

SOAP_FMAC3 dic__Country * SOAP_FMAC4 soap_get_dic__Country(struct soap *soap, dic__Country *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Country * FASTCALL soap_instantiate_dic__Country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Country(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Country, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Country);
		ASSIGN_PTR(size, sizeof(dic__Country));
		((dic__Country*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Country[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Country));
		for(int i = 0; i < n; i++)
			((dic__Country*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Country*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Country(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Country %p -> %p\n", q, p));
	*(dic__Country*)p = *(dic__Country*)q;
}

void dic__UnitList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__UnitList::__sizeunit = 0;
	this->dic__UnitList::unit = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__UnitList::soap_serialize(struct soap *soap) const
{
	if(this->dic__UnitList::unit) {
		for(int i = 0; i < this->dic__UnitList::__sizeunit; i++) {
			soap_serialize_PointerTodic__Unit(soap, this->dic__UnitList::unit + i);
		}
	}
	/* transient soap skipped */
}

int dic__UnitList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__UnitList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__UnitList(struct soap *soap, const char *tag, int id, const dic__UnitList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__UnitList), "dic:UnitList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__UnitList::unit) {
		int i;
		for(i = 0; i < a->dic__UnitList::__sizeunit; i++)
			if(soap_out_PointerTodic__Unit(soap, "dic:unit", -1, a->dic__UnitList::unit + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__UnitList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__UnitList(soap, tag, this, type);
}

SOAP_FMAC3 dic__UnitList * FASTCALL soap_in_dic__UnitList(struct soap *soap, const char *tag, dic__UnitList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__UnitList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__UnitList, sizeof(dic__UnitList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__UnitList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__UnitList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_unit1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:unit", 1, NULL)) {
				if(a->dic__UnitList::unit == NULL) {
					if(soap_blist_unit1 == NULL)
						soap_blist_unit1 = soap_new_block(soap);
					a->dic__UnitList::unit = (dic__Unit **)soap_push_block(soap, soap_blist_unit1, sizeof(dic__Unit *));
					if(a->dic__UnitList::unit == NULL)
						return NULL;
					*a->dic__UnitList::unit = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Unit(soap, "dic:unit", a->dic__UnitList::unit, "dic:Unit"))
				{	a->dic__UnitList::__sizeunit++;
					a->dic__UnitList::unit = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__UnitList::unit)
			soap_pop_block(soap, soap_blist_unit1);
		if(a->dic__UnitList::__sizeunit)
			a->dic__UnitList::unit = (dic__Unit **)soap_save_block(soap, soap_blist_unit1, NULL, 1);
		else
		{	a->dic__UnitList::unit = NULL;
			if(soap_blist_unit1)
				soap_end_block(soap, soap_blist_unit1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__UnitList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__UnitList, 0, sizeof(dic__UnitList), 0, soap_copy_dic__UnitList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__UnitList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__UnitList);
	return this->soap_out(soap, tag?tag:"dic:UnitList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__UnitList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__UnitList(soap, this, tag, type);
}

SOAP_FMAC3 dic__UnitList * SOAP_FMAC4 soap_get_dic__UnitList(struct soap *soap, dic__UnitList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__UnitList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__UnitList * FASTCALL soap_instantiate_dic__UnitList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__UnitList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__UnitList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__UnitList);
		ASSIGN_PTR(size, sizeof(dic__UnitList));
		((dic__UnitList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__UnitList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__UnitList));
		for(int i = 0; i < n; i++)
			((dic__UnitList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__UnitList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__UnitList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__UnitList %p -> %p\n", q, p));
	*(dic__UnitList*)p = *(dic__UnitList*)q;
}

void dic__PurposeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__PurposeList::__sizepurpose = 0;
	this->dic__PurposeList::purpose = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void dic__PurposeList::soap_serialize(struct soap *soap) const
{
	if(this->dic__PurposeList::purpose) {
		for(int i = 0; i < this->dic__PurposeList::__sizepurpose; i++) {
			soap_serialize_PointerTodic__Purpose(soap, this->dic__PurposeList::purpose + i);
		}
	}
	/* transient soap skipped */
}

int dic__PurposeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__PurposeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__PurposeList(struct soap *soap, const char *tag, int id, const dic__PurposeList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__PurposeList), "dic:PurposeList"))
		return soap->error;
	/* transient soap skipped */
	if(a->dic__PurposeList::purpose) {
		int i;
		for(i = 0; i < a->dic__PurposeList::__sizepurpose; i++)
			if(soap_out_PointerTodic__Purpose(soap, "dic:purpose", -1, a->dic__PurposeList::purpose + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *dic__PurposeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__PurposeList(soap, tag, this, type);
}

SOAP_FMAC3 dic__PurposeList * FASTCALL soap_in_dic__PurposeList(struct soap *soap, const char *tag, dic__PurposeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__PurposeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__PurposeList, sizeof(dic__PurposeList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__PurposeList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__PurposeList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_purpose1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:purpose", 1, NULL)) {
				if(a->dic__PurposeList::purpose == NULL) {
					if(soap_blist_purpose1 == NULL)
						soap_blist_purpose1 = soap_new_block(soap);
					a->dic__PurposeList::purpose = (dic__Purpose **)soap_push_block(soap, soap_blist_purpose1, sizeof(dic__Purpose *));
					if(a->dic__PurposeList::purpose == NULL)
						return NULL;
					*a->dic__PurposeList::purpose = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Purpose(soap, "dic:purpose", a->dic__PurposeList::purpose, "dic:Purpose"))
				{	a->dic__PurposeList::__sizepurpose++;
					a->dic__PurposeList::purpose = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->dic__PurposeList::purpose)
			soap_pop_block(soap, soap_blist_purpose1);
		if(a->dic__PurposeList::__sizepurpose)
			a->dic__PurposeList::purpose = (dic__Purpose **)soap_save_block(soap, soap_blist_purpose1, NULL, 1);
		else
		{	a->dic__PurposeList::purpose = NULL;
			if(soap_blist_purpose1)
				soap_end_block(soap, soap_blist_purpose1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__PurposeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__PurposeList, 0, sizeof(dic__PurposeList), 0, soap_copy_dic__PurposeList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__PurposeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__PurposeList);
	return this->soap_out(soap, tag?tag:"dic:PurposeList", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__PurposeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__PurposeList(soap, this, tag, type);
}

SOAP_FMAC3 dic__PurposeList * SOAP_FMAC4 soap_get_dic__PurposeList(struct soap *soap, dic__PurposeList *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__PurposeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__PurposeList * FASTCALL soap_instantiate_dic__PurposeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__PurposeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__PurposeList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__PurposeList);
		ASSIGN_PTR(size, sizeof(dic__PurposeList));
		((dic__PurposeList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__PurposeList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__PurposeList));
		for(int i = 0; i < n; i++)
			((dic__PurposeList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__PurposeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__PurposeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__PurposeList %p -> %p\n", q, p));
	*(dic__PurposeList*)p = *(dic__PurposeList*)q;
}

void dic__PackingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->dic__PackingType::globalID = NULL;
	soap_default_base__String255(soap, &this->dic__PackingType::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__PackingType::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__PackingCodeType(soap, &this->dic__PackingType::globalID);
	soap_serialize_base__String255(soap, &this->dic__PackingType::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__PackingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__PackingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__PackingType(struct soap *soap, const char *tag, int id, const dic__PackingType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__PackingType), "dic:PackingType"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTodic__PackingCodeType(soap, "dic:globalID", -1, &(a->dic__PackingType::globalID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__PackingType::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__PackingType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__PackingType(soap, tag, this, type);
}

SOAP_FMAC3 dic__PackingType * FASTCALL soap_in_dic__PackingType(struct soap *soap, const char *tag, dic__PackingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__PackingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__PackingType, sizeof(dic__PackingType), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__PackingType) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__PackingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__PackingCodeType(soap, "dic:globalID", &(a->dic__PackingType::globalID), "dic:PackingCodeType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__PackingType::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__PackingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__PackingType, 0, sizeof(dic__PackingType), 0, soap_copy_dic__PackingType);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__PackingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__PackingType);
	return this->soap_out(soap, tag?tag:"dic:PackingType", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__PackingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__PackingType(soap, this, tag, type);
}

SOAP_FMAC3 dic__PackingType * SOAP_FMAC4 soap_get_dic__PackingType(struct soap *soap, dic__PackingType *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__PackingType * FASTCALL soap_instantiate_dic__PackingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__PackingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__PackingType, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__PackingType);
		ASSIGN_PTR(size, sizeof(dic__PackingType));
		((dic__PackingType*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__PackingType[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__PackingType));
		for(int i = 0; i < n; i++)
			((dic__PackingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__PackingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__PackingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__PackingType %p -> %p\n", q, p));
	*(dic__PackingType*)p = *(dic__PackingType*)q;
}

void dic__Unit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Unit::name);
	soap_default_base__String255(soap, &this->dic__Unit::fullName);
	soap_default_base__UUID(soap, &this->dic__Unit::commonUnitGuid);
	soap_default_xsd__integer(soap, &this->dic__Unit::factor);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Unit::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Unit::name);
	soap_serialize_base__String255(soap, &this->dic__Unit::fullName);
	soap_serialize_base__UUID(soap, &this->dic__Unit::commonUnitGuid);
	soap_serialize_xsd__integer(soap, &this->dic__Unit::factor);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Unit(struct soap *soap, const char *tag, int id, const dic__Unit *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Unit), "dic:Unit"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Unit::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:fullName", -1, &(a->dic__Unit::fullName), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "dic:commonUnitGuid", -1, &(a->dic__Unit::commonUnitGuid), ""))
		return soap->error;
	if(soap_out_xsd__integer(soap, "dic:factor", -1, &(a->dic__Unit::factor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Unit::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Unit(soap, tag, this, type);
}

SOAP_FMAC3 dic__Unit * FASTCALL soap_in_dic__Unit(struct soap *soap, const char *tag, dic__Unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Unit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Unit, sizeof(dic__Unit), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Unit) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Unit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_commonUnitGuid1 = 1;
	size_t soap_flag_factor1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Unit::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:fullName", &(a->dic__Unit::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_commonUnitGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:commonUnitGuid", &(a->dic__Unit::commonUnitGuid), "base:UUID"))
				{	soap_flag_commonUnitGuid1--;
					continue;
				}
			if(soap_flag_factor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "dic:factor", &(a->dic__Unit::factor), "xsd:integer"))
				{	soap_flag_factor1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Unit, 0, sizeof(dic__Unit), 0, soap_copy_dic__Unit);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Unit);
	return this->soap_out(soap, tag?tag:"dic:Unit", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Unit(soap, this, tag, type);
}

SOAP_FMAC3 dic__Unit * SOAP_FMAC4 soap_get_dic__Unit(struct soap *soap, dic__Unit *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Unit * FASTCALL soap_instantiate_dic__Unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Unit, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Unit);
		ASSIGN_PTR(size, sizeof(dic__Unit));
		((dic__Unit*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Unit[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Unit));
		for(int i = 0; i < n; i++)
			((dic__Unit*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Unit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Unit %p -> %p\n", q, p));
	*(dic__Unit*)p = *(dic__Unit*)q;
}

void dic__Purpose::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->dic__Purpose::name);
	this->dic__Purpose::forSubstandard = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void dic__Purpose::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->dic__Purpose::name);
	soap_serialize_PointerTobool(soap, &this->dic__Purpose::forSubstandard);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int dic__Purpose::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dic__Purpose(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Purpose(struct soap *soap, const char *tag, int id, const dic__Purpose *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dic__Purpose), "dic:Purpose"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "dic:name", -1, &(a->dic__Purpose::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "dic:forSubstandard", -1, &(a->dic__Purpose::forSubstandard), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dic__Purpose::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_dic__Purpose(soap, tag, this, type);
}

SOAP_FMAC3 dic__Purpose * FASTCALL soap_in_dic__Purpose(struct soap *soap, const char *tag, dic__Purpose *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dic__Purpose *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dic__Purpose, sizeof(dic__Purpose), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_dic__Purpose) {
			soap_revert(soap);
			*soap->id = '\0';
			return (dic__Purpose *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_forSubstandard1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "dic:name", &(a->dic__Purpose::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_forSubstandard1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "dic:forSubstandard", &(a->dic__Purpose::forSubstandard), "xsd:boolean"))
				{	soap_flag_forSubstandard1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (dic__Purpose *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dic__Purpose, 0, sizeof(dic__Purpose), 0, soap_copy_dic__Purpose);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int dic__Purpose::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dic__Purpose);
	return this->soap_out(soap, tag?tag:"dic:Purpose", id, type) ? soap->error : soap_putindependent(soap);
}

void *dic__Purpose::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dic__Purpose(soap, this, tag, type);
}

SOAP_FMAC3 dic__Purpose * SOAP_FMAC4 soap_get_dic__Purpose(struct soap *soap, dic__Purpose *p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dic__Purpose * FASTCALL soap_instantiate_dic__Purpose(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dic__Purpose(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dic__Purpose, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(dic__Purpose);
		ASSIGN_PTR(size, sizeof(dic__Purpose));
		((dic__Purpose*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(dic__Purpose[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(dic__Purpose));
		for(int i = 0; i < n; i++)
			((dic__Purpose*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dic__Purpose*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dic__Purpose(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dic__Purpose %p -> %p\n", q, p));
	*(dic__Purpose*)p = *(dic__Purpose*)q;
}

void app__BusinessError::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__Error::__item);
	soap_default_xsd__NCName(soap, &this->base__Error::code);
	this->base__Error::qualifier = NULL;
	/* transient soap skipped */
}

void app__BusinessError::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__Error::__item);
	/* transient soap skipped */
}

int app__BusinessError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__BusinessError(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__BusinessError(struct soap *soap, const char *tag, int id, const app__BusinessError *a, const char *type)
{
	if(((base__Error*)a)->code)
		soap_set_attr(soap, "code", ((base__Error*)a)->code, 1);
	if(((base__Error*)a)->qualifier)
		if(*((base__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((base__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &(a->base__Error::__item), "app:BusinessError");
}

void *app__BusinessError::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__BusinessError(soap, tag, this, type);
}

SOAP_FMAC3 app__BusinessError * FASTCALL soap_in_app__BusinessError(struct soap *soap, const char *tag, app__BusinessError *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (app__BusinessError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__BusinessError)
			return (app__BusinessError *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((base__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((base__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((base__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->base__Error::__item), "app:BusinessError"))
		return NULL;
	return a;
}

int app__BusinessError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__BusinessError);
	return this->soap_out(soap, tag?tag:"app:BusinessError", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__BusinessError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__BusinessError(soap, this, tag, type);
}

SOAP_FMAC3 app__BusinessError * SOAP_FMAC4 soap_get_app__BusinessError(struct soap *soap, app__BusinessError *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__BusinessError * FASTCALL soap_instantiate_app__BusinessError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__BusinessError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__BusinessError, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__BusinessError);
		ASSIGN_PTR(size, sizeof(app__BusinessError));
		((app__BusinessError*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__BusinessError[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__BusinessError));
		for(int i = 0; i < n; i++)
			((app__BusinessError*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__BusinessError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__BusinessError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__BusinessError %p -> %p\n", q, p));
	*(app__BusinessError*)p = *(app__BusinessError*)q;
}

void app__BusinessErrorList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__BusinessErrorList::__sizeerror = 0;
	this->app__BusinessErrorList::error = NULL;
	/* transient soap skipped */
}

void app__BusinessErrorList::soap_serialize(struct soap *soap) const
{
	if(this->app__BusinessErrorList::error) {
		for(int i = 0; i < this->app__BusinessErrorList::__sizeerror; i++) {
			soap_serialize_PointerToapp__BusinessError(soap, this->app__BusinessErrorList::error + i);
		}
	}
	/* transient soap skipped */
}

int app__BusinessErrorList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__BusinessErrorList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__BusinessErrorList(struct soap *soap, const char *tag, int id, const app__BusinessErrorList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__BusinessErrorList), type))
		return soap->error;
	if(a->app__BusinessErrorList::error) {
		int i;
		for(i = 0; i < a->app__BusinessErrorList::__sizeerror; i++)
			if(soap_out_PointerToapp__BusinessError(soap, "app:error", -1, a->app__BusinessErrorList::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__BusinessErrorList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__BusinessErrorList(soap, tag, this, type);
}

SOAP_FMAC3 app__BusinessErrorList * FASTCALL soap_in_app__BusinessErrorList(struct soap *soap, const char *tag, app__BusinessErrorList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__BusinessErrorList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BusinessErrorList, sizeof(app__BusinessErrorList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__BusinessErrorList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__BusinessErrorList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "app:error", 1, NULL)) {
				if(a->app__BusinessErrorList::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->app__BusinessErrorList::error = (app__BusinessError **)soap_push_block(soap, soap_blist_error1, sizeof(app__BusinessError *));
					if(a->app__BusinessErrorList::error == NULL)
						return NULL;
					*a->app__BusinessErrorList::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToapp__BusinessError(soap, "app:error", a->app__BusinessErrorList::error, "app:BusinessError"))
				{	a->app__BusinessErrorList::__sizeerror++;
					a->app__BusinessErrorList::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->app__BusinessErrorList::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->app__BusinessErrorList::__sizeerror)
			a->app__BusinessErrorList::error = (app__BusinessError **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->app__BusinessErrorList::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__BusinessErrorList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__BusinessErrorList, 0, sizeof(app__BusinessErrorList), 0, soap_copy_app__BusinessErrorList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__BusinessErrorList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__BusinessErrorList);
	return this->soap_out(soap, tag?tag:"app:BusinessErrorList", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__BusinessErrorList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__BusinessErrorList(soap, this, tag, type);
}

SOAP_FMAC3 app__BusinessErrorList * SOAP_FMAC4 soap_get_app__BusinessErrorList(struct soap *soap, app__BusinessErrorList *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__BusinessErrorList * FASTCALL soap_instantiate_app__BusinessErrorList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__BusinessErrorList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__BusinessErrorList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__BusinessErrorList);
		ASSIGN_PTR(size, sizeof(app__BusinessErrorList));
		((app__BusinessErrorList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__BusinessErrorList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__BusinessErrorList));
		for(int i = 0; i < n; i++)
			((app__BusinessErrorList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__BusinessErrorList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__BusinessErrorList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__BusinessErrorList %p -> %p\n", q, p));
	*(app__BusinessErrorList*)p = *(app__BusinessErrorList*)q;
}

void app__ApplicationResultData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void app__ApplicationResultData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationResultData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationResultData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationResultData(struct soap *soap, const char *tag, int id, const app__ApplicationResultData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationResultData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationResultData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationResultData(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationResultData * FASTCALL soap_in_app__ApplicationResultData(struct soap *soap, const char *tag, app__ApplicationResultData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationResultData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationResultData, sizeof(app__ApplicationResultData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationResultData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationResultData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationResultData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationResultData, 0, sizeof(app__ApplicationResultData), 0, soap_copy_app__ApplicationResultData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationResultData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationResultData);
	return this->soap_out(soap, tag?tag:"app:ApplicationResultData", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationResultData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationResultData(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationResultData * SOAP_FMAC4 soap_get_app__ApplicationResultData(struct soap *soap, app__ApplicationResultData *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationResultData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationResultData * FASTCALL soap_instantiate_app__ApplicationResultData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationResultData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationResultData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "g2ba:ProcessIncomingConsignmentResponse")) {
		cp->type = SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ProcessIncomingConsignmentResponse));
			((g2ba__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ProcessIncomingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ProcessIncomingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:PrepareOutgoingConsignmentResponse")) {
		cp->type = SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__PrepareOutgoingConsignmentResponse));
			((g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__PrepareOutgoingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:RegisterProductionOperationResponse")) {
		cp->type = SOAP_TYPE_g2ba__RegisterProductionOperationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__RegisterProductionOperationResponse));
			((g2ba__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__RegisterProductionOperationResponse));
			for(int i = 0; i < n; i++)
				((g2ba__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__RegisterProductionOperationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:MergeStockEntriesResponse")) {
		cp->type = SOAP_TYPE_g2ba__MergeStockEntriesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__MergeStockEntriesResponse));
			((g2ba__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__MergeStockEntriesResponse));
			for(int i = 0; i < n; i++)
				((g2ba__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__MergeStockEntriesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:WithdrawVetDocumentResponse")) {
		cp->type = SOAP_TYPE_g2ba__WithdrawVetDocumentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__WithdrawVetDocumentResponse));
			((g2ba__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__WithdrawVetDocumentResponse));
			for(int i = 0; i < n; i++)
				((g2ba__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__WithdrawVetDocumentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyBusinessEntityResponse")) {
		cp->type = SOAP_TYPE_g2ba__ModifyBusinessEntityResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyBusinessEntityResponse));
			((g2ba__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyBusinessEntityResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyBusinessEntityResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyEnterpriseResponse")) {
		cp->type = SOAP_TYPE_g2ba__ModifyEnterpriseResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyEnterpriseResponse));
			((g2ba__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyEnterpriseResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyEnterpriseResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyActivityLocationsResponse")) {
		cp->type = SOAP_TYPE_g2ba__ModifyActivityLocationsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyActivityLocationsResponse));
			((g2ba__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyActivityLocationsResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyActivityLocationsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ResolveDiscrepancyResponse")) {
		cp->type = SOAP_TYPE_g2ba__ResolveDiscrepancyResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ResolveDiscrepancyResponse));
			((g2ba__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ResolveDiscrepancyResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ResolveDiscrepancyResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyProducerStockListResponse")) {
		cp->type = SOAP_TYPE_g2ba__ModifyProducerStockListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyProducerStockListResponse));
			((g2ba__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyProducerStockListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyProducerStockListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentByUuidResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentByUuidResponse));
			((g2ba__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentByUuidResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentListResponse));
			((g2ba__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentChangesListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentChangesListResponse));
			((g2ba__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentChangesListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByGuidResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByGuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByGuidResponse));
			((g2ba__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByGuidResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByGuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByUuidResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByUuidResponse));
			((g2ba__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByUuidResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryChangesListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryChangesListResponse));
			((g2ba__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryChangesListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryListResponse));
			((g2ba__GetStockEntryListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryVersionListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryVersionListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryVersionListResponse));
			((g2ba__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryVersionListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryVersionListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateTransportMovementDetailsResponse")) {
		cp->type = SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateTransportMovementDetailsResponse));
			((g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateTransportMovementDetailsResponse));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateVeterinaryEventsResponse")) {
		cp->type = SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateVeterinaryEventsResponse));
			((g2ba__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateVeterinaryEventsResponse));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateVeterinaryEventsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:CheckShipmentRegionalizationResponse")) {
		cp->type = SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__CheckShipmentRegionalizationResponse));
			((g2ba__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__CheckShipmentRegionalizationResponse));
			for(int i = 0; i < n; i++)
				((g2ba__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__CheckShipmentRegionalizationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:AddBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_g2ba__AddBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__AddBusinessEntityUserResponse));
			((g2ba__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__AddBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((g2ba__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__AddBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserListResponse));
			((g2ba__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserResponse));
			((g2ba__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserAuthoritiesResponse")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserAuthoritiesResponse));
			((g2ba__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserAuthoritiesResponse));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserAuthoritiesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserWorkingAreasResponse")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserWorkingAreasResponse));
			((g2ba__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserWorkingAreasResponse));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserWorkingAreasResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UnbindBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UnbindBusinessEntityUserResponse));
			((g2ba__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UnbindBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((g2ba__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UnbindBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetApplicableUserAuthorityListResponse")) {
		cp->type = SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetApplicableUserAuthorityListResponse));
			((g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetApplicableUserAuthorityListResponse));
			for(int i = 0; i < n; i++)
				((g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultData);
		ASSIGN_PTR(size, sizeof(app__ApplicationResultData));
		((app__ApplicationResultData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationResultData));
		for(int i = 0; i < n; i++)
			((app__ApplicationResultData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationResultData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationResultData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationResultData %p -> %p\n", q, p));
	*(app__ApplicationResultData*)p = *(app__ApplicationResultData*)q;
}

void app__ApplicationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void app__ApplicationData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationData(struct soap *soap, const char *tag, int id, const app__ApplicationData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationData(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationData * FASTCALL soap_in_app__ApplicationData(struct soap *soap, const char *tag, app__ApplicationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationData, sizeof(app__ApplicationData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationData, 0, sizeof(app__ApplicationData), 0, soap_copy_app__ApplicationData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationData);
	return this->soap_out(soap, tag?tag:"app:ApplicationData", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationData(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationData * SOAP_FMAC4 soap_get_app__ApplicationData(struct soap *soap, app__ApplicationData *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationData * FASTCALL soap_instantiate_app__ApplicationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "g2ba:MercuryApplicationRequest")) {
		cp->type = SOAP_TYPE_g2ba__MercuryApplicationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__MercuryApplicationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__MercuryApplicationRequest));
			((g2ba__MercuryApplicationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__MercuryApplicationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__MercuryApplicationRequest));
			for(int i = 0; i < n; i++)
				((g2ba__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__MercuryApplicationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ProcessIncomingConsignmentRequest));
			((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__PrepareOutgoingConsignmentRequest));
			((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_g2ba__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__RegisterProductionOperationRequest));
			((g2ba__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((g2ba__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_g2ba__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__MergeStockEntriesRequest));
			((g2ba__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((g2ba__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_g2ba__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__WithdrawVetDocumentRequest));
			((g2ba__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyBusinessEntityRequest));
			((g2ba__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyEnterpriseRequest));
			((g2ba__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyActivityLocationsRequest));
			((g2ba__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_g2ba__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ResolveDiscrepancyRequest));
			((g2ba__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyProducerStockListRequest));
			((g2ba__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentByUuidRequest));
			((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentListRequest));
			((g2ba__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentChangesListRequest));
			((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByGuidRequest));
			((g2ba__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByUuidRequest));
			((g2ba__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryChangesListRequest));
			((g2ba__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryListRequest));
			((g2ba__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryVersionListRequest));
			((g2ba__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateTransportMovementDetailsRequest));
			((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateVeterinaryEventsRequest));
			((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__CheckShipmentRegionalizationRequest));
			((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__AddBusinessEntityUserRequest));
			((g2ba__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserListRequest));
			((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserRequest));
			((g2ba__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserAuthoritiesRequest));
			((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserWorkingAreasRequest));
			((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UnbindBusinessEntityUserRequest));
			((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetApplicableUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetApplicableUserAuthorityListRequest));
			((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetApplicableUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationData);
		ASSIGN_PTR(size, sizeof(app__ApplicationData));
		((app__ApplicationData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationData));
		for(int i = 0; i < n; i++)
			((app__ApplicationData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationData %p -> %p\n", q, p));
	*(app__ApplicationData*)p = *(app__ApplicationData*)q;
}

void app__ApplicationResultWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__ApplicationResultWrapper::__any = NULL;
	this->app__ApplicationResultWrapper::encoding = NULL;
	/* transient soap skipped */
}

void app__ApplicationResultWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationResultWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationResultWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, const app__ApplicationResultWrapper *a, const char *type)
{
	if(((app__ApplicationResultWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_app__ContentEncoding2s(soap, *((app__ApplicationResultWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationResultWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->app__ApplicationResultWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationResultWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationResultWrapper(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper * FASTCALL soap_in_app__ApplicationResultWrapper(struct soap *soap, const char *tag, app__ApplicationResultWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationResultWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationResultWrapper, sizeof(app__ApplicationResultWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationResultWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationResultWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((app__ApplicationResultWrapper*)a)->encoding = (enum app__ContentEncoding *)soap_malloc(soap, sizeof(enum app__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2app__ContentEncoding(soap, t, ((app__ApplicationResultWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->app__ApplicationResultWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationResultWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationResultWrapper, 0, sizeof(app__ApplicationResultWrapper), 0, soap_copy_app__ApplicationResultWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationResultWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationResultWrapper);
	return this->soap_out(soap, tag?tag:"app:ApplicationResultWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationResultWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationResultWrapper(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper * SOAP_FMAC4 soap_get_app__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationResultWrapper * FASTCALL soap_instantiate_app__ApplicationResultWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationResultWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationResultWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultWrapper);
		ASSIGN_PTR(size, sizeof(app__ApplicationResultWrapper));
		((app__ApplicationResultWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationResultWrapper));
		for(int i = 0; i < n; i++)
			((app__ApplicationResultWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationResultWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationResultWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationResultWrapper %p -> %p\n", q, p));
	*(app__ApplicationResultWrapper*)p = *(app__ApplicationResultWrapper*)q;
}

void app__ApplicationDataWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__ApplicationDataWrapper::__any = NULL;
	this->app__ApplicationDataWrapper::encoding = NULL;
	/* transient soap skipped */
}

void app__ApplicationDataWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationDataWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationDataWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, const app__ApplicationDataWrapper *a, const char *type)
{
	if(((app__ApplicationDataWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_app__ContentEncoding2s(soap, *((app__ApplicationDataWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationDataWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->app__ApplicationDataWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationDataWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationDataWrapper(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper * FASTCALL soap_in_app__ApplicationDataWrapper(struct soap *soap, const char *tag, app__ApplicationDataWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationDataWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationDataWrapper, sizeof(app__ApplicationDataWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationDataWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationDataWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((app__ApplicationDataWrapper*)a)->encoding = (enum app__ContentEncoding *)soap_malloc(soap, sizeof(enum app__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2app__ContentEncoding(soap, t, ((app__ApplicationDataWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->app__ApplicationDataWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationDataWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationDataWrapper, 0, sizeof(app__ApplicationDataWrapper), 0, soap_copy_app__ApplicationDataWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationDataWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationDataWrapper);
	return this->soap_out(soap, tag?tag:"app:ApplicationDataWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationDataWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationDataWrapper(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper * SOAP_FMAC4 soap_get_app__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationDataWrapper * FASTCALL soap_instantiate_app__ApplicationDataWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationDataWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationDataWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationDataWrapper);
		ASSIGN_PTR(size, sizeof(app__ApplicationDataWrapper));
		((app__ApplicationDataWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationDataWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationDataWrapper));
		for(int i = 0; i < n; i++)
			((app__ApplicationDataWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationDataWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationDataWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationDataWrapper %p -> %p\n", q, p));
	*(app__ApplicationDataWrapper*)p = *(app__ApplicationDataWrapper*)q;
}

void app__Application::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->app__Application::applicationId);
	this->app__Application::status = NULL;
	soap_default_xsd__Name(soap, &this->app__Application::serviceId);
	soap_default_base__UUID(soap, &this->app__Application::issuerId);
	this->app__Application::issueDate = NULL;
	this->app__Application::rcvDate = NULL;
	this->app__Application::prdcRsltDate = NULL;
	this->app__Application::data = NULL;
	this->app__Application::result = NULL;
	this->app__Application::errors = NULL;
	/* transient soap skipped */
}

void app__Application::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->app__Application::applicationId);
	soap_serialize_PointerToapp__ApplicationStatus(soap, &this->app__Application::status);
	soap_serialize_xsd__Name(soap, &this->app__Application::serviceId);
	soap_serialize_base__UUID(soap, &this->app__Application::issuerId);
	soap_serialize_PointerTotime(soap, &this->app__Application::issueDate);
	soap_serialize_PointerTotime(soap, &this->app__Application::rcvDate);
	soap_serialize_PointerTotime(soap, &this->app__Application::prdcRsltDate);
	soap_serialize_PointerToapp__ApplicationDataWrapper(soap, &this->app__Application::data);
	soap_serialize_PointerToapp__ApplicationResultWrapper(soap, &this->app__Application::result);
	soap_serialize_PointerToapp__BusinessErrorList(soap, &this->app__Application::errors);
	/* transient soap skipped */
}

int app__Application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__Application(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__Application(struct soap *soap, const char *tag, int id, const app__Application *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__Application), type))
		return soap->error;
	if(soap_out_base__UUID(soap, "app:applicationId", -1, &(a->app__Application::applicationId), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationStatus(soap, "app:status", -1, &(a->app__Application::status), ""))
		return soap->error;
	if(soap_out_xsd__Name(soap, "app:serviceId", -1, &(a->app__Application::serviceId), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "app:issuerId", -1, &(a->app__Application::issuerId), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:issueDate", -1, &(a->app__Application::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:rcvDate", -1, &(a->app__Application::rcvDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:prdcRsltDate", -1, &(a->app__Application::prdcRsltDate), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationDataWrapper(soap, "app:data", -1, &(a->app__Application::data), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationResultWrapper(soap, "app:result", -1, &(a->app__Application::result), ""))
		return soap->error;
	if(soap_out_PointerToapp__BusinessErrorList(soap, "app:errors", -1, &(a->app__Application::errors), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__Application::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__Application(soap, tag, this, type);
}

SOAP_FMAC3 app__Application * FASTCALL soap_in_app__Application(struct soap *soap, const char *tag, app__Application *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__Application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__Application, sizeof(app__Application), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__Application) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__Application *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_serviceId1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_rcvDate1 = 1;
	size_t soap_flag_prdcRsltDate1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_errors1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "app:applicationId", &(a->app__Application::applicationId), "base:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationStatus(soap, "app:status", &(a->app__Application::status), "app:ApplicationStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_serviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__Name(soap, "app:serviceId", &(a->app__Application::serviceId), "xsd:Name"))
				{	soap_flag_serviceId1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "app:issuerId", &(a->app__Application::issuerId), "base:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_issueDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:issueDate", &(a->app__Application::issueDate), "xsd:dateTime"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_rcvDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:rcvDate", &(a->app__Application::rcvDate), "xsd:dateTime"))
				{	soap_flag_rcvDate1--;
					continue;
				}
			if(soap_flag_prdcRsltDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:prdcRsltDate", &(a->app__Application::prdcRsltDate), "xsd:dateTime"))
				{	soap_flag_prdcRsltDate1--;
					continue;
				}
			if(soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationDataWrapper(soap, "app:data", &(a->app__Application::data), "app:ApplicationDataWrapper"))
				{	soap_flag_data1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationResultWrapper(soap, "app:result", &(a->app__Application::result), "app:ApplicationResultWrapper"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_errors1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__BusinessErrorList(soap, "app:errors", &(a->app__Application::errors), "app:BusinessErrorList"))
				{	soap_flag_errors1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__Application *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__Application, 0, sizeof(app__Application), 0, soap_copy_app__Application);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__Application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__Application);
	return this->soap_out(soap, tag?tag:"app:Application", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__Application::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__Application(soap, this, tag, type);
}

SOAP_FMAC3 app__Application * SOAP_FMAC4 soap_get_app__Application(struct soap *soap, app__Application *p, const char *tag, const char *type)
{
	if((p = soap_in_app__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__Application * FASTCALL soap_instantiate_app__Application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__Application(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__Application, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__Application);
		ASSIGN_PTR(size, sizeof(app__Application));
		((app__Application*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__Application[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__Application));
		for(int i = 0; i < n; i++)
			((app__Application*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__Application*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__Application(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__Application %p -> %p\n", q, p));
	*(app__Application*)p = *(app__Application*)q;
}

void base__ComplexDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->base__ComplexDate::year = NULL;
	this->base__ComplexDate::month = NULL;
	this->base__ComplexDate::day = NULL;
	this->base__ComplexDate::hour = NULL;
	/* transient soap skipped */
}

void base__ComplexDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Year(soap, &this->base__ComplexDate::year);
	soap_serialize_PointerTobase__Month(soap, &this->base__ComplexDate::month);
	soap_serialize_PointerTobase__Day(soap, &this->base__ComplexDate::day);
	soap_serialize_PointerTobase__Hour(soap, &this->base__ComplexDate::hour);
	/* transient soap skipped */
}

int base__ComplexDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__ComplexDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__ComplexDate(struct soap *soap, const char *tag, int id, const base__ComplexDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__ComplexDate), type))
		return soap->error;
	if(soap_out_PointerTobase__Year(soap, "base:year", -1, &(a->base__ComplexDate::year), ""))
		return soap->error;
	if(soap_out_PointerTobase__Month(soap, "base:month", -1, &(a->base__ComplexDate::month), ""))
		return soap->error;
	if(soap_out_PointerTobase__Day(soap, "base:day", -1, &(a->base__ComplexDate::day), ""))
		return soap->error;
	if(soap_out_PointerTobase__Hour(soap, "base:hour", -1, &(a->base__ComplexDate::hour), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__ComplexDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__ComplexDate(soap, tag, this, type);
}

SOAP_FMAC3 base__ComplexDate * FASTCALL soap_in_base__ComplexDate(struct soap *soap, const char *tag, base__ComplexDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__ComplexDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__ComplexDate, sizeof(base__ComplexDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__ComplexDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__ComplexDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_year1 = 1;
	size_t soap_flag_month1 = 1;
	size_t soap_flag_day1 = 1;
	size_t soap_flag_hour1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Year(soap, "base:year", &(a->base__ComplexDate::year), "base:Year"))
				{	soap_flag_year1--;
					continue;
				}
			if(soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Month(soap, "base:month", &(a->base__ComplexDate::month), "base:Month"))
				{	soap_flag_month1--;
					continue;
				}
			if(soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Day(soap, "base:day", &(a->base__ComplexDate::day), "base:Day"))
				{	soap_flag_day1--;
					continue;
				}
			if(soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Hour(soap, "base:hour", &(a->base__ComplexDate::hour), "base:Hour"))
				{	soap_flag_hour1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__ComplexDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__ComplexDate, 0, sizeof(base__ComplexDate), 0, soap_copy_base__ComplexDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__ComplexDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__ComplexDate);
	return this->soap_out(soap, tag?tag:"base:ComplexDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__ComplexDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__ComplexDate(soap, this, tag, type);
}

SOAP_FMAC3 base__ComplexDate * SOAP_FMAC4 soap_get_base__ComplexDate(struct soap *soap, base__ComplexDate *p, const char *tag, const char *type)
{
	if((p = soap_in_base__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__ComplexDate * FASTCALL soap_instantiate_base__ComplexDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__ComplexDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__ComplexDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__ComplexDate);
		ASSIGN_PTR(size, sizeof(base__ComplexDate));
		((base__ComplexDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__ComplexDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__ComplexDate));
		for(int i = 0; i < n; i++)
			((base__ComplexDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__ComplexDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__ComplexDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__ComplexDate %p -> %p\n", q, p));
	*(base__ComplexDate*)p = *(base__ComplexDate*)q;
}

void base__Error::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__Error::__item);
	soap_default_xsd__NCName(soap, &this->base__Error::code);
	this->base__Error::qualifier = NULL;
	/* transient soap skipped */
}

void base__Error::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__Error::__item);
	/* transient soap skipped */
}

int base__Error::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__Error(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__Error(struct soap *soap, const char *tag, int id, const base__Error *a, const char *type)
{
	if(((base__Error*)a)->code)
		soap_set_attr(soap, "code", ((base__Error*)a)->code, 1);
	if(((base__Error*)a)->qualifier)
		if(*((base__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((base__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &a->base__Error::__item, "");
}

void *base__Error::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__Error(soap, tag, this, type);
}

SOAP_FMAC3 base__Error * FASTCALL soap_in_base__Error(struct soap *soap, const char *tag, base__Error *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (base__Error *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__Error, sizeof(base__Error), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__Error)
			return (base__Error *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((base__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((base__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((base__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->base__Error::__item), "base:Error"))
		return NULL;
	return a;
}

int base__Error::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__Error);
	return this->soap_out(soap, tag?tag:"base:Error", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__Error::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__Error(soap, this, tag, type);
}

SOAP_FMAC3 base__Error * SOAP_FMAC4 soap_get_base__Error(struct soap *soap, base__Error *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__Error * FASTCALL soap_instantiate_base__Error(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__Error(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__Error, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "app:BusinessError")) {
		cp->type = SOAP_TYPE_app__BusinessError;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(app__BusinessError);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(app__BusinessError));
			((app__BusinessError*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(app__BusinessError[n]);
			ASSIGN_PTR(size, n * sizeof(app__BusinessError));
			for(int i = 0; i < n; i++)
				((app__BusinessError*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (app__BusinessError*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__Error);
		ASSIGN_PTR(size, sizeof(base__Error));
		((base__Error*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__Error[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__Error));
		for(int i = 0; i < n; i++)
			((base__Error*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__Error*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__Error(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__Error %p -> %p\n", q, p));
	*(base__Error*)p = *(base__Error*)q;
}

void base__FaultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__FaultInfo::message);
	this->base__FaultInfo::__sizeerror = 0;
	this->base__FaultInfo::error = NULL;
	/* transient soap skipped */
}

void base__FaultInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__FaultInfo::message);
	if(this->base__FaultInfo::error) {
		for(int i = 0; i < this->base__FaultInfo::__sizeerror; i++) {
			soap_serialize_PointerTobase__Error(soap, this->base__FaultInfo::error + i);
		}
	}
	/* transient soap skipped */
}

int base__FaultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__FaultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__FaultInfo(struct soap *soap, const char *tag, int id, const base__FaultInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__FaultInfo), type))
		return soap->error;
	if(a->base__FaultInfo::message) {
		if(soap_out_string(soap, "base:message", -1, &a->base__FaultInfo::message, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:message"))
		return soap->error;
	if(a->base__FaultInfo::error) {
		int i;
		for(i = 0; i < a->base__FaultInfo::__sizeerror; i++)
			if(soap_out_PointerTobase__Error(soap, "base:error", -1, a->base__FaultInfo::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__FaultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__FaultInfo(soap, tag, this, type);
}

SOAP_FMAC3 base__FaultInfo * FASTCALL soap_in_base__FaultInfo(struct soap *soap, const char *tag, base__FaultInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__FaultInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__FaultInfo, sizeof(base__FaultInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__FaultInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__FaultInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "base:message", &(a->base__FaultInfo::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "base:error", 1, NULL)) {
				if(a->base__FaultInfo::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->base__FaultInfo::error = (base__Error **)soap_push_block(soap, soap_blist_error1, sizeof(base__Error *));
					if(a->base__FaultInfo::error == NULL)
						return NULL;
					*a->base__FaultInfo::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTobase__Error(soap, "base:error", a->base__FaultInfo::error, "base:Error"))
				{	a->base__FaultInfo::__sizeerror++;
					a->base__FaultInfo::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->base__FaultInfo::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->base__FaultInfo::__sizeerror)
			a->base__FaultInfo::error = (base__Error **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->base__FaultInfo::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__FaultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__FaultInfo, 0, sizeof(base__FaultInfo), 0, soap_copy_base__FaultInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_message1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int base__FaultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__FaultInfo);
	return this->soap_out(soap, tag?tag:"base:FaultInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__FaultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__FaultInfo(soap, this, tag, type);
}

SOAP_FMAC3 base__FaultInfo * SOAP_FMAC4 soap_get_base__FaultInfo(struct soap *soap, base__FaultInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_base__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__FaultInfo * FASTCALL soap_instantiate_base__FaultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__FaultInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__FaultInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__FaultInfo);
		ASSIGN_PTR(size, sizeof(base__FaultInfo));
		((base__FaultInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__FaultInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__FaultInfo));
		for(int i = 0; i < n; i++)
			((base__FaultInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__FaultInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__FaultInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__FaultInfo %p -> %p\n", q, p));
	*(base__FaultInfo*)p = *(base__FaultInfo*)q;
}

void base__EntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void base__EntityList::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int base__EntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__EntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__EntityList(struct soap *soap, const char *tag, int id, const base__EntityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__EntityList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__EntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__EntityList(soap, tag, this, type);
}

SOAP_FMAC3 base__EntityList * FASTCALL soap_in_base__EntityList(struct soap *soap, const char *tag, base__EntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__EntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__EntityList, sizeof(base__EntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__EntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__EntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__EntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__EntityList, 0, sizeof(base__EntityList), 0, soap_copy_base__EntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__EntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__EntityList);
	return this->soap_out(soap, tag?tag:"base:EntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__EntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__EntityList(soap, this, tag, type);
}

SOAP_FMAC3 base__EntityList * SOAP_FMAC4 soap_get_base__EntityList(struct soap *soap, base__EntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_base__EntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__EntityList * FASTCALL soap_instantiate_base__EntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__EntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__EntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "dic:PurposeList")) {
		cp->type = SOAP_TYPE_dic__PurposeList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__PurposeList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__PurposeList));
			((dic__PurposeList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__PurposeList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__PurposeList));
			for(int i = 0; i < n; i++)
				((dic__PurposeList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__PurposeList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:UnitList")) {
		cp->type = SOAP_TYPE_dic__UnitList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__UnitList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__UnitList));
			((dic__UnitList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__UnitList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__UnitList));
			for(int i = 0; i < n; i++)
				((dic__UnitList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__UnitList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:CountryList")) {
		cp->type = SOAP_TYPE_dic__CountryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__CountryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__CountryList));
			((dic__CountryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__CountryList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__CountryList));
			for(int i = 0; i < n; i++)
				((dic__CountryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__CountryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionList")) {
		cp->type = SOAP_TYPE_dic__RegionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionList));
			((dic__RegionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionList));
			for(int i = 0; i < n; i++)
				((dic__RegionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:DistrictList")) {
		cp->type = SOAP_TYPE_dic__DistrictList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__DistrictList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__DistrictList));
			((dic__DistrictList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__DistrictList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__DistrictList));
			for(int i = 0; i < n; i++)
				((dic__DistrictList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__DistrictList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:LocalityList")) {
		cp->type = SOAP_TYPE_dic__LocalityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__LocalityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__LocalityList));
			((dic__LocalityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__LocalityList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__LocalityList));
			for(int i = 0; i < n; i++)
				((dic__LocalityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__LocalityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:StreetList")) {
		cp->type = SOAP_TYPE_dic__StreetList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__StreetList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__StreetList));
			((dic__StreetList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__StreetList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__StreetList));
			for(int i = 0; i < n; i++)
				((dic__StreetList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__StreetList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:EnterpriseActivityList")) {
		cp->type = SOAP_TYPE_dic__EnterpriseActivityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__EnterpriseActivityList));
			((dic__EnterpriseActivityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivityList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__EnterpriseActivityList));
			for(int i = 0; i < n; i++)
				((dic__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__EnterpriseActivityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:EnterpriseList")) {
		cp->type = SOAP_TYPE_dic__EnterpriseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__EnterpriseList));
			((dic__EnterpriseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__EnterpriseList));
			for(int i = 0; i < n; i++)
				((dic__EnterpriseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__EnterpriseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:BusinessEntityList")) {
		cp->type = SOAP_TYPE_dic__BusinessEntityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__BusinessEntityList));
			((dic__BusinessEntityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntityList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__BusinessEntityList));
			for(int i = 0; i < n; i++)
				((dic__BusinessEntityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__BusinessEntityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ProductList")) {
		cp->type = SOAP_TYPE_dic__ProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ProductList));
			((dic__ProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ProductList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ProductList));
			for(int i = 0; i < n; i++)
				((dic__ProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:SubProductList")) {
		cp->type = SOAP_TYPE_dic__SubProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__SubProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__SubProductList));
			((dic__SubProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__SubProductList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__SubProductList));
			for(int i = 0; i < n; i++)
				((dic__SubProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__SubProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ProductItemList")) {
		cp->type = SOAP_TYPE_dic__ProductItemList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ProductItemList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ProductItemList));
			((dic__ProductItemList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ProductItemList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ProductItemList));
			for(int i = 0; i < n; i++)
				((dic__ProductItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ProductItemList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationConditionList")) {
		cp->type = SOAP_TYPE_dic__RegionalizationConditionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationConditionList));
			((dic__RegionalizationConditionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationConditionList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationConditionList));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationConditionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationRegionStatusList")) {
		cp->type = SOAP_TYPE_dic__RegionalizationRegionStatusList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatusList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationRegionStatusList));
			((dic__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatusList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRegionStatusList));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationRegionStatusList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationShippingRuleList")) {
		cp->type = SOAP_TYPE_dic__RegionalizationShippingRuleList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRuleList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationShippingRuleList));
			((dic__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRuleList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationShippingRuleList));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationShippingRuleList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:AnimalDiseaseList")) {
		cp->type = SOAP_TYPE_dic__AnimalDiseaseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__AnimalDiseaseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__AnimalDiseaseList));
			((dic__AnimalDiseaseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__AnimalDiseaseList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__AnimalDiseaseList));
			for(int i = 0; i < n; i++)
				((dic__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__AnimalDiseaseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ResearchMethodList")) {
		cp->type = SOAP_TYPE_dic__ResearchMethodList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethodList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ResearchMethodList));
			((dic__ResearchMethodList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethodList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ResearchMethodList));
			for(int i = 0; i < n; i++)
				((dic__ResearchMethodList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ResearchMethodList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ActivityLocationList")) {
		cp->type = SOAP_TYPE_dic__ActivityLocationList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ActivityLocationList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ActivityLocationList));
			((dic__ActivityLocationList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ActivityLocationList[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ActivityLocationList));
			for(int i = 0; i < n; i++)
				((dic__ActivityLocationList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ActivityLocationList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:VetDocumentList")) {
		cp->type = SOAP_TYPE_vd__VetDocumentList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocumentList));
			((vd__VetDocumentList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocumentList));
			for(int i = 0; i < n; i++)
				((vd__VetDocumentList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocumentList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntryList")) {
		cp->type = SOAP_TYPE_vd__StockEntryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntryList));
			((vd__StockEntryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntryList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntryList));
			for(int i = 0; i < n; i++)
				((vd__StockEntryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:UserList")) {
		cp->type = SOAP_TYPE_vd__UserList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__UserList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__UserList));
			((vd__UserList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__UserList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__UserList));
			for(int i = 0; i < n; i++)
				((vd__UserList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__UserList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:WorkingAreaList")) {
		cp->type = SOAP_TYPE_vd__WorkingAreaList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__WorkingAreaList));
			((vd__WorkingAreaList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__WorkingAreaList));
			for(int i = 0; i < n; i++)
				((vd__WorkingAreaList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__WorkingAreaList*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__EntityList);
		ASSIGN_PTR(size, sizeof(base__EntityList));
		((base__EntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__EntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__EntityList));
		for(int i = 0; i < n; i++)
			((base__EntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__EntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__EntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__EntityList %p -> %p\n", q, p));
	*(base__EntityList*)p = *(base__EntityList*)q;
}

void base__DateInterval::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->base__DateInterval::beginDate = NULL;
	this->base__DateInterval::endDate = NULL;
	/* transient soap skipped */
}

void base__DateInterval::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->base__DateInterval::beginDate);
	soap_serialize_PointerTotime(soap, &this->base__DateInterval::endDate);
	/* transient soap skipped */
}

int base__DateInterval::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__DateInterval(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__DateInterval(struct soap *soap, const char *tag, int id, const base__DateInterval *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__DateInterval), type))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:beginDate", -1, &(a->base__DateInterval::beginDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:endDate", -1, &(a->base__DateInterval::endDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__DateInterval::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__DateInterval(soap, tag, this, type);
}

SOAP_FMAC3 base__DateInterval * FASTCALL soap_in_base__DateInterval(struct soap *soap, const char *tag, base__DateInterval *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__DateInterval *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__DateInterval, sizeof(base__DateInterval), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__DateInterval) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__DateInterval *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_beginDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_beginDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:beginDate", &(a->base__DateInterval::beginDate), "xsd:dateTime"))
				{	soap_flag_beginDate1--;
					continue;
				}
			if(soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:endDate", &(a->base__DateInterval::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__DateInterval *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__DateInterval, 0, sizeof(base__DateInterval), 0, soap_copy_base__DateInterval);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__DateInterval::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__DateInterval);
	return this->soap_out(soap, tag?tag:"base:DateInterval", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__DateInterval::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__DateInterval(soap, this, tag, type);
}

SOAP_FMAC3 base__DateInterval * SOAP_FMAC4 soap_get_base__DateInterval(struct soap *soap, base__DateInterval *p, const char *tag, const char *type)
{
	if((p = soap_in_base__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__DateInterval * FASTCALL soap_instantiate_base__DateInterval(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__DateInterval(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__DateInterval, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__DateInterval);
		ASSIGN_PTR(size, sizeof(base__DateInterval));
		((base__DateInterval*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__DateInterval[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__DateInterval));
		for(int i = 0; i < n; i++)
			((base__DateInterval*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__DateInterval*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__DateInterval(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__DateInterval %p -> %p\n", q, p));
	*(base__DateInterval*)p = *(base__DateInterval*)q;
}

void base__ListOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->base__ListOptions::count);
	soap_default_xsd__nonNegativeInteger(soap, &this->base__ListOptions::offset);
	/* transient soap skipped */
}

void base__ListOptions::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__nonNegativeInteger(soap, &this->base__ListOptions::count);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->base__ListOptions::offset);
	/* transient soap skipped */
}

int base__ListOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__ListOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__ListOptions(struct soap *soap, const char *tag, int id, const base__ListOptions *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__ListOptions), type))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "base:count", -1, &(a->base__ListOptions::count), ""))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "base:offset", -1, &(a->base__ListOptions::offset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__ListOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__ListOptions(soap, tag, this, type);
}

SOAP_FMAC3 base__ListOptions * FASTCALL soap_in_base__ListOptions(struct soap *soap, const char *tag, base__ListOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__ListOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__ListOptions, sizeof(base__ListOptions), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__ListOptions) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__ListOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_count1 = 1;
	size_t soap_flag_offset1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "base:count", &(a->base__ListOptions::count), "xsd:nonNegativeInteger"))
				{	soap_flag_count1--;
					continue;
				}
			if(soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "base:offset", &(a->base__ListOptions::offset), "xsd:nonNegativeInteger"))
				{	soap_flag_offset1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__ListOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__ListOptions, 0, sizeof(base__ListOptions), 0, soap_copy_base__ListOptions);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__ListOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__ListOptions);
	return this->soap_out(soap, tag?tag:"base:ListOptions", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__ListOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__ListOptions(soap, this, tag, type);
}

SOAP_FMAC3 base__ListOptions * SOAP_FMAC4 soap_get_base__ListOptions(struct soap *soap, base__ListOptions *p, const char *tag, const char *type)
{
	if((p = soap_in_base__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__ListOptions * FASTCALL soap_instantiate_base__ListOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__ListOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__ListOptions, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__ListOptions);
		ASSIGN_PTR(size, sizeof(base__ListOptions));
		((base__ListOptions*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__ListOptions[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__ListOptions));
		for(int i = 0; i < n; i++)
			((base__ListOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__ListOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__ListOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__ListOptions %p -> %p\n", q, p));
	*(base__ListOptions*)p = *(base__ListOptions*)q;
}

void base__GenericVersioningEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void base__GenericVersioningEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int base__GenericVersioningEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__GenericVersioningEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__GenericVersioningEntity(struct soap *soap, const char *tag, int id, const base__GenericVersioningEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__GenericVersioningEntity), "base:GenericVersioningEntity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *base__GenericVersioningEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__GenericVersioningEntity(soap, tag, this, type);
}

SOAP_FMAC3 base__GenericVersioningEntity * FASTCALL soap_in_base__GenericVersioningEntity(struct soap *soap, const char *tag, base__GenericVersioningEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__GenericVersioningEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__GenericVersioningEntity, sizeof(base__GenericVersioningEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__GenericVersioningEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__GenericVersioningEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_last1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_updateDate1 = 1;
	size_t soap_flag_previous1 = 1;
	size_t soap_flag_next1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid1--;
					continue;
				}
			if(soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if(soap_flag_last1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if(soap_flag_updateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate1--;
					continue;
				}
			if(soap_flag_previous1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous1--;
					continue;
				}
			if(soap_flag_next1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__GenericVersioningEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__GenericVersioningEntity, 0, sizeof(base__GenericVersioningEntity), 0, soap_copy_base__GenericVersioningEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__GenericVersioningEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__GenericVersioningEntity);
	return this->soap_out(soap, tag?tag:"base:GenericVersioningEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__GenericVersioningEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__GenericVersioningEntity(soap, this, tag, type);
}

SOAP_FMAC3 base__GenericVersioningEntity * SOAP_FMAC4 soap_get_base__GenericVersioningEntity(struct soap *soap, base__GenericVersioningEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_base__GenericVersioningEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__GenericVersioningEntity * FASTCALL soap_instantiate_base__GenericVersioningEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__GenericVersioningEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__GenericVersioningEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "dic:Purpose")) {
		cp->type = SOAP_TYPE_dic__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Purpose));
			((dic__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Purpose));
			for(int i = 0; i < n; i++)
				((dic__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Unit")) {
		cp->type = SOAP_TYPE_dic__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Unit));
			((dic__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Unit));
			for(int i = 0; i < n; i++)
				((dic__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:PackingType")) {
		cp->type = SOAP_TYPE_dic__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__PackingType));
			((dic__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(dic__PackingType));
			for(int i = 0; i < n; i++)
				((dic__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Country")) {
		cp->type = SOAP_TYPE_dic__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Country));
			((dic__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Country[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Country));
			for(int i = 0; i < n; i++)
				((dic__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:FederalDistrict")) {
		cp->type = SOAP_TYPE_dic__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__FederalDistrict));
			((dic__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(dic__FederalDistrict));
			for(int i = 0; i < n; i++)
				((dic__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:AddressObjectView")) {
		cp->type = SOAP_TYPE_dic__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__AddressObjectView));
			((dic__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(dic__AddressObjectView));
			for(int i = 0; i < n; i++)
				((dic__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Enterprise")) {
		cp->type = SOAP_TYPE_dic__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Enterprise));
			((dic__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Enterprise));
			for(int i = 0; i < n; i++)
				((dic__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:BusinessEntity")) {
		cp->type = SOAP_TYPE_dic__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__BusinessEntity));
			((dic__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(dic__BusinessEntity));
			for(int i = 0; i < n; i++)
				((dic__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ProductItem")) {
		cp->type = SOAP_TYPE_dic__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ProductItem));
			((dic__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ProductItem));
			for(int i = 0; i < n; i++)
				((dic__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Product")) {
		cp->type = SOAP_TYPE_dic__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Product));
			((dic__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Product[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Product));
			for(int i = 0; i < n; i++)
				((dic__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:SubProduct")) {
		cp->type = SOAP_TYPE_dic__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__SubProduct));
			((dic__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(dic__SubProduct));
			for(int i = 0; i < n; i++)
				((dic__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Indicator")) {
		cp->type = SOAP_TYPE_dic__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Indicator));
			((dic__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Indicator));
			for(int i = 0; i < n; i++)
				((dic__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:AnimalDisease")) {
		cp->type = SOAP_TYPE_dic__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__AnimalDisease));
			((dic__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(dic__AnimalDisease));
			for(int i = 0; i < n; i++)
				((dic__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ResearchMethod")) {
		cp->type = SOAP_TYPE_dic__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ResearchMethod));
			((dic__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ResearchMethod));
			for(int i = 0; i < n; i++)
				((dic__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_dic__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationCondition));
			((dic__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_dic__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationShippingRule));
			((dic__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_dic__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationRegionStatus));
			((dic__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntry")) {
		cp->type = SOAP_TYPE_vd__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntry));
			((vd__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
			for(int i = 0; i < n; i++)
				((vd__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Region")) {
		cp->type = SOAP_TYPE_dic__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Region));
			((dic__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Region[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Region));
			for(int i = 0; i < n; i++)
				((dic__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:District")) {
		cp->type = SOAP_TYPE_dic__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__District));
			((dic__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__District[n]);
			ASSIGN_PTR(size, n * sizeof(dic__District));
			for(int i = 0; i < n; i++)
				((dic__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Locality")) {
		cp->type = SOAP_TYPE_dic__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Locality));
			((dic__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Locality));
			for(int i = 0; i < n; i++)
				((dic__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Street")) {
		cp->type = SOAP_TYPE_dic__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Street));
			((dic__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Street[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Street));
			for(int i = 0; i < n; i++)
				((dic__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity);
		ASSIGN_PTR(size, sizeof(base__GenericVersioningEntity));
		((base__GenericVersioningEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__GenericVersioningEntity));
		for(int i = 0; i < n; i++)
			((base__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__GenericVersioningEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__GenericVersioningEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__GenericVersioningEntity %p -> %p\n", q, p));
	*(base__GenericVersioningEntity*)p = *(base__GenericVersioningEntity*)q;
}

void base__GenericEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void base__GenericEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int base__GenericEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__GenericEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__GenericEntity(struct soap *soap, const char *tag, int id, const base__GenericEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__GenericEntity), type))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__GenericEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__GenericEntity(soap, tag, this, type);
}

SOAP_FMAC3 base__GenericEntity * FASTCALL soap_in_base__GenericEntity(struct soap *soap, const char *tag, base__GenericEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__GenericEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__GenericEntity, sizeof(base__GenericEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__GenericEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__GenericEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__GenericEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__GenericEntity, 0, sizeof(base__GenericEntity), 0, soap_copy_base__GenericEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__GenericEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__GenericEntity);
	return this->soap_out(soap, tag?tag:"base:GenericEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__GenericEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__GenericEntity(soap, this, tag, type);
}

SOAP_FMAC3 base__GenericEntity * SOAP_FMAC4 soap_get_base__GenericEntity(struct soap *soap, base__GenericEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_base__GenericEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__GenericEntity * FASTCALL soap_instantiate_base__GenericEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__GenericEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__GenericEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "base:GenericVersioningEntity")) {
		cp->type = SOAP_TYPE_base__GenericVersioningEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(base__GenericVersioningEntity));
			((base__GenericVersioningEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity[n]);
			ASSIGN_PTR(size, n * sizeof(base__GenericVersioningEntity));
			for(int i = 0; i < n; i++)
				((base__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (base__GenericVersioningEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:EnterpriseActivity")) {
		cp->type = SOAP_TYPE_dic__EnterpriseActivity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__EnterpriseActivity));
			((dic__EnterpriseActivity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__EnterpriseActivity[n]);
			ASSIGN_PTR(size, n * sizeof(dic__EnterpriseActivity));
			for(int i = 0; i < n; i++)
				((dic__EnterpriseActivity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__EnterpriseActivity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:IncorporationForm")) {
		cp->type = SOAP_TYPE_dic__IncorporationForm;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__IncorporationForm);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__IncorporationForm));
			((dic__IncorporationForm*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__IncorporationForm[n]);
			ASSIGN_PTR(size, n * sizeof(dic__IncorporationForm));
			for(int i = 0; i < n; i++)
				((dic__IncorporationForm*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__IncorporationForm*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Delivery")) {
		cp->type = SOAP_TYPE_vd__Delivery;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Delivery);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Delivery));
			((vd__Delivery*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Delivery[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Delivery));
			for(int i = 0; i < n; i++)
				((vd__Delivery*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Delivery*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReason")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReason;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReason));
			((vd__DiscrepancyReason*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReason));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReason*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReason*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Document")) {
		cp->type = SOAP_TYPE_vd__Document;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Document);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Document));
			((vd__Document*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Document[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Document));
			for(int i = 0; i < n; i++)
				((vd__Document*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Document*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ShipmentRoutePoint")) {
		cp->type = SOAP_TYPE_vd__ShipmentRoutePoint;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ShipmentRoutePoint));
			((vd__ShipmentRoutePoint*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoutePoint));
			for(int i = 0; i < n; i++)
				((vd__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ShipmentRoutePoint*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:User")) {
		cp->type = SOAP_TYPE_vd__User;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__User);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__User));
			((vd__User*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__User[n]);
			ASSIGN_PTR(size, n * sizeof(vd__User));
			for(int i = 0; i < n; i++)
				((vd__User*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__User*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Purpose")) {
		cp->type = SOAP_TYPE_dic__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Purpose));
			((dic__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Purpose));
			for(int i = 0; i < n; i++)
				((dic__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Unit")) {
		cp->type = SOAP_TYPE_dic__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Unit));
			((dic__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Unit));
			for(int i = 0; i < n; i++)
				((dic__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:PackingType")) {
		cp->type = SOAP_TYPE_dic__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__PackingType));
			((dic__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(dic__PackingType));
			for(int i = 0; i < n; i++)
				((dic__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Country")) {
		cp->type = SOAP_TYPE_dic__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Country));
			((dic__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Country[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Country));
			for(int i = 0; i < n; i++)
				((dic__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:FederalDistrict")) {
		cp->type = SOAP_TYPE_dic__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__FederalDistrict));
			((dic__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(dic__FederalDistrict));
			for(int i = 0; i < n; i++)
				((dic__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:AddressObjectView")) {
		cp->type = SOAP_TYPE_dic__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__AddressObjectView));
			((dic__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(dic__AddressObjectView));
			for(int i = 0; i < n; i++)
				((dic__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Enterprise")) {
		cp->type = SOAP_TYPE_dic__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Enterprise));
			((dic__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Enterprise));
			for(int i = 0; i < n; i++)
				((dic__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:BusinessEntity")) {
		cp->type = SOAP_TYPE_dic__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__BusinessEntity));
			((dic__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(dic__BusinessEntity));
			for(int i = 0; i < n; i++)
				((dic__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ProductItem")) {
		cp->type = SOAP_TYPE_dic__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ProductItem));
			((dic__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ProductItem));
			for(int i = 0; i < n; i++)
				((dic__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Product")) {
		cp->type = SOAP_TYPE_dic__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Product));
			((dic__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Product[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Product));
			for(int i = 0; i < n; i++)
				((dic__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:SubProduct")) {
		cp->type = SOAP_TYPE_dic__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__SubProduct));
			((dic__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(dic__SubProduct));
			for(int i = 0; i < n; i++)
				((dic__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Indicator")) {
		cp->type = SOAP_TYPE_dic__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Indicator));
			((dic__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Indicator));
			for(int i = 0; i < n; i++)
				((dic__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:AnimalDisease")) {
		cp->type = SOAP_TYPE_dic__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__AnimalDisease));
			((dic__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(dic__AnimalDisease));
			for(int i = 0; i < n; i++)
				((dic__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:ResearchMethod")) {
		cp->type = SOAP_TYPE_dic__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__ResearchMethod));
			((dic__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(dic__ResearchMethod));
			for(int i = 0; i < n; i++)
				((dic__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_dic__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationCondition));
			((dic__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_dic__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationShippingRule));
			((dic__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_dic__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__RegionalizationRegionStatus));
			((dic__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(dic__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((dic__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:VetDocument")) {
		cp->type = SOAP_TYPE_vd__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocument));
			((vd__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
			for(int i = 0; i < n; i++)
				((vd__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
			((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntry")) {
		cp->type = SOAP_TYPE_vd__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntry));
			((vd__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
			for(int i = 0; i < n; i++)
				((vd__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Waybill")) {
		cp->type = SOAP_TYPE_vd__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Waybill));
			((vd__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Waybill));
			for(int i = 0; i < n; i++)
				((vd__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ReferencedDocument")) {
		cp->type = SOAP_TYPE_vd__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
			((vd__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ReferencedDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Region")) {
		cp->type = SOAP_TYPE_dic__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Region));
			((dic__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Region[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Region));
			for(int i = 0; i < n; i++)
				((dic__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:District")) {
		cp->type = SOAP_TYPE_dic__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__District));
			((dic__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__District[n]);
			ASSIGN_PTR(size, n * sizeof(dic__District));
			for(int i = 0; i < n; i++)
				((dic__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Locality")) {
		cp->type = SOAP_TYPE_dic__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Locality));
			((dic__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Locality));
			for(int i = 0; i < n; i++)
				((dic__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "dic:Street")) {
		cp->type = SOAP_TYPE_dic__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(dic__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(dic__Street));
			((dic__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(dic__Street[n]);
			ASSIGN_PTR(size, n * sizeof(dic__Street));
			for(int i = 0; i < n; i++)
				((dic__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (dic__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__GenericEntity);
		ASSIGN_PTR(size, sizeof(base__GenericEntity));
		((base__GenericEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__GenericEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__GenericEntity));
		for(int i = 0; i < n; i++)
			((base__GenericEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__GenericEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__GenericEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__GenericEntity %p -> %p\n", q, p));
	*(base__GenericEntity*)p = *(base__GenericEntity*)q;
}

void g2ba__GetApplicableUserAuthorityListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetApplicableUserAuthorityListResponse::vd__authorityList = NULL;
	/* transient soap skipped */
}

void g2ba__GetApplicableUserAuthorityListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__AuthorityList(soap, &this->g2ba__GetApplicableUserAuthorityListResponse::vd__authorityList);
	/* transient soap skipped */
}

int g2ba__GetApplicableUserAuthorityListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetApplicableUserAuthorityListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetApplicableUserAuthorityListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse), "g2ba:GetApplicableUserAuthorityListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__authorityList)
		soap_element_result(soap, "vd:authorityList");
	if(soap_out_PointerTovd__AuthorityList(soap, "vd:authorityList", -1, &(a->g2ba__GetApplicableUserAuthorityListResponse::vd__authorityList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetApplicableUserAuthorityListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetApplicableUserAuthorityListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListResponse * FASTCALL soap_in_g2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, const char *tag, g2ba__GetApplicableUserAuthorityListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetApplicableUserAuthorityListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse, sizeof(g2ba__GetApplicableUserAuthorityListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetApplicableUserAuthorityListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__authorityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AuthorityList(soap, "vd:authorityList", &(a->g2ba__GetApplicableUserAuthorityListResponse::vd__authorityList), "vd:AuthorityList"))
				{	soap_flag_vd__authorityList1--;
					continue;
				}
			soap_check_result(soap, "vd:authorityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetApplicableUserAuthorityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse, 0, sizeof(g2ba__GetApplicableUserAuthorityListResponse), 0, soap_copy_g2ba__GetApplicableUserAuthorityListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__GetApplicableUserAuthorityListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetApplicableUserAuthorityListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetApplicableUserAuthorityListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetApplicableUserAuthorityListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListResponse * SOAP_FMAC4 soap_get_g2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, g2ba__GetApplicableUserAuthorityListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetApplicableUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetApplicableUserAuthorityListResponse * FASTCALL soap_instantiate_g2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetApplicableUserAuthorityListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetApplicableUserAuthorityListResponse));
		((g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetApplicableUserAuthorityListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetApplicableUserAuthorityListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetApplicableUserAuthorityListResponse %p -> %p\n", q, p));
	*(g2ba__GetApplicableUserAuthorityListResponse*)p = *(g2ba__GetApplicableUserAuthorityListResponse*)q;
}

void g2ba__GetApplicableUserAuthorityListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetApplicableUserAuthorityListRequest::base__listOptions = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetApplicableUserAuthorityListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetApplicableUserAuthorityListRequest::base__listOptions);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetApplicableUserAuthorityListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetApplicableUserAuthorityListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetApplicableUserAuthorityListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest), "g2ba:GetApplicableUserAuthorityListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetApplicableUserAuthorityListRequest::base__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetApplicableUserAuthorityListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetApplicableUserAuthorityListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListRequest * FASTCALL soap_in_g2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, g2ba__GetApplicableUserAuthorityListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetApplicableUserAuthorityListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest, sizeof(g2ba__GetApplicableUserAuthorityListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetApplicableUserAuthorityListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetApplicableUserAuthorityListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetApplicableUserAuthorityListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest, 0, sizeof(g2ba__GetApplicableUserAuthorityListRequest), 0, soap_copy_g2ba__GetApplicableUserAuthorityListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetApplicableUserAuthorityListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetApplicableUserAuthorityListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetApplicableUserAuthorityListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetApplicableUserAuthorityListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListRequest * SOAP_FMAC4 soap_get_g2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, g2ba__GetApplicableUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetApplicableUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetApplicableUserAuthorityListRequest * FASTCALL soap_instantiate_g2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetApplicableUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetApplicableUserAuthorityListRequest));
		((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetApplicableUserAuthorityListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetApplicableUserAuthorityListRequest %p -> %p\n", q, p));
	*(g2ba__GetApplicableUserAuthorityListRequest*)p = *(g2ba__GetApplicableUserAuthorityListRequest*)q;
}

void g2ba__UnbindBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UnbindBusinessEntityUserResponse::__sizeuser = 0;
	this->g2ba__UnbindBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void g2ba__UnbindBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UnbindBusinessEntityUserResponse::vd__user) {
		for(int i = 0; i < this->g2ba__UnbindBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UnbindBusinessEntityUserResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__UnbindBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UnbindBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const g2ba__UnbindBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse), "g2ba:UnbindBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->g2ba__UnbindBusinessEntityUserResponse::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UnbindBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UnbindBusinessEntityUserResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UnbindBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UnbindBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserResponse * FASTCALL soap_in_g2ba__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__UnbindBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UnbindBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse, sizeof(g2ba__UnbindBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UnbindBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UnbindBusinessEntityUserResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UnbindBusinessEntityUserResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UnbindBusinessEntityUserResponse::vd__user == NULL)
						return NULL;
					*a->g2ba__UnbindBusinessEntityUserResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UnbindBusinessEntityUserResponse::vd__user, "vd:User"))
				{	a->g2ba__UnbindBusinessEntityUserResponse::__sizeuser++;
					a->g2ba__UnbindBusinessEntityUserResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UnbindBusinessEntityUserResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UnbindBusinessEntityUserResponse::__sizeuser)
			a->g2ba__UnbindBusinessEntityUserResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UnbindBusinessEntityUserResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UnbindBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse, 0, sizeof(g2ba__UnbindBusinessEntityUserResponse), 0, soap_copy_g2ba__UnbindBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__UnbindBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"g2ba:UnbindBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UnbindBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UnbindBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserResponse * SOAP_FMAC4 soap_get_g2ba__UnbindBusinessEntityUserResponse(struct soap *soap, g2ba__UnbindBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UnbindBusinessEntityUserResponse * FASTCALL soap_instantiate_g2ba__UnbindBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UnbindBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(g2ba__UnbindBusinessEntityUserResponse));
		((g2ba__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UnbindBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((g2ba__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UnbindBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UnbindBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UnbindBusinessEntityUserResponse %p -> %p\n", q, p));
	*(g2ba__UnbindBusinessEntityUserResponse*)p = *(g2ba__UnbindBusinessEntityUserResponse*)q;
}

void g2ba__UnbindBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UnbindBusinessEntityUserRequest::__sizeuser = 0;
	this->g2ba__UnbindBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__UnbindBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UnbindBusinessEntityUserRequest::vd__user) {
		for(int i = 0; i < this->g2ba__UnbindBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UnbindBusinessEntityUserRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__UnbindBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UnbindBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const g2ba__UnbindBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest), "g2ba:UnbindBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__UnbindBusinessEntityUserRequest::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UnbindBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UnbindBusinessEntityUserRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UnbindBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UnbindBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserRequest * FASTCALL soap_in_g2ba__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__UnbindBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UnbindBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest, sizeof(g2ba__UnbindBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UnbindBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UnbindBusinessEntityUserRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UnbindBusinessEntityUserRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UnbindBusinessEntityUserRequest::vd__user == NULL)
						return NULL;
					*a->g2ba__UnbindBusinessEntityUserRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UnbindBusinessEntityUserRequest::vd__user, "vd:User"))
				{	a->g2ba__UnbindBusinessEntityUserRequest::__sizeuser++;
					a->g2ba__UnbindBusinessEntityUserRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UnbindBusinessEntityUserRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UnbindBusinessEntityUserRequest::__sizeuser)
			a->g2ba__UnbindBusinessEntityUserRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UnbindBusinessEntityUserRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UnbindBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest, 0, sizeof(g2ba__UnbindBusinessEntityUserRequest), 0, soap_copy_g2ba__UnbindBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__UnbindBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__UnbindBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"g2ba:UnbindBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UnbindBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UnbindBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get_g2ba__UnbindBusinessEntityUserRequest(struct soap *soap, g2ba__UnbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UnbindBusinessEntityUserRequest * FASTCALL soap_instantiate_g2ba__UnbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UnbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(g2ba__UnbindBusinessEntityUserRequest));
		((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UnbindBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UnbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UnbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UnbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(g2ba__UnbindBusinessEntityUserRequest*)p = *(g2ba__UnbindBusinessEntityUserRequest*)q;
}

void g2ba__UpdateUserWorkingAreasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateUserWorkingAreasResponse::__sizeuser = 0;
	this->g2ba__UpdateUserWorkingAreasResponse::vd__user = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateUserWorkingAreasResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateUserWorkingAreasResponse::vd__user) {
		for(int i = 0; i < this->g2ba__UpdateUserWorkingAreasResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UpdateUserWorkingAreasResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__UpdateUserWorkingAreasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateUserWorkingAreasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, const g2ba__UpdateUserWorkingAreasResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse), "g2ba:UpdateUserWorkingAreasResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->g2ba__UpdateUserWorkingAreasResponse::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UpdateUserWorkingAreasResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UpdateUserWorkingAreasResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateUserWorkingAreasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateUserWorkingAreasResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasResponse * FASTCALL soap_in_g2ba__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, g2ba__UpdateUserWorkingAreasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateUserWorkingAreasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse, sizeof(g2ba__UpdateUserWorkingAreasResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateUserWorkingAreasResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UpdateUserWorkingAreasResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UpdateUserWorkingAreasResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UpdateUserWorkingAreasResponse::vd__user == NULL)
						return NULL;
					*a->g2ba__UpdateUserWorkingAreasResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UpdateUserWorkingAreasResponse::vd__user, "vd:User"))
				{	a->g2ba__UpdateUserWorkingAreasResponse::__sizeuser++;
					a->g2ba__UpdateUserWorkingAreasResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateUserWorkingAreasResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UpdateUserWorkingAreasResponse::__sizeuser)
			a->g2ba__UpdateUserWorkingAreasResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UpdateUserWorkingAreasResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateUserWorkingAreasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse, 0, sizeof(g2ba__UpdateUserWorkingAreasResponse), 0, soap_copy_g2ba__UpdateUserWorkingAreasResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__UpdateUserWorkingAreasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateUserWorkingAreasResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateUserWorkingAreasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateUserWorkingAreasResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasResponse * SOAP_FMAC4 soap_get_g2ba__UpdateUserWorkingAreasResponse(struct soap *soap, g2ba__UpdateUserWorkingAreasResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateUserWorkingAreasResponse * FASTCALL soap_instantiate_g2ba__UpdateUserWorkingAreasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateUserWorkingAreasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasResponse);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateUserWorkingAreasResponse));
		((g2ba__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserWorkingAreasResponse));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateUserWorkingAreasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateUserWorkingAreasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateUserWorkingAreasResponse %p -> %p\n", q, p));
	*(g2ba__UpdateUserWorkingAreasResponse*)p = *(g2ba__UpdateUserWorkingAreasResponse*)q;
}

void g2ba__UpdateUserWorkingAreasRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateUserWorkingAreasRequest::__sizeuser = 0;
	this->g2ba__UpdateUserWorkingAreasRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateUserWorkingAreasRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateUserWorkingAreasRequest::vd__user) {
		for(int i = 0; i < this->g2ba__UpdateUserWorkingAreasRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UpdateUserWorkingAreasRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__UpdateUserWorkingAreasRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateUserWorkingAreasRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const g2ba__UpdateUserWorkingAreasRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest), "g2ba:UpdateUserWorkingAreasRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__UpdateUserWorkingAreasRequest::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UpdateUserWorkingAreasRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UpdateUserWorkingAreasRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateUserWorkingAreasRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateUserWorkingAreasRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasRequest * FASTCALL soap_in_g2ba__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, g2ba__UpdateUserWorkingAreasRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateUserWorkingAreasRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest, sizeof(g2ba__UpdateUserWorkingAreasRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateUserWorkingAreasRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UpdateUserWorkingAreasRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UpdateUserWorkingAreasRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UpdateUserWorkingAreasRequest::vd__user == NULL)
						return NULL;
					*a->g2ba__UpdateUserWorkingAreasRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UpdateUserWorkingAreasRequest::vd__user, "vd:User"))
				{	a->g2ba__UpdateUserWorkingAreasRequest::__sizeuser++;
					a->g2ba__UpdateUserWorkingAreasRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateUserWorkingAreasRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UpdateUserWorkingAreasRequest::__sizeuser)
			a->g2ba__UpdateUserWorkingAreasRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UpdateUserWorkingAreasRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateUserWorkingAreasRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest, 0, sizeof(g2ba__UpdateUserWorkingAreasRequest), 0, soap_copy_g2ba__UpdateUserWorkingAreasRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__UpdateUserWorkingAreasRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__UpdateUserWorkingAreasRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateUserWorkingAreasRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateUserWorkingAreasRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateUserWorkingAreasRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasRequest * SOAP_FMAC4 soap_get_g2ba__UpdateUserWorkingAreasRequest(struct soap *soap, g2ba__UpdateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateUserWorkingAreasRequest * FASTCALL soap_instantiate_g2ba__UpdateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateUserWorkingAreasRequest));
		((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserWorkingAreasRequest));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(g2ba__UpdateUserWorkingAreasRequest*)p = *(g2ba__UpdateUserWorkingAreasRequest*)q;
}

void g2ba__UpdateUserAuthoritiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateUserAuthoritiesResponse::__sizeuser = 0;
	this->g2ba__UpdateUserAuthoritiesResponse::vd__user = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateUserAuthoritiesResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateUserAuthoritiesResponse::vd__user) {
		for(int i = 0; i < this->g2ba__UpdateUserAuthoritiesResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UpdateUserAuthoritiesResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__UpdateUserAuthoritiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateUserAuthoritiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, const g2ba__UpdateUserAuthoritiesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse), "g2ba:UpdateUserAuthoritiesResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->g2ba__UpdateUserAuthoritiesResponse::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UpdateUserAuthoritiesResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UpdateUserAuthoritiesResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateUserAuthoritiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateUserAuthoritiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesResponse * FASTCALL soap_in_g2ba__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, g2ba__UpdateUserAuthoritiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateUserAuthoritiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse, sizeof(g2ba__UpdateUserAuthoritiesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateUserAuthoritiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UpdateUserAuthoritiesResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UpdateUserAuthoritiesResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UpdateUserAuthoritiesResponse::vd__user == NULL)
						return NULL;
					*a->g2ba__UpdateUserAuthoritiesResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UpdateUserAuthoritiesResponse::vd__user, "vd:User"))
				{	a->g2ba__UpdateUserAuthoritiesResponse::__sizeuser++;
					a->g2ba__UpdateUserAuthoritiesResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateUserAuthoritiesResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UpdateUserAuthoritiesResponse::__sizeuser)
			a->g2ba__UpdateUserAuthoritiesResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UpdateUserAuthoritiesResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateUserAuthoritiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse, 0, sizeof(g2ba__UpdateUserAuthoritiesResponse), 0, soap_copy_g2ba__UpdateUserAuthoritiesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__UpdateUserAuthoritiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateUserAuthoritiesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateUserAuthoritiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateUserAuthoritiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesResponse * SOAP_FMAC4 soap_get_g2ba__UpdateUserAuthoritiesResponse(struct soap *soap, g2ba__UpdateUserAuthoritiesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateUserAuthoritiesResponse * FASTCALL soap_instantiate_g2ba__UpdateUserAuthoritiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateUserAuthoritiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesResponse);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateUserAuthoritiesResponse));
		((g2ba__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserAuthoritiesResponse));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateUserAuthoritiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateUserAuthoritiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateUserAuthoritiesResponse %p -> %p\n", q, p));
	*(g2ba__UpdateUserAuthoritiesResponse*)p = *(g2ba__UpdateUserAuthoritiesResponse*)q;
}

void g2ba__UpdateUserAuthoritiesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateUserAuthoritiesRequest::__sizeuser = 0;
	this->g2ba__UpdateUserAuthoritiesRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateUserAuthoritiesRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateUserAuthoritiesRequest::vd__user) {
		for(int i = 0; i < this->g2ba__UpdateUserAuthoritiesRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__UpdateUserAuthoritiesRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__UpdateUserAuthoritiesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateUserAuthoritiesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const g2ba__UpdateUserAuthoritiesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest), "g2ba:UpdateUserAuthoritiesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__UpdateUserAuthoritiesRequest::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__UpdateUserAuthoritiesRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__UpdateUserAuthoritiesRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateUserAuthoritiesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateUserAuthoritiesRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesRequest * FASTCALL soap_in_g2ba__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, g2ba__UpdateUserAuthoritiesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateUserAuthoritiesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest, sizeof(g2ba__UpdateUserAuthoritiesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateUserAuthoritiesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__UpdateUserAuthoritiesRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__UpdateUserAuthoritiesRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__UpdateUserAuthoritiesRequest::vd__user == NULL)
						return NULL;
					*a->g2ba__UpdateUserAuthoritiesRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__UpdateUserAuthoritiesRequest::vd__user, "vd:User"))
				{	a->g2ba__UpdateUserAuthoritiesRequest::__sizeuser++;
					a->g2ba__UpdateUserAuthoritiesRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateUserAuthoritiesRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__UpdateUserAuthoritiesRequest::__sizeuser)
			a->g2ba__UpdateUserAuthoritiesRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__UpdateUserAuthoritiesRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateUserAuthoritiesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest, 0, sizeof(g2ba__UpdateUserAuthoritiesRequest), 0, soap_copy_g2ba__UpdateUserAuthoritiesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__UpdateUserAuthoritiesRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__UpdateUserAuthoritiesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateUserAuthoritiesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateUserAuthoritiesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateUserAuthoritiesRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesRequest * SOAP_FMAC4 soap_get_g2ba__UpdateUserAuthoritiesRequest(struct soap *soap, g2ba__UpdateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateUserAuthoritiesRequest * FASTCALL soap_instantiate_g2ba__UpdateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateUserAuthoritiesRequest));
		((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserAuthoritiesRequest));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(g2ba__UpdateUserAuthoritiesRequest*)p = *(g2ba__UpdateUserAuthoritiesRequest*)q;
}

void g2ba__GetBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void g2ba__GetBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->g2ba__GetBusinessEntityUserResponse::vd__user);
	/* transient soap skipped */
}

int g2ba__GetBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const g2ba__GetBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse), "g2ba:GetBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__user)
		soap_element_result(soap, "vd:user");
	if(soap_out_PointerTovd__User(soap, "vd:user", -1, &(a->g2ba__GetBusinessEntityUserResponse::vd__user), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserResponse * FASTCALL soap_in_g2ba__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse, sizeof(g2ba__GetBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:user", &(a->g2ba__GetBusinessEntityUserResponse::vd__user), "vd:User"))
				{	soap_flag_vd__user1--;
					continue;
				}
			soap_check_result(soap, "vd:user");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse, 0, sizeof(g2ba__GetBusinessEntityUserResponse), 0, soap_copy_g2ba__GetBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__GetBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserResponse * SOAP_FMAC4 soap_get_g2ba__GetBusinessEntityUserResponse(struct soap *soap, g2ba__GetBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetBusinessEntityUserResponse * FASTCALL soap_instantiate_g2ba__GetBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserResponse));
		((g2ba__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetBusinessEntityUserResponse %p -> %p\n", q, p));
	*(g2ba__GetBusinessEntityUserResponse*)p = *(g2ba__GetBusinessEntityUserResponse*)q;
}

void g2ba__GetBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->g2ba__GetBusinessEntityUserRequest::vd__user);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const g2ba__GetBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest), "g2ba:GetBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__GetBusinessEntityUserRequest::vd__user) {
		if(soap_out_PointerTovd__User(soap, "vd:user", -1, &a->g2ba__GetBusinessEntityUserRequest::vd__user, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:user"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserRequest * FASTCALL soap_in_g2ba__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest, sizeof(g2ba__GetBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vd__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vd__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:user", &(a->g2ba__GetBusinessEntityUserRequest::vd__user), "vd:User"))
				{	soap_flag_vd__user1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest, 0, sizeof(g2ba__GetBusinessEntityUserRequest), 0, soap_copy_g2ba__GetBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vd__user1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserRequest * SOAP_FMAC4 soap_get_g2ba__GetBusinessEntityUserRequest(struct soap *soap, g2ba__GetBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetBusinessEntityUserRequest * FASTCALL soap_instantiate_g2ba__GetBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserRequest));
		((g2ba__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetBusinessEntityUserRequest %p -> %p\n", q, p));
	*(g2ba__GetBusinessEntityUserRequest*)p = *(g2ba__GetBusinessEntityUserRequest*)q;
}

void g2ba__GetBusinessEntityUserListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetBusinessEntityUserListResponse::vd__userList = NULL;
	/* transient soap skipped */
}

void g2ba__GetBusinessEntityUserListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__UserList(soap, &this->g2ba__GetBusinessEntityUserListResponse::vd__userList);
	/* transient soap skipped */
}

int g2ba__GetBusinessEntityUserListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetBusinessEntityUserListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetBusinessEntityUserListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse), "g2ba:GetBusinessEntityUserListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__userList)
		soap_element_result(soap, "vd:userList");
	if(soap_out_PointerTovd__UserList(soap, "vd:userList", -1, &(a->g2ba__GetBusinessEntityUserListResponse::vd__userList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetBusinessEntityUserListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetBusinessEntityUserListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListResponse * FASTCALL soap_in_g2ba__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetBusinessEntityUserListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse, sizeof(g2ba__GetBusinessEntityUserListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetBusinessEntityUserListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__userList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__userList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__UserList(soap, "vd:userList", &(a->g2ba__GetBusinessEntityUserListResponse::vd__userList), "vd:UserList"))
				{	soap_flag_vd__userList1--;
					continue;
				}
			soap_check_result(soap, "vd:userList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetBusinessEntityUserListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse, 0, sizeof(g2ba__GetBusinessEntityUserListResponse), 0, soap_copy_g2ba__GetBusinessEntityUserListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__GetBusinessEntityUserListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetBusinessEntityUserListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetBusinessEntityUserListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetBusinessEntityUserListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListResponse * SOAP_FMAC4 soap_get_g2ba__GetBusinessEntityUserListResponse(struct soap *soap, g2ba__GetBusinessEntityUserListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetBusinessEntityUserListResponse * FASTCALL soap_instantiate_g2ba__GetBusinessEntityUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetBusinessEntityUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserListResponse));
		((g2ba__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetBusinessEntityUserListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetBusinessEntityUserListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetBusinessEntityUserListResponse %p -> %p\n", q, p));
	*(g2ba__GetBusinessEntityUserListResponse*)p = *(g2ba__GetBusinessEntityUserListResponse*)q;
}

void g2ba__GetBusinessEntityUserListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetBusinessEntityUserListRequest::base__listOptions = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetBusinessEntityUserListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetBusinessEntityUserListRequest::base__listOptions);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetBusinessEntityUserListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetBusinessEntityUserListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetBusinessEntityUserListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest), "g2ba:GetBusinessEntityUserListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetBusinessEntityUserListRequest::base__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetBusinessEntityUserListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetBusinessEntityUserListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListRequest * FASTCALL soap_in_g2ba__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetBusinessEntityUserListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest, sizeof(g2ba__GetBusinessEntityUserListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetBusinessEntityUserListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetBusinessEntityUserListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetBusinessEntityUserListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest, 0, sizeof(g2ba__GetBusinessEntityUserListRequest), 0, soap_copy_g2ba__GetBusinessEntityUserListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetBusinessEntityUserListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetBusinessEntityUserListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetBusinessEntityUserListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetBusinessEntityUserListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListRequest * SOAP_FMAC4 soap_get_g2ba__GetBusinessEntityUserListRequest(struct soap *soap, g2ba__GetBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetBusinessEntityUserListRequest * FASTCALL soap_instantiate_g2ba__GetBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserListRequest));
		((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(g2ba__GetBusinessEntityUserListRequest*)p = *(g2ba__GetBusinessEntityUserListRequest*)q;
}

void g2ba__AddBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__AddBusinessEntityUserResponse::__sizeuser = 0;
	this->g2ba__AddBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void g2ba__AddBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__AddBusinessEntityUserResponse::vd__user) {
		for(int i = 0; i < this->g2ba__AddBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__AddBusinessEntityUserResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__AddBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__AddBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const g2ba__AddBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse), "g2ba:AddBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->g2ba__AddBusinessEntityUserResponse::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__AddBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__AddBusinessEntityUserResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__AddBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__AddBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserResponse * FASTCALL soap_in_g2ba__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__AddBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__AddBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse, sizeof(g2ba__AddBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__AddBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__AddBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__AddBusinessEntityUserResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__AddBusinessEntityUserResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__AddBusinessEntityUserResponse::vd__user == NULL)
						return NULL;
					*a->g2ba__AddBusinessEntityUserResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__AddBusinessEntityUserResponse::vd__user, "vd:User"))
				{	a->g2ba__AddBusinessEntityUserResponse::__sizeuser++;
					a->g2ba__AddBusinessEntityUserResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__AddBusinessEntityUserResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__AddBusinessEntityUserResponse::__sizeuser)
			a->g2ba__AddBusinessEntityUserResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__AddBusinessEntityUserResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__AddBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse, 0, sizeof(g2ba__AddBusinessEntityUserResponse), 0, soap_copy_g2ba__AddBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__AddBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"g2ba:AddBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__AddBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__AddBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserResponse * SOAP_FMAC4 soap_get_g2ba__AddBusinessEntityUserResponse(struct soap *soap, g2ba__AddBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__AddBusinessEntityUserResponse * FASTCALL soap_instantiate_g2ba__AddBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__AddBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(g2ba__AddBusinessEntityUserResponse));
		((g2ba__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__AddBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((g2ba__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__AddBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__AddBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__AddBusinessEntityUserResponse %p -> %p\n", q, p));
	*(g2ba__AddBusinessEntityUserResponse*)p = *(g2ba__AddBusinessEntityUserResponse*)q;
}

void g2ba__AddBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__AddBusinessEntityUserRequest::__sizeuser = 0;
	this->g2ba__AddBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__AddBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__AddBusinessEntityUserRequest::vd__user) {
		for(int i = 0; i < this->g2ba__AddBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->g2ba__AddBusinessEntityUserRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__AddBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__AddBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const g2ba__AddBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest), "g2ba:AddBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__AddBusinessEntityUserRequest::vd__user) {
		int i;
		for(i = 0; i < a->g2ba__AddBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->g2ba__AddBusinessEntityUserRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__AddBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__AddBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserRequest * FASTCALL soap_in_g2ba__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__AddBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__AddBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest, sizeof(g2ba__AddBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__AddBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__AddBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->g2ba__AddBusinessEntityUserRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->g2ba__AddBusinessEntityUserRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->g2ba__AddBusinessEntityUserRequest::vd__user == NULL)
						return NULL;
					*a->g2ba__AddBusinessEntityUserRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->g2ba__AddBusinessEntityUserRequest::vd__user, "vd:User"))
				{	a->g2ba__AddBusinessEntityUserRequest::__sizeuser++;
					a->g2ba__AddBusinessEntityUserRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__AddBusinessEntityUserRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->g2ba__AddBusinessEntityUserRequest::__sizeuser)
			a->g2ba__AddBusinessEntityUserRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->g2ba__AddBusinessEntityUserRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__AddBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest, 0, sizeof(g2ba__AddBusinessEntityUserRequest), 0, soap_copy_g2ba__AddBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__AddBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__AddBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"g2ba:AddBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__AddBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__AddBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserRequest * SOAP_FMAC4 soap_get_g2ba__AddBusinessEntityUserRequest(struct soap *soap, g2ba__AddBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__AddBusinessEntityUserRequest * FASTCALL soap_instantiate_g2ba__AddBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__AddBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(g2ba__AddBusinessEntityUserRequest));
		((g2ba__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__AddBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((g2ba__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__AddBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__AddBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__AddBusinessEntityUserRequest %p -> %p\n", q, p));
	*(g2ba__AddBusinessEntityUserRequest*)p = *(g2ba__AddBusinessEntityUserRequest*)q;
}

void g2ba__CheckShipmentRegionalizationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__CheckShipmentRegionalizationResponse::__sizer13nRouteSection = 0;
	this->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
	/* transient soap skipped */
}

void g2ba__CheckShipmentRegionalizationResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection) {
		for(int i = 0; i < this->g2ba__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++) {
			soap_serialize_PointerTovd__RouteSectionR13nRules(soap, this->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__CheckShipmentRegionalizationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__CheckShipmentRegionalizationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, const g2ba__CheckShipmentRegionalizationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse), "g2ba:CheckShipmentRegionalizationResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizer13nRouteSection");
	if(a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection) {
		int i;
		for(i = 0; i < a->g2ba__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++)
			if(soap_out_PointerTovd__RouteSectionR13nRules(soap, "vd:r13nRouteSection", -1, a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__CheckShipmentRegionalizationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__CheckShipmentRegionalizationResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationResponse * FASTCALL soap_in_g2ba__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, g2ba__CheckShipmentRegionalizationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__CheckShipmentRegionalizationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse, sizeof(g2ba__CheckShipmentRegionalizationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__CheckShipmentRegionalizationResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__r13nRouteSection1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:r13nRouteSection", 1, NULL)) {
				if(a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection == NULL) {
					if(soap_blist_vd__r13nRouteSection1 == NULL)
						soap_blist_vd__r13nRouteSection1 = soap_new_block(soap);
					a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = (vd__RouteSectionR13nRules **)soap_push_block(soap, soap_blist_vd__r13nRouteSection1, sizeof(vd__RouteSectionR13nRules *));
					if(a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection == NULL)
						return NULL;
					*a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RouteSectionR13nRules(soap, "vd:r13nRouteSection", a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection, "vd:RouteSectionR13nRules"))
				{	a->g2ba__CheckShipmentRegionalizationResponse::__sizer13nRouteSection++;
					a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizer13nRouteSection");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection)
			soap_pop_block(soap, soap_blist_vd__r13nRouteSection1);
		if(a->g2ba__CheckShipmentRegionalizationResponse::__sizer13nRouteSection)
			a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = (vd__RouteSectionR13nRules **)soap_save_block(soap, soap_blist_vd__r13nRouteSection1, NULL, 1);
		else
		{	a->g2ba__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
			if(soap_blist_vd__r13nRouteSection1)
				soap_end_block(soap, soap_blist_vd__r13nRouteSection1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__CheckShipmentRegionalizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse, 0, sizeof(g2ba__CheckShipmentRegionalizationResponse), 0, soap_copy_g2ba__CheckShipmentRegionalizationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__CheckShipmentRegionalizationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse);
	return this->soap_out(soap, tag?tag:"g2ba:CheckShipmentRegionalizationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__CheckShipmentRegionalizationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__CheckShipmentRegionalizationResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationResponse * SOAP_FMAC4 soap_get_g2ba__CheckShipmentRegionalizationResponse(struct soap *soap, g2ba__CheckShipmentRegionalizationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__CheckShipmentRegionalizationResponse * FASTCALL soap_instantiate_g2ba__CheckShipmentRegionalizationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__CheckShipmentRegionalizationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationResponse);
		ASSIGN_PTR(size, sizeof(g2ba__CheckShipmentRegionalizationResponse));
		((g2ba__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__CheckShipmentRegionalizationResponse));
		for(int i = 0; i < n; i++)
			((g2ba__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__CheckShipmentRegionalizationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__CheckShipmentRegionalizationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__CheckShipmentRegionalizationResponse %p -> %p\n", q, p));
	*(g2ba__CheckShipmentRegionalizationResponse*)p = *(g2ba__CheckShipmentRegionalizationResponse*)q;
}

void g2ba__CheckShipmentRegionalizationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType = 0;
	this->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = NULL;
	this->g2ba__CheckShipmentRegionalizationRequest::vd__shipmentRoute = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__CheckShipmentRegionalizationRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType) {
		for(int i = 0; i < this->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType; i++) {
			soap_serialize_PointerTodic__SubProduct(soap, this->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType + i);
		}
	}
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->g2ba__CheckShipmentRegionalizationRequest::vd__shipmentRoute);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__CheckShipmentRegionalizationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__CheckShipmentRegionalizationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const g2ba__CheckShipmentRegionalizationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest), "g2ba:CheckShipmentRegionalizationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType) {
		int i;
		for(i = 0; i < a->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType; i++)
			if(soap_out_PointerTodic__SubProduct(soap, "dic:cargoType", -1, a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType + i, ""))
				return soap->error;
	}
	if(a->g2ba__CheckShipmentRegionalizationRequest::vd__shipmentRoute) {
		if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &a->g2ba__CheckShipmentRegionalizationRequest::vd__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__CheckShipmentRegionalizationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__CheckShipmentRegionalizationRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationRequest * FASTCALL soap_in_g2ba__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, g2ba__CheckShipmentRegionalizationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__CheckShipmentRegionalizationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest, sizeof(g2ba__CheckShipmentRegionalizationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__CheckShipmentRegionalizationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_dic__cargoType1 = NULL;
	size_t soap_flag_vd__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "dic:cargoType", 1, NULL)) {
				if(a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType == NULL) {
					if(soap_blist_dic__cargoType1 == NULL)
						soap_blist_dic__cargoType1 = soap_new_block(soap);
					a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = (dic__SubProduct **)soap_push_block(soap, soap_blist_dic__cargoType1, sizeof(dic__SubProduct *));
					if(a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType == NULL)
						return NULL;
					*a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__SubProduct(soap, "dic:cargoType", a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType, "dic:SubProduct"))
				{	a->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType++;
					a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_vd__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->g2ba__CheckShipmentRegionalizationRequest::vd__shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_vd__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType)
			soap_pop_block(soap, soap_blist_dic__cargoType1);
		if(a->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType)
			a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = (dic__SubProduct **)soap_save_block(soap, soap_blist_dic__cargoType1, NULL, 1);
		else
		{	a->g2ba__CheckShipmentRegionalizationRequest::dic__cargoType = NULL;
			if(soap_blist_dic__cargoType1)
				soap_end_block(soap, soap_blist_dic__cargoType1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__CheckShipmentRegionalizationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest, 0, sizeof(g2ba__CheckShipmentRegionalizationRequest), 0, soap_copy_g2ba__CheckShipmentRegionalizationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__CheckShipmentRegionalizationRequest::__sizecargoType < 1 || soap_flag_vd__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__CheckShipmentRegionalizationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest);
	return this->soap_out(soap, tag?tag:"g2ba:CheckShipmentRegionalizationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__CheckShipmentRegionalizationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__CheckShipmentRegionalizationRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationRequest * SOAP_FMAC4 soap_get_g2ba__CheckShipmentRegionalizationRequest(struct soap *soap, g2ba__CheckShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__CheckShipmentRegionalizationRequest * FASTCALL soap_instantiate_g2ba__CheckShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__CheckShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(g2ba__CheckShipmentRegionalizationRequest));
		((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__CheckShipmentRegionalizationRequest));
		for(int i = 0; i < n; i++)
			((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__CheckShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__CheckShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__CheckShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(g2ba__CheckShipmentRegionalizationRequest*)p = *(g2ba__CheckShipmentRegionalizationRequest*)q;
}

void g2ba__UpdateVeterinaryEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateVeterinaryEventsResponse::__sizestockEntry = 0;
	this->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateVeterinaryEventsResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry) {
		for(int i = 0; i < this->g2ba__UpdateVeterinaryEventsResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__UpdateVeterinaryEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateVeterinaryEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, const g2ba__UpdateVeterinaryEventsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse), "g2ba:UpdateVeterinaryEventsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry) {
		int i;
		for(i = 0; i < a->g2ba__UpdateVeterinaryEventsResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateVeterinaryEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateVeterinaryEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsResponse * FASTCALL soap_in_g2ba__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, g2ba__UpdateVeterinaryEventsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateVeterinaryEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse, sizeof(g2ba__UpdateVeterinaryEventsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateVeterinaryEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry == NULL) {
					if(soap_blist_vd__stockEntry1 == NULL)
						soap_blist_vd__stockEntry1 = soap_new_block(soap);
					a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_vd__stockEntry1, sizeof(vd__StockEntry *));
					if(a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry == NULL)
						return NULL;
					*a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry, "vd:StockEntry"))
				{	a->g2ba__UpdateVeterinaryEventsResponse::__sizestockEntry++;
					a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry)
			soap_pop_block(soap, soap_blist_vd__stockEntry1);
		if(a->g2ba__UpdateVeterinaryEventsResponse::__sizestockEntry)
			a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_vd__stockEntry1, NULL, 1);
		else
		{	a->g2ba__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
			if(soap_blist_vd__stockEntry1)
				soap_end_block(soap, soap_blist_vd__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateVeterinaryEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse, 0, sizeof(g2ba__UpdateVeterinaryEventsResponse), 0, soap_copy_g2ba__UpdateVeterinaryEventsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__UpdateVeterinaryEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateVeterinaryEventsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateVeterinaryEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateVeterinaryEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsResponse * SOAP_FMAC4 soap_get_g2ba__UpdateVeterinaryEventsResponse(struct soap *soap, g2ba__UpdateVeterinaryEventsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateVeterinaryEventsResponse * FASTCALL soap_instantiate_g2ba__UpdateVeterinaryEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateVeterinaryEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsResponse);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateVeterinaryEventsResponse));
		((g2ba__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateVeterinaryEventsResponse));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateVeterinaryEventsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateVeterinaryEventsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateVeterinaryEventsResponse %p -> %p\n", q, p));
	*(g2ba__UpdateVeterinaryEventsResponse*)p = *(g2ba__UpdateVeterinaryEventsResponse*)q;
}

void g2ba__UpdateVeterinaryEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateVeterinaryEventsRequest::enterprise = NULL;
	this->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry = 0;
	this->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateVeterinaryEventsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->g2ba__UpdateVeterinaryEventsRequest::enterprise);
	if(this->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry) {
		for(int i = 0; i < this->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__UpdateVeterinaryEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateVeterinaryEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const g2ba__UpdateVeterinaryEventsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest), "g2ba:UpdateVeterinaryEventsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__UpdateVeterinaryEventsRequest::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "g2ba:enterprise", -1, &a->g2ba__UpdateVeterinaryEventsRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:enterprise"))
		return soap->error;
	if(a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry) {
		int i;
		for(i = 0; i < a->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateVeterinaryEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateVeterinaryEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsRequest * FASTCALL soap_in_g2ba__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, g2ba__UpdateVeterinaryEventsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateVeterinaryEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest, sizeof(g2ba__UpdateVeterinaryEventsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateVeterinaryEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	struct soap_blist *soap_blist_vd__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "g2ba:enterprise", &(a->g2ba__UpdateVeterinaryEventsRequest::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry == NULL) {
					if(soap_blist_vd__stockEntry1 == NULL)
						soap_blist_vd__stockEntry1 = soap_new_block(soap);
					a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_vd__stockEntry1, sizeof(vd__StockEntry *));
					if(a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry == NULL)
						return NULL;
					*a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry, "vd:StockEntry"))
				{	a->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry++;
					a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry)
			soap_pop_block(soap, soap_blist_vd__stockEntry1);
		if(a->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry)
			a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_vd__stockEntry1, NULL, 1);
		else
		{	a->g2ba__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
			if(soap_blist_vd__stockEntry1)
				soap_end_block(soap, soap_blist_vd__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateVeterinaryEventsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest, 0, sizeof(g2ba__UpdateVeterinaryEventsRequest), 0, soap_copy_g2ba__UpdateVeterinaryEventsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || a->g2ba__UpdateVeterinaryEventsRequest::__sizestockEntry < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__UpdateVeterinaryEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateVeterinaryEventsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateVeterinaryEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateVeterinaryEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsRequest * SOAP_FMAC4 soap_get_g2ba__UpdateVeterinaryEventsRequest(struct soap *soap, g2ba__UpdateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateVeterinaryEventsRequest * FASTCALL soap_instantiate_g2ba__UpdateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateVeterinaryEventsRequest));
		((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateVeterinaryEventsRequest));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(g2ba__UpdateVeterinaryEventsRequest*)p = *(g2ba__UpdateVeterinaryEventsRequest*)q;
}

void g2ba__UpdateTransportMovementDetailsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateTransportMovementDetailsResponse::__sizevetDocument = 0;
	this->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateTransportMovementDetailsResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument) {
		for(int i = 0; i < this->g2ba__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__UpdateTransportMovementDetailsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateTransportMovementDetailsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, const g2ba__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse), "g2ba:UpdateTransportMovementDetailsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizevetDocument");
	if(a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument) {
		int i;
		for(i = 0; i < a->g2ba__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateTransportMovementDetailsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateTransportMovementDetailsResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsResponse * FASTCALL soap_in_g2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, g2ba__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateTransportMovementDetailsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse, sizeof(g2ba__UpdateTransportMovementDetailsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateTransportMovementDetailsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument == NULL) {
					if(soap_blist_vd__vetDocument1 == NULL)
						soap_blist_vd__vetDocument1 = soap_new_block(soap);
					a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vd__vetDocument1, sizeof(vd__VetDocument *));
					if(a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument == NULL)
						return NULL;
					*a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument, "vd:VetDocument"))
				{	a->g2ba__UpdateTransportMovementDetailsResponse::__sizevetDocument++;
					a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizevetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument)
			soap_pop_block(soap, soap_blist_vd__vetDocument1);
		if(a->g2ba__UpdateTransportMovementDetailsResponse::__sizevetDocument)
			a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vd__vetDocument1, NULL, 1);
		else
		{	a->g2ba__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
			if(soap_blist_vd__vetDocument1)
				soap_end_block(soap, soap_blist_vd__vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateTransportMovementDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse, 0, sizeof(g2ba__UpdateTransportMovementDetailsResponse), 0, soap_copy_g2ba__UpdateTransportMovementDetailsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__UpdateTransportMovementDetailsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateTransportMovementDetailsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateTransportMovementDetailsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateTransportMovementDetailsResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsResponse * SOAP_FMAC4 soap_get_g2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, g2ba__UpdateTransportMovementDetailsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateTransportMovementDetailsResponse * FASTCALL soap_instantiate_g2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateTransportMovementDetailsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsResponse);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateTransportMovementDetailsResponse));
		((g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateTransportMovementDetailsResponse));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateTransportMovementDetailsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateTransportMovementDetailsResponse %p -> %p\n", q, p));
	*(g2ba__UpdateTransportMovementDetailsResponse*)p = *(g2ba__UpdateTransportMovementDetailsResponse*)q;
}

void g2ba__UpdateTransportMovementDetailsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant = NULL;
	this->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid = 0;
	this->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
	this->g2ba__UpdateTransportMovementDetailsRequest::vd__shipmentRoute = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__UpdateTransportMovementDetailsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessMember(soap, &this->g2ba__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant);
	if(this->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid) {
		for(int i = 0; i < this->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++) {
			soap_serialize_base__UUID(soap, this->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid + i);
		}
	}
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->g2ba__UpdateTransportMovementDetailsRequest::vd__shipmentRoute);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__UpdateTransportMovementDetailsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__UpdateTransportMovementDetailsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const g2ba__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest), "g2ba:UpdateTransportMovementDetailsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant) {
		if(soap_out_PointerTodic__BusinessMember(soap, "vd:deliveryParticipant", -1, &a->g2ba__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:deliveryParticipant"))
		return soap->error;
	if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid) {
		int i;
		for(i = 0; i < a->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++)
			if(soap_out_base__UUID(soap, "vd:vetDocumentUuid", -1, a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid + i, ""))
				return soap->error;
	}
	if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__shipmentRoute) {
		if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &a->g2ba__UpdateTransportMovementDetailsRequest::vd__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__UpdateTransportMovementDetailsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__UpdateTransportMovementDetailsRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsRequest * FASTCALL soap_in_g2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, g2ba__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__UpdateTransportMovementDetailsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest, sizeof(g2ba__UpdateTransportMovementDetailsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__UpdateTransportMovementDetailsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vd__deliveryParticipant1 = 1;
	struct soap_blist *soap_blist_vd__vetDocumentUuid1 = NULL;
	size_t soap_flag_vd__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vd__deliveryParticipant1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessMember(soap, "vd:deliveryParticipant", &(a->g2ba__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant), "dic:BusinessMember"))
				{	soap_flag_vd__deliveryParticipant1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocumentUuid", 1, NULL)) {
				if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid == NULL) {
					if(soap_blist_vd__vetDocumentUuid1 == NULL)
						soap_blist_vd__vetDocumentUuid1 = soap_new_block(soap);
					a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = (char **)soap_push_block(soap, soap_blist_vd__vetDocumentUuid1, sizeof(char *));
					if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid == NULL)
						return NULL;
					*a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__UUID(soap, "vd:vetDocumentUuid", a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid, "base:UUID"))
				{	a->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid++;
					a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
					continue;
				}
			}
			if(soap_flag_vd__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->g2ba__UpdateTransportMovementDetailsRequest::vd__shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_vd__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid)
			soap_pop_block(soap, soap_blist_vd__vetDocumentUuid1);
		if(a->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid)
			a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = (char **)soap_save_block(soap, soap_blist_vd__vetDocumentUuid1, NULL, 1);
		else
		{	a->g2ba__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
			if(soap_blist_vd__vetDocumentUuid1)
				soap_end_block(soap, soap_blist_vd__vetDocumentUuid1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__UpdateTransportMovementDetailsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest, 0, sizeof(g2ba__UpdateTransportMovementDetailsRequest), 0, soap_copy_g2ba__UpdateTransportMovementDetailsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vd__deliveryParticipant1 > 0 || a->g2ba__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid < 1 || soap_flag_vd__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__UpdateTransportMovementDetailsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest);
	return this->soap_out(soap, tag?tag:"g2ba:UpdateTransportMovementDetailsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__UpdateTransportMovementDetailsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__UpdateTransportMovementDetailsRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get_g2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, g2ba__UpdateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__UpdateTransportMovementDetailsRequest * FASTCALL soap_instantiate_g2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__UpdateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(g2ba__UpdateTransportMovementDetailsRequest));
		((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__UpdateTransportMovementDetailsRequest));
		for(int i = 0; i < n; i++)
			((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__UpdateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(g2ba__UpdateTransportMovementDetailsRequest*)p = *(g2ba__UpdateTransportMovementDetailsRequest*)q;
}

void g2ba__GetStockEntryVersionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryVersionListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryVersionListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__GetStockEntryVersionListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int g2ba__GetStockEntryVersionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryVersionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryVersionListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse), "g2ba:GetStockEntryVersionListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->g2ba__GetStockEntryVersionListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->g2ba__GetStockEntryVersionListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryVersionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryVersionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListResponse * FASTCALL soap_in_g2ba__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryVersionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryVersionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse, sizeof(g2ba__GetStockEntryVersionListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryVersionListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryVersionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->g2ba__GetStockEntryVersionListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryVersionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse, 0, sizeof(g2ba__GetStockEntryVersionListResponse), 0, soap_copy_g2ba__GetStockEntryVersionListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryVersionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryVersionListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryVersionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryVersionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListResponse * SOAP_FMAC4 soap_get_g2ba__GetStockEntryVersionListResponse(struct soap *soap, g2ba__GetStockEntryVersionListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryVersionListResponse * FASTCALL soap_instantiate_g2ba__GetStockEntryVersionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryVersionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryVersionListResponse));
		((g2ba__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryVersionListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryVersionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryVersionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryVersionListResponse %p -> %p\n", q, p));
	*(g2ba__GetStockEntryVersionListResponse*)p = *(g2ba__GetStockEntryVersionListResponse*)q;
}

void g2ba__GetStockEntryVersionListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryVersionListRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryVersionListRequest::base__guid);
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryVersionListRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryVersionListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetStockEntryVersionListRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryVersionListRequest::base__guid);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryVersionListRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetStockEntryVersionListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryVersionListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryVersionListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest), "g2ba:GetStockEntryVersionListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetStockEntryVersionListRequest::base__listOptions), ""))
		return soap->error;
	if(a->g2ba__GetStockEntryVersionListRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->g2ba__GetStockEntryVersionListRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	if(a->g2ba__GetStockEntryVersionListRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetStockEntryVersionListRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryVersionListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryVersionListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListRequest * FASTCALL soap_in_g2ba__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryVersionListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryVersionListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest, sizeof(g2ba__GetStockEntryVersionListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryVersionListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryVersionListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__guid1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetStockEntryVersionListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->g2ba__GetStockEntryVersionListRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetStockEntryVersionListRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryVersionListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest, 0, sizeof(g2ba__GetStockEntryVersionListRequest), 0, soap_copy_g2ba__GetStockEntryVersionListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__guid1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryVersionListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryVersionListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryVersionListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryVersionListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListRequest * SOAP_FMAC4 soap_get_g2ba__GetStockEntryVersionListRequest(struct soap *soap, g2ba__GetStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryVersionListRequest * FASTCALL soap_instantiate_g2ba__GetStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryVersionListRequest));
		((g2ba__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryVersionListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryVersionListRequest %p -> %p\n", q, p));
	*(g2ba__GetStockEntryVersionListRequest*)p = *(g2ba__GetStockEntryVersionListRequest*)q;
}

void g2ba__GetStockEntryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__GetStockEntryListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int g2ba__GetStockEntryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryListResponse), "g2ba:GetStockEntryListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->g2ba__GetStockEntryListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->g2ba__GetStockEntryListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListResponse * FASTCALL soap_in_g2ba__GetStockEntryListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryListResponse, sizeof(g2ba__GetStockEntryListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->g2ba__GetStockEntryListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryListResponse, 0, sizeof(g2ba__GetStockEntryListResponse), 0, soap_copy_g2ba__GetStockEntryListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListResponse * SOAP_FMAC4 soap_get_g2ba__GetStockEntryListResponse(struct soap *soap, g2ba__GetStockEntryListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryListResponse * FASTCALL soap_instantiate_g2ba__GetStockEntryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryListResponse));
		((g2ba__GetStockEntryListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryListResponse %p -> %p\n", q, p));
	*(g2ba__GetStockEntryListResponse*)p = *(g2ba__GetStockEntryListResponse*)q;
}

void g2ba__GetStockEntryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryListRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryListRequest::dic__enterpriseGuid);
	this->g2ba__GetStockEntryListRequest::searchPattern = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetStockEntryListRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryListRequest::dic__enterpriseGuid);
	soap_serialize_PointerTovd__StockEntrySearchPattern(soap, &this->g2ba__GetStockEntryListRequest::searchPattern);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetStockEntryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryListRequest), "g2ba:GetStockEntryListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetStockEntryListRequest::base__listOptions), ""))
		return soap->error;
	if(a->g2ba__GetStockEntryListRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetStockEntryListRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	if(soap_out_PointerTovd__StockEntrySearchPattern(soap, "g2ba:searchPattern", -1, &(a->g2ba__GetStockEntryListRequest::searchPattern), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListRequest * FASTCALL soap_in_g2ba__GetStockEntryListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryListRequest, sizeof(g2ba__GetStockEntryListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	size_t soap_flag_searchPattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetStockEntryListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetStockEntryListRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap_flag_searchPattern1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntrySearchPattern(soap, "g2ba:searchPattern", &(a->g2ba__GetStockEntryListRequest::searchPattern), "vd:StockEntrySearchPattern"))
				{	soap_flag_searchPattern1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryListRequest, 0, sizeof(g2ba__GetStockEntryListRequest), 0, soap_copy_g2ba__GetStockEntryListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListRequest * SOAP_FMAC4 soap_get_g2ba__GetStockEntryListRequest(struct soap *soap, g2ba__GetStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryListRequest * FASTCALL soap_instantiate_g2ba__GetStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryListRequest));
		((g2ba__GetStockEntryListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryListRequest %p -> %p\n", q, p));
	*(g2ba__GetStockEntryListRequest*)p = *(g2ba__GetStockEntryListRequest*)q;
}

void g2ba__GetStockEntryChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryChangesListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__GetStockEntryChangesListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int g2ba__GetStockEntryChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse), "g2ba:GetStockEntryChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->g2ba__GetStockEntryChangesListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->g2ba__GetStockEntryChangesListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListResponse * FASTCALL soap_in_g2ba__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse, sizeof(g2ba__GetStockEntryChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->g2ba__GetStockEntryChangesListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse, 0, sizeof(g2ba__GetStockEntryChangesListResponse), 0, soap_copy_g2ba__GetStockEntryChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListResponse * SOAP_FMAC4 soap_get_g2ba__GetStockEntryChangesListResponse(struct soap *soap, g2ba__GetStockEntryChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryChangesListResponse * FASTCALL soap_instantiate_g2ba__GetStockEntryChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryChangesListResponse));
		((g2ba__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryChangesListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryChangesListResponse %p -> %p\n", q, p));
	*(g2ba__GetStockEntryChangesListResponse*)p = *(g2ba__GetStockEntryChangesListResponse*)q;
}

void g2ba__GetStockEntryChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryChangesListRequest::base__listOptions = NULL;
	this->g2ba__GetStockEntryChangesListRequest::base__updateDateInterval = NULL;
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryChangesListRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetStockEntryChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->g2ba__GetStockEntryChangesListRequest::base__updateDateInterval);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryChangesListRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetStockEntryChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest), "g2ba:GetStockEntryChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetStockEntryChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->g2ba__GetStockEntryChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->g2ba__GetStockEntryChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	if(a->g2ba__GetStockEntryChangesListRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetStockEntryChangesListRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListRequest * FASTCALL soap_in_g2ba__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest, sizeof(g2ba__GetStockEntryChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetStockEntryChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->g2ba__GetStockEntryChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetStockEntryChangesListRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest, 0, sizeof(g2ba__GetStockEntryChangesListRequest), 0, soap_copy_g2ba__GetStockEntryChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__updateDateInterval1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListRequest * SOAP_FMAC4 soap_get_g2ba__GetStockEntryChangesListRequest(struct soap *soap, g2ba__GetStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryChangesListRequest * FASTCALL soap_instantiate_g2ba__GetStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryChangesListRequest));
		((g2ba__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryChangesListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryChangesListRequest %p -> %p\n", q, p));
	*(g2ba__GetStockEntryChangesListRequest*)p = *(g2ba__GetStockEntryChangesListRequest*)q;
}

void g2ba__GetStockEntryByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryByUuidResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->g2ba__GetStockEntryByUuidResponse::vd__stockEntry);
	/* transient soap skipped */
}

int g2ba__GetStockEntryByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse), "g2ba:GetStockEntryByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntry)
		soap_element_result(soap, "vd:stockEntry");
	if(a->g2ba__GetStockEntryByUuidResponse::vd__stockEntry) {
		if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, &a->g2ba__GetStockEntryByUuidResponse::vd__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidResponse * FASTCALL soap_in_g2ba__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse, sizeof(g2ba__GetStockEntryByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", &(a->g2ba__GetStockEntryByUuidResponse::vd__stockEntry), "vd:StockEntry"))
				{	soap_flag_vd__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse, 0, sizeof(g2ba__GetStockEntryByUuidResponse), 0, soap_copy_g2ba__GetStockEntryByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidResponse * SOAP_FMAC4 soap_get_g2ba__GetStockEntryByUuidResponse(struct soap *soap, g2ba__GetStockEntryByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryByUuidResponse * FASTCALL soap_instantiate_g2ba__GetStockEntryByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByUuidResponse));
		((g2ba__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByUuidResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryByUuidResponse %p -> %p\n", q, p));
	*(g2ba__GetStockEntryByUuidResponse*)p = *(g2ba__GetStockEntryByUuidResponse*)q;
}

void g2ba__GetStockEntryByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryByUuidRequest::base__uuid);
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryByUuidRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryByUuidRequest::base__uuid);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryByUuidRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetStockEntryByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest), "g2ba:GetStockEntryByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__GetStockEntryByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->g2ba__GetStockEntryByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	if(a->g2ba__GetStockEntryByUuidRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetStockEntryByUuidRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidRequest * FASTCALL soap_in_g2ba__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest, sizeof(g2ba__GetStockEntryByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__uuid1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->g2ba__GetStockEntryByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetStockEntryByUuidRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest, 0, sizeof(g2ba__GetStockEntryByUuidRequest), 0, soap_copy_g2ba__GetStockEntryByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__uuid1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidRequest * SOAP_FMAC4 soap_get_g2ba__GetStockEntryByUuidRequest(struct soap *soap, g2ba__GetStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryByUuidRequest * FASTCALL soap_instantiate_g2ba__GetStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByUuidRequest));
		((g2ba__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByUuidRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryByUuidRequest %p -> %p\n", q, p));
	*(g2ba__GetStockEntryByUuidRequest*)p = *(g2ba__GetStockEntryByUuidRequest*)q;
}

void g2ba__GetStockEntryByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetStockEntryByGuidResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->g2ba__GetStockEntryByGuidResponse::vd__stockEntry);
	/* transient soap skipped */
}

int g2ba__GetStockEntryByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse), "g2ba:GetStockEntryByGuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntry)
		soap_element_result(soap, "vd:stockEntry");
	if(a->g2ba__GetStockEntryByGuidResponse::vd__stockEntry) {
		if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, &a->g2ba__GetStockEntryByGuidResponse::vd__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidResponse * FASTCALL soap_in_g2ba__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse, sizeof(g2ba__GetStockEntryByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", &(a->g2ba__GetStockEntryByGuidResponse::vd__stockEntry), "vd:StockEntry"))
				{	soap_flag_vd__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse, 0, sizeof(g2ba__GetStockEntryByGuidResponse), 0, soap_copy_g2ba__GetStockEntryByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidResponse * SOAP_FMAC4 soap_get_g2ba__GetStockEntryByGuidResponse(struct soap *soap, g2ba__GetStockEntryByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryByGuidResponse * FASTCALL soap_instantiate_g2ba__GetStockEntryByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByGuidResponse));
		((g2ba__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByGuidResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryByGuidResponse %p -> %p\n", q, p));
	*(g2ba__GetStockEntryByGuidResponse*)p = *(g2ba__GetStockEntryByGuidResponse*)q;
}

void g2ba__GetStockEntryByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryByGuidRequest::base__guid);
	soap_default_base__UUID(soap, &this->g2ba__GetStockEntryByGuidRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetStockEntryByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryByGuidRequest::base__guid);
	soap_serialize_base__UUID(soap, &this->g2ba__GetStockEntryByGuidRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetStockEntryByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetStockEntryByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const g2ba__GetStockEntryByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest), "g2ba:GetStockEntryByGuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__GetStockEntryByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->g2ba__GetStockEntryByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	if(a->g2ba__GetStockEntryByGuidRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetStockEntryByGuidRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetStockEntryByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetStockEntryByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidRequest * FASTCALL soap_in_g2ba__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetStockEntryByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest, sizeof(g2ba__GetStockEntryByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetStockEntryByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetStockEntryByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__guid1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->g2ba__GetStockEntryByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetStockEntryByGuidRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetStockEntryByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest, 0, sizeof(g2ba__GetStockEntryByGuidRequest), 0, soap_copy_g2ba__GetStockEntryByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__guid1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetStockEntryByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetStockEntryByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetStockEntryByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetStockEntryByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidRequest * SOAP_FMAC4 soap_get_g2ba__GetStockEntryByGuidRequest(struct soap *soap, g2ba__GetStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetStockEntryByGuidRequest * FASTCALL soap_instantiate_g2ba__GetStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByGuidRequest));
		((g2ba__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByGuidRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetStockEntryByGuidRequest %p -> %p\n", q, p));
	*(g2ba__GetStockEntryByGuidRequest*)p = *(g2ba__GetStockEntryByGuidRequest*)q;
}

void g2ba__GetVetDocumentChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetVetDocumentChangesListResponse::vd__vetDocumentList = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentList(soap, &this->g2ba__GetVetDocumentChangesListResponse::vd__vetDocumentList);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse), "g2ba:GetVetDocumentChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocumentList)
		soap_element_result(soap, "vd:vetDocumentList");
	if(a->g2ba__GetVetDocumentChangesListResponse::vd__vetDocumentList) {
		if(soap_out_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", -1, &a->g2ba__GetVetDocumentChangesListResponse::vd__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListResponse * FASTCALL soap_in_g2ba__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse, sizeof(g2ba__GetVetDocumentChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", &(a->g2ba__GetVetDocumentChangesListResponse::vd__vetDocumentList), "vd:VetDocumentList"))
				{	soap_flag_vd__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse, 0, sizeof(g2ba__GetVetDocumentChangesListResponse), 0, soap_copy_g2ba__GetVetDocumentChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListResponse * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentChangesListResponse(struct soap *soap, g2ba__GetVetDocumentChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentChangesListResponse * FASTCALL soap_instantiate_g2ba__GetVetDocumentChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentChangesListResponse));
		((g2ba__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentChangesListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentChangesListResponse %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentChangesListResponse*)p = *(g2ba__GetVetDocumentChangesListResponse*)q;
}

void g2ba__GetVetDocumentChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetVetDocumentChangesListRequest::base__listOptions = NULL;
	this->g2ba__GetVetDocumentChangesListRequest::base__updateDateInterval = NULL;
	soap_default_base__UUID(soap, &this->g2ba__GetVetDocumentChangesListRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetVetDocumentChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->g2ba__GetVetDocumentChangesListRequest::base__updateDateInterval);
	soap_serialize_base__UUID(soap, &this->g2ba__GetVetDocumentChangesListRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest), "g2ba:GetVetDocumentChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetVetDocumentChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->g2ba__GetVetDocumentChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->g2ba__GetVetDocumentChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	if(a->g2ba__GetVetDocumentChangesListRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetVetDocumentChangesListRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListRequest * FASTCALL soap_in_g2ba__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest, sizeof(g2ba__GetVetDocumentChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetVetDocumentChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->g2ba__GetVetDocumentChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetVetDocumentChangesListRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest, 0, sizeof(g2ba__GetVetDocumentChangesListRequest), 0, soap_copy_g2ba__GetVetDocumentChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__updateDateInterval1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListRequest * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentChangesListRequest(struct soap *soap, g2ba__GetVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentChangesListRequest * FASTCALL soap_instantiate_g2ba__GetVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentChangesListRequest));
		((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentChangesListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentChangesListRequest*)p = *(g2ba__GetVetDocumentChangesListRequest*)q;
}

void g2ba__GetVetDocumentListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetVetDocumentListResponse::vd__vetDocumentList = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentList(soap, &this->g2ba__GetVetDocumentListResponse::vd__vetDocumentList);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentListResponse), "g2ba:GetVetDocumentListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocumentList)
		soap_element_result(soap, "vd:vetDocumentList");
	if(a->g2ba__GetVetDocumentListResponse::vd__vetDocumentList) {
		if(soap_out_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", -1, &a->g2ba__GetVetDocumentListResponse::vd__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListResponse * FASTCALL soap_in_g2ba__GetVetDocumentListResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentListResponse, sizeof(g2ba__GetVetDocumentListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", &(a->g2ba__GetVetDocumentListResponse::vd__vetDocumentList), "vd:VetDocumentList"))
				{	soap_flag_vd__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentListResponse, 0, sizeof(g2ba__GetVetDocumentListResponse), 0, soap_copy_g2ba__GetVetDocumentListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListResponse * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentListResponse(struct soap *soap, g2ba__GetVetDocumentListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentListResponse * FASTCALL soap_instantiate_g2ba__GetVetDocumentListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentListResponse));
		((g2ba__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentListResponse %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentListResponse*)p = *(g2ba__GetVetDocumentListResponse*)q;
}

void g2ba__GetVetDocumentListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetVetDocumentListRequest::base__listOptions = NULL;
	this->g2ba__GetVetDocumentListRequest::vd__vetDocumentType = NULL;
	this->g2ba__GetVetDocumentListRequest::vd__vetDocumentStatus = NULL;
	soap_default_base__UUID(soap, &this->g2ba__GetVetDocumentListRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->g2ba__GetVetDocumentListRequest::base__listOptions);
	soap_serialize_PointerTovd__VetDocumentType(soap, &this->g2ba__GetVetDocumentListRequest::vd__vetDocumentType);
	soap_serialize_PointerTovd__VetDocumentStatus(soap, &this->g2ba__GetVetDocumentListRequest::vd__vetDocumentStatus);
	soap_serialize_base__UUID(soap, &this->g2ba__GetVetDocumentListRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentListRequest), "g2ba:GetVetDocumentListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->g2ba__GetVetDocumentListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentType(soap, "vd:vetDocumentType", -1, &(a->g2ba__GetVetDocumentListRequest::vd__vetDocumentType), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentStatus(soap, "vd:vetDocumentStatus", -1, &(a->g2ba__GetVetDocumentListRequest::vd__vetDocumentStatus), ""))
		return soap->error;
	if(a->g2ba__GetVetDocumentListRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetVetDocumentListRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListRequest * FASTCALL soap_in_g2ba__GetVetDocumentListRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentListRequest, sizeof(g2ba__GetVetDocumentListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_vd__vetDocumentType1 = 1;
	size_t soap_flag_vd__vetDocumentStatus1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->g2ba__GetVetDocumentListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_vd__vetDocumentType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentType(soap, "vd:vetDocumentType", &(a->g2ba__GetVetDocumentListRequest::vd__vetDocumentType), "vd:VetDocumentType"))
				{	soap_flag_vd__vetDocumentType1--;
					continue;
				}
			if(soap_flag_vd__vetDocumentStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentStatus(soap, "vd:vetDocumentStatus", &(a->g2ba__GetVetDocumentListRequest::vd__vetDocumentStatus), "vd:VetDocumentStatus"))
				{	soap_flag_vd__vetDocumentStatus1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetVetDocumentListRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentListRequest, 0, sizeof(g2ba__GetVetDocumentListRequest), 0, soap_copy_g2ba__GetVetDocumentListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListRequest * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentListRequest(struct soap *soap, g2ba__GetVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentListRequest * FASTCALL soap_instantiate_g2ba__GetVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentListRequest));
		((g2ba__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentListRequest %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentListRequest*)p = *(g2ba__GetVetDocumentListRequest*)q;
}

void g2ba__GetVetDocumentByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__GetVetDocumentByUuidResponse::vd__vetDocument = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocument(soap, &this->g2ba__GetVetDocumentByUuidResponse::vd__vetDocument);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse), "g2ba:GetVetDocumentByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocument)
		soap_element_result(soap, "vd:vetDocument");
	if(a->g2ba__GetVetDocumentByUuidResponse::vd__vetDocument) {
		if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, &a->g2ba__GetVetDocumentByUuidResponse::vd__vetDocument, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocument"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidResponse * FASTCALL soap_in_g2ba__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse, sizeof(g2ba__GetVetDocumentByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocument1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", &(a->g2ba__GetVetDocumentByUuidResponse::vd__vetDocument), "vd:VetDocument"))
				{	soap_flag_vd__vetDocument1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse, 0, sizeof(g2ba__GetVetDocumentByUuidResponse), 0, soap_copy_g2ba__GetVetDocumentByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocument1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidResponse * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentByUuidResponse(struct soap *soap, g2ba__GetVetDocumentByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentByUuidResponse * FASTCALL soap_instantiate_g2ba__GetVetDocumentByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidResponse);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentByUuidResponse));
		((g2ba__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentByUuidResponse));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentByUuidResponse %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentByUuidResponse*)p = *(g2ba__GetVetDocumentByUuidResponse*)q;
}

void g2ba__GetVetDocumentByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->g2ba__GetVetDocumentByUuidRequest::base__uuid);
	soap_default_base__UUID(soap, &this->g2ba__GetVetDocumentByUuidRequest::dic__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__GetVetDocumentByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->g2ba__GetVetDocumentByUuidRequest::base__uuid);
	soap_serialize_base__UUID(soap, &this->g2ba__GetVetDocumentByUuidRequest::dic__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__GetVetDocumentByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__GetVetDocumentByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const g2ba__GetVetDocumentByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest), "g2ba:GetVetDocumentByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__GetVetDocumentByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->g2ba__GetVetDocumentByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	if(a->g2ba__GetVetDocumentByUuidRequest::dic__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "dic:enterpriseGuid", -1, &a->g2ba__GetVetDocumentByUuidRequest::dic__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "dic:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__GetVetDocumentByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__GetVetDocumentByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidRequest * FASTCALL soap_in_g2ba__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__GetVetDocumentByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest, sizeof(g2ba__GetVetDocumentByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__GetVetDocumentByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__uuid1 = 1;
	size_t soap_flag_dic__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->g2ba__GetVetDocumentByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			if(soap_flag_dic__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "dic:enterpriseGuid", &(a->g2ba__GetVetDocumentByUuidRequest::dic__enterpriseGuid), "base:UUID"))
				{	soap_flag_dic__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__GetVetDocumentByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest, 0, sizeof(g2ba__GetVetDocumentByUuidRequest), 0, soap_copy_g2ba__GetVetDocumentByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__uuid1 > 0 || soap_flag_dic__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__GetVetDocumentByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest);
	return this->soap_out(soap, tag?tag:"g2ba:GetVetDocumentByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__GetVetDocumentByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__GetVetDocumentByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidRequest * SOAP_FMAC4 soap_get_g2ba__GetVetDocumentByUuidRequest(struct soap *soap, g2ba__GetVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__GetVetDocumentByUuidRequest * FASTCALL soap_instantiate_g2ba__GetVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__GetVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentByUuidRequest));
		((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentByUuidRequest));
		for(int i = 0; i < n; i++)
			((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__GetVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__GetVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__GetVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(g2ba__GetVetDocumentByUuidRequest*)p = *(g2ba__GetVetDocumentByUuidRequest*)q;
}

void g2ba__ModifyProducerStockListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyProducerStockListResponse::productItemList = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyProducerStockListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__ProductItemList(soap, &this->g2ba__ModifyProducerStockListResponse::productItemList);
	/* transient soap skipped */
}

int g2ba__ModifyProducerStockListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyProducerStockListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, const g2ba__ModifyProducerStockListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyProducerStockListResponse), "g2ba:ModifyProducerStockListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->productItemList)
		soap_element_result(soap, "g2ba:productItemList");
	if(a->g2ba__ModifyProducerStockListResponse::productItemList) {
		if(soap_out_PointerTodic__ProductItemList(soap, "g2ba:productItemList", -1, &a->g2ba__ModifyProducerStockListResponse::productItemList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:productItemList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyProducerStockListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyProducerStockListResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListResponse * FASTCALL soap_in_g2ba__ModifyProducerStockListResponse(struct soap *soap, const char *tag, g2ba__ModifyProducerStockListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyProducerStockListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyProducerStockListResponse, sizeof(g2ba__ModifyProducerStockListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyProducerStockListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyProducerStockListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__ProductItemList(soap, "g2ba:productItemList", &(a->g2ba__ModifyProducerStockListResponse::productItemList), "dic:ProductItemList"))
				{	soap_flag_productItemList1--;
					continue;
				}
			soap_check_result(soap, "g2ba:productItemList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyProducerStockListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyProducerStockListResponse, 0, sizeof(g2ba__ModifyProducerStockListResponse), 0, soap_copy_g2ba__ModifyProducerStockListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_productItemList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ModifyProducerStockListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyProducerStockListResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyProducerStockListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyProducerStockListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyProducerStockListResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListResponse * SOAP_FMAC4 soap_get_g2ba__ModifyProducerStockListResponse(struct soap *soap, g2ba__ModifyProducerStockListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyProducerStockListResponse * FASTCALL soap_instantiate_g2ba__ModifyProducerStockListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyProducerStockListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyProducerStockListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyProducerStockListResponse));
		((g2ba__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyProducerStockListResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyProducerStockListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyProducerStockListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyProducerStockListResponse %p -> %p\n", q, p));
	*(g2ba__ModifyProducerStockListResponse*)p = *(g2ba__ModifyProducerStockListResponse*)q;
}

void g2ba__ModifyProducerStockListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyProducerStockListRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyProducerStockListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__PSLModificationOperation(soap, &this->g2ba__ModifyProducerStockListRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ModifyProducerStockListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyProducerStockListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const g2ba__ModifyProducerStockListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyProducerStockListRequest), "g2ba:ModifyProducerStockListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ModifyProducerStockListRequest::modificationOperation) {
		if(soap_out_PointerTovd__PSLModificationOperation(soap, "g2ba:modificationOperation", -1, &a->g2ba__ModifyProducerStockListRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyProducerStockListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyProducerStockListRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListRequest * FASTCALL soap_in_g2ba__ModifyProducerStockListRequest(struct soap *soap, const char *tag, g2ba__ModifyProducerStockListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyProducerStockListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyProducerStockListRequest, sizeof(g2ba__ModifyProducerStockListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyProducerStockListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyProducerStockListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__PSLModificationOperation(soap, "g2ba:modificationOperation", &(a->g2ba__ModifyProducerStockListRequest::modificationOperation), "vd:PSLModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyProducerStockListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyProducerStockListRequest, 0, sizeof(g2ba__ModifyProducerStockListRequest), 0, soap_copy_g2ba__ModifyProducerStockListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ModifyProducerStockListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyProducerStockListRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyProducerStockListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyProducerStockListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyProducerStockListRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListRequest * SOAP_FMAC4 soap_get_g2ba__ModifyProducerStockListRequest(struct soap *soap, g2ba__ModifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyProducerStockListRequest * FASTCALL soap_instantiate_g2ba__ModifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyProducerStockListRequest));
		((g2ba__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyProducerStockListRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyProducerStockListRequest %p -> %p\n", q, p));
	*(g2ba__ModifyProducerStockListRequest*)p = *(g2ba__ModifyProducerStockListRequest*)q;
}

void g2ba__ResolveDiscrepancyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ResolveDiscrepancyResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void g2ba__ResolveDiscrepancyResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__ResolveDiscrepancyResponse::stockEntryList);
	/* transient soap skipped */
}

int g2ba__ResolveDiscrepancyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ResolveDiscrepancyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, const g2ba__ResolveDiscrepancyResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse), "g2ba:ResolveDiscrepancyResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "g2ba:stockEntryList");
	if(a->g2ba__ResolveDiscrepancyResponse::stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", -1, &a->g2ba__ResolveDiscrepancyResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ResolveDiscrepancyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ResolveDiscrepancyResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyResponse * FASTCALL soap_in_g2ba__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, g2ba__ResolveDiscrepancyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ResolveDiscrepancyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse, sizeof(g2ba__ResolveDiscrepancyResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ResolveDiscrepancyResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ResolveDiscrepancyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", &(a->g2ba__ResolveDiscrepancyResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "g2ba:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ResolveDiscrepancyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse, 0, sizeof(g2ba__ResolveDiscrepancyResponse), 0, soap_copy_g2ba__ResolveDiscrepancyResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ResolveDiscrepancyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ResolveDiscrepancyResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ResolveDiscrepancyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ResolveDiscrepancyResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyResponse * SOAP_FMAC4 soap_get_g2ba__ResolveDiscrepancyResponse(struct soap *soap, g2ba__ResolveDiscrepancyResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ResolveDiscrepancyResponse * FASTCALL soap_instantiate_g2ba__ResolveDiscrepancyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ResolveDiscrepancyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ResolveDiscrepancyResponse));
		((g2ba__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ResolveDiscrepancyResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ResolveDiscrepancyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ResolveDiscrepancyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ResolveDiscrepancyResponse %p -> %p\n", q, p));
	*(g2ba__ResolveDiscrepancyResponse*)p = *(g2ba__ResolveDiscrepancyResponse*)q;
}

void g2ba__ResolveDiscrepancyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ResolveDiscrepancyRequest::enterprise = NULL;
	soap_default_time(soap, &this->g2ba__ResolveDiscrepancyRequest::inventoryDate);
	this->g2ba__ResolveDiscrepancyRequest::responsible = NULL;
	this->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy = 0;
	this->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
	this->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport = 0;
	this->g2ba__ResolveDiscrepancyRequest::discrepancyReport = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ResolveDiscrepancyRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->g2ba__ResolveDiscrepancyRequest::enterprise);
	soap_embedded(soap, &this->g2ba__ResolveDiscrepancyRequest::inventoryDate, SOAP_TYPE_time);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__ResolveDiscrepancyRequest::responsible);
	if(this->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy) {
		for(int i = 0; i < this->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++) {
			soap_serialize_PointerTovd__StockDiscrepancy(soap, this->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy + i);
		}
	}
	if(this->g2ba__ResolveDiscrepancyRequest::discrepancyReport) {
		for(int i = 0; i < this->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTovd__DiscrepancyReport(soap, this->g2ba__ResolveDiscrepancyRequest::discrepancyReport + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ResolveDiscrepancyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ResolveDiscrepancyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const g2ba__ResolveDiscrepancyRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest), "g2ba:ResolveDiscrepancyRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ResolveDiscrepancyRequest::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "g2ba:enterprise", -1, &a->g2ba__ResolveDiscrepancyRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:enterprise"))
		return soap->error;
	if(soap_out_time(soap, "g2ba:inventoryDate", -1, &(a->g2ba__ResolveDiscrepancyRequest::inventoryDate), ""))
		return soap->error;
	if(a->g2ba__ResolveDiscrepancyRequest::responsible) {
		if(soap_out_PointerTovd__User(soap, "g2ba:responsible", -1, &a->g2ba__ResolveDiscrepancyRequest::responsible, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:responsible"))
		return soap->error;
	if(a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy) {
		int i;
		for(i = 0; i < a->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++)
			if(soap_out_PointerTovd__StockDiscrepancy(soap, "g2ba:stockDiscrepancy", -1, a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy + i, ""))
				return soap->error;
	}
	if(a->g2ba__ResolveDiscrepancyRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTovd__DiscrepancyReport(soap, "g2ba:discrepancyReport", -1, a->g2ba__ResolveDiscrepancyRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__ResolveDiscrepancyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ResolveDiscrepancyRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyRequest * FASTCALL soap_in_g2ba__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, g2ba__ResolveDiscrepancyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ResolveDiscrepancyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest, sizeof(g2ba__ResolveDiscrepancyRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ResolveDiscrepancyRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ResolveDiscrepancyRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_inventoryDate1 = 1;
	size_t soap_flag_responsible1 = 1;
	struct soap_blist *soap_blist_stockDiscrepancy1 = NULL;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "g2ba:enterprise", &(a->g2ba__ResolveDiscrepancyRequest::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_inventoryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "g2ba:inventoryDate", &(a->g2ba__ResolveDiscrepancyRequest::inventoryDate), "xsd:dateTime"))
				{	soap_flag_inventoryDate1--;
					continue;
				}
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:responsible", &(a->g2ba__ResolveDiscrepancyRequest::responsible), "vd:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:stockDiscrepancy", 1, NULL)) {
				if(a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy == NULL) {
					if(soap_blist_stockDiscrepancy1 == NULL)
						soap_blist_stockDiscrepancy1 = soap_new_block(soap);
					a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = (vd__StockDiscrepancy **)soap_push_block(soap, soap_blist_stockDiscrepancy1, sizeof(vd__StockDiscrepancy *));
					if(a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy == NULL)
						return NULL;
					*a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockDiscrepancy(soap, "g2ba:stockDiscrepancy", a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy, "vd:StockDiscrepancy"))
				{	a->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy++;
					a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:discrepancyReport", 1, NULL)) {
				if(a->g2ba__ResolveDiscrepancyRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->g2ba__ResolveDiscrepancyRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(vd__DiscrepancyReport *));
					if(a->g2ba__ResolveDiscrepancyRequest::discrepancyReport == NULL)
						return NULL;
					*a->g2ba__ResolveDiscrepancyRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__DiscrepancyReport(soap, "g2ba:discrepancyReport", a->g2ba__ResolveDiscrepancyRequest::discrepancyReport, "vd:DiscrepancyReport"))
				{	a->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport++;
					a->g2ba__ResolveDiscrepancyRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy)
			soap_pop_block(soap, soap_blist_stockDiscrepancy1);
		if(a->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy)
			a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = (vd__StockDiscrepancy **)soap_save_block(soap, soap_blist_stockDiscrepancy1, NULL, 1);
		else
		{	a->g2ba__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
			if(soap_blist_stockDiscrepancy1)
				soap_end_block(soap, soap_blist_stockDiscrepancy1);
		}
		if(a->g2ba__ResolveDiscrepancyRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport)
			a->g2ba__ResolveDiscrepancyRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->g2ba__ResolveDiscrepancyRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ResolveDiscrepancyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest, 0, sizeof(g2ba__ResolveDiscrepancyRequest), 0, soap_copy_g2ba__ResolveDiscrepancyRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_inventoryDate1 > 0 || soap_flag_responsible1 > 0 || a->g2ba__ResolveDiscrepancyRequest::__sizestockDiscrepancy < 1 || a->g2ba__ResolveDiscrepancyRequest::__sizediscrepancyReport < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ResolveDiscrepancyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ResolveDiscrepancyRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ResolveDiscrepancyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ResolveDiscrepancyRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyRequest * SOAP_FMAC4 soap_get_g2ba__ResolveDiscrepancyRequest(struct soap *soap, g2ba__ResolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ResolveDiscrepancyRequest * FASTCALL soap_instantiate_g2ba__ResolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ResolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ResolveDiscrepancyRequest));
		((g2ba__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ResolveDiscrepancyRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ResolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ResolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ResolveDiscrepancyRequest %p -> %p\n", q, p));
	*(g2ba__ResolveDiscrepancyRequest*)p = *(g2ba__ResolveDiscrepancyRequest*)q;
}

void g2ba__ModifyActivityLocationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyActivityLocationsResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyActivityLocationsResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__BusinessEntity(soap, &this->g2ba__ModifyActivityLocationsResponse::businessEntity);
	/* transient soap skipped */
}

int g2ba__ModifyActivityLocationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyActivityLocationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, const g2ba__ModifyActivityLocationsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse), "g2ba:ModifyActivityLocationsResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->businessEntity)
		soap_element_result(soap, "g2ba:businessEntity");
	if(soap_out_PointerTodic__BusinessEntity(soap, "g2ba:businessEntity", -1, &(a->g2ba__ModifyActivityLocationsResponse::businessEntity), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyActivityLocationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyActivityLocationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsResponse * FASTCALL soap_in_g2ba__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, g2ba__ModifyActivityLocationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyActivityLocationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse, sizeof(g2ba__ModifyActivityLocationsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyActivityLocationsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyActivityLocationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__BusinessEntity(soap, "g2ba:businessEntity", &(a->g2ba__ModifyActivityLocationsResponse::businessEntity), "dic:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			soap_check_result(soap, "g2ba:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyActivityLocationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse, 0, sizeof(g2ba__ModifyActivityLocationsResponse), 0, soap_copy_g2ba__ModifyActivityLocationsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__ModifyActivityLocationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyActivityLocationsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyActivityLocationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyActivityLocationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsResponse * SOAP_FMAC4 soap_get_g2ba__ModifyActivityLocationsResponse(struct soap *soap, g2ba__ModifyActivityLocationsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyActivityLocationsResponse * FASTCALL soap_instantiate_g2ba__ModifyActivityLocationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyActivityLocationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyActivityLocationsResponse));
		((g2ba__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyActivityLocationsResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyActivityLocationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyActivityLocationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyActivityLocationsResponse %p -> %p\n", q, p));
	*(g2ba__ModifyActivityLocationsResponse*)p = *(g2ba__ModifyActivityLocationsResponse*)q;
}

void g2ba__ModifyActivityLocationsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyActivityLocationsRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyActivityLocationsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(soap, &this->g2ba__ModifyActivityLocationsRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ModifyActivityLocationsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyActivityLocationsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const g2ba__ModifyActivityLocationsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest), "g2ba:ModifyActivityLocationsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ModifyActivityLocationsRequest::modificationOperation) {
		if(soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, "g2ba:modificationOperation", -1, &a->g2ba__ModifyActivityLocationsRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyActivityLocationsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyActivityLocationsRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsRequest * FASTCALL soap_in_g2ba__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, g2ba__ModifyActivityLocationsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyActivityLocationsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest, sizeof(g2ba__ModifyActivityLocationsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyActivityLocationsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyActivityLocationsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, "g2ba:modificationOperation", &(a->g2ba__ModifyActivityLocationsRequest::modificationOperation), "vd:BEActivityLocationsModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyActivityLocationsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest, 0, sizeof(g2ba__ModifyActivityLocationsRequest), 0, soap_copy_g2ba__ModifyActivityLocationsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ModifyActivityLocationsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyActivityLocationsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyActivityLocationsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyActivityLocationsRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsRequest * SOAP_FMAC4 soap_get_g2ba__ModifyActivityLocationsRequest(struct soap *soap, g2ba__ModifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyActivityLocationsRequest * FASTCALL soap_instantiate_g2ba__ModifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyActivityLocationsRequest));
		((g2ba__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyActivityLocationsRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyActivityLocationsRequest %p -> %p\n", q, p));
	*(g2ba__ModifyActivityLocationsRequest*)p = *(g2ba__ModifyActivityLocationsRequest*)q;
}

void g2ba__ModifyEnterpriseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyEnterpriseResponse::__sizeenterprise = 0;
	this->g2ba__ModifyEnterpriseResponse::enterprise = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyEnterpriseResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__ModifyEnterpriseResponse::enterprise) {
		for(int i = 0; i < this->g2ba__ModifyEnterpriseResponse::__sizeenterprise; i++) {
			soap_serialize_PointerTodic__Enterprise(soap, this->g2ba__ModifyEnterpriseResponse::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__ModifyEnterpriseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyEnterpriseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, const g2ba__ModifyEnterpriseResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyEnterpriseResponse), "g2ba:ModifyEnterpriseResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeenterprise");
	if(a->g2ba__ModifyEnterpriseResponse::enterprise) {
		int i;
		for(i = 0; i < a->g2ba__ModifyEnterpriseResponse::__sizeenterprise; i++)
			if(soap_out_PointerTodic__Enterprise(soap, "g2ba:enterprise", -1, a->g2ba__ModifyEnterpriseResponse::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyEnterpriseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyEnterpriseResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseResponse * FASTCALL soap_in_g2ba__ModifyEnterpriseResponse(struct soap *soap, const char *tag, g2ba__ModifyEnterpriseResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyEnterpriseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyEnterpriseResponse, sizeof(g2ba__ModifyEnterpriseResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyEnterpriseResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyEnterpriseResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:enterprise", 1, NULL)) {
				if(a->g2ba__ModifyEnterpriseResponse::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->g2ba__ModifyEnterpriseResponse::enterprise = (dic__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(dic__Enterprise *));
					if(a->g2ba__ModifyEnterpriseResponse::enterprise == NULL)
						return NULL;
					*a->g2ba__ModifyEnterpriseResponse::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__Enterprise(soap, "g2ba:enterprise", a->g2ba__ModifyEnterpriseResponse::enterprise, "dic:Enterprise"))
				{	a->g2ba__ModifyEnterpriseResponse::__sizeenterprise++;
					a->g2ba__ModifyEnterpriseResponse::enterprise = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeenterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__ModifyEnterpriseResponse::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->g2ba__ModifyEnterpriseResponse::__sizeenterprise)
			a->g2ba__ModifyEnterpriseResponse::enterprise = (dic__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->g2ba__ModifyEnterpriseResponse::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyEnterpriseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyEnterpriseResponse, 0, sizeof(g2ba__ModifyEnterpriseResponse), 0, soap_copy_g2ba__ModifyEnterpriseResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__ModifyEnterpriseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyEnterpriseResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyEnterpriseResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyEnterpriseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyEnterpriseResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseResponse * SOAP_FMAC4 soap_get_g2ba__ModifyEnterpriseResponse(struct soap *soap, g2ba__ModifyEnterpriseResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyEnterpriseResponse * FASTCALL soap_instantiate_g2ba__ModifyEnterpriseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyEnterpriseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyEnterpriseResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyEnterpriseResponse));
		((g2ba__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyEnterpriseResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyEnterpriseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyEnterpriseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyEnterpriseResponse %p -> %p\n", q, p));
	*(g2ba__ModifyEnterpriseResponse*)p = *(g2ba__ModifyEnterpriseResponse*)q;
}

void g2ba__ModifyEnterpriseRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyEnterpriseRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyEnterpriseRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__ENTModificationOperation(soap, &this->g2ba__ModifyEnterpriseRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ModifyEnterpriseRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyEnterpriseRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const g2ba__ModifyEnterpriseRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyEnterpriseRequest), "g2ba:ModifyEnterpriseRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ModifyEnterpriseRequest::modificationOperation) {
		if(soap_out_PointerTovd__ENTModificationOperation(soap, "g2ba:modificationOperation", -1, &a->g2ba__ModifyEnterpriseRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyEnterpriseRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyEnterpriseRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseRequest * FASTCALL soap_in_g2ba__ModifyEnterpriseRequest(struct soap *soap, const char *tag, g2ba__ModifyEnterpriseRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyEnterpriseRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyEnterpriseRequest, sizeof(g2ba__ModifyEnterpriseRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyEnterpriseRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyEnterpriseRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ENTModificationOperation(soap, "g2ba:modificationOperation", &(a->g2ba__ModifyEnterpriseRequest::modificationOperation), "vd:ENTModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyEnterpriseRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyEnterpriseRequest, 0, sizeof(g2ba__ModifyEnterpriseRequest), 0, soap_copy_g2ba__ModifyEnterpriseRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ModifyEnterpriseRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyEnterpriseRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyEnterpriseRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyEnterpriseRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyEnterpriseRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseRequest * SOAP_FMAC4 soap_get_g2ba__ModifyEnterpriseRequest(struct soap *soap, g2ba__ModifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyEnterpriseRequest * FASTCALL soap_instantiate_g2ba__ModifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyEnterpriseRequest));
		((g2ba__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyEnterpriseRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyEnterpriseRequest %p -> %p\n", q, p));
	*(g2ba__ModifyEnterpriseRequest*)p = *(g2ba__ModifyEnterpriseRequest*)q;
}

void g2ba__ModifyBusinessEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyBusinessEntityResponse::__sizebusinessEntity = 0;
	this->g2ba__ModifyBusinessEntityResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyBusinessEntityResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__ModifyBusinessEntityResponse::businessEntity) {
		for(int i = 0; i < this->g2ba__ModifyBusinessEntityResponse::__sizebusinessEntity; i++) {
			soap_serialize_PointerTodic__BusinessEntity(soap, this->g2ba__ModifyBusinessEntityResponse::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__ModifyBusinessEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyBusinessEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, const g2ba__ModifyBusinessEntityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse), "g2ba:ModifyBusinessEntityResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizebusinessEntity");
	if(a->g2ba__ModifyBusinessEntityResponse::businessEntity) {
		int i;
		for(i = 0; i < a->g2ba__ModifyBusinessEntityResponse::__sizebusinessEntity; i++)
			if(soap_out_PointerTodic__BusinessEntity(soap, "g2ba:businessEntity", -1, a->g2ba__ModifyBusinessEntityResponse::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyBusinessEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyBusinessEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityResponse * FASTCALL soap_in_g2ba__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, g2ba__ModifyBusinessEntityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyBusinessEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse, sizeof(g2ba__ModifyBusinessEntityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyBusinessEntityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyBusinessEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:businessEntity", 1, NULL)) {
				if(a->g2ba__ModifyBusinessEntityResponse::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->g2ba__ModifyBusinessEntityResponse::businessEntity = (dic__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(dic__BusinessEntity *));
					if(a->g2ba__ModifyBusinessEntityResponse::businessEntity == NULL)
						return NULL;
					*a->g2ba__ModifyBusinessEntityResponse::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTodic__BusinessEntity(soap, "g2ba:businessEntity", a->g2ba__ModifyBusinessEntityResponse::businessEntity, "dic:BusinessEntity"))
				{	a->g2ba__ModifyBusinessEntityResponse::__sizebusinessEntity++;
					a->g2ba__ModifyBusinessEntityResponse::businessEntity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizebusinessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__ModifyBusinessEntityResponse::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->g2ba__ModifyBusinessEntityResponse::__sizebusinessEntity)
			a->g2ba__ModifyBusinessEntityResponse::businessEntity = (dic__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->g2ba__ModifyBusinessEntityResponse::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyBusinessEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse, 0, sizeof(g2ba__ModifyBusinessEntityResponse), 0, soap_copy_g2ba__ModifyBusinessEntityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__ModifyBusinessEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyBusinessEntityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyBusinessEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyBusinessEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityResponse * SOAP_FMAC4 soap_get_g2ba__ModifyBusinessEntityResponse(struct soap *soap, g2ba__ModifyBusinessEntityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyBusinessEntityResponse * FASTCALL soap_instantiate_g2ba__ModifyBusinessEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyBusinessEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyBusinessEntityResponse));
		((g2ba__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyBusinessEntityResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyBusinessEntityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyBusinessEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyBusinessEntityResponse %p -> %p\n", q, p));
	*(g2ba__ModifyBusinessEntityResponse*)p = *(g2ba__ModifyBusinessEntityResponse*)q;
}

void g2ba__ModifyBusinessEntityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ModifyBusinessEntityRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ModifyBusinessEntityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__BEModificationOperation(soap, &this->g2ba__ModifyBusinessEntityRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ModifyBusinessEntityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ModifyBusinessEntityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const g2ba__ModifyBusinessEntityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest), "g2ba:ModifyBusinessEntityRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ModifyBusinessEntityRequest::modificationOperation) {
		if(soap_out_PointerTovd__BEModificationOperation(soap, "g2ba:modificationOperation", -1, &a->g2ba__ModifyBusinessEntityRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ModifyBusinessEntityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ModifyBusinessEntityRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityRequest * FASTCALL soap_in_g2ba__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, g2ba__ModifyBusinessEntityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ModifyBusinessEntityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest, sizeof(g2ba__ModifyBusinessEntityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ModifyBusinessEntityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ModifyBusinessEntityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BEModificationOperation(soap, "g2ba:modificationOperation", &(a->g2ba__ModifyBusinessEntityRequest::modificationOperation), "vd:BEModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ModifyBusinessEntityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest, 0, sizeof(g2ba__ModifyBusinessEntityRequest), 0, soap_copy_g2ba__ModifyBusinessEntityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ModifyBusinessEntityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ModifyBusinessEntityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ModifyBusinessEntityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ModifyBusinessEntityRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityRequest * SOAP_FMAC4 soap_get_g2ba__ModifyBusinessEntityRequest(struct soap *soap, g2ba__ModifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ModifyBusinessEntityRequest * FASTCALL soap_instantiate_g2ba__ModifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ModifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ModifyBusinessEntityRequest));
		((g2ba__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ModifyBusinessEntityRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ModifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ModifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ModifyBusinessEntityRequest %p -> %p\n", q, p));
	*(g2ba__ModifyBusinessEntityRequest*)p = *(g2ba__ModifyBusinessEntityRequest*)q;
}

void g2ba__WithdrawVetDocumentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__WithdrawVetDocumentResponse::vetDocument = NULL;
	this->g2ba__WithdrawVetDocumentResponse::__sizestockEntry = 0;
	this->g2ba__WithdrawVetDocumentResponse::stockEntry = NULL;
	/* transient soap skipped */
}

void g2ba__WithdrawVetDocumentResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocument(soap, &this->g2ba__WithdrawVetDocumentResponse::vetDocument);
	if(this->g2ba__WithdrawVetDocumentResponse::stockEntry) {
		for(int i = 0; i < this->g2ba__WithdrawVetDocumentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->g2ba__WithdrawVetDocumentResponse::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__WithdrawVetDocumentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__WithdrawVetDocumentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, const g2ba__WithdrawVetDocumentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse), "g2ba:WithdrawVetDocumentResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vetDocument)
		soap_element_result(soap, "g2ba:vetDocument");
	if(soap_out_PointerTovd__VetDocument(soap, "g2ba:vetDocument", -1, &(a->g2ba__WithdrawVetDocumentResponse::vetDocument), ""))
		return soap->error;
	if(a->g2ba__WithdrawVetDocumentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->g2ba__WithdrawVetDocumentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "g2ba:stockEntry", -1, a->g2ba__WithdrawVetDocumentResponse::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__WithdrawVetDocumentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__WithdrawVetDocumentResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentResponse * FASTCALL soap_in_g2ba__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, g2ba__WithdrawVetDocumentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__WithdrawVetDocumentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse, sizeof(g2ba__WithdrawVetDocumentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__WithdrawVetDocumentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__WithdrawVetDocumentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetDocument1 = 1;
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocument(soap, "g2ba:vetDocument", &(a->g2ba__WithdrawVetDocumentResponse::vetDocument), "vd:VetDocument"))
				{	soap_flag_vetDocument1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:stockEntry", 1, NULL)) {
				if(a->g2ba__WithdrawVetDocumentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->g2ba__WithdrawVetDocumentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->g2ba__WithdrawVetDocumentResponse::stockEntry == NULL)
						return NULL;
					*a->g2ba__WithdrawVetDocumentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "g2ba:stockEntry", a->g2ba__WithdrawVetDocumentResponse::stockEntry, "vd:StockEntry"))
				{	a->g2ba__WithdrawVetDocumentResponse::__sizestockEntry++;
					a->g2ba__WithdrawVetDocumentResponse::stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "g2ba:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__WithdrawVetDocumentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->g2ba__WithdrawVetDocumentResponse::__sizestockEntry)
			a->g2ba__WithdrawVetDocumentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->g2ba__WithdrawVetDocumentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__WithdrawVetDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse, 0, sizeof(g2ba__WithdrawVetDocumentResponse), 0, soap_copy_g2ba__WithdrawVetDocumentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__WithdrawVetDocumentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse);
	return this->soap_out(soap, tag?tag:"g2ba:WithdrawVetDocumentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__WithdrawVetDocumentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__WithdrawVetDocumentResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentResponse * SOAP_FMAC4 soap_get_g2ba__WithdrawVetDocumentResponse(struct soap *soap, g2ba__WithdrawVetDocumentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__WithdrawVetDocumentResponse * FASTCALL soap_instantiate_g2ba__WithdrawVetDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__WithdrawVetDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentResponse);
		ASSIGN_PTR(size, sizeof(g2ba__WithdrawVetDocumentResponse));
		((g2ba__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__WithdrawVetDocumentResponse));
		for(int i = 0; i < n; i++)
			((g2ba__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__WithdrawVetDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__WithdrawVetDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__WithdrawVetDocumentResponse %p -> %p\n", q, p));
	*(g2ba__WithdrawVetDocumentResponse*)p = *(g2ba__WithdrawVetDocumentResponse*)q;
}

void g2ba__WithdrawVetDocumentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->g2ba__WithdrawVetDocumentRequest::vetDocumentId);
	soap_default_vd__VetDocumentStatusChangeReason(soap, &this->g2ba__WithdrawVetDocumentRequest::withdrawReason);
	soap_default_time(soap, &this->g2ba__WithdrawVetDocumentRequest::withdrawDate);
	this->g2ba__WithdrawVetDocumentRequest::specifiedPerson = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__WithdrawVetDocumentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->g2ba__WithdrawVetDocumentRequest::vetDocumentId);
	soap_serialize_vd__VetDocumentStatusChangeReason(soap, &this->g2ba__WithdrawVetDocumentRequest::withdrawReason);
	soap_embedded(soap, &this->g2ba__WithdrawVetDocumentRequest::withdrawDate, SOAP_TYPE_time);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__WithdrawVetDocumentRequest::specifiedPerson);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__WithdrawVetDocumentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__WithdrawVetDocumentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const g2ba__WithdrawVetDocumentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest), "g2ba:WithdrawVetDocumentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__WithdrawVetDocumentRequest::vetDocumentId) {
		if(soap_out_base__UUID(soap, "g2ba:vetDocumentId", -1, &a->g2ba__WithdrawVetDocumentRequest::vetDocumentId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:vetDocumentId"))
		return soap->error;
	if(a->g2ba__WithdrawVetDocumentRequest::withdrawReason) {
		if(soap_out_vd__VetDocumentStatusChangeReason(soap, "g2ba:withdrawReason", -1, &a->g2ba__WithdrawVetDocumentRequest::withdrawReason, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:withdrawReason"))
		return soap->error;
	if(soap_out_time(soap, "g2ba:withdrawDate", -1, &(a->g2ba__WithdrawVetDocumentRequest::withdrawDate), ""))
		return soap->error;
	if(soap_out_PointerTovd__User(soap, "g2ba:specifiedPerson", -1, &(a->g2ba__WithdrawVetDocumentRequest::specifiedPerson), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__WithdrawVetDocumentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__WithdrawVetDocumentRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentRequest * FASTCALL soap_in_g2ba__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, g2ba__WithdrawVetDocumentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__WithdrawVetDocumentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest, sizeof(g2ba__WithdrawVetDocumentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__WithdrawVetDocumentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__WithdrawVetDocumentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vetDocumentId1 = 1;
	size_t soap_flag_withdrawReason1 = 1;
	size_t soap_flag_withdrawDate1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vetDocumentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "g2ba:vetDocumentId", &(a->g2ba__WithdrawVetDocumentRequest::vetDocumentId), "base:UUID"))
				{	soap_flag_vetDocumentId1--;
					continue;
				}
			if(soap_flag_withdrawReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__VetDocumentStatusChangeReason(soap, "g2ba:withdrawReason", &(a->g2ba__WithdrawVetDocumentRequest::withdrawReason), "vd:VetDocumentStatusChangeReason"))
				{	soap_flag_withdrawReason1--;
					continue;
				}
			if(soap_flag_withdrawDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "g2ba:withdrawDate", &(a->g2ba__WithdrawVetDocumentRequest::withdrawDate), "xsd:dateTime"))
				{	soap_flag_withdrawDate1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:specifiedPerson", &(a->g2ba__WithdrawVetDocumentRequest::specifiedPerson), "vd:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__WithdrawVetDocumentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest, 0, sizeof(g2ba__WithdrawVetDocumentRequest), 0, soap_copy_g2ba__WithdrawVetDocumentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vetDocumentId1 > 0 || soap_flag_withdrawReason1 > 0 || soap_flag_withdrawDate1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__WithdrawVetDocumentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest);
	return this->soap_out(soap, tag?tag:"g2ba:WithdrawVetDocumentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__WithdrawVetDocumentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__WithdrawVetDocumentRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentRequest * SOAP_FMAC4 soap_get_g2ba__WithdrawVetDocumentRequest(struct soap *soap, g2ba__WithdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__WithdrawVetDocumentRequest * FASTCALL soap_instantiate_g2ba__WithdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__WithdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(g2ba__WithdrawVetDocumentRequest));
		((g2ba__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__WithdrawVetDocumentRequest));
		for(int i = 0; i < n; i++)
			((g2ba__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__WithdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__WithdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__WithdrawVetDocumentRequest %p -> %p\n", q, p));
	*(g2ba__WithdrawVetDocumentRequest*)p = *(g2ba__WithdrawVetDocumentRequest*)q;
}

void g2ba__MergeStockEntriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__MergeStockEntriesResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void g2ba__MergeStockEntriesResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__MergeStockEntriesResponse::stockEntryList);
	/* transient soap skipped */
}

int g2ba__MergeStockEntriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__MergeStockEntriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, const g2ba__MergeStockEntriesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__MergeStockEntriesResponse), "g2ba:MergeStockEntriesResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "g2ba:stockEntryList");
	if(a->g2ba__MergeStockEntriesResponse::stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", -1, &a->g2ba__MergeStockEntriesResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__MergeStockEntriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__MergeStockEntriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesResponse * FASTCALL soap_in_g2ba__MergeStockEntriesResponse(struct soap *soap, const char *tag, g2ba__MergeStockEntriesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__MergeStockEntriesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__MergeStockEntriesResponse, sizeof(g2ba__MergeStockEntriesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__MergeStockEntriesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__MergeStockEntriesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", &(a->g2ba__MergeStockEntriesResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "g2ba:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__MergeStockEntriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__MergeStockEntriesResponse, 0, sizeof(g2ba__MergeStockEntriesResponse), 0, soap_copy_g2ba__MergeStockEntriesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__MergeStockEntriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__MergeStockEntriesResponse);
	return this->soap_out(soap, tag?tag:"g2ba:MergeStockEntriesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__MergeStockEntriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__MergeStockEntriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesResponse * SOAP_FMAC4 soap_get_g2ba__MergeStockEntriesResponse(struct soap *soap, g2ba__MergeStockEntriesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__MergeStockEntriesResponse * FASTCALL soap_instantiate_g2ba__MergeStockEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__MergeStockEntriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__MergeStockEntriesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesResponse);
		ASSIGN_PTR(size, sizeof(g2ba__MergeStockEntriesResponse));
		((g2ba__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__MergeStockEntriesResponse));
		for(int i = 0; i < n; i++)
			((g2ba__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__MergeStockEntriesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__MergeStockEntriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__MergeStockEntriesResponse %p -> %p\n", q, p));
	*(g2ba__MergeStockEntriesResponse*)p = *(g2ba__MergeStockEntriesResponse*)q;
}

void g2ba__MergeStockEntriesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__MergeStockEntriesRequest::enterprise = NULL;
	this->g2ba__MergeStockEntriesRequest::mergeOperation = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__MergeStockEntriesRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->g2ba__MergeStockEntriesRequest::enterprise);
	soap_serialize_PointerTovd__MergeStockEntriesOperation(soap, &this->g2ba__MergeStockEntriesRequest::mergeOperation);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__MergeStockEntriesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__MergeStockEntriesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const g2ba__MergeStockEntriesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__MergeStockEntriesRequest), "g2ba:MergeStockEntriesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__MergeStockEntriesRequest::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "g2ba:enterprise", -1, &a->g2ba__MergeStockEntriesRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:enterprise"))
		return soap->error;
	if(a->g2ba__MergeStockEntriesRequest::mergeOperation) {
		if(soap_out_PointerTovd__MergeStockEntriesOperation(soap, "g2ba:mergeOperation", -1, &a->g2ba__MergeStockEntriesRequest::mergeOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:mergeOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__MergeStockEntriesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__MergeStockEntriesRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesRequest * FASTCALL soap_in_g2ba__MergeStockEntriesRequest(struct soap *soap, const char *tag, g2ba__MergeStockEntriesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__MergeStockEntriesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__MergeStockEntriesRequest, sizeof(g2ba__MergeStockEntriesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__MergeStockEntriesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__MergeStockEntriesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_mergeOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "g2ba:enterprise", &(a->g2ba__MergeStockEntriesRequest::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_mergeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__MergeStockEntriesOperation(soap, "g2ba:mergeOperation", &(a->g2ba__MergeStockEntriesRequest::mergeOperation), "vd:MergeStockEntriesOperation"))
				{	soap_flag_mergeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__MergeStockEntriesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__MergeStockEntriesRequest, 0, sizeof(g2ba__MergeStockEntriesRequest), 0, soap_copy_g2ba__MergeStockEntriesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_mergeOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__MergeStockEntriesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__MergeStockEntriesRequest);
	return this->soap_out(soap, tag?tag:"g2ba:MergeStockEntriesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__MergeStockEntriesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__MergeStockEntriesRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesRequest * SOAP_FMAC4 soap_get_g2ba__MergeStockEntriesRequest(struct soap *soap, g2ba__MergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__MergeStockEntriesRequest * FASTCALL soap_instantiate_g2ba__MergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__MergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__MergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(g2ba__MergeStockEntriesRequest));
		((g2ba__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__MergeStockEntriesRequest));
		for(int i = 0; i < n; i++)
			((g2ba__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__MergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__MergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__MergeStockEntriesRequest %p -> %p\n", q, p));
	*(g2ba__MergeStockEntriesRequest*)p = *(g2ba__MergeStockEntriesRequest*)q;
}

void g2ba__RegisterProductionOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__RegisterProductionOperationResponse::stockEntryList = NULL;
	this->g2ba__RegisterProductionOperationResponse::__sizevetDocument = 0;
	this->g2ba__RegisterProductionOperationResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void g2ba__RegisterProductionOperationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->g2ba__RegisterProductionOperationResponse::stockEntryList);
	if(this->g2ba__RegisterProductionOperationResponse::vetDocument) {
		for(int i = 0; i < this->g2ba__RegisterProductionOperationResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->g2ba__RegisterProductionOperationResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__RegisterProductionOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__RegisterProductionOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, const g2ba__RegisterProductionOperationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__RegisterProductionOperationResponse), "g2ba:RegisterProductionOperationResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "g2ba:stockEntryList");
	if(soap_out_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", -1, &(a->g2ba__RegisterProductionOperationResponse::stockEntryList), ""))
		return soap->error;
	if(a->g2ba__RegisterProductionOperationResponse::vetDocument) {
		int i;
		for(i = 0; i < a->g2ba__RegisterProductionOperationResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "g2ba:vetDocument", -1, a->g2ba__RegisterProductionOperationResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__RegisterProductionOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__RegisterProductionOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationResponse * FASTCALL soap_in_g2ba__RegisterProductionOperationResponse(struct soap *soap, const char *tag, g2ba__RegisterProductionOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__RegisterProductionOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__RegisterProductionOperationResponse, sizeof(g2ba__RegisterProductionOperationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__RegisterProductionOperationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__RegisterProductionOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "g2ba:stockEntryList", &(a->g2ba__RegisterProductionOperationResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:vetDocument", 1, NULL)) {
				if(a->g2ba__RegisterProductionOperationResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->g2ba__RegisterProductionOperationResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->g2ba__RegisterProductionOperationResponse::vetDocument == NULL)
						return NULL;
					*a->g2ba__RegisterProductionOperationResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "g2ba:vetDocument", a->g2ba__RegisterProductionOperationResponse::vetDocument, "vd:VetDocument"))
				{	a->g2ba__RegisterProductionOperationResponse::__sizevetDocument++;
					a->g2ba__RegisterProductionOperationResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "g2ba:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__RegisterProductionOperationResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->g2ba__RegisterProductionOperationResponse::__sizevetDocument)
			a->g2ba__RegisterProductionOperationResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->g2ba__RegisterProductionOperationResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__RegisterProductionOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__RegisterProductionOperationResponse, 0, sizeof(g2ba__RegisterProductionOperationResponse), 0, soap_copy_g2ba__RegisterProductionOperationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__RegisterProductionOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__RegisterProductionOperationResponse);
	return this->soap_out(soap, tag?tag:"g2ba:RegisterProductionOperationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__RegisterProductionOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__RegisterProductionOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationResponse * SOAP_FMAC4 soap_get_g2ba__RegisterProductionOperationResponse(struct soap *soap, g2ba__RegisterProductionOperationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__RegisterProductionOperationResponse * FASTCALL soap_instantiate_g2ba__RegisterProductionOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__RegisterProductionOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__RegisterProductionOperationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationResponse);
		ASSIGN_PTR(size, sizeof(g2ba__RegisterProductionOperationResponse));
		((g2ba__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__RegisterProductionOperationResponse));
		for(int i = 0; i < n; i++)
			((g2ba__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__RegisterProductionOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__RegisterProductionOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__RegisterProductionOperationResponse %p -> %p\n", q, p));
	*(g2ba__RegisterProductionOperationResponse*)p = *(g2ba__RegisterProductionOperationResponse*)q;
}

void g2ba__RegisterProductionOperationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__RegisterProductionOperationRequest::enterprise = NULL;
	this->g2ba__RegisterProductionOperationRequest::productionOperation = NULL;
	this->g2ba__RegisterProductionOperationRequest::__sizevetDocument = 0;
	this->g2ba__RegisterProductionOperationRequest::vetDocument = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__RegisterProductionOperationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTodic__Enterprise(soap, &this->g2ba__RegisterProductionOperationRequest::enterprise);
	soap_serialize_PointerTovd__ProductionOperation(soap, &this->g2ba__RegisterProductionOperationRequest::productionOperation);
	if(this->g2ba__RegisterProductionOperationRequest::vetDocument) {
		for(int i = 0; i < this->g2ba__RegisterProductionOperationRequest::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->g2ba__RegisterProductionOperationRequest::vetDocument + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__RegisterProductionOperationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__RegisterProductionOperationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, const g2ba__RegisterProductionOperationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__RegisterProductionOperationRequest), "g2ba:RegisterProductionOperationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__RegisterProductionOperationRequest::enterprise) {
		if(soap_out_PointerTodic__Enterprise(soap, "g2ba:enterprise", -1, &a->g2ba__RegisterProductionOperationRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:enterprise"))
		return soap->error;
	if(a->g2ba__RegisterProductionOperationRequest::productionOperation) {
		if(soap_out_PointerTovd__ProductionOperation(soap, "g2ba:productionOperation", -1, &a->g2ba__RegisterProductionOperationRequest::productionOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:productionOperation"))
		return soap->error;
	if(a->g2ba__RegisterProductionOperationRequest::vetDocument) {
		int i;
		for(i = 0; i < a->g2ba__RegisterProductionOperationRequest::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "g2ba:vetDocument", -1, a->g2ba__RegisterProductionOperationRequest::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__RegisterProductionOperationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__RegisterProductionOperationRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationRequest * FASTCALL soap_in_g2ba__RegisterProductionOperationRequest(struct soap *soap, const char *tag, g2ba__RegisterProductionOperationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__RegisterProductionOperationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__RegisterProductionOperationRequest, sizeof(g2ba__RegisterProductionOperationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__RegisterProductionOperationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__RegisterProductionOperationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_productionOperation1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__Enterprise(soap, "g2ba:enterprise", &(a->g2ba__RegisterProductionOperationRequest::enterprise), "dic:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_productionOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ProductionOperation(soap, "g2ba:productionOperation", &(a->g2ba__RegisterProductionOperationRequest::productionOperation), "vd:ProductionOperation"))
				{	soap_flag_productionOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:vetDocument", 1, NULL)) {
				if(a->g2ba__RegisterProductionOperationRequest::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->g2ba__RegisterProductionOperationRequest::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->g2ba__RegisterProductionOperationRequest::vetDocument == NULL)
						return NULL;
					*a->g2ba__RegisterProductionOperationRequest::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "g2ba:vetDocument", a->g2ba__RegisterProductionOperationRequest::vetDocument, "vd:VetDocument"))
				{	a->g2ba__RegisterProductionOperationRequest::__sizevetDocument++;
					a->g2ba__RegisterProductionOperationRequest::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__RegisterProductionOperationRequest::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->g2ba__RegisterProductionOperationRequest::__sizevetDocument)
			a->g2ba__RegisterProductionOperationRequest::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->g2ba__RegisterProductionOperationRequest::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__RegisterProductionOperationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__RegisterProductionOperationRequest, 0, sizeof(g2ba__RegisterProductionOperationRequest), 0, soap_copy_g2ba__RegisterProductionOperationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_productionOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__RegisterProductionOperationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__RegisterProductionOperationRequest);
	return this->soap_out(soap, tag?tag:"g2ba:RegisterProductionOperationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__RegisterProductionOperationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__RegisterProductionOperationRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationRequest * SOAP_FMAC4 soap_get_g2ba__RegisterProductionOperationRequest(struct soap *soap, g2ba__RegisterProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__RegisterProductionOperationRequest * FASTCALL soap_instantiate_g2ba__RegisterProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__RegisterProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__RegisterProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(g2ba__RegisterProductionOperationRequest));
		((g2ba__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__RegisterProductionOperationRequest));
		for(int i = 0; i < n; i++)
			((g2ba__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__RegisterProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__RegisterProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__RegisterProductionOperationRequest %p -> %p\n", q, p));
	*(g2ba__RegisterProductionOperationRequest*)p = *(g2ba__RegisterProductionOperationRequest*)q;
}

void g2ba__PrepareOutgoingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__PrepareOutgoingConsignmentResponse::__sizestockEntry = 0;
	this->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
	this->g2ba__PrepareOutgoingConsignmentResponse::__sizevetDocument = 0;
	this->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void g2ba__PrepareOutgoingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__PrepareOutgoingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->g2ba__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->g2ba__PrepareOutgoingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->g2ba__PrepareOutgoingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->g2ba__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->g2ba__PrepareOutgoingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__PrepareOutgoingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__PrepareOutgoingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, const g2ba__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse), "g2ba:PrepareOutgoingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->g2ba__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "g2ba:stockEntry", -1, a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->g2ba__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "g2ba:vetDocument", -1, a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__PrepareOutgoingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__PrepareOutgoingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentResponse * FASTCALL soap_in_g2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, g2ba__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__PrepareOutgoingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse, sizeof(g2ba__PrepareOutgoingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__PrepareOutgoingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:stockEntry", 1, NULL)) {
				if(a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "g2ba:stockEntry", a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry, "vd:StockEntry"))
				{	a->g2ba__PrepareOutgoingConsignmentResponse::__sizestockEntry++;
					a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:vetDocument", 1, NULL)) {
				if(a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "g2ba:vetDocument", a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument, "vd:VetDocument"))
				{	a->g2ba__PrepareOutgoingConsignmentResponse::__sizevetDocument++;
					a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->g2ba__PrepareOutgoingConsignmentResponse::__sizestockEntry)
			a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->g2ba__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->g2ba__PrepareOutgoingConsignmentResponse::__sizevetDocument)
			a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->g2ba__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__PrepareOutgoingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse, 0, sizeof(g2ba__PrepareOutgoingConsignmentResponse), 0, soap_copy_g2ba__PrepareOutgoingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__PrepareOutgoingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"g2ba:PrepareOutgoingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__PrepareOutgoingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__PrepareOutgoingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentResponse * SOAP_FMAC4 soap_get_g2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, g2ba__PrepareOutgoingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__PrepareOutgoingConsignmentResponse * FASTCALL soap_instantiate_g2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__PrepareOutgoingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(g2ba__PrepareOutgoingConsignmentResponse));
		((g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__PrepareOutgoingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__PrepareOutgoingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__PrepareOutgoingConsignmentResponse %p -> %p\n", q, p));
	*(g2ba__PrepareOutgoingConsignmentResponse*)p = *(g2ba__PrepareOutgoingConsignmentResponse*)q;
}

void g2ba__PrepareOutgoingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery = 0;
	this->g2ba__PrepareOutgoingConsignmentRequest::delivery = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__PrepareOutgoingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__PrepareOutgoingConsignmentRequest::delivery) {
		for(int i = 0; i < this->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery; i++) {
			soap_serialize_PointerTovd__Delivery(soap, this->g2ba__PrepareOutgoingConsignmentRequest::delivery + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__PrepareOutgoingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__PrepareOutgoingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const g2ba__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest), "g2ba:PrepareOutgoingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__PrepareOutgoingConsignmentRequest::delivery) {
		int i;
		for(i = 0; i < a->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery; i++)
			if(soap_out_PointerTovd__Delivery(soap, "g2ba:delivery", -1, a->g2ba__PrepareOutgoingConsignmentRequest::delivery + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__PrepareOutgoingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__PrepareOutgoingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentRequest * FASTCALL soap_in_g2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, g2ba__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__PrepareOutgoingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest, sizeof(g2ba__PrepareOutgoingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__PrepareOutgoingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_delivery1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:delivery", 1, NULL)) {
				if(a->g2ba__PrepareOutgoingConsignmentRequest::delivery == NULL) {
					if(soap_blist_delivery1 == NULL)
						soap_blist_delivery1 = soap_new_block(soap);
					a->g2ba__PrepareOutgoingConsignmentRequest::delivery = (vd__Delivery **)soap_push_block(soap, soap_blist_delivery1, sizeof(vd__Delivery *));
					if(a->g2ba__PrepareOutgoingConsignmentRequest::delivery == NULL)
						return NULL;
					*a->g2ba__PrepareOutgoingConsignmentRequest::delivery = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Delivery(soap, "g2ba:delivery", a->g2ba__PrepareOutgoingConsignmentRequest::delivery, "vd:Delivery"))
				{	a->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery++;
					a->g2ba__PrepareOutgoingConsignmentRequest::delivery = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__PrepareOutgoingConsignmentRequest::delivery)
			soap_pop_block(soap, soap_blist_delivery1);
		if(a->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery)
			a->g2ba__PrepareOutgoingConsignmentRequest::delivery = (vd__Delivery **)soap_save_block(soap, soap_blist_delivery1, NULL, 1);
		else
		{	a->g2ba__PrepareOutgoingConsignmentRequest::delivery = NULL;
			if(soap_blist_delivery1)
				soap_end_block(soap, soap_blist_delivery1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__PrepareOutgoingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest, 0, sizeof(g2ba__PrepareOutgoingConsignmentRequest), 0, soap_copy_g2ba__PrepareOutgoingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->g2ba__PrepareOutgoingConsignmentRequest::__sizedelivery < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__PrepareOutgoingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"g2ba:PrepareOutgoingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__PrepareOutgoingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__PrepareOutgoingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get_g2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, g2ba__PrepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__PrepareOutgoingConsignmentRequest * FASTCALL soap_instantiate_g2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__PrepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(g2ba__PrepareOutgoingConsignmentRequest));
		((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__PrepareOutgoingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__PrepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(g2ba__PrepareOutgoingConsignmentRequest*)p = *(g2ba__PrepareOutgoingConsignmentRequest*)q;
}

void g2ba__ProcessIncomingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ProcessIncomingConsignmentResponse::__sizestockEntry = 0;
	this->g2ba__ProcessIncomingConsignmentResponse::stockEntry = NULL;
	this->g2ba__ProcessIncomingConsignmentResponse::__sizevetDocument = 0;
	this->g2ba__ProcessIncomingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void g2ba__ProcessIncomingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->g2ba__ProcessIncomingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->g2ba__ProcessIncomingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->g2ba__ProcessIncomingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->g2ba__ProcessIncomingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->g2ba__ProcessIncomingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->g2ba__ProcessIncomingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int g2ba__ProcessIncomingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ProcessIncomingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, const g2ba__ProcessIncomingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse), "g2ba:ProcessIncomingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->g2ba__ProcessIncomingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->g2ba__ProcessIncomingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "g2ba:stockEntry", -1, a->g2ba__ProcessIncomingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->g2ba__ProcessIncomingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->g2ba__ProcessIncomingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "g2ba:vetDocument", -1, a->g2ba__ProcessIncomingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *g2ba__ProcessIncomingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ProcessIncomingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentResponse * FASTCALL soap_in_g2ba__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, g2ba__ProcessIncomingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ProcessIncomingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse, sizeof(g2ba__ProcessIncomingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ProcessIncomingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:stockEntry", 1, NULL)) {
				if(a->g2ba__ProcessIncomingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->g2ba__ProcessIncomingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->g2ba__ProcessIncomingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->g2ba__ProcessIncomingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "g2ba:stockEntry", a->g2ba__ProcessIncomingConsignmentResponse::stockEntry, "vd:StockEntry"))
				{	a->g2ba__ProcessIncomingConsignmentResponse::__sizestockEntry++;
					a->g2ba__ProcessIncomingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:vetDocument", 1, NULL)) {
				if(a->g2ba__ProcessIncomingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->g2ba__ProcessIncomingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->g2ba__ProcessIncomingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->g2ba__ProcessIncomingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "g2ba:vetDocument", a->g2ba__ProcessIncomingConsignmentResponse::vetDocument, "vd:VetDocument"))
				{	a->g2ba__ProcessIncomingConsignmentResponse::__sizevetDocument++;
					a->g2ba__ProcessIncomingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__ProcessIncomingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->g2ba__ProcessIncomingConsignmentResponse::__sizestockEntry)
			a->g2ba__ProcessIncomingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->g2ba__ProcessIncomingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->g2ba__ProcessIncomingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->g2ba__ProcessIncomingConsignmentResponse::__sizevetDocument)
			a->g2ba__ProcessIncomingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->g2ba__ProcessIncomingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ProcessIncomingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse, 0, sizeof(g2ba__ProcessIncomingConsignmentResponse), 0, soap_copy_g2ba__ProcessIncomingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int g2ba__ProcessIncomingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"g2ba:ProcessIncomingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ProcessIncomingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ProcessIncomingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentResponse * SOAP_FMAC4 soap_get_g2ba__ProcessIncomingConsignmentResponse(struct soap *soap, g2ba__ProcessIncomingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ProcessIncomingConsignmentResponse * FASTCALL soap_instantiate_g2ba__ProcessIncomingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ProcessIncomingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(g2ba__ProcessIncomingConsignmentResponse));
		((g2ba__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ProcessIncomingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((g2ba__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ProcessIncomingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ProcessIncomingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ProcessIncomingConsignmentResponse %p -> %p\n", q, p));
	*(g2ba__ProcessIncomingConsignmentResponse*)p = *(g2ba__ProcessIncomingConsignmentResponse*)q;
}

void g2ba__ProcessIncomingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->g2ba__ProcessIncomingConsignmentRequest::delivery = NULL;
	this->g2ba__ProcessIncomingConsignmentRequest::deliveryFacts = NULL;
	this->g2ba__ProcessIncomingConsignmentRequest::__sizediscrepancyReport = 0;
	this->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
	this->g2ba__ProcessIncomingConsignmentRequest::returnedDelivery = NULL;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__ProcessIncomingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__Delivery(soap, &this->g2ba__ProcessIncomingConsignmentRequest::delivery);
	soap_serialize_PointerTovd__DeliveryFactList(soap, &this->g2ba__ProcessIncomingConsignmentRequest::deliveryFacts);
	if(this->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport) {
		for(int i = 0; i < this->g2ba__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTovd__DiscrepancyReport(soap, this->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport + i);
		}
	}
	soap_serialize_PointerTovd__Delivery(soap, &this->g2ba__ProcessIncomingConsignmentRequest::returnedDelivery);
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__ProcessIncomingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__ProcessIncomingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const g2ba__ProcessIncomingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest), "g2ba:ProcessIncomingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->g2ba__ProcessIncomingConsignmentRequest::delivery) {
		if(soap_out_PointerTovd__Delivery(soap, "g2ba:delivery", -1, &a->g2ba__ProcessIncomingConsignmentRequest::delivery, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:delivery"))
		return soap->error;
	if(a->g2ba__ProcessIncomingConsignmentRequest::deliveryFacts) {
		if(soap_out_PointerTovd__DeliveryFactList(soap, "g2ba:deliveryFacts", -1, &a->g2ba__ProcessIncomingConsignmentRequest::deliveryFacts, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:deliveryFacts"))
		return soap->error;
	if(a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->g2ba__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTovd__DiscrepancyReport(soap, "g2ba:discrepancyReport", -1, a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__Delivery(soap, "g2ba:returnedDelivery", -1, &(a->g2ba__ProcessIncomingConsignmentRequest::returnedDelivery), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__ProcessIncomingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__ProcessIncomingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentRequest * FASTCALL soap_in_g2ba__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, g2ba__ProcessIncomingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__ProcessIncomingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest, sizeof(g2ba__ProcessIncomingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__ProcessIncomingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_delivery1 = 1;
	size_t soap_flag_deliveryFacts1 = 1;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	size_t soap_flag_returnedDelivery1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_delivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Delivery(soap, "g2ba:delivery", &(a->g2ba__ProcessIncomingConsignmentRequest::delivery), "vd:Delivery"))
				{	soap_flag_delivery1--;
					continue;
				}
			if(soap_flag_deliveryFacts1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryFactList(soap, "g2ba:deliveryFacts", &(a->g2ba__ProcessIncomingConsignmentRequest::deliveryFacts), "vd:DeliveryFactList"))
				{	soap_flag_deliveryFacts1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "g2ba:discrepancyReport", 1, NULL)) {
				if(a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(vd__DiscrepancyReport *));
					if(a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport == NULL)
						return NULL;
					*a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__DiscrepancyReport(soap, "g2ba:discrepancyReport", a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport, "vd:DiscrepancyReport"))
				{	a->g2ba__ProcessIncomingConsignmentRequest::__sizediscrepancyReport++;
					a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap_flag_returnedDelivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Delivery(soap, "g2ba:returnedDelivery", &(a->g2ba__ProcessIncomingConsignmentRequest::returnedDelivery), "vd:Delivery"))
				{	soap_flag_returnedDelivery1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->g2ba__ProcessIncomingConsignmentRequest::__sizediscrepancyReport)
			a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->g2ba__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__ProcessIncomingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest, 0, sizeof(g2ba__ProcessIncomingConsignmentRequest), 0, soap_copy_g2ba__ProcessIncomingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_delivery1 > 0 || soap_flag_deliveryFacts1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__ProcessIncomingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"g2ba:ProcessIncomingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__ProcessIncomingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__ProcessIncomingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentRequest * SOAP_FMAC4 soap_get_g2ba__ProcessIncomingConsignmentRequest(struct soap *soap, g2ba__ProcessIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__ProcessIncomingConsignmentRequest * FASTCALL soap_instantiate_g2ba__ProcessIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__ProcessIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(g2ba__ProcessIncomingConsignmentRequest));
		((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__ProcessIncomingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__ProcessIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__ProcessIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__ProcessIncomingConsignmentRequest %p -> %p\n", q, p));
	*(g2ba__ProcessIncomingConsignmentRequest*)p = *(g2ba__ProcessIncomingConsignmentRequest*)q;
}

void g2ba__MercuryApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	this->g2ba__MercuryApplicationRequest::initiator = NULL;
	this->g2ba__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void g2ba__MercuryApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__Identifier(soap, &this->g2ba__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->g2ba__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTodic__OTPToken(soap, &this->g2ba__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int g2ba__MercuryApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_g2ba__MercuryApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_g2ba__MercuryApplicationRequest(struct soap *soap, const char *tag, int id, const g2ba__MercuryApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_g2ba__MercuryApplicationRequest), "g2ba:MercuryApplicationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->g2ba__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "g2ba:localTransactionId", -1, &a->g2ba__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:localTransactionId"))
		return soap->error;
	if(a->g2ba__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "g2ba:initiator", -1, &a->g2ba__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "g2ba:initiator"))
		return soap->error;
	if(soap_out_PointerTodic__OTPToken(soap, "g2ba:sessionToken", -1, &(a->g2ba__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *g2ba__MercuryApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_g2ba__MercuryApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 g2ba__MercuryApplicationRequest * FASTCALL soap_in_g2ba__MercuryApplicationRequest(struct soap *soap, const char *tag, g2ba__MercuryApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (g2ba__MercuryApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_g2ba__MercuryApplicationRequest, sizeof(g2ba__MercuryApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_g2ba__MercuryApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (g2ba__MercuryApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId1 = 1;
	size_t soap_flag_initiator1 = 1;
	size_t soap_flag_sessionToken1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "g2ba:localTransactionId", &(a->g2ba__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId1--;
					continue;
				}
			if(soap_flag_initiator1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "g2ba:initiator", &(a->g2ba__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator1--;
					continue;
				}
			if(soap_flag_sessionToken1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTodic__OTPToken(soap, "g2ba:sessionToken", &(a->g2ba__MercuryApplicationRequest::sessionToken), "dic:OTPToken"))
				{	soap_flag_sessionToken1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (g2ba__MercuryApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_g2ba__MercuryApplicationRequest, 0, sizeof(g2ba__MercuryApplicationRequest), 0, soap_copy_g2ba__MercuryApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId1 > 0 || soap_flag_initiator1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int g2ba__MercuryApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_g2ba__MercuryApplicationRequest);
	return this->soap_out(soap, tag?tag:"g2ba:MercuryApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *g2ba__MercuryApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_g2ba__MercuryApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 g2ba__MercuryApplicationRequest * SOAP_FMAC4 soap_get_g2ba__MercuryApplicationRequest(struct soap *soap, g2ba__MercuryApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_g2ba__MercuryApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 g2ba__MercuryApplicationRequest * FASTCALL soap_instantiate_g2ba__MercuryApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_g2ba__MercuryApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_g2ba__MercuryApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "g2ba:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ProcessIncomingConsignmentRequest));
			((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__PrepareOutgoingConsignmentRequest));
			((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_g2ba__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__RegisterProductionOperationRequest));
			((g2ba__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((g2ba__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_g2ba__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__MergeStockEntriesRequest));
			((g2ba__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((g2ba__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_g2ba__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__WithdrawVetDocumentRequest));
			((g2ba__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((g2ba__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyBusinessEntityRequest));
			((g2ba__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyEnterpriseRequest));
			((g2ba__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyActivityLocationsRequest));
			((g2ba__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_g2ba__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ResolveDiscrepancyRequest));
			((g2ba__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_g2ba__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__ModifyProducerStockListRequest));
			((g2ba__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentByUuidRequest));
			((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentListRequest));
			((g2ba__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetVetDocumentChangesListRequest));
			((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByGuidRequest));
			((g2ba__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryByUuidRequest));
			((g2ba__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryChangesListRequest));
			((g2ba__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryListRequest));
			((g2ba__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetStockEntryVersionListRequest));
			((g2ba__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateTransportMovementDetailsRequest));
			((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateVeterinaryEventsRequest));
			((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__CheckShipmentRegionalizationRequest));
			((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((g2ba__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__AddBusinessEntityUserRequest));
			((g2ba__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserListRequest));
			((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetBusinessEntityUserRequest));
			((g2ba__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserAuthoritiesRequest));
			((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UpdateUserWorkingAreasRequest));
			((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__UnbindBusinessEntityUserRequest));
			((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((g2ba__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "g2ba:GetApplicableUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(g2ba__GetApplicableUserAuthorityListRequest));
			((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(g2ba__GetApplicableUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(g2ba__GetApplicableUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (g2ba__GetApplicableUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(g2ba__MercuryApplicationRequest);
		ASSIGN_PTR(size, sizeof(g2ba__MercuryApplicationRequest));
		((g2ba__MercuryApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(g2ba__MercuryApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(g2ba__MercuryApplicationRequest));
		for(int i = 0; i < n; i++)
			((g2ba__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (g2ba__MercuryApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_g2ba__MercuryApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying g2ba__MercuryApplicationRequest %p -> %p\n", q, p));
	*(g2ba__MercuryApplicationRequest*)p = *(g2ba__MercuryApplicationRequest*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if(this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if(this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	return this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type) ? soap->error : soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * FASTCALL soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		ASSIGN_PTR(size, sizeof(xsd__base64Binary));
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(xsd__base64Binary));
		for(int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if(soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if(soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if(soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * FASTCALL soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if(soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if(soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if(soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	return soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * FASTCALL soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Fault));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Fault));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if(soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if(soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * FASTCALL soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	return soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * FASTCALL soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Reason));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Reason));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if(soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * FASTCALL soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	return soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * FASTCALL soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Code));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Code));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * FASTCALL soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	return soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * FASTCALL soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Header));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Header));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, struct __g2b__getApplicableUserAuthorityListRequest *a)
{
	a->g2ba__getApplicableUserAuthorityListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, const struct __g2b__getApplicableUserAuthorityListRequest *a)
{
	soap_serialize_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, &a->g2ba__getApplicableUserAuthorityListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getApplicableUserAuthorityListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, "g2ba:getApplicableUserAuthorityListRequest", -1, &a->g2ba__getApplicableUserAuthorityListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getApplicableUserAuthorityListRequest * FASTCALL soap_in___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, struct __g2b__getApplicableUserAuthorityListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getApplicableUserAuthorityListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getApplicableUserAuthorityListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getApplicableUserAuthorityListRequest, sizeof(struct __g2b__getApplicableUserAuthorityListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getApplicableUserAuthorityListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getApplicableUserAuthorityListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, "g2ba:getApplicableUserAuthorityListRequest", &a->g2ba__getApplicableUserAuthorityListRequest, "g2ba:GetApplicableUserAuthorityListRequest"))
				{	soap_flag_g2ba__getApplicableUserAuthorityListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, const struct __g2b__getApplicableUserAuthorityListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getApplicableUserAuthorityListRequest(soap, tag?tag:"-g2b:getApplicableUserAuthorityListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getApplicableUserAuthorityListRequest * SOAP_FMAC4 soap_get___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, struct __g2b__getApplicableUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getApplicableUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getApplicableUserAuthorityListRequest * FASTCALL soap_instantiate___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getApplicableUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getApplicableUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getApplicableUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getApplicableUserAuthorityListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getApplicableUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getApplicableUserAuthorityListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getApplicableUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getApplicableUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getApplicableUserAuthorityListRequest %p -> %p\n", q, p));
	*(struct __g2b__getApplicableUserAuthorityListRequest*)p = *(struct __g2b__getApplicableUserAuthorityListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__unbindBusinessEntityUserRequest(struct soap *soap, struct __g2b__unbindBusinessEntityUserRequest *a)
{
	a->g2ba__unbindBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__unbindBusinessEntityUserRequest(struct soap *soap, const struct __g2b__unbindBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, &a->g2ba__unbindBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __g2b__unbindBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, "g2ba:unbindBusinessEntityUserRequest", -1, &a->g2ba__unbindBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__unbindBusinessEntityUserRequest * FASTCALL soap_in___g2b__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __g2b__unbindBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_g2ba__unbindBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __g2b__unbindBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__unbindBusinessEntityUserRequest, sizeof(struct __g2b__unbindBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__unbindBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__unbindBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, "g2ba:unbindBusinessEntityUserRequest", &a->g2ba__unbindBusinessEntityUserRequest, "g2ba:UnbindBusinessEntityUserRequest"))
				{	soap_flag_g2ba__unbindBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__unbindBusinessEntityUserRequest(struct soap *soap, const struct __g2b__unbindBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__unbindBusinessEntityUserRequest(soap, tag?tag:"-g2b:unbindBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__unbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get___g2b__unbindBusinessEntityUserRequest(struct soap *soap, struct __g2b__unbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__unbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__unbindBusinessEntityUserRequest * FASTCALL soap_instantiate___g2b__unbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__unbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__unbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__unbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__unbindBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__unbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__unbindBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__unbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__unbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__unbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __g2b__unbindBusinessEntityUserRequest*)p = *(struct __g2b__unbindBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__updateUserWorkingAreasRequest(struct soap *soap, struct __g2b__updateUserWorkingAreasRequest *a)
{
	a->g2ba__updateUserWorkingAreasRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__updateUserWorkingAreasRequest(struct soap *soap, const struct __g2b__updateUserWorkingAreasRequest *a)
{
	soap_serialize_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, &a->g2ba__updateUserWorkingAreasRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const struct __g2b__updateUserWorkingAreasRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, "g2ba:updateUserWorkingAreasRequest", -1, &a->g2ba__updateUserWorkingAreasRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateUserWorkingAreasRequest * FASTCALL soap_in___g2b__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, struct __g2b__updateUserWorkingAreasRequest *a, const char *type)
{
	size_t soap_flag_g2ba__updateUserWorkingAreasRequest = 1;
	short soap_flag;
	a = (struct __g2b__updateUserWorkingAreasRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__updateUserWorkingAreasRequest, sizeof(struct __g2b__updateUserWorkingAreasRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__updateUserWorkingAreasRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__updateUserWorkingAreasRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, "g2ba:updateUserWorkingAreasRequest", &a->g2ba__updateUserWorkingAreasRequest, "g2ba:UpdateUserWorkingAreasRequest"))
				{	soap_flag_g2ba__updateUserWorkingAreasRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__updateUserWorkingAreasRequest(struct soap *soap, const struct __g2b__updateUserWorkingAreasRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__updateUserWorkingAreasRequest(soap, tag?tag:"-g2b:updateUserWorkingAreasRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateUserWorkingAreasRequest * SOAP_FMAC4 soap_get___g2b__updateUserWorkingAreasRequest(struct soap *soap, struct __g2b__updateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__updateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__updateUserWorkingAreasRequest * FASTCALL soap_instantiate___g2b__updateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__updateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__updateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__updateUserWorkingAreasRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__updateUserWorkingAreasRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__updateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__updateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__updateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(struct __g2b__updateUserWorkingAreasRequest*)p = *(struct __g2b__updateUserWorkingAreasRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__updateUserAuthoritiesRequest(struct soap *soap, struct __g2b__updateUserAuthoritiesRequest *a)
{
	a->g2ba__updateUserAuthoritiesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__updateUserAuthoritiesRequest(struct soap *soap, const struct __g2b__updateUserAuthoritiesRequest *a)
{
	soap_serialize_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, &a->g2ba__updateUserAuthoritiesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const struct __g2b__updateUserAuthoritiesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, "g2ba:updateUserAuthoritiesRequest", -1, &a->g2ba__updateUserAuthoritiesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateUserAuthoritiesRequest * FASTCALL soap_in___g2b__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, struct __g2b__updateUserAuthoritiesRequest *a, const char *type)
{
	size_t soap_flag_g2ba__updateUserAuthoritiesRequest = 1;
	short soap_flag;
	a = (struct __g2b__updateUserAuthoritiesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__updateUserAuthoritiesRequest, sizeof(struct __g2b__updateUserAuthoritiesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__updateUserAuthoritiesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__updateUserAuthoritiesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, "g2ba:updateUserAuthoritiesRequest", &a->g2ba__updateUserAuthoritiesRequest, "g2ba:UpdateUserAuthoritiesRequest"))
				{	soap_flag_g2ba__updateUserAuthoritiesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__updateUserAuthoritiesRequest(struct soap *soap, const struct __g2b__updateUserAuthoritiesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__updateUserAuthoritiesRequest(soap, tag?tag:"-g2b:updateUserAuthoritiesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateUserAuthoritiesRequest * SOAP_FMAC4 soap_get___g2b__updateUserAuthoritiesRequest(struct soap *soap, struct __g2b__updateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__updateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__updateUserAuthoritiesRequest * FASTCALL soap_instantiate___g2b__updateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__updateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__updateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__updateUserAuthoritiesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__updateUserAuthoritiesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__updateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__updateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__updateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(struct __g2b__updateUserAuthoritiesRequest*)p = *(struct __g2b__updateUserAuthoritiesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getBusinessEntityUserRequest(struct soap *soap, struct __g2b__getBusinessEntityUserRequest *a)
{
	a->g2ba__getBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getBusinessEntityUserRequest(struct soap *soap, const struct __g2b__getBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTog2ba__GetBusinessEntityUserRequest(soap, &a->g2ba__getBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetBusinessEntityUserRequest(soap, "g2ba:getBusinessEntityUserRequest", -1, &a->g2ba__getBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getBusinessEntityUserRequest * FASTCALL soap_in___g2b__getBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __g2b__getBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __g2b__getBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getBusinessEntityUserRequest, sizeof(struct __g2b__getBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetBusinessEntityUserRequest(soap, "g2ba:getBusinessEntityUserRequest", &a->g2ba__getBusinessEntityUserRequest, "g2ba:GetBusinessEntityUserRequest"))
				{	soap_flag_g2ba__getBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getBusinessEntityUserRequest(struct soap *soap, const struct __g2b__getBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getBusinessEntityUserRequest(soap, tag?tag:"-g2b:getBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getBusinessEntityUserRequest * SOAP_FMAC4 soap_get___g2b__getBusinessEntityUserRequest(struct soap *soap, struct __g2b__getBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getBusinessEntityUserRequest * FASTCALL soap_instantiate___g2b__getBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __g2b__getBusinessEntityUserRequest*)p = *(struct __g2b__getBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getBusinessEntityUserListRequest(struct soap *soap, struct __g2b__getBusinessEntityUserListRequest *a)
{
	a->g2ba__getBusinessEntityUserListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getBusinessEntityUserListRequest(struct soap *soap, const struct __g2b__getBusinessEntityUserListRequest *a)
{
	soap_serialize_PointerTog2ba__GetBusinessEntityUserListRequest(soap, &a->g2ba__getBusinessEntityUserListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getBusinessEntityUserListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetBusinessEntityUserListRequest(soap, "g2ba:getBusinessEntityUserListRequest", -1, &a->g2ba__getBusinessEntityUserListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getBusinessEntityUserListRequest * FASTCALL soap_in___g2b__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, struct __g2b__getBusinessEntityUserListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getBusinessEntityUserListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getBusinessEntityUserListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getBusinessEntityUserListRequest, sizeof(struct __g2b__getBusinessEntityUserListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getBusinessEntityUserListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getBusinessEntityUserListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetBusinessEntityUserListRequest(soap, "g2ba:getBusinessEntityUserListRequest", &a->g2ba__getBusinessEntityUserListRequest, "g2ba:GetBusinessEntityUserListRequest"))
				{	soap_flag_g2ba__getBusinessEntityUserListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getBusinessEntityUserListRequest(struct soap *soap, const struct __g2b__getBusinessEntityUserListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getBusinessEntityUserListRequest(soap, tag?tag:"-g2b:getBusinessEntityUserListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getBusinessEntityUserListRequest * SOAP_FMAC4 soap_get___g2b__getBusinessEntityUserListRequest(struct soap *soap, struct __g2b__getBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getBusinessEntityUserListRequest * FASTCALL soap_instantiate___g2b__getBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getBusinessEntityUserListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getBusinessEntityUserListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(struct __g2b__getBusinessEntityUserListRequest*)p = *(struct __g2b__getBusinessEntityUserListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__addBusinessEntityUserRequest(struct soap *soap, struct __g2b__addBusinessEntityUserRequest *a)
{
	a->g2ba__addBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__addBusinessEntityUserRequest(struct soap *soap, const struct __g2b__addBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTog2ba__AddBusinessEntityUserRequest(soap, &a->g2ba__addBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__addBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __g2b__addBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__AddBusinessEntityUserRequest(soap, "g2ba:addBusinessEntityUserRequest", -1, &a->g2ba__addBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__addBusinessEntityUserRequest * FASTCALL soap_in___g2b__addBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __g2b__addBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_g2ba__addBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __g2b__addBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__addBusinessEntityUserRequest, sizeof(struct __g2b__addBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__addBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__addBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__AddBusinessEntityUserRequest(soap, "g2ba:addBusinessEntityUserRequest", &a->g2ba__addBusinessEntityUserRequest, "g2ba:AddBusinessEntityUserRequest"))
				{	soap_flag_g2ba__addBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__addBusinessEntityUserRequest(struct soap *soap, const struct __g2b__addBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__addBusinessEntityUserRequest(soap, tag?tag:"-g2b:addBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__addBusinessEntityUserRequest * SOAP_FMAC4 soap_get___g2b__addBusinessEntityUserRequest(struct soap *soap, struct __g2b__addBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__addBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__addBusinessEntityUserRequest * FASTCALL soap_instantiate___g2b__addBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__addBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__addBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__addBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__addBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__addBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__addBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__addBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__addBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__addBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __g2b__addBusinessEntityUserRequest*)p = *(struct __g2b__addBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__checkShipmentRegionalizationRequest(struct soap *soap, struct __g2b__checkShipmentRegionalizationRequest *a)
{
	a->g2ba__checkShipmentRegionalizationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__checkShipmentRegionalizationRequest(struct soap *soap, const struct __g2b__checkShipmentRegionalizationRequest *a)
{
	soap_serialize_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, &a->g2ba__checkShipmentRegionalizationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const struct __g2b__checkShipmentRegionalizationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, "g2ba:checkShipmentRegionalizationRequest", -1, &a->g2ba__checkShipmentRegionalizationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__checkShipmentRegionalizationRequest * FASTCALL soap_in___g2b__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, struct __g2b__checkShipmentRegionalizationRequest *a, const char *type)
{
	size_t soap_flag_g2ba__checkShipmentRegionalizationRequest = 1;
	short soap_flag;
	a = (struct __g2b__checkShipmentRegionalizationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__checkShipmentRegionalizationRequest, sizeof(struct __g2b__checkShipmentRegionalizationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__checkShipmentRegionalizationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__checkShipmentRegionalizationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, "g2ba:checkShipmentRegionalizationRequest", &a->g2ba__checkShipmentRegionalizationRequest, "g2ba:CheckShipmentRegionalizationRequest"))
				{	soap_flag_g2ba__checkShipmentRegionalizationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__checkShipmentRegionalizationRequest(struct soap *soap, const struct __g2b__checkShipmentRegionalizationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__checkShipmentRegionalizationRequest(soap, tag?tag:"-g2b:checkShipmentRegionalizationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__checkShipmentRegionalizationRequest * SOAP_FMAC4 soap_get___g2b__checkShipmentRegionalizationRequest(struct soap *soap, struct __g2b__checkShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__checkShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__checkShipmentRegionalizationRequest * FASTCALL soap_instantiate___g2b__checkShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__checkShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__checkShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__checkShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__checkShipmentRegionalizationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__checkShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__checkShipmentRegionalizationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__checkShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__checkShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__checkShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(struct __g2b__checkShipmentRegionalizationRequest*)p = *(struct __g2b__checkShipmentRegionalizationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__updateVeterinaryEventsRequest(struct soap *soap, struct __g2b__updateVeterinaryEventsRequest *a)
{
	a->g2ba__updateVeterinaryEventsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__updateVeterinaryEventsRequest(struct soap *soap, const struct __g2b__updateVeterinaryEventsRequest *a)
{
	soap_serialize_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, &a->g2ba__updateVeterinaryEventsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const struct __g2b__updateVeterinaryEventsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, "g2ba:updateVeterinaryEventsRequest", -1, &a->g2ba__updateVeterinaryEventsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateVeterinaryEventsRequest * FASTCALL soap_in___g2b__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, struct __g2b__updateVeterinaryEventsRequest *a, const char *type)
{
	size_t soap_flag_g2ba__updateVeterinaryEventsRequest = 1;
	short soap_flag;
	a = (struct __g2b__updateVeterinaryEventsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__updateVeterinaryEventsRequest, sizeof(struct __g2b__updateVeterinaryEventsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__updateVeterinaryEventsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__updateVeterinaryEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, "g2ba:updateVeterinaryEventsRequest", &a->g2ba__updateVeterinaryEventsRequest, "g2ba:UpdateVeterinaryEventsRequest"))
				{	soap_flag_g2ba__updateVeterinaryEventsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__updateVeterinaryEventsRequest(struct soap *soap, const struct __g2b__updateVeterinaryEventsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__updateVeterinaryEventsRequest(soap, tag?tag:"-g2b:updateVeterinaryEventsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateVeterinaryEventsRequest * SOAP_FMAC4 soap_get___g2b__updateVeterinaryEventsRequest(struct soap *soap, struct __g2b__updateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__updateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__updateVeterinaryEventsRequest * FASTCALL soap_instantiate___g2b__updateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__updateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__updateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__updateVeterinaryEventsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__updateVeterinaryEventsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__updateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__updateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__updateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(struct __g2b__updateVeterinaryEventsRequest*)p = *(struct __g2b__updateVeterinaryEventsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__updateTransportMovementDetailsRequest(struct soap *soap, struct __g2b__updateTransportMovementDetailsRequest *a)
{
	a->g2ba__updateTransportMovementDetailsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__updateTransportMovementDetailsRequest(struct soap *soap, const struct __g2b__updateTransportMovementDetailsRequest *a)
{
	soap_serialize_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, &a->g2ba__updateTransportMovementDetailsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const struct __g2b__updateTransportMovementDetailsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, "g2ba:updateTransportMovementDetailsRequest", -1, &a->g2ba__updateTransportMovementDetailsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateTransportMovementDetailsRequest * FASTCALL soap_in___g2b__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, struct __g2b__updateTransportMovementDetailsRequest *a, const char *type)
{
	size_t soap_flag_g2ba__updateTransportMovementDetailsRequest = 1;
	short soap_flag;
	a = (struct __g2b__updateTransportMovementDetailsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__updateTransportMovementDetailsRequest, sizeof(struct __g2b__updateTransportMovementDetailsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__updateTransportMovementDetailsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__updateTransportMovementDetailsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, "g2ba:updateTransportMovementDetailsRequest", &a->g2ba__updateTransportMovementDetailsRequest, "g2ba:UpdateTransportMovementDetailsRequest"))
				{	soap_flag_g2ba__updateTransportMovementDetailsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__updateTransportMovementDetailsRequest(struct soap *soap, const struct __g2b__updateTransportMovementDetailsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__updateTransportMovementDetailsRequest(soap, tag?tag:"-g2b:updateTransportMovementDetailsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__updateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get___g2b__updateTransportMovementDetailsRequest(struct soap *soap, struct __g2b__updateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__updateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__updateTransportMovementDetailsRequest * FASTCALL soap_instantiate___g2b__updateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__updateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__updateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__updateTransportMovementDetailsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__updateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__updateTransportMovementDetailsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__updateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__updateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__updateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(struct __g2b__updateTransportMovementDetailsRequest*)p = *(struct __g2b__updateTransportMovementDetailsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getStockEntryVersionListRequest(struct soap *soap, struct __g2b__getStockEntryVersionListRequest *a)
{
	a->g2ba__getStockEntryVersionListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getStockEntryVersionListRequest(struct soap *soap, const struct __g2b__getStockEntryVersionListRequest *a)
{
	soap_serialize_PointerTog2ba__GetStockEntryVersionListRequest(soap, &a->g2ba__getStockEntryVersionListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getStockEntryVersionListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetStockEntryVersionListRequest(soap, "g2ba:getStockEntryVersionListRequest", -1, &a->g2ba__getStockEntryVersionListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryVersionListRequest * FASTCALL soap_in___g2b__getStockEntryVersionListRequest(struct soap *soap, const char *tag, struct __g2b__getStockEntryVersionListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getStockEntryVersionListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getStockEntryVersionListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getStockEntryVersionListRequest, sizeof(struct __g2b__getStockEntryVersionListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getStockEntryVersionListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getStockEntryVersionListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetStockEntryVersionListRequest(soap, "g2ba:getStockEntryVersionListRequest", &a->g2ba__getStockEntryVersionListRequest, "g2ba:GetStockEntryVersionListRequest"))
				{	soap_flag_g2ba__getStockEntryVersionListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getStockEntryVersionListRequest(struct soap *soap, const struct __g2b__getStockEntryVersionListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getStockEntryVersionListRequest(soap, tag?tag:"-g2b:getStockEntryVersionListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryVersionListRequest * SOAP_FMAC4 soap_get___g2b__getStockEntryVersionListRequest(struct soap *soap, struct __g2b__getStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getStockEntryVersionListRequest * FASTCALL soap_instantiate___g2b__getStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getStockEntryVersionListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getStockEntryVersionListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getStockEntryVersionListRequest %p -> %p\n", q, p));
	*(struct __g2b__getStockEntryVersionListRequest*)p = *(struct __g2b__getStockEntryVersionListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getStockEntryChangesListRequest(struct soap *soap, struct __g2b__getStockEntryChangesListRequest *a)
{
	a->g2ba__getStockEntryChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getStockEntryChangesListRequest(struct soap *soap, const struct __g2b__getStockEntryChangesListRequest *a)
{
	soap_serialize_PointerTog2ba__GetStockEntryChangesListRequest(soap, &a->g2ba__getStockEntryChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getStockEntryChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetStockEntryChangesListRequest(soap, "g2ba:getStockEntryChangesListRequest", -1, &a->g2ba__getStockEntryChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryChangesListRequest * FASTCALL soap_in___g2b__getStockEntryChangesListRequest(struct soap *soap, const char *tag, struct __g2b__getStockEntryChangesListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getStockEntryChangesListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getStockEntryChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getStockEntryChangesListRequest, sizeof(struct __g2b__getStockEntryChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getStockEntryChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getStockEntryChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetStockEntryChangesListRequest(soap, "g2ba:getStockEntryChangesListRequest", &a->g2ba__getStockEntryChangesListRequest, "g2ba:GetStockEntryChangesListRequest"))
				{	soap_flag_g2ba__getStockEntryChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getStockEntryChangesListRequest(struct soap *soap, const struct __g2b__getStockEntryChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getStockEntryChangesListRequest(soap, tag?tag:"-g2b:getStockEntryChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryChangesListRequest * SOAP_FMAC4 soap_get___g2b__getStockEntryChangesListRequest(struct soap *soap, struct __g2b__getStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getStockEntryChangesListRequest * FASTCALL soap_instantiate___g2b__getStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getStockEntryChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getStockEntryChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getStockEntryChangesListRequest %p -> %p\n", q, p));
	*(struct __g2b__getStockEntryChangesListRequest*)p = *(struct __g2b__getStockEntryChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getStockEntryListRequest(struct soap *soap, struct __g2b__getStockEntryListRequest *a)
{
	a->g2ba__getStockEntryListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getStockEntryListRequest(struct soap *soap, const struct __g2b__getStockEntryListRequest *a)
{
	soap_serialize_PointerTog2ba__GetStockEntryListRequest(soap, &a->g2ba__getStockEntryListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getStockEntryListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getStockEntryListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetStockEntryListRequest(soap, "g2ba:getStockEntryListRequest", -1, &a->g2ba__getStockEntryListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryListRequest * FASTCALL soap_in___g2b__getStockEntryListRequest(struct soap *soap, const char *tag, struct __g2b__getStockEntryListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getStockEntryListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getStockEntryListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getStockEntryListRequest, sizeof(struct __g2b__getStockEntryListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getStockEntryListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getStockEntryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetStockEntryListRequest(soap, "g2ba:getStockEntryListRequest", &a->g2ba__getStockEntryListRequest, "g2ba:GetStockEntryListRequest"))
				{	soap_flag_g2ba__getStockEntryListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getStockEntryListRequest(struct soap *soap, const struct __g2b__getStockEntryListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getStockEntryListRequest(soap, tag?tag:"-g2b:getStockEntryListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryListRequest * SOAP_FMAC4 soap_get___g2b__getStockEntryListRequest(struct soap *soap, struct __g2b__getStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getStockEntryListRequest * FASTCALL soap_instantiate___g2b__getStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getStockEntryListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getStockEntryListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getStockEntryListRequest %p -> %p\n", q, p));
	*(struct __g2b__getStockEntryListRequest*)p = *(struct __g2b__getStockEntryListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getStockEntryByUuidRequest(struct soap *soap, struct __g2b__getStockEntryByUuidRequest *a)
{
	a->g2ba__getStockEntryByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getStockEntryByUuidRequest(struct soap *soap, const struct __g2b__getStockEntryByUuidRequest *a)
{
	soap_serialize_PointerTog2ba__GetStockEntryByUuidRequest(soap, &a->g2ba__getStockEntryByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getStockEntryByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetStockEntryByUuidRequest(soap, "g2ba:getStockEntryByUuidRequest", -1, &a->g2ba__getStockEntryByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryByUuidRequest * FASTCALL soap_in___g2b__getStockEntryByUuidRequest(struct soap *soap, const char *tag, struct __g2b__getStockEntryByUuidRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getStockEntryByUuidRequest = 1;
	short soap_flag;
	a = (struct __g2b__getStockEntryByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getStockEntryByUuidRequest, sizeof(struct __g2b__getStockEntryByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getStockEntryByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getStockEntryByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetStockEntryByUuidRequest(soap, "g2ba:getStockEntryByUuidRequest", &a->g2ba__getStockEntryByUuidRequest, "g2ba:GetStockEntryByUuidRequest"))
				{	soap_flag_g2ba__getStockEntryByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getStockEntryByUuidRequest(struct soap *soap, const struct __g2b__getStockEntryByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getStockEntryByUuidRequest(soap, tag?tag:"-g2b:getStockEntryByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryByUuidRequest * SOAP_FMAC4 soap_get___g2b__getStockEntryByUuidRequest(struct soap *soap, struct __g2b__getStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getStockEntryByUuidRequest * FASTCALL soap_instantiate___g2b__getStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getStockEntryByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getStockEntryByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getStockEntryByUuidRequest %p -> %p\n", q, p));
	*(struct __g2b__getStockEntryByUuidRequest*)p = *(struct __g2b__getStockEntryByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getStockEntryByGuidRequest(struct soap *soap, struct __g2b__getStockEntryByGuidRequest *a)
{
	a->g2ba__getStockEntryByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getStockEntryByGuidRequest(struct soap *soap, const struct __g2b__getStockEntryByGuidRequest *a)
{
	soap_serialize_PointerTog2ba__GetStockEntryByGuidRequest(soap, &a->g2ba__getStockEntryByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getStockEntryByGuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetStockEntryByGuidRequest(soap, "g2ba:getStockEntryByGuidRequest", -1, &a->g2ba__getStockEntryByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryByGuidRequest * FASTCALL soap_in___g2b__getStockEntryByGuidRequest(struct soap *soap, const char *tag, struct __g2b__getStockEntryByGuidRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getStockEntryByGuidRequest = 1;
	short soap_flag;
	a = (struct __g2b__getStockEntryByGuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getStockEntryByGuidRequest, sizeof(struct __g2b__getStockEntryByGuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getStockEntryByGuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getStockEntryByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetStockEntryByGuidRequest(soap, "g2ba:getStockEntryByGuidRequest", &a->g2ba__getStockEntryByGuidRequest, "g2ba:GetStockEntryByGuidRequest"))
				{	soap_flag_g2ba__getStockEntryByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getStockEntryByGuidRequest(struct soap *soap, const struct __g2b__getStockEntryByGuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getStockEntryByGuidRequest(soap, tag?tag:"-g2b:getStockEntryByGuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getStockEntryByGuidRequest * SOAP_FMAC4 soap_get___g2b__getStockEntryByGuidRequest(struct soap *soap, struct __g2b__getStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getStockEntryByGuidRequest * FASTCALL soap_instantiate___g2b__getStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getStockEntryByGuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getStockEntryByGuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getStockEntryByGuidRequest %p -> %p\n", q, p));
	*(struct __g2b__getStockEntryByGuidRequest*)p = *(struct __g2b__getStockEntryByGuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getVetDocumentChangesListRequest(struct soap *soap, struct __g2b__getVetDocumentChangesListRequest *a)
{
	a->g2ba__getVetDocumentChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getVetDocumentChangesListRequest(struct soap *soap, const struct __g2b__getVetDocumentChangesListRequest *a)
{
	soap_serialize_PointerTog2ba__GetVetDocumentChangesListRequest(soap, &a->g2ba__getVetDocumentChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getVetDocumentChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetVetDocumentChangesListRequest(soap, "g2ba:getVetDocumentChangesListRequest", -1, &a->g2ba__getVetDocumentChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentChangesListRequest * FASTCALL soap_in___g2b__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, struct __g2b__getVetDocumentChangesListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getVetDocumentChangesListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getVetDocumentChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getVetDocumentChangesListRequest, sizeof(struct __g2b__getVetDocumentChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getVetDocumentChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getVetDocumentChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetVetDocumentChangesListRequest(soap, "g2ba:getVetDocumentChangesListRequest", &a->g2ba__getVetDocumentChangesListRequest, "g2ba:GetVetDocumentChangesListRequest"))
				{	soap_flag_g2ba__getVetDocumentChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getVetDocumentChangesListRequest(struct soap *soap, const struct __g2b__getVetDocumentChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getVetDocumentChangesListRequest(soap, tag?tag:"-g2b:getVetDocumentChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentChangesListRequest * SOAP_FMAC4 soap_get___g2b__getVetDocumentChangesListRequest(struct soap *soap, struct __g2b__getVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getVetDocumentChangesListRequest * FASTCALL soap_instantiate___g2b__getVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getVetDocumentChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getVetDocumentChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(struct __g2b__getVetDocumentChangesListRequest*)p = *(struct __g2b__getVetDocumentChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getVetDocumentListRequest(struct soap *soap, struct __g2b__getVetDocumentListRequest *a)
{
	a->g2ba__getVetDocumentListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getVetDocumentListRequest(struct soap *soap, const struct __g2b__getVetDocumentListRequest *a)
{
	soap_serialize_PointerTog2ba__GetVetDocumentListRequest(soap, &a->g2ba__getVetDocumentListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getVetDocumentListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getVetDocumentListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetVetDocumentListRequest(soap, "g2ba:getVetDocumentListRequest", -1, &a->g2ba__getVetDocumentListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentListRequest * FASTCALL soap_in___g2b__getVetDocumentListRequest(struct soap *soap, const char *tag, struct __g2b__getVetDocumentListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getVetDocumentListRequest = 1;
	short soap_flag;
	a = (struct __g2b__getVetDocumentListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getVetDocumentListRequest, sizeof(struct __g2b__getVetDocumentListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getVetDocumentListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getVetDocumentListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetVetDocumentListRequest(soap, "g2ba:getVetDocumentListRequest", &a->g2ba__getVetDocumentListRequest, "g2ba:GetVetDocumentListRequest"))
				{	soap_flag_g2ba__getVetDocumentListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getVetDocumentListRequest(struct soap *soap, const struct __g2b__getVetDocumentListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getVetDocumentListRequest(soap, tag?tag:"-g2b:getVetDocumentListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentListRequest * SOAP_FMAC4 soap_get___g2b__getVetDocumentListRequest(struct soap *soap, struct __g2b__getVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getVetDocumentListRequest * FASTCALL soap_instantiate___g2b__getVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getVetDocumentListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getVetDocumentListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getVetDocumentListRequest %p -> %p\n", q, p));
	*(struct __g2b__getVetDocumentListRequest*)p = *(struct __g2b__getVetDocumentListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__getVetDocumentByUuidRequest(struct soap *soap, struct __g2b__getVetDocumentByUuidRequest *a)
{
	a->g2ba__getVetDocumentByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__getVetDocumentByUuidRequest(struct soap *soap, const struct __g2b__getVetDocumentByUuidRequest *a)
{
	soap_serialize_PointerTog2ba__GetVetDocumentByUuidRequest(soap, &a->g2ba__getVetDocumentByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const struct __g2b__getVetDocumentByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__GetVetDocumentByUuidRequest(soap, "g2ba:getVetDocumentByUuidRequest", -1, &a->g2ba__getVetDocumentByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentByUuidRequest * FASTCALL soap_in___g2b__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, struct __g2b__getVetDocumentByUuidRequest *a, const char *type)
{
	size_t soap_flag_g2ba__getVetDocumentByUuidRequest = 1;
	short soap_flag;
	a = (struct __g2b__getVetDocumentByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__getVetDocumentByUuidRequest, sizeof(struct __g2b__getVetDocumentByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__getVetDocumentByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__getVetDocumentByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__GetVetDocumentByUuidRequest(soap, "g2ba:getVetDocumentByUuidRequest", &a->g2ba__getVetDocumentByUuidRequest, "g2ba:GetVetDocumentByUuidRequest"))
				{	soap_flag_g2ba__getVetDocumentByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__getVetDocumentByUuidRequest(struct soap *soap, const struct __g2b__getVetDocumentByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__getVetDocumentByUuidRequest(soap, tag?tag:"-g2b:getVetDocumentByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__getVetDocumentByUuidRequest * SOAP_FMAC4 soap_get___g2b__getVetDocumentByUuidRequest(struct soap *soap, struct __g2b__getVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__getVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__getVetDocumentByUuidRequest * FASTCALL soap_instantiate___g2b__getVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__getVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__getVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__getVetDocumentByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__getVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__getVetDocumentByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__getVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__getVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__getVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(struct __g2b__getVetDocumentByUuidRequest*)p = *(struct __g2b__getVetDocumentByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__modifyProducerStockListRequest(struct soap *soap, struct __g2b__modifyProducerStockListRequest *a)
{
	a->g2ba__modifyProducerStockListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__modifyProducerStockListRequest(struct soap *soap, const struct __g2b__modifyProducerStockListRequest *a)
{
	soap_serialize_PointerTog2ba__ModifyProducerStockListRequest(soap, &a->g2ba__modifyProducerStockListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__modifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const struct __g2b__modifyProducerStockListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ModifyProducerStockListRequest(soap, "g2ba:modifyProducerStockListRequest", -1, &a->g2ba__modifyProducerStockListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyProducerStockListRequest * FASTCALL soap_in___g2b__modifyProducerStockListRequest(struct soap *soap, const char *tag, struct __g2b__modifyProducerStockListRequest *a, const char *type)
{
	size_t soap_flag_g2ba__modifyProducerStockListRequest = 1;
	short soap_flag;
	a = (struct __g2b__modifyProducerStockListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__modifyProducerStockListRequest, sizeof(struct __g2b__modifyProducerStockListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__modifyProducerStockListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__modifyProducerStockListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ModifyProducerStockListRequest(soap, "g2ba:modifyProducerStockListRequest", &a->g2ba__modifyProducerStockListRequest, "g2ba:ModifyProducerStockListRequest"))
				{	soap_flag_g2ba__modifyProducerStockListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__modifyProducerStockListRequest(struct soap *soap, const struct __g2b__modifyProducerStockListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__modifyProducerStockListRequest(soap, tag?tag:"-g2b:modifyProducerStockListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyProducerStockListRequest * SOAP_FMAC4 soap_get___g2b__modifyProducerStockListRequest(struct soap *soap, struct __g2b__modifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__modifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__modifyProducerStockListRequest * FASTCALL soap_instantiate___g2b__modifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__modifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__modifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__modifyProducerStockListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__modifyProducerStockListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__modifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__modifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__modifyProducerStockListRequest %p -> %p\n", q, p));
	*(struct __g2b__modifyProducerStockListRequest*)p = *(struct __g2b__modifyProducerStockListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__resolveDiscrepancyRequest(struct soap *soap, struct __g2b__resolveDiscrepancyRequest *a)
{
	a->g2ba__resolveDiscrepancyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__resolveDiscrepancyRequest(struct soap *soap, const struct __g2b__resolveDiscrepancyRequest *a)
{
	soap_serialize_PointerTog2ba__ResolveDiscrepancyRequest(soap, &a->g2ba__resolveDiscrepancyRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__resolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const struct __g2b__resolveDiscrepancyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ResolveDiscrepancyRequest(soap, "g2ba:resolveDiscrepancyRequest", -1, &a->g2ba__resolveDiscrepancyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__resolveDiscrepancyRequest * FASTCALL soap_in___g2b__resolveDiscrepancyRequest(struct soap *soap, const char *tag, struct __g2b__resolveDiscrepancyRequest *a, const char *type)
{
	size_t soap_flag_g2ba__resolveDiscrepancyRequest = 1;
	short soap_flag;
	a = (struct __g2b__resolveDiscrepancyRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__resolveDiscrepancyRequest, sizeof(struct __g2b__resolveDiscrepancyRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__resolveDiscrepancyRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__resolveDiscrepancyRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ResolveDiscrepancyRequest(soap, "g2ba:resolveDiscrepancyRequest", &a->g2ba__resolveDiscrepancyRequest, "g2ba:ResolveDiscrepancyRequest"))
				{	soap_flag_g2ba__resolveDiscrepancyRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__resolveDiscrepancyRequest(struct soap *soap, const struct __g2b__resolveDiscrepancyRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__resolveDiscrepancyRequest(soap, tag?tag:"-g2b:resolveDiscrepancyRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__resolveDiscrepancyRequest * SOAP_FMAC4 soap_get___g2b__resolveDiscrepancyRequest(struct soap *soap, struct __g2b__resolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__resolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__resolveDiscrepancyRequest * FASTCALL soap_instantiate___g2b__resolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__resolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__resolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__resolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__resolveDiscrepancyRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__resolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__resolveDiscrepancyRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__resolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__resolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__resolveDiscrepancyRequest %p -> %p\n", q, p));
	*(struct __g2b__resolveDiscrepancyRequest*)p = *(struct __g2b__resolveDiscrepancyRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__modifyActivityLocationsRequest(struct soap *soap, struct __g2b__modifyActivityLocationsRequest *a)
{
	a->g2ba__modifyActivityLocationsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__modifyActivityLocationsRequest(struct soap *soap, const struct __g2b__modifyActivityLocationsRequest *a)
{
	soap_serialize_PointerTog2ba__ModifyActivityLocationsRequest(soap, &a->g2ba__modifyActivityLocationsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__modifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const struct __g2b__modifyActivityLocationsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ModifyActivityLocationsRequest(soap, "g2ba:modifyActivityLocationsRequest", -1, &a->g2ba__modifyActivityLocationsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyActivityLocationsRequest * FASTCALL soap_in___g2b__modifyActivityLocationsRequest(struct soap *soap, const char *tag, struct __g2b__modifyActivityLocationsRequest *a, const char *type)
{
	size_t soap_flag_g2ba__modifyActivityLocationsRequest = 1;
	short soap_flag;
	a = (struct __g2b__modifyActivityLocationsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__modifyActivityLocationsRequest, sizeof(struct __g2b__modifyActivityLocationsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__modifyActivityLocationsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__modifyActivityLocationsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ModifyActivityLocationsRequest(soap, "g2ba:modifyActivityLocationsRequest", &a->g2ba__modifyActivityLocationsRequest, "g2ba:ModifyActivityLocationsRequest"))
				{	soap_flag_g2ba__modifyActivityLocationsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__modifyActivityLocationsRequest(struct soap *soap, const struct __g2b__modifyActivityLocationsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__modifyActivityLocationsRequest(soap, tag?tag:"-g2b:modifyActivityLocationsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyActivityLocationsRequest * SOAP_FMAC4 soap_get___g2b__modifyActivityLocationsRequest(struct soap *soap, struct __g2b__modifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__modifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__modifyActivityLocationsRequest * FASTCALL soap_instantiate___g2b__modifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__modifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__modifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__modifyActivityLocationsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__modifyActivityLocationsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__modifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__modifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__modifyActivityLocationsRequest %p -> %p\n", q, p));
	*(struct __g2b__modifyActivityLocationsRequest*)p = *(struct __g2b__modifyActivityLocationsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__modifyEnterpriseRequest(struct soap *soap, struct __g2b__modifyEnterpriseRequest *a)
{
	a->g2ba__modifyEnterpriseRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__modifyEnterpriseRequest(struct soap *soap, const struct __g2b__modifyEnterpriseRequest *a)
{
	soap_serialize_PointerTog2ba__ModifyEnterpriseRequest(soap, &a->g2ba__modifyEnterpriseRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__modifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const struct __g2b__modifyEnterpriseRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ModifyEnterpriseRequest(soap, "g2ba:modifyEnterpriseRequest", -1, &a->g2ba__modifyEnterpriseRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyEnterpriseRequest * FASTCALL soap_in___g2b__modifyEnterpriseRequest(struct soap *soap, const char *tag, struct __g2b__modifyEnterpriseRequest *a, const char *type)
{
	size_t soap_flag_g2ba__modifyEnterpriseRequest = 1;
	short soap_flag;
	a = (struct __g2b__modifyEnterpriseRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__modifyEnterpriseRequest, sizeof(struct __g2b__modifyEnterpriseRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__modifyEnterpriseRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__modifyEnterpriseRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ModifyEnterpriseRequest(soap, "g2ba:modifyEnterpriseRequest", &a->g2ba__modifyEnterpriseRequest, "g2ba:ModifyEnterpriseRequest"))
				{	soap_flag_g2ba__modifyEnterpriseRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__modifyEnterpriseRequest(struct soap *soap, const struct __g2b__modifyEnterpriseRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__modifyEnterpriseRequest(soap, tag?tag:"-g2b:modifyEnterpriseRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyEnterpriseRequest * SOAP_FMAC4 soap_get___g2b__modifyEnterpriseRequest(struct soap *soap, struct __g2b__modifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__modifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__modifyEnterpriseRequest * FASTCALL soap_instantiate___g2b__modifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__modifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__modifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__modifyEnterpriseRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__modifyEnterpriseRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__modifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__modifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__modifyEnterpriseRequest %p -> %p\n", q, p));
	*(struct __g2b__modifyEnterpriseRequest*)p = *(struct __g2b__modifyEnterpriseRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__modifyBusinessEntityRequest(struct soap *soap, struct __g2b__modifyBusinessEntityRequest *a)
{
	a->g2ba__modifyBusinessEntityRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__modifyBusinessEntityRequest(struct soap *soap, const struct __g2b__modifyBusinessEntityRequest *a)
{
	soap_serialize_PointerTog2ba__ModifyBusinessEntityRequest(soap, &a->g2ba__modifyBusinessEntityRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__modifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const struct __g2b__modifyBusinessEntityRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ModifyBusinessEntityRequest(soap, "g2ba:modifyBusinessEntityRequest", -1, &a->g2ba__modifyBusinessEntityRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyBusinessEntityRequest * FASTCALL soap_in___g2b__modifyBusinessEntityRequest(struct soap *soap, const char *tag, struct __g2b__modifyBusinessEntityRequest *a, const char *type)
{
	size_t soap_flag_g2ba__modifyBusinessEntityRequest = 1;
	short soap_flag;
	a = (struct __g2b__modifyBusinessEntityRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__modifyBusinessEntityRequest, sizeof(struct __g2b__modifyBusinessEntityRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__modifyBusinessEntityRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__modifyBusinessEntityRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ModifyBusinessEntityRequest(soap, "g2ba:modifyBusinessEntityRequest", &a->g2ba__modifyBusinessEntityRequest, "g2ba:ModifyBusinessEntityRequest"))
				{	soap_flag_g2ba__modifyBusinessEntityRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__modifyBusinessEntityRequest(struct soap *soap, const struct __g2b__modifyBusinessEntityRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__modifyBusinessEntityRequest(soap, tag?tag:"-g2b:modifyBusinessEntityRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__modifyBusinessEntityRequest * SOAP_FMAC4 soap_get___g2b__modifyBusinessEntityRequest(struct soap *soap, struct __g2b__modifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__modifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__modifyBusinessEntityRequest * FASTCALL soap_instantiate___g2b__modifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__modifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__modifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__modifyBusinessEntityRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__modifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__modifyBusinessEntityRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__modifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__modifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__modifyBusinessEntityRequest %p -> %p\n", q, p));
	*(struct __g2b__modifyBusinessEntityRequest*)p = *(struct __g2b__modifyBusinessEntityRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__withdrawVetDocumentRequest(struct soap *soap, struct __g2b__withdrawVetDocumentRequest *a)
{
	a->g2ba__withdrawVetDocumentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__withdrawVetDocumentRequest(struct soap *soap, const struct __g2b__withdrawVetDocumentRequest *a)
{
	soap_serialize_PointerTog2ba__WithdrawVetDocumentRequest(soap, &a->g2ba__withdrawVetDocumentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__withdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const struct __g2b__withdrawVetDocumentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__WithdrawVetDocumentRequest(soap, "g2ba:withdrawVetDocumentRequest", -1, &a->g2ba__withdrawVetDocumentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__withdrawVetDocumentRequest * FASTCALL soap_in___g2b__withdrawVetDocumentRequest(struct soap *soap, const char *tag, struct __g2b__withdrawVetDocumentRequest *a, const char *type)
{
	size_t soap_flag_g2ba__withdrawVetDocumentRequest = 1;
	short soap_flag;
	a = (struct __g2b__withdrawVetDocumentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__withdrawVetDocumentRequest, sizeof(struct __g2b__withdrawVetDocumentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__withdrawVetDocumentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__withdrawVetDocumentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__WithdrawVetDocumentRequest(soap, "g2ba:withdrawVetDocumentRequest", &a->g2ba__withdrawVetDocumentRequest, "g2ba:WithdrawVetDocumentRequest"))
				{	soap_flag_g2ba__withdrawVetDocumentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__withdrawVetDocumentRequest(struct soap *soap, const struct __g2b__withdrawVetDocumentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__withdrawVetDocumentRequest(soap, tag?tag:"-g2b:withdrawVetDocumentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__withdrawVetDocumentRequest * SOAP_FMAC4 soap_get___g2b__withdrawVetDocumentRequest(struct soap *soap, struct __g2b__withdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__withdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__withdrawVetDocumentRequest * FASTCALL soap_instantiate___g2b__withdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__withdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__withdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__withdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__withdrawVetDocumentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__withdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__withdrawVetDocumentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__withdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__withdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__withdrawVetDocumentRequest %p -> %p\n", q, p));
	*(struct __g2b__withdrawVetDocumentRequest*)p = *(struct __g2b__withdrawVetDocumentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__mergeStockEntriesRequest(struct soap *soap, struct __g2b__mergeStockEntriesRequest *a)
{
	a->g2ba__mergeStockEntriesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__mergeStockEntriesRequest(struct soap *soap, const struct __g2b__mergeStockEntriesRequest *a)
{
	soap_serialize_PointerTog2ba__MergeStockEntriesRequest(soap, &a->g2ba__mergeStockEntriesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__mergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const struct __g2b__mergeStockEntriesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__MergeStockEntriesRequest(soap, "g2ba:mergeStockEntriesRequest", -1, &a->g2ba__mergeStockEntriesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__mergeStockEntriesRequest * FASTCALL soap_in___g2b__mergeStockEntriesRequest(struct soap *soap, const char *tag, struct __g2b__mergeStockEntriesRequest *a, const char *type)
{
	size_t soap_flag_g2ba__mergeStockEntriesRequest = 1;
	short soap_flag;
	a = (struct __g2b__mergeStockEntriesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__mergeStockEntriesRequest, sizeof(struct __g2b__mergeStockEntriesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__mergeStockEntriesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__mergeStockEntriesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__MergeStockEntriesRequest(soap, "g2ba:mergeStockEntriesRequest", &a->g2ba__mergeStockEntriesRequest, "g2ba:MergeStockEntriesRequest"))
				{	soap_flag_g2ba__mergeStockEntriesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__mergeStockEntriesRequest(struct soap *soap, const struct __g2b__mergeStockEntriesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__mergeStockEntriesRequest(soap, tag?tag:"-g2b:mergeStockEntriesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__mergeStockEntriesRequest * SOAP_FMAC4 soap_get___g2b__mergeStockEntriesRequest(struct soap *soap, struct __g2b__mergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__mergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__mergeStockEntriesRequest * FASTCALL soap_instantiate___g2b__mergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__mergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__mergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__mergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__mergeStockEntriesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__mergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__mergeStockEntriesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__mergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__mergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__mergeStockEntriesRequest %p -> %p\n", q, p));
	*(struct __g2b__mergeStockEntriesRequest*)p = *(struct __g2b__mergeStockEntriesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__registerProductionOperationRequest(struct soap *soap, struct __g2b__registerProductionOperationRequest *a)
{
	a->g2ba__registerProductionOperationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__registerProductionOperationRequest(struct soap *soap, const struct __g2b__registerProductionOperationRequest *a)
{
	soap_serialize_PointerTog2ba__RegisterProductionOperationRequest(soap, &a->g2ba__registerProductionOperationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__registerProductionOperationRequest(struct soap *soap, const char *tag, int id, const struct __g2b__registerProductionOperationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__RegisterProductionOperationRequest(soap, "g2ba:registerProductionOperationRequest", -1, &a->g2ba__registerProductionOperationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__registerProductionOperationRequest * FASTCALL soap_in___g2b__registerProductionOperationRequest(struct soap *soap, const char *tag, struct __g2b__registerProductionOperationRequest *a, const char *type)
{
	size_t soap_flag_g2ba__registerProductionOperationRequest = 1;
	short soap_flag;
	a = (struct __g2b__registerProductionOperationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__registerProductionOperationRequest, sizeof(struct __g2b__registerProductionOperationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__registerProductionOperationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__registerProductionOperationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__RegisterProductionOperationRequest(soap, "g2ba:registerProductionOperationRequest", &a->g2ba__registerProductionOperationRequest, "g2ba:RegisterProductionOperationRequest"))
				{	soap_flag_g2ba__registerProductionOperationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__registerProductionOperationRequest(struct soap *soap, const struct __g2b__registerProductionOperationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__registerProductionOperationRequest(soap, tag?tag:"-g2b:registerProductionOperationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__registerProductionOperationRequest * SOAP_FMAC4 soap_get___g2b__registerProductionOperationRequest(struct soap *soap, struct __g2b__registerProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__registerProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__registerProductionOperationRequest * FASTCALL soap_instantiate___g2b__registerProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__registerProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__registerProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__registerProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__registerProductionOperationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__registerProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__registerProductionOperationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__registerProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__registerProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__registerProductionOperationRequest %p -> %p\n", q, p));
	*(struct __g2b__registerProductionOperationRequest*)p = *(struct __g2b__registerProductionOperationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, struct __g2b__prepareOutgoingConsignmentRequest *a)
{
	a->g2ba__prepareOutgoingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __g2b__prepareOutgoingConsignmentRequest *a)
{
	soap_serialize_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, &a->g2ba__prepareOutgoingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __g2b__prepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, "g2ba:prepareOutgoingConsignmentRequest", -1, &a->g2ba__prepareOutgoingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__prepareOutgoingConsignmentRequest * FASTCALL soap_in___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, struct __g2b__prepareOutgoingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_g2ba__prepareOutgoingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __g2b__prepareOutgoingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__prepareOutgoingConsignmentRequest, sizeof(struct __g2b__prepareOutgoingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__prepareOutgoingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__prepareOutgoingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, "g2ba:prepareOutgoingConsignmentRequest", &a->g2ba__prepareOutgoingConsignmentRequest, "g2ba:PrepareOutgoingConsignmentRequest"))
				{	soap_flag_g2ba__prepareOutgoingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __g2b__prepareOutgoingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__prepareOutgoingConsignmentRequest(soap, tag?tag:"-g2b:prepareOutgoingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__prepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, struct __g2b__prepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__prepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__prepareOutgoingConsignmentRequest * FASTCALL soap_instantiate___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__prepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__prepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__prepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__prepareOutgoingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__prepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__prepareOutgoingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__prepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__prepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__prepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(struct __g2b__prepareOutgoingConsignmentRequest*)p = *(struct __g2b__prepareOutgoingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___g2b__processIncomingConsignmentRequest(struct soap *soap, struct __g2b__processIncomingConsignmentRequest *a)
{
	a->g2ba__processIncomingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___g2b__processIncomingConsignmentRequest(struct soap *soap, const struct __g2b__processIncomingConsignmentRequest *a)
{
	soap_serialize_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, &a->g2ba__processIncomingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___g2b__processIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __g2b__processIncomingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, "g2ba:processIncomingConsignmentRequest", -1, &a->g2ba__processIncomingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __g2b__processIncomingConsignmentRequest * FASTCALL soap_in___g2b__processIncomingConsignmentRequest(struct soap *soap, const char *tag, struct __g2b__processIncomingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_g2ba__processIncomingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __g2b__processIncomingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___g2b__processIncomingConsignmentRequest, sizeof(struct __g2b__processIncomingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___g2b__processIncomingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_g2ba__processIncomingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, "g2ba:processIncomingConsignmentRequest", &a->g2ba__processIncomingConsignmentRequest, "g2ba:ProcessIncomingConsignmentRequest"))
				{	soap_flag_g2ba__processIncomingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___g2b__processIncomingConsignmentRequest(struct soap *soap, const struct __g2b__processIncomingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___g2b__processIncomingConsignmentRequest(soap, tag?tag:"-g2b:processIncomingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __g2b__processIncomingConsignmentRequest * SOAP_FMAC4 soap_get___g2b__processIncomingConsignmentRequest(struct soap *soap, struct __g2b__processIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___g2b__processIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __g2b__processIncomingConsignmentRequest * FASTCALL soap_instantiate___g2b__processIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___g2b__processIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___g2b__processIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__processIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __g2b__processIncomingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __g2b__processIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __g2b__processIncomingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __g2b__processIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___g2b__processIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __g2b__processIncomingConsignmentRequest %p -> %p\n", q, p));
	*(struct __g2b__processIncomingConsignmentRequest*)p = *(struct __g2b__processIncomingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___apps__receiveApplicationResult(struct soap *soap, struct __apps__receiveApplicationResult *a)
{
	a->ws__receiveApplicationResultRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___apps__receiveApplicationResult(struct soap *soap, const struct __apps__receiveApplicationResult *a)
{
	soap_serialize_PointerTo_ws__receiveApplicationResultRequest(soap, &a->ws__receiveApplicationResultRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___apps__receiveApplicationResult(struct soap *soap, const char *tag, int id, const struct __apps__receiveApplicationResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, "ws:receiveApplicationResultRequest", -1, &a->ws__receiveApplicationResultRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __apps__receiveApplicationResult * FASTCALL soap_in___apps__receiveApplicationResult(struct soap *soap, const char *tag, struct __apps__receiveApplicationResult *a, const char *type)
{
	size_t soap_flag_ws__receiveApplicationResultRequest = 1;
	short soap_flag;
	a = (struct __apps__receiveApplicationResult *)soap_id_enter(soap, "", a, SOAP_TYPE___apps__receiveApplicationResult, sizeof(struct __apps__receiveApplicationResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___apps__receiveApplicationResult(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ws__receiveApplicationResultRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, "ws:receiveApplicationResultRequest", &a->ws__receiveApplicationResultRequest, ""))
				{	soap_flag_ws__receiveApplicationResultRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___apps__receiveApplicationResult(struct soap *soap, const struct __apps__receiveApplicationResult *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___apps__receiveApplicationResult(soap, tag?tag:"-apps:receiveApplicationResult", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __apps__receiveApplicationResult * SOAP_FMAC4 soap_get___apps__receiveApplicationResult(struct soap *soap, struct __apps__receiveApplicationResult *p, const char *tag, const char *type)
{
	if((p = soap_in___apps__receiveApplicationResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __apps__receiveApplicationResult * FASTCALL soap_instantiate___apps__receiveApplicationResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___apps__receiveApplicationResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___apps__receiveApplicationResult, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __apps__receiveApplicationResult);
		ASSIGN_PTR(size, sizeof(struct __apps__receiveApplicationResult));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __apps__receiveApplicationResult[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __apps__receiveApplicationResult));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __apps__receiveApplicationResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___apps__receiveApplicationResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __apps__receiveApplicationResult %p -> %p\n", q, p));
	*(struct __apps__receiveApplicationResult*)p = *(struct __apps__receiveApplicationResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___apps__submitApplicationRequest(struct soap *soap, struct __apps__submitApplicationRequest *a)
{
	a->ws__submitApplicationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___apps__submitApplicationRequest(struct soap *soap, const struct __apps__submitApplicationRequest *a)
{
	soap_serialize_PointerTo_ws__submitApplicationRequest(soap, &a->ws__submitApplicationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___apps__submitApplicationRequest(struct soap *soap, const char *tag, int id, const struct __apps__submitApplicationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ws__submitApplicationRequest(soap, "ws:submitApplicationRequest", -1, &a->ws__submitApplicationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __apps__submitApplicationRequest * FASTCALL soap_in___apps__submitApplicationRequest(struct soap *soap, const char *tag, struct __apps__submitApplicationRequest *a, const char *type)
{
	size_t soap_flag_ws__submitApplicationRequest = 1;
	short soap_flag;
	a = (struct __apps__submitApplicationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___apps__submitApplicationRequest, sizeof(struct __apps__submitApplicationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___apps__submitApplicationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ws__submitApplicationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ws__submitApplicationRequest(soap, "ws:submitApplicationRequest", &a->ws__submitApplicationRequest, ""))
				{	soap_flag_ws__submitApplicationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___apps__submitApplicationRequest(struct soap *soap, const struct __apps__submitApplicationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___apps__submitApplicationRequest(soap, tag?tag:"-apps:submitApplicationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __apps__submitApplicationRequest * SOAP_FMAC4 soap_get___apps__submitApplicationRequest(struct soap *soap, struct __apps__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___apps__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __apps__submitApplicationRequest * FASTCALL soap_instantiate___apps__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___apps__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___apps__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __apps__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(struct __apps__submitApplicationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __apps__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __apps__submitApplicationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __apps__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___apps__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __apps__submitApplicationRequest %p -> %p\n", q, p));
	*(struct __apps__submitApplicationRequest*)p = *(struct __apps__submitApplicationRequest*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__any = NULL;
	a->ns2__accessDeniedFault = NULL;
	a->ns2__entityNotFoundFault = NULL;
	a->ns2__incorrectRequestFault = NULL;
	a->ns2__internalServiceFault = NULL;
	a->ws__unknownServiceIdFault = NULL;
	a->ws__unsupportedApplicationDataTypeFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__accessDeniedFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__entityNotFoundFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__incorrectRequestFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__internalServiceFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ws__unknownServiceIdFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ws__unsupportedApplicationDataTypeFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:accessDeniedFault", -1, &a->ns2__accessDeniedFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:entityNotFoundFault", -1, &a->ns2__entityNotFoundFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:incorrectRequestFault", -1, &a->ns2__incorrectRequestFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:internalServiceFault", -1, &a->ns2__internalServiceFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ws:unknownServiceIdFault", -1, &a->ws__unknownServiceIdFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ws:unsupportedApplicationDataTypeFault", -1, &a->ws__unsupportedApplicationDataTypeFault, ""))
		return soap->error;
	if(soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * FASTCALL soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns2__accessDeniedFault = 1;
	size_t soap_flag_ns2__entityNotFoundFault = 1;
	size_t soap_flag_ns2__incorrectRequestFault = 1;
	size_t soap_flag_ns2__internalServiceFault = 1;
	size_t soap_flag_ws__unknownServiceIdFault = 1;
	size_t soap_flag_ws__unsupportedApplicationDataTypeFault = 1;
	size_t soap_flag_fault = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns2__accessDeniedFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:accessDeniedFault", &a->ns2__accessDeniedFault, "base:FaultInfo"))
				{	soap_flag_ns2__accessDeniedFault--;
					continue;
				}
			if(soap_flag_ns2__entityNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:entityNotFoundFault", &a->ns2__entityNotFoundFault, "base:FaultInfo"))
				{	soap_flag_ns2__entityNotFoundFault--;
					continue;
				}
			if(soap_flag_ns2__incorrectRequestFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:incorrectRequestFault", &a->ns2__incorrectRequestFault, "base:FaultInfo"))
				{	soap_flag_ns2__incorrectRequestFault--;
					continue;
				}
			if(soap_flag_ns2__internalServiceFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:internalServiceFault", &a->ns2__internalServiceFault, "base:FaultInfo"))
				{	soap_flag_ns2__internalServiceFault--;
					continue;
				}
			if(soap_flag_ws__unknownServiceIdFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ws:unknownServiceIdFault", &a->ws__unknownServiceIdFault, "base:FaultInfo"))
				{	soap_flag_ws__unknownServiceIdFault--;
					continue;
				}
			if(soap_flag_ws__unsupportedApplicationDataTypeFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ws:unsupportedApplicationDataTypeFault", &a->ws__unsupportedApplicationDataTypeFault, "base:FaultInfo"))
				{	soap_flag_ws__unsupportedApplicationDataTypeFault--;
					continue;
				}
			if(soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if(soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	return soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * FASTCALL soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Detail));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Detail));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_VetDocument(struct soap *soap, int choice, const union _vd__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VetDocument_certifiedBatch:
		soap_serialize_PointerTovd__CertifiedBatch(soap, &a->certifiedBatch);
		break;
	case SOAP_UNION__vd__union_VetDocument_certifiedConsignment:
		soap_serialize_PointerTovd__CertifiedConsignment(soap, &a->certifiedConsignment);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_VetDocument(struct soap *soap, int choice, const union _vd__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VetDocument_certifiedBatch:
		return soap_out_PointerTovd__CertifiedBatch(soap, "vd:certifiedBatch", -1, &a->certifiedBatch, "");
	case SOAP_UNION__vd__union_VetDocument_certifiedConsignment:
		return soap_out_PointerTovd__CertifiedConsignment(soap, "vd:certifiedConsignment", -1, &a->certifiedConsignment, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_VetDocument * FASTCALL soap_in__vd__union_VetDocument(struct soap *soap, int *choice, union _vd__union_VetDocument *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->certifiedBatch = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTovd__CertifiedBatch(soap, "vd:certifiedBatch", &a->certifiedBatch, "vd:CertifiedBatch"))
	{	*choice = SOAP_UNION__vd__union_VetDocument_certifiedBatch;
		return a;
	}
	a->certifiedConsignment = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTovd__CertifiedConsignment(soap, "vd:certifiedConsignment", &a->certifiedConsignment, "vd:CertifiedConsignment"))
	{	*choice = SOAP_UNION__vd__union_VetDocument_certifiedConsignment;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_User(struct soap *soap, int choice, const union _vd__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_User_organization:
		soap_serialize_PointerTodic__Organization(soap, &a->organization);
		break;
	case SOAP_UNION__vd__union_User_businessEntity:
		soap_serialize_PointerTodic__BusinessEntity(soap, &a->businessEntity);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_User(struct soap *soap, int choice, const union _vd__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_User_organization:
		return soap_out_PointerTodic__Organization(soap, "vd:organization", -1, &a->organization, "");
	case SOAP_UNION__vd__union_User_businessEntity:
		return soap_out_PointerTodic__BusinessEntity(soap, "vd:businessEntity", -1, &a->businessEntity, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_User * FASTCALL soap_in__vd__union_User(struct soap *soap, int *choice, union _vd__union_User *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->organization = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Organization(soap, "vd:organization", &a->organization, "dic:Organization"))
	{	*choice = SOAP_UNION__vd__union_User_organization;
		return a;
	}
	a->businessEntity = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__BusinessEntity(soap, "vd:businessEntity", &a->businessEntity, "dic:BusinessEntity"))
	{	*choice = SOAP_UNION__vd__union_User_businessEntity;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _vd__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator:
		soap_serialize_PointerTodic__Indicator(soap, &a->indicator);
		break;
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__disease:
		soap_serialize_PointerTodic__AnimalDisease(soap, &a->disease);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _vd__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator:
		return soap_out_PointerTodic__Indicator(soap, "vd:indicator", -1, &a->indicator, "");
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__disease:
		return soap_out_PointerTodic__AnimalDisease(soap, "vd:disease", -1, &a->disease, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_LaboratoryResearchEvent_ * FASTCALL soap_in__vd__union_LaboratoryResearchEvent_(struct soap *soap, int *choice, union _vd__union_LaboratoryResearchEvent_ *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->indicator = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Indicator(soap, "vd:indicator", &a->indicator, "dic:Indicator"))
	{	*choice = SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator;
		return a;
	}
	a->disease = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__AnimalDisease(soap, "vd:disease", &a->disease, "dic:AnimalDisease"))
	{	*choice = SOAP_UNION__vd__union_LaboratoryResearchEvent__disease;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _vd__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_ShipmentRoutePoint_location:
		soap_serialize_PointerTodic__Location(soap, &a->location);
		break;
	case SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise:
		soap_serialize_PointerTodic__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _vd__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_ShipmentRoutePoint_location:
		return soap_out_PointerTodic__Location(soap, "vd:location", -1, &a->location, "");
	case SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise:
		return soap_out_PointerTodic__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_ShipmentRoutePoint * FASTCALL soap_in__vd__union_ShipmentRoutePoint(struct soap *soap, int *choice, union _vd__union_ShipmentRoutePoint *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Location(soap, "vd:location", &a->location, "dic:Location"))
	{	*choice = SOAP_UNION__vd__union_ShipmentRoutePoint_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Enterprise(soap, "vd:enterprise", &a->enterprise, "dic:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_WorkingArea(struct soap *soap, int choice, const union _vd__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_WorkingArea_area:
		soap_serialize_PointerTodic__Area(soap, &a->area);
		break;
	case SOAP_UNION__vd__union_WorkingArea_enterprise:
		soap_serialize_PointerTodic__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_WorkingArea(struct soap *soap, int choice, const union _vd__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_WorkingArea_area:
		return soap_out_PointerTodic__Area(soap, "vd:area", -1, &a->area, "");
	case SOAP_UNION__vd__union_WorkingArea_enterprise:
		return soap_out_PointerTodic__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_WorkingArea * FASTCALL soap_in__vd__union_WorkingArea(struct soap *soap, int *choice, union _vd__union_WorkingArea *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->area = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Area(soap, "vd:area", &a->area, "dic:Area"))
	{	*choice = SOAP_UNION__vd__union_WorkingArea_area;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Enterprise(soap, "vd:enterprise", &a->enterprise, "dic:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_WorkingArea_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_VeterinaryEvent(struct soap *soap, int choice, const union _vd__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VeterinaryEvent_location:
		soap_serialize_PointerTodic__Location(soap, &a->location);
		break;
	case SOAP_UNION__vd__union_VeterinaryEvent_enterprise:
		soap_serialize_PointerTodic__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_VeterinaryEvent(struct soap *soap, int choice, const union _vd__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VeterinaryEvent_location:
		return soap_out_PointerTodic__Location(soap, "vd:location", -1, &a->location, "");
	case SOAP_UNION__vd__union_VeterinaryEvent_enterprise:
		return soap_out_PointerTodic__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_VeterinaryEvent * FASTCALL soap_in__vd__union_VeterinaryEvent(struct soap *soap, int *choice, union _vd__union_VeterinaryEvent *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Location(soap, "vd:location", &a->location, "dic:Location"))
	{	*choice = SOAP_UNION__vd__union_VeterinaryEvent_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTodic__Enterprise(soap, "vd:enterprise", &a->enterprise, "dic:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_VeterinaryEvent_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** FASTCALL soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	return soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** FASTCALL soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	return soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** FASTCALL soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	return soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, g2ba__GetApplicableUserAuthorityListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, const char *tag, int id, g2ba__GetApplicableUserAuthorityListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListResponse ** FASTCALL soap_in_PointerTog2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, const char *tag, g2ba__GetApplicableUserAuthorityListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetApplicableUserAuthorityListResponse **)soap_malloc(soap, sizeof(g2ba__GetApplicableUserAuthorityListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetApplicableUserAuthorityListResponse *)soap_instantiate_g2ba__GetApplicableUserAuthorityListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetApplicableUserAuthorityListResponse ** p = (g2ba__GetApplicableUserAuthorityListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListResponse, sizeof(g2ba__GetApplicableUserAuthorityListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, g2ba__GetApplicableUserAuthorityListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListResponse);
	return soap_out_PointerTog2ba__GetApplicableUserAuthorityListResponse(soap, tag?tag:"g2ba:GetApplicableUserAuthorityListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetApplicableUserAuthorityListResponse(struct soap *soap, g2ba__GetApplicableUserAuthorityListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetApplicableUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, g2ba__GetApplicableUserAuthorityListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, int id, g2ba__GetApplicableUserAuthorityListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListRequest ** FASTCALL soap_in_PointerTog2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, const char *tag, g2ba__GetApplicableUserAuthorityListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetApplicableUserAuthorityListRequest **)soap_malloc(soap, sizeof(g2ba__GetApplicableUserAuthorityListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetApplicableUserAuthorityListRequest *)soap_instantiate_g2ba__GetApplicableUserAuthorityListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetApplicableUserAuthorityListRequest ** p = (g2ba__GetApplicableUserAuthorityListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetApplicableUserAuthorityListRequest, sizeof(g2ba__GetApplicableUserAuthorityListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, g2ba__GetApplicableUserAuthorityListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetApplicableUserAuthorityListRequest);
	return soap_out_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, tag?tag:"g2ba:GetApplicableUserAuthorityListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetApplicableUserAuthorityListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetApplicableUserAuthorityListRequest(struct soap *soap, g2ba__GetApplicableUserAuthorityListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetApplicableUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UnbindBusinessEntityUserResponse(struct soap *soap, g2ba__UnbindBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, g2ba__UnbindBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserResponse ** FASTCALL soap_in_PointerTog2ba__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__UnbindBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UnbindBusinessEntityUserResponse **)soap_malloc(soap, sizeof(g2ba__UnbindBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UnbindBusinessEntityUserResponse *)soap_instantiate_g2ba__UnbindBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UnbindBusinessEntityUserResponse ** p = (g2ba__UnbindBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserResponse, sizeof(g2ba__UnbindBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UnbindBusinessEntityUserResponse(struct soap *soap, g2ba__UnbindBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserResponse);
	return soap_out_PointerTog2ba__UnbindBusinessEntityUserResponse(soap, tag?tag:"g2ba:UnbindBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__UnbindBusinessEntityUserResponse(struct soap *soap, g2ba__UnbindBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UnbindBusinessEntityUserRequest(struct soap *soap, g2ba__UnbindBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, g2ba__UnbindBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserRequest ** FASTCALL soap_in_PointerTog2ba__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__UnbindBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UnbindBusinessEntityUserRequest **)soap_malloc(soap, sizeof(g2ba__UnbindBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UnbindBusinessEntityUserRequest *)soap_instantiate_g2ba__UnbindBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UnbindBusinessEntityUserRequest ** p = (g2ba__UnbindBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UnbindBusinessEntityUserRequest, sizeof(g2ba__UnbindBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UnbindBusinessEntityUserRequest(struct soap *soap, g2ba__UnbindBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UnbindBusinessEntityUserRequest);
	return soap_out_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, tag?tag:"g2ba:UnbindBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UnbindBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__UnbindBusinessEntityUserRequest(struct soap *soap, g2ba__UnbindBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateUserWorkingAreasResponse(struct soap *soap, g2ba__UpdateUserWorkingAreasResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, g2ba__UpdateUserWorkingAreasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasResponse ** FASTCALL soap_in_PointerTog2ba__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, g2ba__UpdateUserWorkingAreasResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateUserWorkingAreasResponse **)soap_malloc(soap, sizeof(g2ba__UpdateUserWorkingAreasResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateUserWorkingAreasResponse *)soap_instantiate_g2ba__UpdateUserWorkingAreasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateUserWorkingAreasResponse ** p = (g2ba__UpdateUserWorkingAreasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasResponse, sizeof(g2ba__UpdateUserWorkingAreasResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateUserWorkingAreasResponse(struct soap *soap, g2ba__UpdateUserWorkingAreasResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasResponse);
	return soap_out_PointerTog2ba__UpdateUserWorkingAreasResponse(soap, tag?tag:"g2ba:UpdateUserWorkingAreasResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateUserWorkingAreasResponse(struct soap *soap, g2ba__UpdateUserWorkingAreasResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateUserWorkingAreasRequest(struct soap *soap, g2ba__UpdateUserWorkingAreasRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, g2ba__UpdateUserWorkingAreasRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasRequest ** FASTCALL soap_in_PointerTog2ba__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, g2ba__UpdateUserWorkingAreasRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateUserWorkingAreasRequest **)soap_malloc(soap, sizeof(g2ba__UpdateUserWorkingAreasRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateUserWorkingAreasRequest *)soap_instantiate_g2ba__UpdateUserWorkingAreasRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateUserWorkingAreasRequest ** p = (g2ba__UpdateUserWorkingAreasRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateUserWorkingAreasRequest, sizeof(g2ba__UpdateUserWorkingAreasRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateUserWorkingAreasRequest(struct soap *soap, g2ba__UpdateUserWorkingAreasRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateUserWorkingAreasRequest);
	return soap_out_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, tag?tag:"g2ba:UpdateUserWorkingAreasRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateUserWorkingAreasRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateUserWorkingAreasRequest(struct soap *soap, g2ba__UpdateUserWorkingAreasRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateUserAuthoritiesResponse(struct soap *soap, g2ba__UpdateUserAuthoritiesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, g2ba__UpdateUserAuthoritiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesResponse ** FASTCALL soap_in_PointerTog2ba__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, g2ba__UpdateUserAuthoritiesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateUserAuthoritiesResponse **)soap_malloc(soap, sizeof(g2ba__UpdateUserAuthoritiesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateUserAuthoritiesResponse *)soap_instantiate_g2ba__UpdateUserAuthoritiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateUserAuthoritiesResponse ** p = (g2ba__UpdateUserAuthoritiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesResponse, sizeof(g2ba__UpdateUserAuthoritiesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateUserAuthoritiesResponse(struct soap *soap, g2ba__UpdateUserAuthoritiesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesResponse);
	return soap_out_PointerTog2ba__UpdateUserAuthoritiesResponse(soap, tag?tag:"g2ba:UpdateUserAuthoritiesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateUserAuthoritiesResponse(struct soap *soap, g2ba__UpdateUserAuthoritiesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateUserAuthoritiesRequest(struct soap *soap, g2ba__UpdateUserAuthoritiesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, g2ba__UpdateUserAuthoritiesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesRequest ** FASTCALL soap_in_PointerTog2ba__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, g2ba__UpdateUserAuthoritiesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateUserAuthoritiesRequest **)soap_malloc(soap, sizeof(g2ba__UpdateUserAuthoritiesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateUserAuthoritiesRequest *)soap_instantiate_g2ba__UpdateUserAuthoritiesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateUserAuthoritiesRequest ** p = (g2ba__UpdateUserAuthoritiesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateUserAuthoritiesRequest, sizeof(g2ba__UpdateUserAuthoritiesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateUserAuthoritiesRequest(struct soap *soap, g2ba__UpdateUserAuthoritiesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateUserAuthoritiesRequest);
	return soap_out_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, tag?tag:"g2ba:UpdateUserAuthoritiesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateUserAuthoritiesRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateUserAuthoritiesRequest(struct soap *soap, g2ba__UpdateUserAuthoritiesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetBusinessEntityUserResponse(struct soap *soap, g2ba__GetBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, g2ba__GetBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserResponse ** FASTCALL soap_in_PointerTog2ba__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetBusinessEntityUserResponse **)soap_malloc(soap, sizeof(g2ba__GetBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetBusinessEntityUserResponse *)soap_instantiate_g2ba__GetBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetBusinessEntityUserResponse ** p = (g2ba__GetBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetBusinessEntityUserResponse, sizeof(g2ba__GetBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetBusinessEntityUserResponse(struct soap *soap, g2ba__GetBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserResponse);
	return soap_out_PointerTog2ba__GetBusinessEntityUserResponse(soap, tag?tag:"g2ba:GetBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetBusinessEntityUserResponse(struct soap *soap, g2ba__GetBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetBusinessEntityUserRequest(struct soap *soap, g2ba__GetBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, g2ba__GetBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserRequest ** FASTCALL soap_in_PointerTog2ba__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetBusinessEntityUserRequest **)soap_malloc(soap, sizeof(g2ba__GetBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetBusinessEntityUserRequest *)soap_instantiate_g2ba__GetBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetBusinessEntityUserRequest ** p = (g2ba__GetBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetBusinessEntityUserRequest, sizeof(g2ba__GetBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetBusinessEntityUserRequest(struct soap *soap, g2ba__GetBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserRequest);
	return soap_out_PointerTog2ba__GetBusinessEntityUserRequest(soap, tag?tag:"g2ba:GetBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetBusinessEntityUserRequest(struct soap *soap, g2ba__GetBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetBusinessEntityUserListResponse(struct soap *soap, g2ba__GetBusinessEntityUserListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, g2ba__GetBusinessEntityUserListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListResponse ** FASTCALL soap_in_PointerTog2ba__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetBusinessEntityUserListResponse **)soap_malloc(soap, sizeof(g2ba__GetBusinessEntityUserListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetBusinessEntityUserListResponse *)soap_instantiate_g2ba__GetBusinessEntityUserListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetBusinessEntityUserListResponse ** p = (g2ba__GetBusinessEntityUserListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetBusinessEntityUserListResponse, sizeof(g2ba__GetBusinessEntityUserListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetBusinessEntityUserListResponse(struct soap *soap, g2ba__GetBusinessEntityUserListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListResponse);
	return soap_out_PointerTog2ba__GetBusinessEntityUserListResponse(soap, tag?tag:"g2ba:GetBusinessEntityUserListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetBusinessEntityUserListResponse(struct soap *soap, g2ba__GetBusinessEntityUserListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetBusinessEntityUserListRequest(struct soap *soap, g2ba__GetBusinessEntityUserListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, g2ba__GetBusinessEntityUserListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListRequest ** FASTCALL soap_in_PointerTog2ba__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, g2ba__GetBusinessEntityUserListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetBusinessEntityUserListRequest **)soap_malloc(soap, sizeof(g2ba__GetBusinessEntityUserListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetBusinessEntityUserListRequest *)soap_instantiate_g2ba__GetBusinessEntityUserListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetBusinessEntityUserListRequest ** p = (g2ba__GetBusinessEntityUserListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetBusinessEntityUserListRequest, sizeof(g2ba__GetBusinessEntityUserListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetBusinessEntityUserListRequest(struct soap *soap, g2ba__GetBusinessEntityUserListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetBusinessEntityUserListRequest);
	return soap_out_PointerTog2ba__GetBusinessEntityUserListRequest(soap, tag?tag:"g2ba:GetBusinessEntityUserListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetBusinessEntityUserListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetBusinessEntityUserListRequest(struct soap *soap, g2ba__GetBusinessEntityUserListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__AddBusinessEntityUserResponse(struct soap *soap, g2ba__AddBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, g2ba__AddBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserResponse ** FASTCALL soap_in_PointerTog2ba__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, g2ba__AddBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__AddBusinessEntityUserResponse **)soap_malloc(soap, sizeof(g2ba__AddBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__AddBusinessEntityUserResponse *)soap_instantiate_g2ba__AddBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__AddBusinessEntityUserResponse ** p = (g2ba__AddBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__AddBusinessEntityUserResponse, sizeof(g2ba__AddBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__AddBusinessEntityUserResponse(struct soap *soap, g2ba__AddBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserResponse);
	return soap_out_PointerTog2ba__AddBusinessEntityUserResponse(soap, tag?tag:"g2ba:AddBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__AddBusinessEntityUserResponse(struct soap *soap, g2ba__AddBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__AddBusinessEntityUserRequest(struct soap *soap, g2ba__AddBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, g2ba__AddBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserRequest ** FASTCALL soap_in_PointerTog2ba__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, g2ba__AddBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__AddBusinessEntityUserRequest **)soap_malloc(soap, sizeof(g2ba__AddBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__AddBusinessEntityUserRequest *)soap_instantiate_g2ba__AddBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__AddBusinessEntityUserRequest ** p = (g2ba__AddBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__AddBusinessEntityUserRequest, sizeof(g2ba__AddBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__AddBusinessEntityUserRequest(struct soap *soap, g2ba__AddBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__AddBusinessEntityUserRequest);
	return soap_out_PointerTog2ba__AddBusinessEntityUserRequest(soap, tag?tag:"g2ba:AddBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__AddBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__AddBusinessEntityUserRequest(struct soap *soap, g2ba__AddBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__CheckShipmentRegionalizationResponse(struct soap *soap, g2ba__CheckShipmentRegionalizationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, g2ba__CheckShipmentRegionalizationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationResponse ** FASTCALL soap_in_PointerTog2ba__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, g2ba__CheckShipmentRegionalizationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__CheckShipmentRegionalizationResponse **)soap_malloc(soap, sizeof(g2ba__CheckShipmentRegionalizationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__CheckShipmentRegionalizationResponse *)soap_instantiate_g2ba__CheckShipmentRegionalizationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__CheckShipmentRegionalizationResponse ** p = (g2ba__CheckShipmentRegionalizationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationResponse, sizeof(g2ba__CheckShipmentRegionalizationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__CheckShipmentRegionalizationResponse(struct soap *soap, g2ba__CheckShipmentRegionalizationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationResponse);
	return soap_out_PointerTog2ba__CheckShipmentRegionalizationResponse(soap, tag?tag:"g2ba:CheckShipmentRegionalizationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__CheckShipmentRegionalizationResponse(struct soap *soap, g2ba__CheckShipmentRegionalizationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__CheckShipmentRegionalizationRequest(struct soap *soap, g2ba__CheckShipmentRegionalizationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, g2ba__CheckShipmentRegionalizationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationRequest ** FASTCALL soap_in_PointerTog2ba__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, g2ba__CheckShipmentRegionalizationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__CheckShipmentRegionalizationRequest **)soap_malloc(soap, sizeof(g2ba__CheckShipmentRegionalizationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__CheckShipmentRegionalizationRequest *)soap_instantiate_g2ba__CheckShipmentRegionalizationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__CheckShipmentRegionalizationRequest ** p = (g2ba__CheckShipmentRegionalizationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__CheckShipmentRegionalizationRequest, sizeof(g2ba__CheckShipmentRegionalizationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__CheckShipmentRegionalizationRequest(struct soap *soap, g2ba__CheckShipmentRegionalizationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__CheckShipmentRegionalizationRequest);
	return soap_out_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, tag?tag:"g2ba:CheckShipmentRegionalizationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__CheckShipmentRegionalizationRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__CheckShipmentRegionalizationRequest(struct soap *soap, g2ba__CheckShipmentRegionalizationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateVeterinaryEventsResponse(struct soap *soap, g2ba__UpdateVeterinaryEventsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, g2ba__UpdateVeterinaryEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsResponse ** FASTCALL soap_in_PointerTog2ba__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, g2ba__UpdateVeterinaryEventsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateVeterinaryEventsResponse **)soap_malloc(soap, sizeof(g2ba__UpdateVeterinaryEventsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateVeterinaryEventsResponse *)soap_instantiate_g2ba__UpdateVeterinaryEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateVeterinaryEventsResponse ** p = (g2ba__UpdateVeterinaryEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsResponse, sizeof(g2ba__UpdateVeterinaryEventsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateVeterinaryEventsResponse(struct soap *soap, g2ba__UpdateVeterinaryEventsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsResponse);
	return soap_out_PointerTog2ba__UpdateVeterinaryEventsResponse(soap, tag?tag:"g2ba:UpdateVeterinaryEventsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateVeterinaryEventsResponse(struct soap *soap, g2ba__UpdateVeterinaryEventsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateVeterinaryEventsRequest(struct soap *soap, g2ba__UpdateVeterinaryEventsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, g2ba__UpdateVeterinaryEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsRequest ** FASTCALL soap_in_PointerTog2ba__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, g2ba__UpdateVeterinaryEventsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateVeterinaryEventsRequest **)soap_malloc(soap, sizeof(g2ba__UpdateVeterinaryEventsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateVeterinaryEventsRequest *)soap_instantiate_g2ba__UpdateVeterinaryEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateVeterinaryEventsRequest ** p = (g2ba__UpdateVeterinaryEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateVeterinaryEventsRequest, sizeof(g2ba__UpdateVeterinaryEventsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateVeterinaryEventsRequest(struct soap *soap, g2ba__UpdateVeterinaryEventsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateVeterinaryEventsRequest);
	return soap_out_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, tag?tag:"g2ba:UpdateVeterinaryEventsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateVeterinaryEventsRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateVeterinaryEventsRequest(struct soap *soap, g2ba__UpdateVeterinaryEventsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, g2ba__UpdateTransportMovementDetailsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, g2ba__UpdateTransportMovementDetailsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsResponse ** FASTCALL soap_in_PointerTog2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, g2ba__UpdateTransportMovementDetailsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateTransportMovementDetailsResponse **)soap_malloc(soap, sizeof(g2ba__UpdateTransportMovementDetailsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateTransportMovementDetailsResponse *)soap_instantiate_g2ba__UpdateTransportMovementDetailsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateTransportMovementDetailsResponse ** p = (g2ba__UpdateTransportMovementDetailsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsResponse, sizeof(g2ba__UpdateTransportMovementDetailsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, g2ba__UpdateTransportMovementDetailsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsResponse);
	return soap_out_PointerTog2ba__UpdateTransportMovementDetailsResponse(soap, tag?tag:"g2ba:UpdateTransportMovementDetailsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateTransportMovementDetailsResponse(struct soap *soap, g2ba__UpdateTransportMovementDetailsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, g2ba__UpdateTransportMovementDetailsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, g2ba__UpdateTransportMovementDetailsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsRequest ** FASTCALL soap_in_PointerTog2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, g2ba__UpdateTransportMovementDetailsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__UpdateTransportMovementDetailsRequest **)soap_malloc(soap, sizeof(g2ba__UpdateTransportMovementDetailsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__UpdateTransportMovementDetailsRequest *)soap_instantiate_g2ba__UpdateTransportMovementDetailsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__UpdateTransportMovementDetailsRequest ** p = (g2ba__UpdateTransportMovementDetailsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__UpdateTransportMovementDetailsRequest, sizeof(g2ba__UpdateTransportMovementDetailsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, g2ba__UpdateTransportMovementDetailsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__UpdateTransportMovementDetailsRequest);
	return soap_out_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, tag?tag:"g2ba:UpdateTransportMovementDetailsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__UpdateTransportMovementDetailsRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__UpdateTransportMovementDetailsRequest(struct soap *soap, g2ba__UpdateTransportMovementDetailsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryVersionListResponse(struct soap *soap, g2ba__GetStockEntryVersionListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryVersionListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListResponse ** FASTCALL soap_in_PointerTog2ba__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryVersionListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryVersionListResponse **)soap_malloc(soap, sizeof(g2ba__GetStockEntryVersionListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryVersionListResponse *)soap_instantiate_g2ba__GetStockEntryVersionListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryVersionListResponse ** p = (g2ba__GetStockEntryVersionListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryVersionListResponse, sizeof(g2ba__GetStockEntryVersionListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryVersionListResponse(struct soap *soap, g2ba__GetStockEntryVersionListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListResponse);
	return soap_out_PointerTog2ba__GetStockEntryVersionListResponse(soap, tag?tag:"g2ba:GetStockEntryVersionListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryVersionListResponse(struct soap *soap, g2ba__GetStockEntryVersionListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryVersionListRequest(struct soap *soap, g2ba__GetStockEntryVersionListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryVersionListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListRequest ** FASTCALL soap_in_PointerTog2ba__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryVersionListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryVersionListRequest **)soap_malloc(soap, sizeof(g2ba__GetStockEntryVersionListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryVersionListRequest *)soap_instantiate_g2ba__GetStockEntryVersionListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryVersionListRequest ** p = (g2ba__GetStockEntryVersionListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryVersionListRequest, sizeof(g2ba__GetStockEntryVersionListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryVersionListRequest(struct soap *soap, g2ba__GetStockEntryVersionListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryVersionListRequest);
	return soap_out_PointerTog2ba__GetStockEntryVersionListRequest(soap, tag?tag:"g2ba:GetStockEntryVersionListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryVersionListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryVersionListRequest(struct soap *soap, g2ba__GetStockEntryVersionListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryChangesListResponse(struct soap *soap, g2ba__GetStockEntryChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListResponse ** FASTCALL soap_in_PointerTog2ba__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryChangesListResponse **)soap_malloc(soap, sizeof(g2ba__GetStockEntryChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryChangesListResponse *)soap_instantiate_g2ba__GetStockEntryChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryChangesListResponse ** p = (g2ba__GetStockEntryChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryChangesListResponse, sizeof(g2ba__GetStockEntryChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryChangesListResponse(struct soap *soap, g2ba__GetStockEntryChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListResponse);
	return soap_out_PointerTog2ba__GetStockEntryChangesListResponse(soap, tag?tag:"g2ba:GetStockEntryChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryChangesListResponse(struct soap *soap, g2ba__GetStockEntryChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryChangesListRequest(struct soap *soap, g2ba__GetStockEntryChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListRequest ** FASTCALL soap_in_PointerTog2ba__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryChangesListRequest **)soap_malloc(soap, sizeof(g2ba__GetStockEntryChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryChangesListRequest *)soap_instantiate_g2ba__GetStockEntryChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryChangesListRequest ** p = (g2ba__GetStockEntryChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryChangesListRequest, sizeof(g2ba__GetStockEntryChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryChangesListRequest(struct soap *soap, g2ba__GetStockEntryChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryChangesListRequest);
	return soap_out_PointerTog2ba__GetStockEntryChangesListRequest(soap, tag?tag:"g2ba:GetStockEntryChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryChangesListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryChangesListRequest(struct soap *soap, g2ba__GetStockEntryChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryListResponse(struct soap *soap, g2ba__GetStockEntryListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListResponse ** FASTCALL soap_in_PointerTog2ba__GetStockEntryListResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryListResponse **)soap_malloc(soap, sizeof(g2ba__GetStockEntryListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryListResponse *)soap_instantiate_g2ba__GetStockEntryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryListResponse ** p = (g2ba__GetStockEntryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryListResponse, sizeof(g2ba__GetStockEntryListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryListResponse(struct soap *soap, g2ba__GetStockEntryListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryListResponse);
	return soap_out_PointerTog2ba__GetStockEntryListResponse(soap, tag?tag:"g2ba:GetStockEntryListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryListResponse(struct soap *soap, g2ba__GetStockEntryListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryListRequest(struct soap *soap, g2ba__GetStockEntryListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryListRequest ** FASTCALL soap_in_PointerTog2ba__GetStockEntryListRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryListRequest **)soap_malloc(soap, sizeof(g2ba__GetStockEntryListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryListRequest *)soap_instantiate_g2ba__GetStockEntryListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryListRequest ** p = (g2ba__GetStockEntryListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryListRequest, sizeof(g2ba__GetStockEntryListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryListRequest(struct soap *soap, g2ba__GetStockEntryListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryListRequest);
	return soap_out_PointerTog2ba__GetStockEntryListRequest(soap, tag?tag:"g2ba:GetStockEntryListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryListRequest(struct soap *soap, g2ba__GetStockEntryListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryByUuidResponse(struct soap *soap, g2ba__GetStockEntryByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidResponse ** FASTCALL soap_in_PointerTog2ba__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryByUuidResponse **)soap_malloc(soap, sizeof(g2ba__GetStockEntryByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryByUuidResponse *)soap_instantiate_g2ba__GetStockEntryByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryByUuidResponse ** p = (g2ba__GetStockEntryByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryByUuidResponse, sizeof(g2ba__GetStockEntryByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryByUuidResponse(struct soap *soap, g2ba__GetStockEntryByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidResponse);
	return soap_out_PointerTog2ba__GetStockEntryByUuidResponse(soap, tag?tag:"g2ba:GetStockEntryByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryByUuidResponse(struct soap *soap, g2ba__GetStockEntryByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryByUuidRequest(struct soap *soap, g2ba__GetStockEntryByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidRequest ** FASTCALL soap_in_PointerTog2ba__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryByUuidRequest **)soap_malloc(soap, sizeof(g2ba__GetStockEntryByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryByUuidRequest *)soap_instantiate_g2ba__GetStockEntryByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryByUuidRequest ** p = (g2ba__GetStockEntryByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryByUuidRequest, sizeof(g2ba__GetStockEntryByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryByUuidRequest(struct soap *soap, g2ba__GetStockEntryByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryByUuidRequest);
	return soap_out_PointerTog2ba__GetStockEntryByUuidRequest(soap, tag?tag:"g2ba:GetStockEntryByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryByUuidRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryByUuidRequest(struct soap *soap, g2ba__GetStockEntryByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryByGuidResponse(struct soap *soap, g2ba__GetStockEntryByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidResponse ** FASTCALL soap_in_PointerTog2ba__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, g2ba__GetStockEntryByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryByGuidResponse **)soap_malloc(soap, sizeof(g2ba__GetStockEntryByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryByGuidResponse *)soap_instantiate_g2ba__GetStockEntryByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryByGuidResponse ** p = (g2ba__GetStockEntryByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryByGuidResponse, sizeof(g2ba__GetStockEntryByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryByGuidResponse(struct soap *soap, g2ba__GetStockEntryByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidResponse);
	return soap_out_PointerTog2ba__GetStockEntryByGuidResponse(soap, tag?tag:"g2ba:GetStockEntryByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryByGuidResponse(struct soap *soap, g2ba__GetStockEntryByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetStockEntryByGuidRequest(struct soap *soap, g2ba__GetStockEntryByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, g2ba__GetStockEntryByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidRequest ** FASTCALL soap_in_PointerTog2ba__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, g2ba__GetStockEntryByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetStockEntryByGuidRequest **)soap_malloc(soap, sizeof(g2ba__GetStockEntryByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetStockEntryByGuidRequest *)soap_instantiate_g2ba__GetStockEntryByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetStockEntryByGuidRequest ** p = (g2ba__GetStockEntryByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetStockEntryByGuidRequest, sizeof(g2ba__GetStockEntryByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetStockEntryByGuidRequest(struct soap *soap, g2ba__GetStockEntryByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetStockEntryByGuidRequest);
	return soap_out_PointerTog2ba__GetStockEntryByGuidRequest(soap, tag?tag:"g2ba:GetStockEntryByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetStockEntryByGuidRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetStockEntryByGuidRequest(struct soap *soap, g2ba__GetStockEntryByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentChangesListResponse(struct soap *soap, g2ba__GetVetDocumentChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListResponse ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentChangesListResponse **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentChangesListResponse *)soap_instantiate_g2ba__GetVetDocumentChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentChangesListResponse ** p = (g2ba__GetVetDocumentChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentChangesListResponse, sizeof(g2ba__GetVetDocumentChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentChangesListResponse(struct soap *soap, g2ba__GetVetDocumentChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListResponse);
	return soap_out_PointerTog2ba__GetVetDocumentChangesListResponse(soap, tag?tag:"g2ba:GetVetDocumentChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentChangesListResponse(struct soap *soap, g2ba__GetVetDocumentChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentChangesListRequest(struct soap *soap, g2ba__GetVetDocumentChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListRequest ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentChangesListRequest **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentChangesListRequest *)soap_instantiate_g2ba__GetVetDocumentChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentChangesListRequest ** p = (g2ba__GetVetDocumentChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentChangesListRequest, sizeof(g2ba__GetVetDocumentChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentChangesListRequest(struct soap *soap, g2ba__GetVetDocumentChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentChangesListRequest);
	return soap_out_PointerTog2ba__GetVetDocumentChangesListRequest(soap, tag?tag:"g2ba:GetVetDocumentChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentChangesListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentChangesListRequest(struct soap *soap, g2ba__GetVetDocumentChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentListResponse(struct soap *soap, g2ba__GetVetDocumentListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListResponse ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentListResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentListResponse **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentListResponse *)soap_instantiate_g2ba__GetVetDocumentListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentListResponse ** p = (g2ba__GetVetDocumentListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentListResponse, sizeof(g2ba__GetVetDocumentListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentListResponse(struct soap *soap, g2ba__GetVetDocumentListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentListResponse);
	return soap_out_PointerTog2ba__GetVetDocumentListResponse(soap, tag?tag:"g2ba:GetVetDocumentListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentListResponse(struct soap *soap, g2ba__GetVetDocumentListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentListRequest(struct soap *soap, g2ba__GetVetDocumentListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentListRequest ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentListRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentListRequest **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentListRequest *)soap_instantiate_g2ba__GetVetDocumentListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentListRequest ** p = (g2ba__GetVetDocumentListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentListRequest, sizeof(g2ba__GetVetDocumentListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentListRequest(struct soap *soap, g2ba__GetVetDocumentListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentListRequest);
	return soap_out_PointerTog2ba__GetVetDocumentListRequest(soap, tag?tag:"g2ba:GetVetDocumentListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentListRequest(struct soap *soap, g2ba__GetVetDocumentListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentByUuidResponse(struct soap *soap, g2ba__GetVetDocumentByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidResponse ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, g2ba__GetVetDocumentByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentByUuidResponse **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentByUuidResponse *)soap_instantiate_g2ba__GetVetDocumentByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentByUuidResponse ** p = (g2ba__GetVetDocumentByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentByUuidResponse, sizeof(g2ba__GetVetDocumentByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentByUuidResponse(struct soap *soap, g2ba__GetVetDocumentByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidResponse);
	return soap_out_PointerTog2ba__GetVetDocumentByUuidResponse(soap, tag?tag:"g2ba:GetVetDocumentByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentByUuidResponse(struct soap *soap, g2ba__GetVetDocumentByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__GetVetDocumentByUuidRequest(struct soap *soap, g2ba__GetVetDocumentByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, g2ba__GetVetDocumentByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidRequest ** FASTCALL soap_in_PointerTog2ba__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, g2ba__GetVetDocumentByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__GetVetDocumentByUuidRequest **)soap_malloc(soap, sizeof(g2ba__GetVetDocumentByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__GetVetDocumentByUuidRequest *)soap_instantiate_g2ba__GetVetDocumentByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__GetVetDocumentByUuidRequest ** p = (g2ba__GetVetDocumentByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__GetVetDocumentByUuidRequest, sizeof(g2ba__GetVetDocumentByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__GetVetDocumentByUuidRequest(struct soap *soap, g2ba__GetVetDocumentByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__GetVetDocumentByUuidRequest);
	return soap_out_PointerTog2ba__GetVetDocumentByUuidRequest(soap, tag?tag:"g2ba:GetVetDocumentByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__GetVetDocumentByUuidRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__GetVetDocumentByUuidRequest(struct soap *soap, g2ba__GetVetDocumentByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyProducerStockListResponse(struct soap *soap, g2ba__ModifyProducerStockListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyProducerStockListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, g2ba__ModifyProducerStockListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyProducerStockListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListResponse ** FASTCALL soap_in_PointerTog2ba__ModifyProducerStockListResponse(struct soap *soap, const char *tag, g2ba__ModifyProducerStockListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyProducerStockListResponse **)soap_malloc(soap, sizeof(g2ba__ModifyProducerStockListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyProducerStockListResponse *)soap_instantiate_g2ba__ModifyProducerStockListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyProducerStockListResponse ** p = (g2ba__ModifyProducerStockListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyProducerStockListResponse, sizeof(g2ba__ModifyProducerStockListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyProducerStockListResponse(struct soap *soap, g2ba__ModifyProducerStockListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyProducerStockListResponse);
	return soap_out_PointerTog2ba__ModifyProducerStockListResponse(soap, tag?tag:"g2ba:ModifyProducerStockListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyProducerStockListResponse(struct soap *soap, g2ba__ModifyProducerStockListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyProducerStockListRequest(struct soap *soap, g2ba__ModifyProducerStockListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyProducerStockListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, g2ba__ModifyProducerStockListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyProducerStockListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListRequest ** FASTCALL soap_in_PointerTog2ba__ModifyProducerStockListRequest(struct soap *soap, const char *tag, g2ba__ModifyProducerStockListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyProducerStockListRequest **)soap_malloc(soap, sizeof(g2ba__ModifyProducerStockListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyProducerStockListRequest *)soap_instantiate_g2ba__ModifyProducerStockListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyProducerStockListRequest ** p = (g2ba__ModifyProducerStockListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyProducerStockListRequest, sizeof(g2ba__ModifyProducerStockListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyProducerStockListRequest(struct soap *soap, g2ba__ModifyProducerStockListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyProducerStockListRequest);
	return soap_out_PointerTog2ba__ModifyProducerStockListRequest(soap, tag?tag:"g2ba:ModifyProducerStockListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyProducerStockListRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyProducerStockListRequest(struct soap *soap, g2ba__ModifyProducerStockListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ResolveDiscrepancyResponse(struct soap *soap, g2ba__ResolveDiscrepancyResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, g2ba__ResolveDiscrepancyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyResponse ** FASTCALL soap_in_PointerTog2ba__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, g2ba__ResolveDiscrepancyResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ResolveDiscrepancyResponse **)soap_malloc(soap, sizeof(g2ba__ResolveDiscrepancyResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ResolveDiscrepancyResponse *)soap_instantiate_g2ba__ResolveDiscrepancyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ResolveDiscrepancyResponse ** p = (g2ba__ResolveDiscrepancyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ResolveDiscrepancyResponse, sizeof(g2ba__ResolveDiscrepancyResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ResolveDiscrepancyResponse(struct soap *soap, g2ba__ResolveDiscrepancyResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyResponse);
	return soap_out_PointerTog2ba__ResolveDiscrepancyResponse(soap, tag?tag:"g2ba:ResolveDiscrepancyResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ResolveDiscrepancyResponse(struct soap *soap, g2ba__ResolveDiscrepancyResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ResolveDiscrepancyRequest(struct soap *soap, g2ba__ResolveDiscrepancyRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, g2ba__ResolveDiscrepancyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyRequest ** FASTCALL soap_in_PointerTog2ba__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, g2ba__ResolveDiscrepancyRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ResolveDiscrepancyRequest **)soap_malloc(soap, sizeof(g2ba__ResolveDiscrepancyRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ResolveDiscrepancyRequest *)soap_instantiate_g2ba__ResolveDiscrepancyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ResolveDiscrepancyRequest ** p = (g2ba__ResolveDiscrepancyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ResolveDiscrepancyRequest, sizeof(g2ba__ResolveDiscrepancyRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ResolveDiscrepancyRequest(struct soap *soap, g2ba__ResolveDiscrepancyRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ResolveDiscrepancyRequest);
	return soap_out_PointerTog2ba__ResolveDiscrepancyRequest(soap, tag?tag:"g2ba:ResolveDiscrepancyRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ResolveDiscrepancyRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ResolveDiscrepancyRequest(struct soap *soap, g2ba__ResolveDiscrepancyRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyActivityLocationsResponse(struct soap *soap, g2ba__ModifyActivityLocationsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, g2ba__ModifyActivityLocationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsResponse ** FASTCALL soap_in_PointerTog2ba__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, g2ba__ModifyActivityLocationsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyActivityLocationsResponse **)soap_malloc(soap, sizeof(g2ba__ModifyActivityLocationsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyActivityLocationsResponse *)soap_instantiate_g2ba__ModifyActivityLocationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyActivityLocationsResponse ** p = (g2ba__ModifyActivityLocationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyActivityLocationsResponse, sizeof(g2ba__ModifyActivityLocationsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyActivityLocationsResponse(struct soap *soap, g2ba__ModifyActivityLocationsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsResponse);
	return soap_out_PointerTog2ba__ModifyActivityLocationsResponse(soap, tag?tag:"g2ba:ModifyActivityLocationsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyActivityLocationsResponse(struct soap *soap, g2ba__ModifyActivityLocationsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyActivityLocationsRequest(struct soap *soap, g2ba__ModifyActivityLocationsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, g2ba__ModifyActivityLocationsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsRequest ** FASTCALL soap_in_PointerTog2ba__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, g2ba__ModifyActivityLocationsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyActivityLocationsRequest **)soap_malloc(soap, sizeof(g2ba__ModifyActivityLocationsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyActivityLocationsRequest *)soap_instantiate_g2ba__ModifyActivityLocationsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyActivityLocationsRequest ** p = (g2ba__ModifyActivityLocationsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyActivityLocationsRequest, sizeof(g2ba__ModifyActivityLocationsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyActivityLocationsRequest(struct soap *soap, g2ba__ModifyActivityLocationsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyActivityLocationsRequest);
	return soap_out_PointerTog2ba__ModifyActivityLocationsRequest(soap, tag?tag:"g2ba:ModifyActivityLocationsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyActivityLocationsRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyActivityLocationsRequest(struct soap *soap, g2ba__ModifyActivityLocationsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyEnterpriseResponse(struct soap *soap, g2ba__ModifyEnterpriseResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyEnterpriseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, g2ba__ModifyEnterpriseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyEnterpriseResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseResponse ** FASTCALL soap_in_PointerTog2ba__ModifyEnterpriseResponse(struct soap *soap, const char *tag, g2ba__ModifyEnterpriseResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyEnterpriseResponse **)soap_malloc(soap, sizeof(g2ba__ModifyEnterpriseResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyEnterpriseResponse *)soap_instantiate_g2ba__ModifyEnterpriseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyEnterpriseResponse ** p = (g2ba__ModifyEnterpriseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyEnterpriseResponse, sizeof(g2ba__ModifyEnterpriseResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyEnterpriseResponse(struct soap *soap, g2ba__ModifyEnterpriseResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyEnterpriseResponse);
	return soap_out_PointerTog2ba__ModifyEnterpriseResponse(soap, tag?tag:"g2ba:ModifyEnterpriseResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyEnterpriseResponse(struct soap *soap, g2ba__ModifyEnterpriseResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyEnterpriseRequest(struct soap *soap, g2ba__ModifyEnterpriseRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyEnterpriseRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, g2ba__ModifyEnterpriseRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyEnterpriseRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseRequest ** FASTCALL soap_in_PointerTog2ba__ModifyEnterpriseRequest(struct soap *soap, const char *tag, g2ba__ModifyEnterpriseRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyEnterpriseRequest **)soap_malloc(soap, sizeof(g2ba__ModifyEnterpriseRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyEnterpriseRequest *)soap_instantiate_g2ba__ModifyEnterpriseRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyEnterpriseRequest ** p = (g2ba__ModifyEnterpriseRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyEnterpriseRequest, sizeof(g2ba__ModifyEnterpriseRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyEnterpriseRequest(struct soap *soap, g2ba__ModifyEnterpriseRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyEnterpriseRequest);
	return soap_out_PointerTog2ba__ModifyEnterpriseRequest(soap, tag?tag:"g2ba:ModifyEnterpriseRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyEnterpriseRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyEnterpriseRequest(struct soap *soap, g2ba__ModifyEnterpriseRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyBusinessEntityResponse(struct soap *soap, g2ba__ModifyBusinessEntityResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, g2ba__ModifyBusinessEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityResponse ** FASTCALL soap_in_PointerTog2ba__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, g2ba__ModifyBusinessEntityResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyBusinessEntityResponse **)soap_malloc(soap, sizeof(g2ba__ModifyBusinessEntityResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyBusinessEntityResponse *)soap_instantiate_g2ba__ModifyBusinessEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyBusinessEntityResponse ** p = (g2ba__ModifyBusinessEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyBusinessEntityResponse, sizeof(g2ba__ModifyBusinessEntityResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyBusinessEntityResponse(struct soap *soap, g2ba__ModifyBusinessEntityResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityResponse);
	return soap_out_PointerTog2ba__ModifyBusinessEntityResponse(soap, tag?tag:"g2ba:ModifyBusinessEntityResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyBusinessEntityResponse(struct soap *soap, g2ba__ModifyBusinessEntityResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ModifyBusinessEntityRequest(struct soap *soap, g2ba__ModifyBusinessEntityRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, g2ba__ModifyBusinessEntityRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityRequest ** FASTCALL soap_in_PointerTog2ba__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, g2ba__ModifyBusinessEntityRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ModifyBusinessEntityRequest **)soap_malloc(soap, sizeof(g2ba__ModifyBusinessEntityRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ModifyBusinessEntityRequest *)soap_instantiate_g2ba__ModifyBusinessEntityRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ModifyBusinessEntityRequest ** p = (g2ba__ModifyBusinessEntityRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ModifyBusinessEntityRequest, sizeof(g2ba__ModifyBusinessEntityRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ModifyBusinessEntityRequest(struct soap *soap, g2ba__ModifyBusinessEntityRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ModifyBusinessEntityRequest);
	return soap_out_PointerTog2ba__ModifyBusinessEntityRequest(soap, tag?tag:"g2ba:ModifyBusinessEntityRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ModifyBusinessEntityRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ModifyBusinessEntityRequest(struct soap *soap, g2ba__ModifyBusinessEntityRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__WithdrawVetDocumentResponse(struct soap *soap, g2ba__WithdrawVetDocumentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, g2ba__WithdrawVetDocumentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentResponse ** FASTCALL soap_in_PointerTog2ba__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, g2ba__WithdrawVetDocumentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__WithdrawVetDocumentResponse **)soap_malloc(soap, sizeof(g2ba__WithdrawVetDocumentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__WithdrawVetDocumentResponse *)soap_instantiate_g2ba__WithdrawVetDocumentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__WithdrawVetDocumentResponse ** p = (g2ba__WithdrawVetDocumentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__WithdrawVetDocumentResponse, sizeof(g2ba__WithdrawVetDocumentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__WithdrawVetDocumentResponse(struct soap *soap, g2ba__WithdrawVetDocumentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentResponse);
	return soap_out_PointerTog2ba__WithdrawVetDocumentResponse(soap, tag?tag:"g2ba:WithdrawVetDocumentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__WithdrawVetDocumentResponse(struct soap *soap, g2ba__WithdrawVetDocumentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__WithdrawVetDocumentRequest(struct soap *soap, g2ba__WithdrawVetDocumentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, g2ba__WithdrawVetDocumentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentRequest ** FASTCALL soap_in_PointerTog2ba__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, g2ba__WithdrawVetDocumentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__WithdrawVetDocumentRequest **)soap_malloc(soap, sizeof(g2ba__WithdrawVetDocumentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__WithdrawVetDocumentRequest *)soap_instantiate_g2ba__WithdrawVetDocumentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__WithdrawVetDocumentRequest ** p = (g2ba__WithdrawVetDocumentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__WithdrawVetDocumentRequest, sizeof(g2ba__WithdrawVetDocumentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__WithdrawVetDocumentRequest(struct soap *soap, g2ba__WithdrawVetDocumentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__WithdrawVetDocumentRequest);
	return soap_out_PointerTog2ba__WithdrawVetDocumentRequest(soap, tag?tag:"g2ba:WithdrawVetDocumentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__WithdrawVetDocumentRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__WithdrawVetDocumentRequest(struct soap *soap, g2ba__WithdrawVetDocumentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__MergeStockEntriesResponse(struct soap *soap, g2ba__MergeStockEntriesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__MergeStockEntriesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, g2ba__MergeStockEntriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__MergeStockEntriesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesResponse ** FASTCALL soap_in_PointerTog2ba__MergeStockEntriesResponse(struct soap *soap, const char *tag, g2ba__MergeStockEntriesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__MergeStockEntriesResponse **)soap_malloc(soap, sizeof(g2ba__MergeStockEntriesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__MergeStockEntriesResponse *)soap_instantiate_g2ba__MergeStockEntriesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__MergeStockEntriesResponse ** p = (g2ba__MergeStockEntriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__MergeStockEntriesResponse, sizeof(g2ba__MergeStockEntriesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__MergeStockEntriesResponse(struct soap *soap, g2ba__MergeStockEntriesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__MergeStockEntriesResponse);
	return soap_out_PointerTog2ba__MergeStockEntriesResponse(soap, tag?tag:"g2ba:MergeStockEntriesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__MergeStockEntriesResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__MergeStockEntriesResponse(struct soap *soap, g2ba__MergeStockEntriesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__MergeStockEntriesRequest(struct soap *soap, g2ba__MergeStockEntriesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__MergeStockEntriesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, g2ba__MergeStockEntriesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__MergeStockEntriesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__MergeStockEntriesRequest ** FASTCALL soap_in_PointerTog2ba__MergeStockEntriesRequest(struct soap *soap, const char *tag, g2ba__MergeStockEntriesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__MergeStockEntriesRequest **)soap_malloc(soap, sizeof(g2ba__MergeStockEntriesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__MergeStockEntriesRequest *)soap_instantiate_g2ba__MergeStockEntriesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__MergeStockEntriesRequest ** p = (g2ba__MergeStockEntriesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__MergeStockEntriesRequest, sizeof(g2ba__MergeStockEntriesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__MergeStockEntriesRequest(struct soap *soap, g2ba__MergeStockEntriesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__MergeStockEntriesRequest);
	return soap_out_PointerTog2ba__MergeStockEntriesRequest(soap, tag?tag:"g2ba:MergeStockEntriesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__MergeStockEntriesRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__MergeStockEntriesRequest(struct soap *soap, g2ba__MergeStockEntriesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__RegisterProductionOperationResponse(struct soap *soap, g2ba__RegisterProductionOperationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__RegisterProductionOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, g2ba__RegisterProductionOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__RegisterProductionOperationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationResponse ** FASTCALL soap_in_PointerTog2ba__RegisterProductionOperationResponse(struct soap *soap, const char *tag, g2ba__RegisterProductionOperationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__RegisterProductionOperationResponse **)soap_malloc(soap, sizeof(g2ba__RegisterProductionOperationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__RegisterProductionOperationResponse *)soap_instantiate_g2ba__RegisterProductionOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__RegisterProductionOperationResponse ** p = (g2ba__RegisterProductionOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__RegisterProductionOperationResponse, sizeof(g2ba__RegisterProductionOperationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__RegisterProductionOperationResponse(struct soap *soap, g2ba__RegisterProductionOperationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__RegisterProductionOperationResponse);
	return soap_out_PointerTog2ba__RegisterProductionOperationResponse(soap, tag?tag:"g2ba:RegisterProductionOperationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__RegisterProductionOperationResponse(struct soap *soap, g2ba__RegisterProductionOperationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__RegisterProductionOperationRequest(struct soap *soap, g2ba__RegisterProductionOperationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__RegisterProductionOperationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, g2ba__RegisterProductionOperationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__RegisterProductionOperationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationRequest ** FASTCALL soap_in_PointerTog2ba__RegisterProductionOperationRequest(struct soap *soap, const char *tag, g2ba__RegisterProductionOperationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__RegisterProductionOperationRequest **)soap_malloc(soap, sizeof(g2ba__RegisterProductionOperationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__RegisterProductionOperationRequest *)soap_instantiate_g2ba__RegisterProductionOperationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__RegisterProductionOperationRequest ** p = (g2ba__RegisterProductionOperationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__RegisterProductionOperationRequest, sizeof(g2ba__RegisterProductionOperationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__RegisterProductionOperationRequest(struct soap *soap, g2ba__RegisterProductionOperationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__RegisterProductionOperationRequest);
	return soap_out_PointerTog2ba__RegisterProductionOperationRequest(soap, tag?tag:"g2ba:RegisterProductionOperationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__RegisterProductionOperationRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__RegisterProductionOperationRequest(struct soap *soap, g2ba__RegisterProductionOperationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, g2ba__PrepareOutgoingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, g2ba__PrepareOutgoingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentResponse ** FASTCALL soap_in_PointerTog2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, g2ba__PrepareOutgoingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__PrepareOutgoingConsignmentResponse **)soap_malloc(soap, sizeof(g2ba__PrepareOutgoingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__PrepareOutgoingConsignmentResponse *)soap_instantiate_g2ba__PrepareOutgoingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__PrepareOutgoingConsignmentResponse ** p = (g2ba__PrepareOutgoingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentResponse, sizeof(g2ba__PrepareOutgoingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, g2ba__PrepareOutgoingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentResponse);
	return soap_out_PointerTog2ba__PrepareOutgoingConsignmentResponse(soap, tag?tag:"g2ba:PrepareOutgoingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__PrepareOutgoingConsignmentResponse(struct soap *soap, g2ba__PrepareOutgoingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, g2ba__PrepareOutgoingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, g2ba__PrepareOutgoingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentRequest ** FASTCALL soap_in_PointerTog2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, g2ba__PrepareOutgoingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__PrepareOutgoingConsignmentRequest **)soap_malloc(soap, sizeof(g2ba__PrepareOutgoingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__PrepareOutgoingConsignmentRequest *)soap_instantiate_g2ba__PrepareOutgoingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__PrepareOutgoingConsignmentRequest ** p = (g2ba__PrepareOutgoingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__PrepareOutgoingConsignmentRequest, sizeof(g2ba__PrepareOutgoingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, g2ba__PrepareOutgoingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__PrepareOutgoingConsignmentRequest);
	return soap_out_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, tag?tag:"g2ba:PrepareOutgoingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__PrepareOutgoingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__PrepareOutgoingConsignmentRequest(struct soap *soap, g2ba__PrepareOutgoingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ProcessIncomingConsignmentResponse(struct soap *soap, g2ba__ProcessIncomingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, g2ba__ProcessIncomingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentResponse ** FASTCALL soap_in_PointerTog2ba__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, g2ba__ProcessIncomingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ProcessIncomingConsignmentResponse **)soap_malloc(soap, sizeof(g2ba__ProcessIncomingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ProcessIncomingConsignmentResponse *)soap_instantiate_g2ba__ProcessIncomingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ProcessIncomingConsignmentResponse ** p = (g2ba__ProcessIncomingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentResponse, sizeof(g2ba__ProcessIncomingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ProcessIncomingConsignmentResponse(struct soap *soap, g2ba__ProcessIncomingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentResponse);
	return soap_out_PointerTog2ba__ProcessIncomingConsignmentResponse(soap, tag?tag:"g2ba:ProcessIncomingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTog2ba__ProcessIncomingConsignmentResponse(struct soap *soap, g2ba__ProcessIncomingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTog2ba__ProcessIncomingConsignmentRequest(struct soap *soap, g2ba__ProcessIncomingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTog2ba__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, g2ba__ProcessIncomingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentRequest ** FASTCALL soap_in_PointerTog2ba__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, g2ba__ProcessIncomingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (g2ba__ProcessIncomingConsignmentRequest **)soap_malloc(soap, sizeof(g2ba__ProcessIncomingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (g2ba__ProcessIncomingConsignmentRequest *)soap_instantiate_g2ba__ProcessIncomingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		g2ba__ProcessIncomingConsignmentRequest ** p = (g2ba__ProcessIncomingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_g2ba__ProcessIncomingConsignmentRequest, sizeof(g2ba__ProcessIncomingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTog2ba__ProcessIncomingConsignmentRequest(struct soap *soap, g2ba__ProcessIncomingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTog2ba__ProcessIncomingConsignmentRequest);
	return soap_out_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, tag?tag:"g2ba:ProcessIncomingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 g2ba__ProcessIncomingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTog2ba__ProcessIncomingConsignmentRequest(struct soap *soap, g2ba__ProcessIncomingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTog2ba__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__receiveApplicationResultResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, _ws__receiveApplicationResultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__receiveApplicationResultResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse ** FASTCALL soap_in_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ws__receiveApplicationResultResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__receiveApplicationResultResponse **)soap_malloc(soap, sizeof(_ws__receiveApplicationResultResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__receiveApplicationResultResponse *)soap_instantiate__ws__receiveApplicationResultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__receiveApplicationResultResponse ** p = (_ws__receiveApplicationResultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__receiveApplicationResultResponse, sizeof(_ws__receiveApplicationResultResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse);
	return soap_out_PointerTo_ws__receiveApplicationResultResponse(soap, tag?tag:"ws:receiveApplicationResultResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse ** SOAP_FMAC4 soap_get_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__receiveApplicationResultRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, _ws__receiveApplicationResultRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__receiveApplicationResultRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest ** FASTCALL soap_in_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ws__receiveApplicationResultRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__receiveApplicationResultRequest **)soap_malloc(soap, sizeof(_ws__receiveApplicationResultRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__receiveApplicationResultRequest *)soap_instantiate__ws__receiveApplicationResultRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__receiveApplicationResultRequest ** p = (_ws__receiveApplicationResultRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__receiveApplicationResultRequest, sizeof(_ws__receiveApplicationResultRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest);
	return soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, tag?tag:"ws:receiveApplicationResultRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest ** SOAP_FMAC4 soap_get_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__submitApplicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__submitApplicationResponse(struct soap *soap, const char *tag, int id, _ws__submitApplicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__submitApplicationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse ** FASTCALL soap_in_PointerTo_ws__submitApplicationResponse(struct soap *soap, const char *tag, _ws__submitApplicationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__submitApplicationResponse **)soap_malloc(soap, sizeof(_ws__submitApplicationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__submitApplicationResponse *)soap_instantiate__ws__submitApplicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__submitApplicationResponse ** p = (_ws__submitApplicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__submitApplicationResponse, sizeof(_ws__submitApplicationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__submitApplicationResponse);
	return soap_out_PointerTo_ws__submitApplicationResponse(soap, tag?tag:"ws:submitApplicationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__submitApplicationResponse ** SOAP_FMAC4 soap_get_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__submitApplicationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__submitApplicationRequest(struct soap *soap, const char *tag, int id, _ws__submitApplicationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__submitApplicationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest ** FASTCALL soap_in_PointerTo_ws__submitApplicationRequest(struct soap *soap, const char *tag, _ws__submitApplicationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__submitApplicationRequest **)soap_malloc(soap, sizeof(_ws__submitApplicationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__submitApplicationRequest *)soap_instantiate__ws__submitApplicationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__submitApplicationRequest ** p = (_ws__submitApplicationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__submitApplicationRequest, sizeof(_ws__submitApplicationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__submitApplicationRequest);
	return soap_out_PointerTo_ws__submitApplicationRequest(soap, tag?tag:"ws:submitApplicationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__submitApplicationRequest ** SOAP_FMAC4 soap_get_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__FaultInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__FaultInfo(struct soap *soap, const char *tag, int id, base__FaultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__FaultInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__FaultInfo ** FASTCALL soap_in_PointerTobase__FaultInfo(struct soap *soap, const char *tag, base__FaultInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__FaultInfo **)soap_malloc(soap, sizeof(base__FaultInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__FaultInfo *)soap_instantiate_base__FaultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__FaultInfo ** p = (base__FaultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__FaultInfo, sizeof(base__FaultInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__FaultInfo);
	return soap_out_PointerTobase__FaultInfo(soap, tag?tag:"base:FaultInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__FaultInfo ** SOAP_FMAC4 soap_get_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryBlankFilter);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, enum vd__StockEntryBlankFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryBlankFilter);
	return (id < 0) ? soap->error : soap_out_vd__StockEntryBlankFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter ** FASTCALL soap_in_PointerTovd__StockEntryBlankFilter(struct soap *soap, const char *tag, enum vd__StockEntryBlankFilter **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__StockEntryBlankFilter **)soap_malloc(soap, sizeof(enum vd__StockEntryBlankFilter *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__StockEntryBlankFilter(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__StockEntryBlankFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryBlankFilter, sizeof(enum vd__StockEntryBlankFilter), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryBlankFilter);
	return soap_out_PointerTovd__StockEntryBlankFilter(soap, tag?tag:"vd:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryEventList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryEventList(struct soap *soap, const char *tag, int id, vd__StockEntryEventList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryEventList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntryEventList ** FASTCALL soap_in_PointerTovd__StockEntryEventList(struct soap *soap, const char *tag, vd__StockEntryEventList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntryEventList **)soap_malloc(soap, sizeof(vd__StockEntryEventList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntryEventList *)soap_instantiate_vd__StockEntryEventList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntryEventList ** p = (vd__StockEntryEventList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryEventList, sizeof(vd__StockEntryEventList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryEventList);
	return soap_out_PointerTovd__StockEntryEventList(soap, tag?tag:"vd:StockEntryEventList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntryEventList ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DiscrepancyReason))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DiscrepancyReason(struct soap *soap, const char *tag, int id, vd__DiscrepancyReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DiscrepancyReason);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DiscrepancyReason ** FASTCALL soap_in_PointerTovd__DiscrepancyReason(struct soap *soap, const char *tag, vd__DiscrepancyReason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReason **)soap_malloc(soap, sizeof(vd__DiscrepancyReason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DiscrepancyReason *)soap_instantiate_vd__DiscrepancyReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DiscrepancyReason ** p = (vd__DiscrepancyReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReason, sizeof(vd__DiscrepancyReason), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DiscrepancyReason);
	return soap_out_PointerTovd__DiscrepancyReason(soap, tag?tag:"vd:DiscrepancyReason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReason ** SOAP_FMAC4 soap_get_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VetDocumentStatusChange))
		soap_serialize_PointerTovd__VetDocumentStatusChange(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, vd__VetDocumentStatusChange **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VetDocumentStatusChange);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VetDocumentStatusChange(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange *** FASTCALL soap_in_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentStatusChange ***)soap_malloc(soap, sizeof(vd__VetDocumentStatusChange **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VetDocumentStatusChange(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VetDocumentStatusChange ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange);
	return soap_out_PointerToPointerTovd__VetDocumentStatusChange(soap, tag?tag:"vd:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentStatusChange *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentStatusChange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, vd__VetDocumentStatusChange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentStatusChange);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange ** FASTCALL soap_in_PointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentStatusChange **)soap_malloc(soap, sizeof(vd__VetDocumentStatusChange *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocumentStatusChange *)soap_instantiate_vd__VetDocumentStatusChange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocumentStatusChange ** p = (vd__VetDocumentStatusChange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentStatusChange);
	return soap_out_PointerTovd__VetDocumentStatusChange(soap, tag?tag:"vd:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentStatusChange ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryAuthentication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, vd__VeterinaryAuthentication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryAuthentication);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication ** FASTCALL soap_in_PointerTovd__VeterinaryAuthentication(struct soap *soap, const char *tag, vd__VeterinaryAuthentication **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryAuthentication **)soap_malloc(soap, sizeof(vd__VeterinaryAuthentication *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VeterinaryAuthentication *)soap_instantiate_vd__VeterinaryAuthentication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VeterinaryAuthentication ** p = (vd__VeterinaryAuthentication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryAuthentication, sizeof(vd__VeterinaryAuthentication), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryAuthentication);
	return soap_out_PointerTovd__VeterinaryAuthentication(soap, tag?tag:"vd:VeterinaryAuthentication", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryAuthentication ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__CertifiedConsignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__CertifiedConsignment(struct soap *soap, const char *tag, int id, vd__CertifiedConsignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__CertifiedConsignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__CertifiedConsignment ** FASTCALL soap_in_PointerTovd__CertifiedConsignment(struct soap *soap, const char *tag, vd__CertifiedConsignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__CertifiedConsignment **)soap_malloc(soap, sizeof(vd__CertifiedConsignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__CertifiedConsignment *)soap_instantiate_vd__CertifiedConsignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__CertifiedConsignment ** p = (vd__CertifiedConsignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__CertifiedConsignment, sizeof(vd__CertifiedConsignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__CertifiedConsignment);
	return soap_out_PointerTovd__CertifiedConsignment(soap, tag?tag:"vd:CertifiedConsignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__CertifiedConsignment ** SOAP_FMAC4 soap_get_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__CertifiedBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__CertifiedBatch(struct soap *soap, const char *tag, int id, vd__CertifiedBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__CertifiedBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__CertifiedBatch ** FASTCALL soap_in_PointerTovd__CertifiedBatch(struct soap *soap, const char *tag, vd__CertifiedBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__CertifiedBatch **)soap_malloc(soap, sizeof(vd__CertifiedBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__CertifiedBatch *)soap_instantiate_vd__CertifiedBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__CertifiedBatch ** p = (vd__CertifiedBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__CertifiedBatch, sizeof(vd__CertifiedBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__CertifiedBatch);
	return soap_out_PointerTovd__CertifiedBatch(soap, tag?tag:"vd:CertifiedBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__CertifiedBatch ** SOAP_FMAC4 soap_get_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentForm);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentForm(struct soap *soap, const char *tag, int id, enum vd__VetDocumentForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentForm);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentForm(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentForm ** FASTCALL soap_in_PointerTovd__VetDocumentForm(struct soap *soap, const char *tag, enum vd__VetDocumentForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentForm **)soap_malloc(soap, sizeof(enum vd__VetDocumentForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentForm(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentForm, sizeof(enum vd__VetDocumentForm), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentForm);
	return soap_out_PointerTovd__VetDocumentForm(soap, tag?tag:"vd:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentForm ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationStatus))
		soap_serialize_PointerTodic__RegionalizationStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationStatus(struct soap *soap, const char *tag, int id, dic__RegionalizationStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationStatus);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationStatus *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationStatus(struct soap *soap, const char *tag, dic__RegionalizationStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationStatus ***)soap_malloc(soap, sizeof(dic__RegionalizationStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationStatus, sizeof(dic__RegionalizationStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationStatus);
	return soap_out_PointerToPointerTodic__RegionalizationStatus(soap, tag?tag:"dic:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationStatus *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Area(struct soap *soap, dic__Area **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Area))
		soap_serialize_PointerTodic__Area(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Area(struct soap *soap, const char *tag, int id, dic__Area **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Area);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Area(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Area *** FASTCALL soap_in_PointerToPointerTodic__Area(struct soap *soap, const char *tag, dic__Area ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Area ***)soap_malloc(soap, sizeof(dic__Area **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Area(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Area ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Area, sizeof(dic__Area *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Area(struct soap *soap, dic__Area **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Area);
	return soap_out_PointerToPointerTodic__Area(soap, tag?tag:"dic:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Area *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Area(struct soap *soap, dic__Area ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationRequirement))
		soap_serialize_PointerTodic__RegionalizationRequirement(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationRequirement(struct soap *soap, const char *tag, int id, dic__RegionalizationRequirement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationRequirement);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationRequirement(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationRequirement *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationRequirement(struct soap *soap, const char *tag, dic__RegionalizationRequirement ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationRequirement ***)soap_malloc(soap, sizeof(dic__RegionalizationRequirement **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationRequirement(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationRequirement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationRequirement, sizeof(dic__RegionalizationRequirement *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationRequirement);
	return soap_out_PointerToPointerTodic__RegionalizationRequirement(soap, tag?tag:"dic:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationRequirement *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationRequirement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationRequirement(struct soap *soap, const char *tag, int id, dic__RegionalizationRequirement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationRequirement);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationRequirement ** FASTCALL soap_in_PointerTodic__RegionalizationRequirement(struct soap *soap, const char *tag, dic__RegionalizationRequirement **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationRequirement **)soap_malloc(soap, sizeof(dic__RegionalizationRequirement *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationRequirement *)soap_instantiate_dic__RegionalizationRequirement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationRequirement ** p = (dic__RegionalizationRequirement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationRequirement, sizeof(dic__RegionalizationRequirement), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationRequirement);
	return soap_out_PointerTodic__RegionalizationRequirement(soap, tag?tag:"dic:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationRequirement ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationRequirement(struct soap *soap, dic__RegionalizationRequirement **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationDecision(struct soap *soap, enum dic__RegionalizationDecision *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationDecision);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationDecision(struct soap *soap, const char *tag, int id, enum dic__RegionalizationDecision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationDecision);
	return (id < 0) ? soap->error : soap_out_dic__RegionalizationDecision(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__RegionalizationDecision ** FASTCALL soap_in_PointerTodic__RegionalizationDecision(struct soap *soap, const char *tag, enum dic__RegionalizationDecision **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__RegionalizationDecision **)soap_malloc(soap, sizeof(enum dic__RegionalizationDecision *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__RegionalizationDecision(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__RegionalizationDecision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationDecision, sizeof(enum dic__RegionalizationDecision), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationDecision(struct soap *soap, enum dic__RegionalizationDecision *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationDecision);
	return soap_out_PointerTodic__RegionalizationDecision(soap, tag?tag:"dic:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__RegionalizationDecision ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationDecision(struct soap *soap, enum dic__RegionalizationDecision **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationStatus(struct soap *soap, const char *tag, int id, dic__RegionalizationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationStatus ** FASTCALL soap_in_PointerTodic__RegionalizationStatus(struct soap *soap, const char *tag, dic__RegionalizationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationStatus **)soap_malloc(soap, sizeof(dic__RegionalizationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationStatus *)soap_instantiate_dic__RegionalizationStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationStatus ** p = (dic__RegionalizationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationStatus, sizeof(dic__RegionalizationStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationStatus);
	return soap_out_PointerTodic__RegionalizationStatus(soap, tag?tag:"dic:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationStatus ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationStatus(struct soap *soap, dic__RegionalizationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Packaging(struct soap *soap, dic__Packaging *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Packaging))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Packaging(struct soap *soap, const char *tag, int id, dic__Packaging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Packaging);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Packaging ** FASTCALL soap_in_PointerTodic__Packaging(struct soap *soap, const char *tag, dic__Packaging **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Packaging **)soap_malloc(soap, sizeof(dic__Packaging *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Packaging *)soap_instantiate_dic__Packaging(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Packaging ** p = (dic__Packaging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Packaging, sizeof(dic__Packaging), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Packaging(struct soap *soap, dic__Packaging *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Packaging);
	return soap_out_PointerTodic__Packaging(soap, tag?tag:"dic:Packaging", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Packaging ** SOAP_FMAC4 soap_get_PointerTodic__Packaging(struct soap *soap, dic__Packaging **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__ProductItemProducing))
		soap_serialize_PointerTodic__ProductItemProducing(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__ProductItemProducing(struct soap *soap, const char *tag, int id, dic__ProductItemProducing **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__ProductItemProducing);
	return (id < 0) ? soap->error : soap_out_PointerTodic__ProductItemProducing(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__ProductItemProducing *** FASTCALL soap_in_PointerToPointerTodic__ProductItemProducing(struct soap *soap, const char *tag, dic__ProductItemProducing ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductItemProducing ***)soap_malloc(soap, sizeof(dic__ProductItemProducing **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__ProductItemProducing(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__ProductItemProducing ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__ProductItemProducing, sizeof(dic__ProductItemProducing *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__ProductItemProducing);
	return soap_out_PointerToPointerTodic__ProductItemProducing(soap, tag?tag:"dic:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductItemProducing *** SOAP_FMAC4 soap_get_PointerToPointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ProductItemProducing))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ProductItemProducing(struct soap *soap, const char *tag, int id, dic__ProductItemProducing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ProductItemProducing);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ProductItemProducing ** FASTCALL soap_in_PointerTodic__ProductItemProducing(struct soap *soap, const char *tag, dic__ProductItemProducing **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductItemProducing **)soap_malloc(soap, sizeof(dic__ProductItemProducing *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ProductItemProducing *)soap_instantiate_dic__ProductItemProducing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ProductItemProducing ** p = (dic__ProductItemProducing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ProductItemProducing, sizeof(dic__ProductItemProducing), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ProductItemProducing);
	return soap_out_PointerTodic__ProductItemProducing(soap, tag?tag:"dic:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductItemProducing ** SOAP_FMAC4 soap_get_PointerTodic__ProductItemProducing(struct soap *soap, dic__ProductItemProducing **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_dic__BusinessEntity_activityLocation(struct soap *soap, _dic__BusinessEntity_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__dic__BusinessEntity_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_dic__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, _dic__BusinessEntity_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__dic__BusinessEntity_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _dic__BusinessEntity_activityLocation ** FASTCALL soap_in_PointerTo_dic__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _dic__BusinessEntity_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_dic__BusinessEntity_activityLocation **)soap_malloc(soap, sizeof(_dic__BusinessEntity_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_dic__BusinessEntity_activityLocation *)soap_instantiate__dic__BusinessEntity_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_dic__BusinessEntity_activityLocation ** p = (_dic__BusinessEntity_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__dic__BusinessEntity_activityLocation, sizeof(_dic__BusinessEntity_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_dic__BusinessEntity_activityLocation(struct soap *soap, _dic__BusinessEntity_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_dic__BusinessEntity_activityLocation);
	return soap_out_PointerTo_dic__BusinessEntity_activityLocation(soap, tag?tag:"dic:BusinessEntity-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _dic__BusinessEntity_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_dic__BusinessEntity_activityLocation(struct soap *soap, _dic__BusinessEntity_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_dic__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__IncorporationForm(struct soap *soap, dic__IncorporationForm *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__IncorporationForm))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__IncorporationForm(struct soap *soap, const char *tag, int id, dic__IncorporationForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__IncorporationForm);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__IncorporationForm ** FASTCALL soap_in_PointerTodic__IncorporationForm(struct soap *soap, const char *tag, dic__IncorporationForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__IncorporationForm **)soap_malloc(soap, sizeof(dic__IncorporationForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__IncorporationForm *)soap_instantiate_dic__IncorporationForm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__IncorporationForm ** p = (dic__IncorporationForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__IncorporationForm, sizeof(dic__IncorporationForm), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__IncorporationForm(struct soap *soap, dic__IncorporationForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__IncorporationForm);
	return soap_out_PointerTodic__IncorporationForm(soap, tag?tag:"dic:IncorporationForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__IncorporationForm ** SOAP_FMAC4 soap_get_PointerTodic__IncorporationForm(struct soap *soap, dic__IncorporationForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__BusinessEntityType(struct soap *soap, enum dic__BusinessEntityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__BusinessEntityType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__BusinessEntityType(struct soap *soap, const char *tag, int id, enum dic__BusinessEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__BusinessEntityType);
	return (id < 0) ? soap->error : soap_out_dic__BusinessEntityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__BusinessEntityType ** FASTCALL soap_in_PointerTodic__BusinessEntityType(struct soap *soap, const char *tag, enum dic__BusinessEntityType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__BusinessEntityType **)soap_malloc(soap, sizeof(enum dic__BusinessEntityType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__BusinessEntityType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__BusinessEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__BusinessEntityType, sizeof(enum dic__BusinessEntityType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__BusinessEntityType(struct soap *soap, enum dic__BusinessEntityType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__BusinessEntityType);
	return soap_out_PointerTodic__BusinessEntityType(soap, tag?tag:"dic:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__BusinessEntityType ** SOAP_FMAC4 soap_get_PointerTodic__BusinessEntityType(struct soap *soap, enum dic__BusinessEntityType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration))
		soap_serialize_PointerTodic__EnterpriseOfficialRegistration(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, dic__EnterpriseOfficialRegistration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : soap_out_PointerTodic__EnterpriseOfficialRegistration(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration *** FASTCALL soap_in_PointerToPointerTodic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, dic__EnterpriseOfficialRegistration ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseOfficialRegistration ***)soap_malloc(soap, sizeof(dic__EnterpriseOfficialRegistration **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__EnterpriseOfficialRegistration(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__EnterpriseOfficialRegistration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration, sizeof(dic__EnterpriseOfficialRegistration *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__EnterpriseOfficialRegistration);
	return soap_out_PointerToPointerTodic__EnterpriseOfficialRegistration(soap, tag?tag:"dic:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration *** SOAP_FMAC4 soap_get_PointerToPointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseOfficialRegistration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, dic__EnterpriseOfficialRegistration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration ** FASTCALL soap_in_PointerTodic__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, dic__EnterpriseOfficialRegistration **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseOfficialRegistration **)soap_malloc(soap, sizeof(dic__EnterpriseOfficialRegistration *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__EnterpriseOfficialRegistration *)soap_instantiate_dic__EnterpriseOfficialRegistration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__EnterpriseOfficialRegistration ** p = (dic__EnterpriseOfficialRegistration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseOfficialRegistration, sizeof(dic__EnterpriseOfficialRegistration), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseOfficialRegistration);
	return soap_out_PointerTodic__EnterpriseOfficialRegistration(soap, tag?tag:"dic:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseOfficialRegistration ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseOfficialRegistration(struct soap *soap, dic__EnterpriseOfficialRegistration **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseActivityList(struct soap *soap, dic__EnterpriseActivityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseActivityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseActivityList(struct soap *soap, const char *tag, int id, dic__EnterpriseActivityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseActivityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__EnterpriseActivityList ** FASTCALL soap_in_PointerTodic__EnterpriseActivityList(struct soap *soap, const char *tag, dic__EnterpriseActivityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseActivityList **)soap_malloc(soap, sizeof(dic__EnterpriseActivityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__EnterpriseActivityList *)soap_instantiate_dic__EnterpriseActivityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__EnterpriseActivityList ** p = (dic__EnterpriseActivityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseActivityList, sizeof(dic__EnterpriseActivityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseActivityList(struct soap *soap, dic__EnterpriseActivityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseActivityList);
	return soap_out_PointerTodic__EnterpriseActivityList(soap, tag?tag:"dic:EnterpriseActivityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseActivityList ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseActivityList(struct soap *soap, dic__EnterpriseActivityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseNumberList(struct soap *soap, dic__EnterpriseNumberList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseNumberList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseNumberList(struct soap *soap, const char *tag, int id, dic__EnterpriseNumberList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseNumberList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__EnterpriseNumberList ** FASTCALL soap_in_PointerTodic__EnterpriseNumberList(struct soap *soap, const char *tag, dic__EnterpriseNumberList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseNumberList **)soap_malloc(soap, sizeof(dic__EnterpriseNumberList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__EnterpriseNumberList *)soap_instantiate_dic__EnterpriseNumberList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__EnterpriseNumberList ** p = (dic__EnterpriseNumberList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseNumberList, sizeof(dic__EnterpriseNumberList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseNumberList(struct soap *soap, dic__EnterpriseNumberList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseNumberList);
	return soap_out_PointerTodic__EnterpriseNumberList(soap, tag?tag:"dic:EnterpriseNumberList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseNumberList ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseNumberList(struct soap *soap, dic__EnterpriseNumberList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseType))
		soap_serialize_dic__EnterpriseType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseType);
	return (id < 0) ? soap->error : soap_out_dic__EnterpriseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTodic__EnterpriseType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__EnterpriseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseType);
	return soap_out_PointerTodic__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__PackingCodeType(struct soap *soap, enum dic__PackingCodeType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__PackingCodeType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__PackingCodeType(struct soap *soap, const char *tag, int id, enum dic__PackingCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__PackingCodeType);
	return (id < 0) ? soap->error : soap_out_dic__PackingCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__PackingCodeType ** FASTCALL soap_in_PointerTodic__PackingCodeType(struct soap *soap, const char *tag, enum dic__PackingCodeType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__PackingCodeType **)soap_malloc(soap, sizeof(enum dic__PackingCodeType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__PackingCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__PackingCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__PackingCodeType, sizeof(enum dic__PackingCodeType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__PackingCodeType(struct soap *soap, enum dic__PackingCodeType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__PackingCodeType);
	return soap_out_PointerTodic__PackingCodeType(soap, tag?tag:"dic:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__PackingCodeType ** SOAP_FMAC4 soap_get_PointerTodic__PackingCodeType(struct soap *soap, enum dic__PackingCodeType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__UUID(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__UUID))
		soap_serialize_base__UUID(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__UUID(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__UUID);
	return (id < 0) ? soap->error : soap_out_base__UUID(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__UUID(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__UUID(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__UUID, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__UUID(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__UUID);
	return soap_out_PointerTobase__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__UUID(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntrySearchPattern))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, vd__StockEntrySearchPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntrySearchPattern);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern ** FASTCALL soap_in_PointerTovd__StockEntrySearchPattern(struct soap *soap, const char *tag, vd__StockEntrySearchPattern **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntrySearchPattern **)soap_malloc(soap, sizeof(vd__StockEntrySearchPattern *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntrySearchPattern *)soap_instantiate_vd__StockEntrySearchPattern(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntrySearchPattern ** p = (vd__StockEntrySearchPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntrySearchPattern);
	return soap_out_PointerTovd__StockEntrySearchPattern(soap, tag?tag:"vd:StockEntrySearchPattern", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntrySearchPattern ** SOAP_FMAC4 soap_get_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__DateInterval(struct soap *soap, base__DateInterval *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__DateInterval))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__DateInterval(struct soap *soap, const char *tag, int id, base__DateInterval *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__DateInterval);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__DateInterval ** FASTCALL soap_in_PointerTobase__DateInterval(struct soap *soap, const char *tag, base__DateInterval **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__DateInterval **)soap_malloc(soap, sizeof(base__DateInterval *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__DateInterval *)soap_instantiate_base__DateInterval(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__DateInterval ** p = (base__DateInterval **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__DateInterval, sizeof(base__DateInterval), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__DateInterval(struct soap *soap, base__DateInterval *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__DateInterval);
	return soap_out_PointerTobase__DateInterval(soap, tag?tag:"base:DateInterval", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__DateInterval ** SOAP_FMAC4 soap_get_PointerTobase__DateInterval(struct soap *soap, base__DateInterval **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentStatus(struct soap *soap, const char *tag, int id, enum vd__VetDocumentStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentStatus);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentStatus ** FASTCALL soap_in_PointerTovd__VetDocumentStatus(struct soap *soap, const char *tag, enum vd__VetDocumentStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentStatus **)soap_malloc(soap, sizeof(enum vd__VetDocumentStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentStatus, sizeof(enum vd__VetDocumentStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentStatus);
	return soap_out_PointerTovd__VetDocumentStatus(soap, tag?tag:"vd:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentStatus ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentType(struct soap *soap, const char *tag, int id, enum vd__VetDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentType);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentType ** FASTCALL soap_in_PointerTovd__VetDocumentType(struct soap *soap, const char *tag, enum vd__VetDocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentType **)soap_malloc(soap, sizeof(enum vd__VetDocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentType, sizeof(enum vd__VetDocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentType);
	return soap_out_PointerTovd__VetDocumentType(soap, tag?tag:"vd:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentType ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__ListOptions(struct soap *soap, base__ListOptions *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__ListOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__ListOptions(struct soap *soap, const char *tag, int id, base__ListOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__ListOptions);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__ListOptions ** FASTCALL soap_in_PointerTobase__ListOptions(struct soap *soap, const char *tag, base__ListOptions **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__ListOptions **)soap_malloc(soap, sizeof(base__ListOptions *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__ListOptions *)soap_instantiate_base__ListOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__ListOptions ** p = (base__ListOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__ListOptions, sizeof(base__ListOptions), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__ListOptions(struct soap *soap, base__ListOptions *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__ListOptions);
	return soap_out_PointerTobase__ListOptions(soap, tag?tag:"base:ListOptions", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__ListOptions ** SOAP_FMAC4 soap_get_PointerTobase__ListOptions(struct soap *soap, base__ListOptions **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__PSLModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__PSLModificationOperation(struct soap *soap, const char *tag, int id, vd__PSLModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__PSLModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__PSLModificationOperation ** FASTCALL soap_in_PointerTovd__PSLModificationOperation(struct soap *soap, const char *tag, vd__PSLModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__PSLModificationOperation **)soap_malloc(soap, sizeof(vd__PSLModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__PSLModificationOperation *)soap_instantiate_vd__PSLModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__PSLModificationOperation ** p = (vd__PSLModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__PSLModificationOperation, sizeof(vd__PSLModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__PSLModificationOperation);
	return soap_out_PointerTovd__PSLModificationOperation(soap, tag?tag:"vd:PSLModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__PSLModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__StockDiscrepancy))
		soap_serialize_PointerTovd__StockDiscrepancy(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, int id, vd__StockDiscrepancy **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__StockDiscrepancy);
	return (id < 0) ? soap->error : soap_out_PointerTovd__StockDiscrepancy(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__StockDiscrepancy *** FASTCALL soap_in_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockDiscrepancy ***)soap_malloc(soap, sizeof(vd__StockDiscrepancy **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__StockDiscrepancy(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__StockDiscrepancy ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__StockDiscrepancy, sizeof(vd__StockDiscrepancy *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy);
	return soap_out_PointerToPointerTovd__StockDiscrepancy(soap, tag?tag:"vd:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockDiscrepancy *** SOAP_FMAC4 soap_get_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockDiscrepancy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, int id, vd__StockDiscrepancy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockDiscrepancy);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockDiscrepancy ** FASTCALL soap_in_PointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockDiscrepancy **)soap_malloc(soap, sizeof(vd__StockDiscrepancy *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockDiscrepancy *)soap_instantiate_vd__StockDiscrepancy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockDiscrepancy ** p = (vd__StockDiscrepancy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockDiscrepancy, sizeof(vd__StockDiscrepancy), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockDiscrepancy);
	return soap_out_PointerTovd__StockDiscrepancy(soap, tag?tag:"vd:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockDiscrepancy ** SOAP_FMAC4 soap_get_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, vd__BEActivityLocationsModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BEActivityLocationsModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation ** FASTCALL soap_in_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, vd__BEActivityLocationsModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BEActivityLocationsModificationOperation **)soap_malloc(soap, sizeof(vd__BEActivityLocationsModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BEActivityLocationsModificationOperation *)soap_instantiate_vd__BEActivityLocationsModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BEActivityLocationsModificationOperation ** p = (vd__BEActivityLocationsModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, sizeof(vd__BEActivityLocationsModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation);
	return soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, tag?tag:"vd:BEActivityLocationsModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ENTModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ENTModificationOperation(struct soap *soap, const char *tag, int id, vd__ENTModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ENTModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ENTModificationOperation ** FASTCALL soap_in_PointerTovd__ENTModificationOperation(struct soap *soap, const char *tag, vd__ENTModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ENTModificationOperation **)soap_malloc(soap, sizeof(vd__ENTModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ENTModificationOperation *)soap_instantiate_vd__ENTModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ENTModificationOperation ** p = (vd__ENTModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ENTModificationOperation, sizeof(vd__ENTModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ENTModificationOperation);
	return soap_out_PointerTovd__ENTModificationOperation(soap, tag?tag:"vd:ENTModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ENTModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BEModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BEModificationOperation(struct soap *soap, const char *tag, int id, vd__BEModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BEModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BEModificationOperation ** FASTCALL soap_in_PointerTovd__BEModificationOperation(struct soap *soap, const char *tag, vd__BEModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BEModificationOperation **)soap_malloc(soap, sizeof(vd__BEModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BEModificationOperation *)soap_instantiate_vd__BEModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BEModificationOperation ** p = (vd__BEModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BEModificationOperation, sizeof(vd__BEModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BEModificationOperation);
	return soap_out_PointerTovd__BEModificationOperation(soap, tag?tag:"vd:BEModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BEModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__MergeStockEntriesOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, vd__MergeStockEntriesOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__MergeStockEntriesOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation ** FASTCALL soap_in_PointerTovd__MergeStockEntriesOperation(struct soap *soap, const char *tag, vd__MergeStockEntriesOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__MergeStockEntriesOperation **)soap_malloc(soap, sizeof(vd__MergeStockEntriesOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__MergeStockEntriesOperation *)soap_instantiate_vd__MergeStockEntriesOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__MergeStockEntriesOperation ** p = (vd__MergeStockEntriesOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__MergeStockEntriesOperation, sizeof(vd__MergeStockEntriesOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__MergeStockEntriesOperation);
	return soap_out_PointerTovd__MergeStockEntriesOperation(soap, tag?tag:"vd:MergeStockEntriesOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation ** SOAP_FMAC4 soap_get_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProductionOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProductionOperation(struct soap *soap, const char *tag, int id, vd__ProductionOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProductionOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProductionOperation ** FASTCALL soap_in_PointerTovd__ProductionOperation(struct soap *soap, const char *tag, vd__ProductionOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductionOperation **)soap_malloc(soap, sizeof(vd__ProductionOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProductionOperation *)soap_instantiate_vd__ProductionOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProductionOperation ** p = (vd__ProductionOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductionOperation, sizeof(vd__ProductionOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProductionOperation);
	return soap_out_PointerTovd__ProductionOperation(soap, tag?tag:"vd:ProductionOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductionOperation ** SOAP_FMAC4 soap_get_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Delivery))
		soap_serialize_PointerTovd__Delivery(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Delivery(struct soap *soap, const char *tag, int id, vd__Delivery **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Delivery);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Delivery(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Delivery *** FASTCALL soap_in_PointerToPointerTovd__Delivery(struct soap *soap, const char *tag, vd__Delivery ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Delivery ***)soap_malloc(soap, sizeof(vd__Delivery **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Delivery(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Delivery ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Delivery, sizeof(vd__Delivery *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Delivery);
	return soap_out_PointerToPointerTovd__Delivery(soap, tag?tag:"vd:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Delivery *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__DiscrepancyReport))
		soap_serialize_PointerTovd__DiscrepancyReport(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, int id, vd__DiscrepancyReport **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__DiscrepancyReport);
	return (id < 0) ? soap->error : soap_out_PointerTovd__DiscrepancyReport(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__DiscrepancyReport *** FASTCALL soap_in_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReport ***)soap_malloc(soap, sizeof(vd__DiscrepancyReport **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__DiscrepancyReport(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReport ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__DiscrepancyReport, sizeof(vd__DiscrepancyReport *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport);
	return soap_out_PointerToPointerTovd__DiscrepancyReport(soap, tag?tag:"vd:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReport *** SOAP_FMAC4 soap_get_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DiscrepancyReport))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, int id, vd__DiscrepancyReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DiscrepancyReport);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DiscrepancyReport ** FASTCALL soap_in_PointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReport **)soap_malloc(soap, sizeof(vd__DiscrepancyReport *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DiscrepancyReport *)soap_instantiate_vd__DiscrepancyReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DiscrepancyReport ** p = (vd__DiscrepancyReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DiscrepancyReport);
	return soap_out_PointerTovd__DiscrepancyReport(soap, tag?tag:"vd:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReport ** SOAP_FMAC4 soap_get_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DeliveryFactList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DeliveryFactList(struct soap *soap, const char *tag, int id, vd__DeliveryFactList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DeliveryFactList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DeliveryFactList ** FASTCALL soap_in_PointerTovd__DeliveryFactList(struct soap *soap, const char *tag, vd__DeliveryFactList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DeliveryFactList **)soap_malloc(soap, sizeof(vd__DeliveryFactList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DeliveryFactList *)soap_instantiate_vd__DeliveryFactList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DeliveryFactList ** p = (vd__DeliveryFactList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DeliveryFactList, sizeof(vd__DeliveryFactList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DeliveryFactList);
	return soap_out_PointerTovd__DeliveryFactList(soap, tag?tag:"vd:DeliveryFactList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DeliveryFactList ** SOAP_FMAC4 soap_get_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Delivery(struct soap *soap, vd__Delivery *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Delivery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Delivery(struct soap *soap, const char *tag, int id, vd__Delivery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Delivery);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Delivery ** FASTCALL soap_in_PointerTovd__Delivery(struct soap *soap, const char *tag, vd__Delivery **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Delivery **)soap_malloc(soap, sizeof(vd__Delivery *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Delivery *)soap_instantiate_vd__Delivery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Delivery ** p = (vd__Delivery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Delivery, sizeof(vd__Delivery), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Delivery(struct soap *soap, vd__Delivery *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Delivery);
	return soap_out_PointerTovd__Delivery(soap, tag?tag:"vd:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Delivery ** SOAP_FMAC4 soap_get_PointerTovd__Delivery(struct soap *soap, vd__Delivery **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__WorkingArea))
		soap_serialize_PointerTovd__WorkingArea(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__WorkingArea(struct soap *soap, const char *tag, int id, vd__WorkingArea **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__WorkingArea);
	return (id < 0) ? soap->error : soap_out_PointerTovd__WorkingArea(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__WorkingArea *** FASTCALL soap_in_PointerToPointerTovd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingArea ***)soap_malloc(soap, sizeof(vd__WorkingArea **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__WorkingArea(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__WorkingArea ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__WorkingArea, sizeof(vd__WorkingArea *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__WorkingArea);
	return soap_out_PointerToPointerTovd__WorkingArea(soap, tag?tag:"vd:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingArea *** SOAP_FMAC4 soap_get_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__WorkingArea))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__WorkingArea(struct soap *soap, const char *tag, int id, vd__WorkingArea *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__WorkingArea);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__WorkingArea ** FASTCALL soap_in_PointerTovd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingArea **)soap_malloc(soap, sizeof(vd__WorkingArea *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__WorkingArea *)soap_instantiate_vd__WorkingArea(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__WorkingArea ** p = (vd__WorkingArea **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__WorkingArea, sizeof(vd__WorkingArea), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__WorkingArea);
	return soap_out_PointerTovd__WorkingArea(soap, tag?tag:"vd:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingArea ** SOAP_FMAC4 soap_get_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__WorkingAreaList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__WorkingAreaList(struct soap *soap, const char *tag, int id, vd__WorkingAreaList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__WorkingAreaList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__WorkingAreaList ** FASTCALL soap_in_PointerTovd__WorkingAreaList(struct soap *soap, const char *tag, vd__WorkingAreaList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingAreaList **)soap_malloc(soap, sizeof(vd__WorkingAreaList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__WorkingAreaList *)soap_instantiate_vd__WorkingAreaList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__WorkingAreaList ** p = (vd__WorkingAreaList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__WorkingAreaList, sizeof(vd__WorkingAreaList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__WorkingAreaList);
	return soap_out_PointerTovd__WorkingAreaList(soap, tag?tag:"vd:WorkingAreaList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingAreaList ** SOAP_FMAC4 soap_get_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__SNILSType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__SNILSType))
		soap_serialize_vd__SNILSType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__SNILSType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__SNILSType);
	return (id < 0) ? soap->error : soap_out_vd__SNILSType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTovd__SNILSType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__SNILSType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__SNILSType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__SNILSType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__SNILSType);
	return soap_out_PointerTovd__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTovd__SNILSType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Citizenship(struct soap *soap, vd__Citizenship *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Citizenship))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Citizenship(struct soap *soap, const char *tag, int id, vd__Citizenship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Citizenship);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Citizenship ** FASTCALL soap_in_PointerTovd__Citizenship(struct soap *soap, const char *tag, vd__Citizenship **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Citizenship **)soap_malloc(soap, sizeof(vd__Citizenship *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Citizenship *)soap_instantiate_vd__Citizenship(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Citizenship ** p = (vd__Citizenship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Citizenship, sizeof(vd__Citizenship), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Citizenship(struct soap *soap, vd__Citizenship *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Citizenship);
	return soap_out_PointerTovd__Citizenship(soap, tag?tag:"vd:Citizenship", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Citizenship ** SOAP_FMAC4 soap_get_PointerTovd__Citizenship(struct soap *soap, vd__Citizenship **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Citizenship(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__MedicinalDrug(struct soap *soap, dic__MedicinalDrug *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__MedicinalDrug))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__MedicinalDrug(struct soap *soap, const char *tag, int id, dic__MedicinalDrug *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__MedicinalDrug);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__MedicinalDrug ** FASTCALL soap_in_PointerTodic__MedicinalDrug(struct soap *soap, const char *tag, dic__MedicinalDrug **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__MedicinalDrug **)soap_malloc(soap, sizeof(dic__MedicinalDrug *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__MedicinalDrug *)soap_instantiate_dic__MedicinalDrug(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__MedicinalDrug ** p = (dic__MedicinalDrug **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__MedicinalDrug, sizeof(dic__MedicinalDrug), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__MedicinalDrug(struct soap *soap, dic__MedicinalDrug *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__MedicinalDrug);
	return soap_out_PointerTodic__MedicinalDrug(soap, tag?tag:"dic:MedicinalDrug", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__MedicinalDrug ** SOAP_FMAC4 soap_get_PointerTodic__MedicinalDrug(struct soap *soap, dic__MedicinalDrug **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Indicator(struct soap *soap, dic__Indicator *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Indicator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Indicator(struct soap *soap, const char *tag, int id, dic__Indicator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Indicator);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Indicator ** FASTCALL soap_in_PointerTodic__Indicator(struct soap *soap, const char *tag, dic__Indicator **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Indicator **)soap_malloc(soap, sizeof(dic__Indicator *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Indicator *)soap_instantiate_dic__Indicator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Indicator ** p = (dic__Indicator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Indicator, sizeof(dic__Indicator), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Indicator(struct soap *soap, dic__Indicator *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Indicator);
	return soap_out_PointerTodic__Indicator(soap, tag?tag:"dic:Indicator", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Indicator ** SOAP_FMAC4 soap_get_PointerTodic__Indicator(struct soap *soap, dic__Indicator **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__DocumentType(struct soap *soap, enum dic__DocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__DocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__DocumentType(struct soap *soap, const char *tag, int id, enum dic__DocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__DocumentType);
	return (id < 0) ? soap->error : soap_out_dic__DocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__DocumentType ** FASTCALL soap_in_PointerTodic__DocumentType(struct soap *soap, const char *tag, enum dic__DocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__DocumentType **)soap_malloc(soap, sizeof(enum dic__DocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__DocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__DocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__DocumentType, sizeof(enum dic__DocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__DocumentType(struct soap *soap, enum dic__DocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__DocumentType);
	return soap_out_PointerTodic__DocumentType(soap, tag?tag:"dic:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__DocumentType ** SOAP_FMAC4 soap_get_PointerTodic__DocumentType(struct soap *soap, enum dic__DocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ConsignmentDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, vd__ConsignmentDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ConsignmentDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList ** FASTCALL soap_in_PointerTovd__ConsignmentDocumentList(struct soap *soap, const char *tag, vd__ConsignmentDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ConsignmentDocumentList **)soap_malloc(soap, sizeof(vd__ConsignmentDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ConsignmentDocumentList *)soap_instantiate_vd__ConsignmentDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ConsignmentDocumentList ** p = (vd__ConsignmentDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ConsignmentDocumentList, sizeof(vd__ConsignmentDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ConsignmentDocumentList);
	return soap_out_PointerTovd__ConsignmentDocumentList(soap, tag?tag:"vd:ConsignmentDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ConsignmentDocumentList ** SOAP_FMAC4 soap_get_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Consignment))
		soap_serialize_PointerTovd__Consignment(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Consignment(struct soap *soap, const char *tag, int id, vd__Consignment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Consignment);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Consignment(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Consignment *** FASTCALL soap_in_PointerToPointerTovd__Consignment(struct soap *soap, const char *tag, vd__Consignment ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Consignment ***)soap_malloc(soap, sizeof(vd__Consignment **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Consignment(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Consignment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Consignment, sizeof(vd__Consignment *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Consignment);
	return soap_out_PointerToPointerTovd__Consignment(soap, tag?tag:"vd:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Consignment *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Consignment(struct soap *soap, vd__Consignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Consignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Consignment(struct soap *soap, const char *tag, int id, vd__Consignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Consignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Consignment ** FASTCALL soap_in_PointerTovd__Consignment(struct soap *soap, const char *tag, vd__Consignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Consignment **)soap_malloc(soap, sizeof(vd__Consignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Consignment *)soap_instantiate_vd__Consignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Consignment ** p = (vd__Consignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Consignment(struct soap *soap, vd__Consignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Consignment);
	return soap_out_PointerTovd__Consignment(soap, tag?tag:"vd:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Consignment ** SOAP_FMAC4 soap_get_PointerTovd__Consignment(struct soap *soap, vd__Consignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__BusinessMember))
		soap_serialize_PointerTodic__BusinessMember(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__BusinessMember(struct soap *soap, const char *tag, int id, dic__BusinessMember **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__BusinessMember);
	return (id < 0) ? soap->error : soap_out_PointerTodic__BusinessMember(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__BusinessMember *** FASTCALL soap_in_PointerToPointerTodic__BusinessMember(struct soap *soap, const char *tag, dic__BusinessMember ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__BusinessMember ***)soap_malloc(soap, sizeof(dic__BusinessMember **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__BusinessMember(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__BusinessMember ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__BusinessMember, sizeof(dic__BusinessMember *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__BusinessMember);
	return soap_out_PointerToPointerTodic__BusinessMember(soap, tag?tag:"dic:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__BusinessMember *** SOAP_FMAC4 soap_get_PointerToPointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__ResearchMethod))
		soap_serialize_PointerTodic__ResearchMethod(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__ResearchMethod(struct soap *soap, const char *tag, int id, dic__ResearchMethod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__ResearchMethod);
	return (id < 0) ? soap->error : soap_out_PointerTodic__ResearchMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__ResearchMethod *** FASTCALL soap_in_PointerToPointerTodic__ResearchMethod(struct soap *soap, const char *tag, dic__ResearchMethod ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ResearchMethod ***)soap_malloc(soap, sizeof(dic__ResearchMethod **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__ResearchMethod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__ResearchMethod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__ResearchMethod, sizeof(dic__ResearchMethod *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__ResearchMethod);
	return soap_out_PointerToPointerTodic__ResearchMethod(soap, tag?tag:"dic:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ResearchMethod *** SOAP_FMAC4 soap_get_PointerToPointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ResearchMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ResearchMethod(struct soap *soap, const char *tag, int id, dic__ResearchMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ResearchMethod);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ResearchMethod ** FASTCALL soap_in_PointerTodic__ResearchMethod(struct soap *soap, const char *tag, dic__ResearchMethod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ResearchMethod **)soap_malloc(soap, sizeof(dic__ResearchMethod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ResearchMethod *)soap_instantiate_dic__ResearchMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ResearchMethod ** p = (dic__ResearchMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ResearchMethod, sizeof(dic__ResearchMethod), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ResearchMethod);
	return soap_out_PointerTodic__ResearchMethod(soap, tag?tag:"dic:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ResearchMethod ** SOAP_FMAC4 soap_get_PointerTodic__ResearchMethod(struct soap *soap, dic__ResearchMethod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__AnimalDisease))
		soap_serialize_PointerTodic__AnimalDisease(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__AnimalDisease(struct soap *soap, const char *tag, int id, dic__AnimalDisease **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__AnimalDisease);
	return (id < 0) ? soap->error : soap_out_PointerTodic__AnimalDisease(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__AnimalDisease *** FASTCALL soap_in_PointerToPointerTodic__AnimalDisease(struct soap *soap, const char *tag, dic__AnimalDisease ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__AnimalDisease ***)soap_malloc(soap, sizeof(dic__AnimalDisease **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__AnimalDisease(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__AnimalDisease ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__AnimalDisease, sizeof(dic__AnimalDisease *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__AnimalDisease);
	return soap_out_PointerToPointerTodic__AnimalDisease(soap, tag?tag:"dic:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__AnimalDisease *** SOAP_FMAC4 soap_get_PointerToPointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationRegionStatus))
		soap_serialize_PointerTodic__RegionalizationRegionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, dic__RegionalizationRegionStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationRegionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationRegionStatus(struct soap *soap, const char *tag, dic__RegionalizationRegionStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationRegionStatus ***)soap_malloc(soap, sizeof(dic__RegionalizationRegionStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationRegionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationRegionStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationRegionStatus, sizeof(dic__RegionalizationRegionStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationRegionStatus);
	return soap_out_PointerToPointerTodic__RegionalizationRegionStatus(soap, tag?tag:"dic:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationRegionStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, dic__RegionalizationRegionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus ** FASTCALL soap_in_PointerTodic__RegionalizationRegionStatus(struct soap *soap, const char *tag, dic__RegionalizationRegionStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationRegionStatus **)soap_malloc(soap, sizeof(dic__RegionalizationRegionStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationRegionStatus *)soap_instantiate_dic__RegionalizationRegionStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationRegionStatus ** p = (dic__RegionalizationRegionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationRegionStatus, sizeof(dic__RegionalizationRegionStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationRegionStatus);
	return soap_out_PointerTodic__RegionalizationRegionStatus(soap, tag?tag:"dic:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationRegionStatus ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationRegionStatus(struct soap *soap, dic__RegionalizationRegionStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__ProductItem(struct soap *soap, dic__ProductItem **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__ProductItem))
		soap_serialize_PointerTodic__ProductItem(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__ProductItem(struct soap *soap, const char *tag, int id, dic__ProductItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__ProductItem);
	return (id < 0) ? soap->error : soap_out_PointerTodic__ProductItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__ProductItem *** FASTCALL soap_in_PointerToPointerTodic__ProductItem(struct soap *soap, const char *tag, dic__ProductItem ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductItem ***)soap_malloc(soap, sizeof(dic__ProductItem **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__ProductItem(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__ProductItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__ProductItem, sizeof(dic__ProductItem *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__ProductItem(struct soap *soap, dic__ProductItem **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__ProductItem);
	return soap_out_PointerToPointerTodic__ProductItem(soap, tag?tag:"dic:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductItem *** SOAP_FMAC4 soap_get_PointerToPointerTodic__ProductItem(struct soap *soap, dic__ProductItem ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__SubProduct(struct soap *soap, dic__SubProduct **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__SubProduct))
		soap_serialize_PointerTodic__SubProduct(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__SubProduct(struct soap *soap, const char *tag, int id, dic__SubProduct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__SubProduct);
	return (id < 0) ? soap->error : soap_out_PointerTodic__SubProduct(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__SubProduct *** FASTCALL soap_in_PointerToPointerTodic__SubProduct(struct soap *soap, const char *tag, dic__SubProduct ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__SubProduct ***)soap_malloc(soap, sizeof(dic__SubProduct **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__SubProduct(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__SubProduct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__SubProduct, sizeof(dic__SubProduct *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__SubProduct(struct soap *soap, dic__SubProduct **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__SubProduct);
	return soap_out_PointerToPointerTodic__SubProduct(soap, tag?tag:"dic:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__SubProduct *** SOAP_FMAC4 soap_get_PointerToPointerTodic__SubProduct(struct soap *soap, dic__SubProduct ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Product(struct soap *soap, dic__Product **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Product))
		soap_serialize_PointerTodic__Product(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Product(struct soap *soap, const char *tag, int id, dic__Product **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Product);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Product(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Product *** FASTCALL soap_in_PointerToPointerTodic__Product(struct soap *soap, const char *tag, dic__Product ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Product ***)soap_malloc(soap, sizeof(dic__Product **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Product(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Product ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Product, sizeof(dic__Product *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Product(struct soap *soap, dic__Product **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Product);
	return soap_out_PointerToPointerTodic__Product(soap, tag?tag:"dic:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Product *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Product(struct soap *soap, dic__Product ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__EnterpriseActivity))
		soap_serialize_PointerTodic__EnterpriseActivity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__EnterpriseActivity(struct soap *soap, const char *tag, int id, dic__EnterpriseActivity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__EnterpriseActivity);
	return (id < 0) ? soap->error : soap_out_PointerTodic__EnterpriseActivity(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__EnterpriseActivity *** FASTCALL soap_in_PointerToPointerTodic__EnterpriseActivity(struct soap *soap, const char *tag, dic__EnterpriseActivity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseActivity ***)soap_malloc(soap, sizeof(dic__EnterpriseActivity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__EnterpriseActivity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__EnterpriseActivity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__EnterpriseActivity, sizeof(dic__EnterpriseActivity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__EnterpriseActivity);
	return soap_out_PointerToPointerTodic__EnterpriseActivity(soap, tag?tag:"dic:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseActivity *** SOAP_FMAC4 soap_get_PointerToPointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseActivity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseActivity(struct soap *soap, const char *tag, int id, dic__EnterpriseActivity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseActivity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__EnterpriseActivity ** FASTCALL soap_in_PointerTodic__EnterpriseActivity(struct soap *soap, const char *tag, dic__EnterpriseActivity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseActivity **)soap_malloc(soap, sizeof(dic__EnterpriseActivity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__EnterpriseActivity *)soap_instantiate_dic__EnterpriseActivity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__EnterpriseActivity ** p = (dic__EnterpriseActivity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseActivity, sizeof(dic__EnterpriseActivity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseActivity);
	return soap_out_PointerTodic__EnterpriseActivity(soap, tag?tag:"dic:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseActivity ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseActivity(struct soap *soap, dic__EnterpriseActivity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Street(struct soap *soap, dic__Street **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Street))
		soap_serialize_PointerTodic__Street(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Street(struct soap *soap, const char *tag, int id, dic__Street **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Street);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Street(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Street *** FASTCALL soap_in_PointerToPointerTodic__Street(struct soap *soap, const char *tag, dic__Street ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Street ***)soap_malloc(soap, sizeof(dic__Street **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Street(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Street ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Street, sizeof(dic__Street *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Street(struct soap *soap, dic__Street **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Street);
	return soap_out_PointerToPointerTodic__Street(soap, tag?tag:"dic:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Street *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Street(struct soap *soap, dic__Street ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Locality(struct soap *soap, dic__Locality **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Locality))
		soap_serialize_PointerTodic__Locality(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Locality(struct soap *soap, const char *tag, int id, dic__Locality **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Locality);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Locality(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Locality *** FASTCALL soap_in_PointerToPointerTodic__Locality(struct soap *soap, const char *tag, dic__Locality ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Locality ***)soap_malloc(soap, sizeof(dic__Locality **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Locality(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Locality ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Locality, sizeof(dic__Locality *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Locality(struct soap *soap, dic__Locality **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Locality);
	return soap_out_PointerToPointerTodic__Locality(soap, tag?tag:"dic:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Locality *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Locality(struct soap *soap, dic__Locality ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__District(struct soap *soap, dic__District **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__District))
		soap_serialize_PointerTodic__District(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__District(struct soap *soap, const char *tag, int id, dic__District **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__District);
	return (id < 0) ? soap->error : soap_out_PointerTodic__District(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__District *** FASTCALL soap_in_PointerToPointerTodic__District(struct soap *soap, const char *tag, dic__District ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__District ***)soap_malloc(soap, sizeof(dic__District **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__District(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__District ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__District, sizeof(dic__District *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__District(struct soap *soap, dic__District **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__District);
	return soap_out_PointerToPointerTodic__District(soap, tag?tag:"dic:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__District *** SOAP_FMAC4 soap_get_PointerToPointerTodic__District(struct soap *soap, dic__District ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Region(struct soap *soap, dic__Region **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Region))
		soap_serialize_PointerTodic__Region(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Region(struct soap *soap, const char *tag, int id, dic__Region **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Region);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Region(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Region *** FASTCALL soap_in_PointerToPointerTodic__Region(struct soap *soap, const char *tag, dic__Region ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Region ***)soap_malloc(soap, sizeof(dic__Region **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Region(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Region ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Region, sizeof(dic__Region *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Region(struct soap *soap, dic__Region **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Region);
	return soap_out_PointerToPointerTodic__Region(soap, tag?tag:"dic:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Region *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Region(struct soap *soap, dic__Region ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Country(struct soap *soap, dic__Country **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Country))
		soap_serialize_PointerTodic__Country(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Country(struct soap *soap, const char *tag, int id, dic__Country **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Country);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Country(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Country *** FASTCALL soap_in_PointerToPointerTodic__Country(struct soap *soap, const char *tag, dic__Country ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Country ***)soap_malloc(soap, sizeof(dic__Country **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Country(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Country ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Country, sizeof(dic__Country *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Country(struct soap *soap, dic__Country **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Country);
	return soap_out_PointerToPointerTodic__Country(soap, tag?tag:"dic:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Country *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Country(struct soap *soap, dic__Country ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Unit(struct soap *soap, dic__Unit **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Unit))
		soap_serialize_PointerTodic__Unit(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Unit(struct soap *soap, const char *tag, int id, dic__Unit **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Unit);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Unit(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Unit *** FASTCALL soap_in_PointerToPointerTodic__Unit(struct soap *soap, const char *tag, dic__Unit ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Unit ***)soap_malloc(soap, sizeof(dic__Unit **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Unit(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Unit ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Unit, sizeof(dic__Unit *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Unit(struct soap *soap, dic__Unit **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Unit);
	return soap_out_PointerToPointerTodic__Unit(soap, tag?tag:"dic:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Unit *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Unit(struct soap *soap, dic__Unit ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Purpose(struct soap *soap, dic__Purpose **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Purpose))
		soap_serialize_PointerTodic__Purpose(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Purpose(struct soap *soap, const char *tag, int id, dic__Purpose **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Purpose);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Purpose(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Purpose *** FASTCALL soap_in_PointerToPointerTodic__Purpose(struct soap *soap, const char *tag, dic__Purpose ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Purpose ***)soap_malloc(soap, sizeof(dic__Purpose **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Purpose(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Purpose ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Purpose, sizeof(dic__Purpose *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Purpose(struct soap *soap, dic__Purpose **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Purpose);
	return soap_out_PointerToPointerTodic__Purpose(soap, tag?tag:"dic:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Purpose *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Purpose(struct soap *soap, dic__Purpose ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__VersionStatus(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__VersionStatus))
		soap_serialize_base__VersionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__VersionStatus(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__VersionStatus);
	return (id < 0) ? soap->error : soap_out_base__VersionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__VersionStatus(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__VersionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__VersionStatus, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__VersionStatus(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__VersionStatus);
	return soap_out_PointerTobase__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__VersionStatus(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__AuthorityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AuthorityList(struct soap *soap, const char *tag, int id, vd__AuthorityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AuthorityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__AuthorityList ** FASTCALL soap_in_PointerTovd__AuthorityList(struct soap *soap, const char *tag, vd__AuthorityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AuthorityList **)soap_malloc(soap, sizeof(vd__AuthorityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__AuthorityList *)soap_instantiate_vd__AuthorityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__AuthorityList ** p = (vd__AuthorityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AuthorityList, sizeof(vd__AuthorityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AuthorityList);
	return soap_out_PointerTovd__AuthorityList(soap, tag?tag:"vd:AuthorityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AuthorityList ** SOAP_FMAC4 soap_get_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__UserList(struct soap *soap, vd__UserList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__UserList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__UserList(struct soap *soap, const char *tag, int id, vd__UserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__UserList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__UserList ** FASTCALL soap_in_PointerTovd__UserList(struct soap *soap, const char *tag, vd__UserList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserList **)soap_malloc(soap, sizeof(vd__UserList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__UserList *)soap_instantiate_vd__UserList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__UserList ** p = (vd__UserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__UserList, sizeof(vd__UserList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__UserList(struct soap *soap, vd__UserList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__UserList);
	return soap_out_PointerTovd__UserList(soap, tag?tag:"vd:UserList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserList ** SOAP_FMAC4 soap_get_PointerTovd__UserList(struct soap *soap, vd__UserList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__User(struct soap *soap, vd__User **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__User))
		soap_serialize_PointerTovd__User(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__User(struct soap *soap, const char *tag, int id, vd__User **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__User);
	return (id < 0) ? soap->error : soap_out_PointerTovd__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__User *** FASTCALL soap_in_PointerToPointerTovd__User(struct soap *soap, const char *tag, vd__User ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__User ***)soap_malloc(soap, sizeof(vd__User **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__User(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__User ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__User, sizeof(vd__User *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__User(struct soap *soap, vd__User **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__User);
	return soap_out_PointerToPointerTovd__User(soap, tag?tag:"vd:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__User *** SOAP_FMAC4 soap_get_PointerToPointerTovd__User(struct soap *soap, vd__User ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RouteSectionR13nRules))
		soap_serialize_PointerTovd__RouteSectionR13nRules(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, vd__RouteSectionR13nRules **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RouteSectionR13nRules);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RouteSectionR13nRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules *** FASTCALL soap_in_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RouteSectionR13nRules ***)soap_malloc(soap, sizeof(vd__RouteSectionR13nRules **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RouteSectionR13nRules(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RouteSectionR13nRules ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules);
	return soap_out_PointerToPointerTovd__RouteSectionR13nRules(soap, tag?tag:"vd:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RouteSectionR13nRules *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RouteSectionR13nRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, vd__RouteSectionR13nRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RouteSectionR13nRules);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules ** FASTCALL soap_in_PointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RouteSectionR13nRules **)soap_malloc(soap, sizeof(vd__RouteSectionR13nRules *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RouteSectionR13nRules *)soap_instantiate_vd__RouteSectionR13nRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RouteSectionR13nRules ** p = (vd__RouteSectionR13nRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RouteSectionR13nRules);
	return soap_out_PointerTovd__RouteSectionR13nRules(soap, tag?tag:"vd:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RouteSectionR13nRules ** SOAP_FMAC4 soap_get_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentList(struct soap *soap, const char *tag, int id, vd__VetDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocumentList ** FASTCALL soap_in_PointerTovd__VetDocumentList(struct soap *soap, const char *tag, vd__VetDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentList **)soap_malloc(soap, sizeof(vd__VetDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocumentList *)soap_instantiate_vd__VetDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocumentList ** p = (vd__VetDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentList, sizeof(vd__VetDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentList);
	return soap_out_PointerTovd__VetDocumentList(soap, tag?tag:"vd:VetDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentList ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Enterprise(struct soap *soap, dic__Enterprise **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Enterprise))
		soap_serialize_PointerTodic__Enterprise(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Enterprise(struct soap *soap, const char *tag, int id, dic__Enterprise **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Enterprise);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Enterprise(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Enterprise *** FASTCALL soap_in_PointerToPointerTodic__Enterprise(struct soap *soap, const char *tag, dic__Enterprise ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Enterprise ***)soap_malloc(soap, sizeof(dic__Enterprise **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Enterprise(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Enterprise ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Enterprise, sizeof(dic__Enterprise *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Enterprise(struct soap *soap, dic__Enterprise **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Enterprise);
	return soap_out_PointerToPointerTodic__Enterprise(soap, tag?tag:"dic:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Enterprise *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Enterprise(struct soap *soap, dic__Enterprise ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__BusinessEntity))
		soap_serialize_PointerTodic__BusinessEntity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__BusinessEntity(struct soap *soap, const char *tag, int id, dic__BusinessEntity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__BusinessEntity);
	return (id < 0) ? soap->error : soap_out_PointerTodic__BusinessEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__BusinessEntity *** FASTCALL soap_in_PointerToPointerTodic__BusinessEntity(struct soap *soap, const char *tag, dic__BusinessEntity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__BusinessEntity ***)soap_malloc(soap, sizeof(dic__BusinessEntity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__BusinessEntity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__BusinessEntity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__BusinessEntity, sizeof(dic__BusinessEntity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__BusinessEntity);
	return soap_out_PointerToPointerTodic__BusinessEntity(soap, tag?tag:"dic:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__BusinessEntity *** SOAP_FMAC4 soap_get_PointerToPointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__OTPToken(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__OTPToken))
		soap_serialize_dic__OTPToken(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__OTPToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__OTPToken);
	return (id < 0) ? soap->error : soap_out_dic__OTPToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTodic__OTPToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__OTPToken(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__OTPToken, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__OTPToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__OTPToken);
	return soap_out_PointerTodic__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTodic__OTPToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__Application(struct soap *soap, app__Application *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__Application))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__Application(struct soap *soap, const char *tag, int id, app__Application *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__Application);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__Application ** FASTCALL soap_in_PointerToapp__Application(struct soap *soap, const char *tag, app__Application **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__Application **)soap_malloc(soap, sizeof(app__Application *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__Application *)soap_instantiate_app__Application(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__Application ** p = (app__Application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__Application, sizeof(app__Application), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__Application(struct soap *soap, app__Application *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__Application);
	return soap_out_PointerToapp__Application(soap, tag?tag:"app:Application", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__Application ** SOAP_FMAC4 soap_get_PointerToapp__Application(struct soap *soap, app__Application **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Area(struct soap *soap, dic__Area *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Area))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Area(struct soap *soap, const char *tag, int id, dic__Area *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Area);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Area ** FASTCALL soap_in_PointerTodic__Area(struct soap *soap, const char *tag, dic__Area **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Area **)soap_malloc(soap, sizeof(dic__Area *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Area *)soap_instantiate_dic__Area(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Area ** p = (dic__Area **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Area, sizeof(dic__Area), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Area(struct soap *soap, dic__Area *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Area);
	return soap_out_PointerTodic__Area(soap, tag?tag:"dic:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Area ** SOAP_FMAC4 soap_get_PointerTodic__Area(struct soap *soap, dic__Area **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__UserAuthority))
		soap_serialize_PointerTovd__UserAuthority(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__UserAuthority(struct soap *soap, const char *tag, int id, vd__UserAuthority **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__UserAuthority);
	return (id < 0) ? soap->error : soap_out_PointerTovd__UserAuthority(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__UserAuthority *** FASTCALL soap_in_PointerToPointerTovd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserAuthority ***)soap_malloc(soap, sizeof(vd__UserAuthority **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__UserAuthority(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__UserAuthority ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__UserAuthority, sizeof(vd__UserAuthority *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__UserAuthority);
	return soap_out_PointerToPointerTovd__UserAuthority(soap, tag?tag:"vd:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserAuthority *** SOAP_FMAC4 soap_get_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__UserAuthority))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__UserAuthority(struct soap *soap, const char *tag, int id, vd__UserAuthority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__UserAuthority);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__UserAuthority ** FASTCALL soap_in_PointerTovd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserAuthority **)soap_malloc(soap, sizeof(vd__UserAuthority *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__UserAuthority *)soap_instantiate_vd__UserAuthority(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__UserAuthority ** p = (vd__UserAuthority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__UserAuthority, sizeof(vd__UserAuthority), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__UserAuthority);
	return soap_out_PointerTovd__UserAuthority(soap, tag?tag:"vd:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserAuthority ** SOAP_FMAC4 soap_get_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationShippingRule))
		soap_serialize_PointerTodic__RegionalizationShippingRule(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, dic__RegionalizationShippingRule **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationShippingRule);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationShippingRule(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRule *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationShippingRule(struct soap *soap, const char *tag, dic__RegionalizationShippingRule ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationShippingRule ***)soap_malloc(soap, sizeof(dic__RegionalizationShippingRule **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationShippingRule(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationShippingRule ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationShippingRule, sizeof(dic__RegionalizationShippingRule *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationShippingRule);
	return soap_out_PointerToPointerTodic__RegionalizationShippingRule(soap, tag?tag:"dic:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationShippingRule *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationShippingRule))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, dic__RegionalizationShippingRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationShippingRule);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationShippingRule ** FASTCALL soap_in_PointerTodic__RegionalizationShippingRule(struct soap *soap, const char *tag, dic__RegionalizationShippingRule **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationShippingRule **)soap_malloc(soap, sizeof(dic__RegionalizationShippingRule *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationShippingRule *)soap_instantiate_dic__RegionalizationShippingRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationShippingRule ** p = (dic__RegionalizationShippingRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationShippingRule, sizeof(dic__RegionalizationShippingRule), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationShippingRule);
	return soap_out_PointerTodic__RegionalizationShippingRule(soap, tag?tag:"dic:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationShippingRule ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationShippingRule(struct soap *soap, dic__RegionalizationShippingRule **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__SequenceNumber(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__SequenceNumber))
		soap_serialize_base__SequenceNumber(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__SequenceNumber(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__SequenceNumber);
	return (id < 0) ? soap->error : soap_out_base__SequenceNumber(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__SequenceNumber(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__SequenceNumber(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__SequenceNumber, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__SequenceNumber(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__SequenceNumber);
	return soap_out_PointerTobase__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__SequenceNumber(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__QuarantineEvent))
		soap_serialize_PointerTovd__QuarantineEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__QuarantineEvent(struct soap *soap, const char *tag, int id, vd__QuarantineEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__QuarantineEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__QuarantineEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__QuarantineEvent *** FASTCALL soap_in_PointerToPointerTovd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__QuarantineEvent ***)soap_malloc(soap, sizeof(vd__QuarantineEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__QuarantineEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__QuarantineEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__QuarantineEvent, sizeof(vd__QuarantineEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__QuarantineEvent);
	return soap_out_PointerToPointerTovd__QuarantineEvent(soap, tag?tag:"vd:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__QuarantineEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RegionalizationClause))
		soap_serialize_PointerTovd__RegionalizationClause(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RegionalizationClause(struct soap *soap, const char *tag, int id, vd__RegionalizationClause **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RegionalizationClause);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RegionalizationClause(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RegionalizationClause *** FASTCALL soap_in_PointerToPointerTovd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RegionalizationClause ***)soap_malloc(soap, sizeof(vd__RegionalizationClause **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RegionalizationClause(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RegionalizationClause ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RegionalizationClause, sizeof(vd__RegionalizationClause *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RegionalizationClause);
	return soap_out_PointerToPointerTovd__RegionalizationClause(soap, tag?tag:"vd:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RegionalizationClause *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RegionalizationClause))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RegionalizationClause(struct soap *soap, const char *tag, int id, vd__RegionalizationClause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RegionalizationClause);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RegionalizationClause ** FASTCALL soap_in_PointerTovd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RegionalizationClause **)soap_malloc(soap, sizeof(vd__RegionalizationClause *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RegionalizationClause *)soap_instantiate_vd__RegionalizationClause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RegionalizationClause ** p = (vd__RegionalizationClause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RegionalizationClause, sizeof(vd__RegionalizationClause), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RegionalizationClause);
	return soap_out_PointerTovd__RegionalizationClause(soap, tag?tag:"vd:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RegionalizationClause ** SOAP_FMAC4 soap_get_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VeterinaryEvent))
		soap_serialize_PointerTovd__VeterinaryEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, int id, vd__VeterinaryEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VeterinaryEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VeterinaryEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VeterinaryEvent *** FASTCALL soap_in_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryEvent ***)soap_malloc(soap, sizeof(vd__VeterinaryEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VeterinaryEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VeterinaryEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VeterinaryEvent, sizeof(vd__VeterinaryEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent);
	return soap_out_PointerToPointerTovd__VeterinaryEvent(soap, tag?tag:"vd:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, int id, vd__VeterinaryEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VeterinaryEvent ** FASTCALL soap_in_PointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryEvent **)soap_malloc(soap, sizeof(vd__VeterinaryEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VeterinaryEvent *)soap_instantiate_vd__VeterinaryEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VeterinaryEvent ** p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryEvent, sizeof(vd__VeterinaryEvent), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryEvent);
	return soap_out_PointerTovd__VeterinaryEvent(soap, tag?tag:"vd:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryEvent ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__AnimalMedicationEvent))
		soap_serialize_PointerTovd__AnimalMedicationEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, vd__AnimalMedicationEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__AnimalMedicationEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__AnimalMedicationEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent *** FASTCALL soap_in_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AnimalMedicationEvent ***)soap_malloc(soap, sizeof(vd__AnimalMedicationEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__AnimalMedicationEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__AnimalMedicationEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent);
	return soap_out_PointerToPointerTovd__AnimalMedicationEvent(soap, tag?tag:"vd:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AnimalMedicationEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__AnimalMedicationEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, vd__AnimalMedicationEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AnimalMedicationEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent ** FASTCALL soap_in_PointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AnimalMedicationEvent **)soap_malloc(soap, sizeof(vd__AnimalMedicationEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__AnimalMedicationEvent *)soap_instantiate_vd__AnimalMedicationEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__AnimalMedicationEvent ** p = (vd__AnimalMedicationEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AnimalMedicationEvent);
	return soap_out_PointerTovd__AnimalMedicationEvent(soap, tag?tag:"vd:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AnimalMedicationEvent ** SOAP_FMAC4 soap_get_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__QuarantineEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__QuarantineEvent(struct soap *soap, const char *tag, int id, vd__QuarantineEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__QuarantineEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__QuarantineEvent ** FASTCALL soap_in_PointerTovd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__QuarantineEvent **)soap_malloc(soap, sizeof(vd__QuarantineEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__QuarantineEvent *)soap_instantiate_vd__QuarantineEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__QuarantineEvent ** p = (vd__QuarantineEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__QuarantineEvent);
	return soap_out_PointerTovd__QuarantineEvent(soap, tag?tag:"vd:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__QuarantineEvent ** SOAP_FMAC4 soap_get_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent))
		soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, vd__LaboratoryResearchEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent *** FASTCALL soap_in_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__LaboratoryResearchEvent ***)soap_malloc(soap, sizeof(vd__LaboratoryResearchEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__LaboratoryResearchEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__LaboratoryResearchEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent);
	return soap_out_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag?tag:"vd:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__LaboratoryResearchEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, vd__LaboratoryResearchEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent ** FASTCALL soap_in_PointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__LaboratoryResearchEvent **)soap_malloc(soap, sizeof(vd__LaboratoryResearchEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__LaboratoryResearchEvent *)soap_instantiate_vd__LaboratoryResearchEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__LaboratoryResearchEvent ** p = (vd__LaboratoryResearchEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent);
	return soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag?tag:"vd:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent ** SOAP_FMAC4 soap_get_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__AnimalSpentPeriod);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, enum vd__AnimalSpentPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AnimalSpentPeriod);
	return (id < 0) ? soap->error : soap_out_vd__AnimalSpentPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod ** FASTCALL soap_in_PointerTovd__AnimalSpentPeriod(struct soap *soap, const char *tag, enum vd__AnimalSpentPeriod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__AnimalSpentPeriod **)soap_malloc(soap, sizeof(enum vd__AnimalSpentPeriod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__AnimalSpentPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__AnimalSpentPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalSpentPeriod, sizeof(enum vd__AnimalSpentPeriod), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AnimalSpentPeriod);
	return soap_out_PointerTovd__AnimalSpentPeriod(soap, tag?tag:"vd:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod ** SOAP_FMAC4 soap_get_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ResearchResult(struct soap *soap, enum dic__ResearchResult *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__ResearchResult);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ResearchResult(struct soap *soap, const char *tag, int id, enum dic__ResearchResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ResearchResult);
	return (id < 0) ? soap->error : soap_out_dic__ResearchResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__ResearchResult ** FASTCALL soap_in_PointerTodic__ResearchResult(struct soap *soap, const char *tag, enum dic__ResearchResult **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__ResearchResult **)soap_malloc(soap, sizeof(enum dic__ResearchResult *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__ResearchResult(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__ResearchResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ResearchResult, sizeof(enum dic__ResearchResult), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ResearchResult(struct soap *soap, enum dic__ResearchResult *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ResearchResult);
	return soap_out_PointerTodic__ResearchResult(soap, tag?tag:"dic:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ResearchResult ** SOAP_FMAC4 soap_get_PointerTodic__ResearchResult(struct soap *soap, enum dic__ResearchResult **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Purpose(struct soap *soap, dic__Purpose *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Purpose))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Purpose(struct soap *soap, const char *tag, int id, dic__Purpose *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Purpose);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Purpose ** FASTCALL soap_in_PointerTodic__Purpose(struct soap *soap, const char *tag, dic__Purpose **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Purpose **)soap_malloc(soap, sizeof(dic__Purpose *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Purpose *)soap_instantiate_dic__Purpose(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Purpose ** p = (dic__Purpose **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Purpose, sizeof(dic__Purpose), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Purpose(struct soap *soap, dic__Purpose *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Purpose);
	return soap_out_PointerTodic__Purpose(soap, tag?tag:"dic:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Purpose ** SOAP_FMAC4 soap_get_PointerTodic__Purpose(struct soap *soap, dic__Purpose **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Document(struct soap *soap, vd__Document **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Document))
		soap_serialize_PointerTovd__Document(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Document(struct soap *soap, const char *tag, int id, vd__Document **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Document);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Document(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Document *** FASTCALL soap_in_PointerToPointerTovd__Document(struct soap *soap, const char *tag, vd__Document ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Document ***)soap_malloc(soap, sizeof(vd__Document **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Document(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Document ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Document, sizeof(vd__Document *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Document(struct soap *soap, vd__Document **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Document);
	return soap_out_PointerToPointerTovd__Document(soap, tag?tag:"vd:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Document *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Document(struct soap *soap, vd__Document ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Document(struct soap *soap, vd__Document *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Document))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Document(struct soap *soap, const char *tag, int id, vd__Document *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Document);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Document ** FASTCALL soap_in_PointerTovd__Document(struct soap *soap, const char *tag, vd__Document **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Document **)soap_malloc(soap, sizeof(vd__Document *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Document *)soap_instantiate_vd__Document(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Document ** p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Document, sizeof(vd__Document), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Document(struct soap *soap, vd__Document *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Document);
	return soap_out_PointerTovd__Document(soap, tag?tag:"vd:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Document ** SOAP_FMAC4 soap_get_PointerTovd__Document(struct soap *soap, vd__Document **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Organization(struct soap *soap, dic__Organization *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Organization))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Organization(struct soap *soap, const char *tag, int id, dic__Organization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Organization);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Organization ** FASTCALL soap_in_PointerTodic__Organization(struct soap *soap, const char *tag, dic__Organization **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Organization **)soap_malloc(soap, sizeof(dic__Organization *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Organization *)soap_instantiate_dic__Organization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Organization ** p = (dic__Organization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Organization, sizeof(dic__Organization), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Organization(struct soap *soap, dic__Organization *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Organization);
	return soap_out_PointerTodic__Organization(soap, tag?tag:"dic:Organization", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Organization ** SOAP_FMAC4 soap_get_PointerTodic__Organization(struct soap *soap, dic__Organization **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Location(struct soap *soap, dic__Location *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Location))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Location(struct soap *soap, const char *tag, int id, dic__Location *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Location);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Location ** FASTCALL soap_in_PointerTodic__Location(struct soap *soap, const char *tag, dic__Location **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Location **)soap_malloc(soap, sizeof(dic__Location *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Location *)soap_instantiate_dic__Location(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Location ** p = (dic__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Location, sizeof(dic__Location), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Location(struct soap *soap, dic__Location *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Location);
	return soap_out_PointerTodic__Location(soap, tag?tag:"dic:Location", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Location ** SOAP_FMAC4 soap_get_PointerTodic__Location(struct soap *soap, dic__Location **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryEventType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryEventType(struct soap *soap, const char *tag, int id, enum vd__VeterinaryEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryEventType);
	return (id < 0) ? soap->error : soap_out_vd__VeterinaryEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VeterinaryEventType ** FASTCALL soap_in_PointerTovd__VeterinaryEventType(struct soap *soap, const char *tag, enum vd__VeterinaryEventType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VeterinaryEventType **)soap_malloc(soap, sizeof(enum vd__VeterinaryEventType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VeterinaryEventType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VeterinaryEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryEventType, sizeof(enum vd__VeterinaryEventType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryEventType);
	return soap_out_PointerTovd__VeterinaryEventType(soap, tag?tag:"vd:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VeterinaryEventType ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ShipmentRoute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ShipmentRoute(struct soap *soap, const char *tag, int id, vd__ShipmentRoute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ShipmentRoute);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ShipmentRoute ** FASTCALL soap_in_PointerTovd__ShipmentRoute(struct soap *soap, const char *tag, vd__ShipmentRoute **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoute **)soap_malloc(soap, sizeof(vd__ShipmentRoute *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ShipmentRoute *)soap_instantiate_vd__ShipmentRoute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ShipmentRoute ** p = (vd__ShipmentRoute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ShipmentRoute, sizeof(vd__ShipmentRoute), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ShipmentRoute);
	return soap_out_PointerTovd__ShipmentRoute(soap, tag?tag:"vd:ShipmentRoute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoute ** SOAP_FMAC4 soap_get_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__TransportationStorageType(struct soap *soap, enum dic__TransportationStorageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__TransportationStorageType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__TransportationStorageType(struct soap *soap, const char *tag, int id, enum dic__TransportationStorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__TransportationStorageType);
	return (id < 0) ? soap->error : soap_out_dic__TransportationStorageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__TransportationStorageType ** FASTCALL soap_in_PointerTodic__TransportationStorageType(struct soap *soap, const char *tag, enum dic__TransportationStorageType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__TransportationStorageType **)soap_malloc(soap, sizeof(enum dic__TransportationStorageType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__TransportationStorageType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__TransportationStorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__TransportationStorageType, sizeof(enum dic__TransportationStorageType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__TransportationStorageType(struct soap *soap, enum dic__TransportationStorageType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__TransportationStorageType);
	return soap_out_PointerTodic__TransportationStorageType(soap, tag?tag:"dic:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__TransportationStorageType ** SOAP_FMAC4 soap_get_PointerTodic__TransportationStorageType(struct soap *soap, enum dic__TransportationStorageType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__TransportInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__TransportInfo(struct soap *soap, const char *tag, int id, vd__TransportInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__TransportInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__TransportInfo ** FASTCALL soap_in_PointerTovd__TransportInfo(struct soap *soap, const char *tag, vd__TransportInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__TransportInfo **)soap_malloc(soap, sizeof(vd__TransportInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__TransportInfo *)soap_instantiate_vd__TransportInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__TransportInfo ** p = (vd__TransportInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__TransportInfo, sizeof(vd__TransportInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__TransportInfo);
	return soap_out_PointerTovd__TransportInfo(soap, tag?tag:"vd:TransportInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__TransportInfo ** SOAP_FMAC4 soap_get_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Batch(struct soap *soap, vd__Batch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Batch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Batch(struct soap *soap, const char *tag, int id, vd__Batch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Batch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Batch ** FASTCALL soap_in_PointerTovd__Batch(struct soap *soap, const char *tag, vd__Batch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Batch **)soap_malloc(soap, sizeof(vd__Batch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Batch *)soap_instantiate_vd__Batch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Batch ** p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Batch, sizeof(vd__Batch), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Batch(struct soap *soap, vd__Batch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Batch);
	return soap_out_PointerTovd__Batch(soap, tag?tag:"vd:Batch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Batch ** SOAP_FMAC4 soap_get_PointerTovd__Batch(struct soap *soap, vd__Batch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseList(struct soap *soap, dic__EnterpriseList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseList(struct soap *soap, const char *tag, int id, dic__EnterpriseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__EnterpriseList ** FASTCALL soap_in_PointerTodic__EnterpriseList(struct soap *soap, const char *tag, dic__EnterpriseList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__EnterpriseList **)soap_malloc(soap, sizeof(dic__EnterpriseList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__EnterpriseList *)soap_instantiate_dic__EnterpriseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__EnterpriseList ** p = (dic__EnterpriseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseList, sizeof(dic__EnterpriseList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseList(struct soap *soap, dic__EnterpriseList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseList);
	return soap_out_PointerTodic__EnterpriseList(soap, tag?tag:"dic:EnterpriseList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__EnterpriseList ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseList(struct soap *soap, dic__EnterpriseList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation ** FASTCALL soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _vd__BEActivityLocationsModificationOperation_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_vd__BEActivityLocationsModificationOperation_activityLocation **)soap_malloc(soap, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_vd__BEActivityLocationsModificationOperation_activityLocation ** p = (_vd__BEActivityLocationsModificationOperation_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation);
	return soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag?tag:"vd:BEActivityLocationsModificationOperation-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__BusinessEntityList(struct soap *soap, dic__BusinessEntityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__BusinessEntityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__BusinessEntityList(struct soap *soap, const char *tag, int id, dic__BusinessEntityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__BusinessEntityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__BusinessEntityList ** FASTCALL soap_in_PointerTodic__BusinessEntityList(struct soap *soap, const char *tag, dic__BusinessEntityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__BusinessEntityList **)soap_malloc(soap, sizeof(dic__BusinessEntityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__BusinessEntityList *)soap_instantiate_dic__BusinessEntityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__BusinessEntityList ** p = (dic__BusinessEntityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__BusinessEntityList, sizeof(dic__BusinessEntityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__BusinessEntityList(struct soap *soap, dic__BusinessEntityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__BusinessEntityList);
	return soap_out_PointerTodic__BusinessEntityList(soap, tag?tag:"dic:BusinessEntityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__BusinessEntityList ** SOAP_FMAC4 soap_get_PointerTodic__BusinessEntityList(struct soap *soap, dic__BusinessEntityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ProductItemList(struct soap *soap, dic__ProductItemList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ProductItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ProductItemList(struct soap *soap, const char *tag, int id, dic__ProductItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ProductItemList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ProductItemList ** FASTCALL soap_in_PointerTodic__ProductItemList(struct soap *soap, const char *tag, dic__ProductItemList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductItemList **)soap_malloc(soap, sizeof(dic__ProductItemList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ProductItemList *)soap_instantiate_dic__ProductItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ProductItemList ** p = (dic__ProductItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ProductItemList, sizeof(dic__ProductItemList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ProductItemList(struct soap *soap, dic__ProductItemList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ProductItemList);
	return soap_out_PointerTodic__ProductItemList(soap, tag?tag:"dic:ProductItemList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductItemList ** SOAP_FMAC4 soap_get_PointerTodic__ProductItemList(struct soap *soap, dic__ProductItemList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__StockEntry))
		soap_serialize_PointerTovd__StockEntry(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__StockEntry(struct soap *soap, const char *tag, int id, vd__StockEntry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__StockEntry);
	return (id < 0) ? soap->error : soap_out_PointerTovd__StockEntry(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__StockEntry *** FASTCALL soap_in_PointerToPointerTovd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntry ***)soap_malloc(soap, sizeof(vd__StockEntry **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__StockEntry(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__StockEntry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__StockEntry, sizeof(vd__StockEntry *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__StockEntry);
	return soap_out_PointerToPointerTovd__StockEntry(soap, tag?tag:"vd:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntry *** SOAP_FMAC4 soap_get_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__RegisterModificationType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__RegisterModificationType(struct soap *soap, const char *tag, int id, enum base__RegisterModificationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__RegisterModificationType);
	return (id < 0) ? soap->error : soap_out_base__RegisterModificationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum base__RegisterModificationType ** FASTCALL soap_in_PointerTobase__RegisterModificationType(struct soap *soap, const char *tag, enum base__RegisterModificationType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum base__RegisterModificationType **)soap_malloc(soap, sizeof(enum base__RegisterModificationType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__RegisterModificationType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum base__RegisterModificationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__RegisterModificationType, sizeof(enum base__RegisterModificationType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__RegisterModificationType);
	return soap_out_PointerTobase__RegisterModificationType(soap, tag?tag:"base:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum base__RegisterModificationType ** SOAP_FMAC4 soap_get_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ProcessingProcedure))
		soap_serialize_PointerTovd__ProcessingProcedure(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, int id, vd__ProcessingProcedure **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ProcessingProcedure);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ProcessingProcedure(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ProcessingProcedure *** FASTCALL soap_in_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProcessingProcedure ***)soap_malloc(soap, sizeof(vd__ProcessingProcedure **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ProcessingProcedure(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ProcessingProcedure ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ProcessingProcedure, sizeof(vd__ProcessingProcedure *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure);
	return soap_out_PointerToPointerTovd__ProcessingProcedure(soap, tag?tag:"vd:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProcessingProcedure *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProcessingProcedure))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, int id, vd__ProcessingProcedure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProcessingProcedure);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProcessingProcedure ** FASTCALL soap_in_PointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProcessingProcedure **)soap_malloc(soap, sizeof(vd__ProcessingProcedure *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProcessingProcedure *)soap_instantiate_vd__ProcessingProcedure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProcessingProcedure ** p = (vd__ProcessingProcedure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProcessingProcedure, sizeof(vd__ProcessingProcedure), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProcessingProcedure);
	return soap_out_PointerTovd__ProcessingProcedure(soap, tag?tag:"vd:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProcessingProcedure ** SOAP_FMAC4 soap_get_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ProductiveBatch))
		soap_serialize_PointerTovd__ProductiveBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ProductiveBatch(struct soap *soap, const char *tag, int id, vd__ProductiveBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ProductiveBatch);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ProductiveBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ProductiveBatch *** FASTCALL soap_in_PointerToPointerTovd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductiveBatch ***)soap_malloc(soap, sizeof(vd__ProductiveBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ProductiveBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ProductiveBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ProductiveBatch, sizeof(vd__ProductiveBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ProductiveBatch);
	return soap_out_PointerToPointerTovd__ProductiveBatch(soap, tag?tag:"vd:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductiveBatch *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProductiveBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProductiveBatch(struct soap *soap, const char *tag, int id, vd__ProductiveBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProductiveBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProductiveBatch ** FASTCALL soap_in_PointerTovd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductiveBatch **)soap_malloc(soap, sizeof(vd__ProductiveBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProductiveBatch *)soap_instantiate_vd__ProductiveBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProductiveBatch ** p = (vd__ProductiveBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProductiveBatch);
	return soap_out_PointerTovd__ProductiveBatch(soap, tag?tag:"vd:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductiveBatch ** SOAP_FMAC4 soap_get_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RawBatch))
		soap_serialize_PointerTovd__RawBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RawBatch(struct soap *soap, const char *tag, int id, vd__RawBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RawBatch);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RawBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RawBatch *** FASTCALL soap_in_PointerToPointerTovd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RawBatch ***)soap_malloc(soap, sizeof(vd__RawBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RawBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RawBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RawBatch, sizeof(vd__RawBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RawBatch);
	return soap_out_PointerToPointerTovd__RawBatch(soap, tag?tag:"vd:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RawBatch *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RawBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RawBatch(struct soap *soap, const char *tag, int id, vd__RawBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RawBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RawBatch ** FASTCALL soap_in_PointerTovd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RawBatch **)soap_malloc(soap, sizeof(vd__RawBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RawBatch *)soap_instantiate_vd__RawBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RawBatch ** p = (vd__RawBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RawBatch, sizeof(vd__RawBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RawBatch);
	return soap_out_PointerTovd__RawBatch(soap, tag?tag:"vd:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RawBatch ** SOAP_FMAC4 soap_get_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ShipmentRoutePoint))
		soap_serialize_PointerTovd__ShipmentRoutePoint(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, vd__ShipmentRoutePoint **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ShipmentRoutePoint);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ShipmentRoutePoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint *** FASTCALL soap_in_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoutePoint ***)soap_malloc(soap, sizeof(vd__ShipmentRoutePoint **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ShipmentRoutePoint(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoutePoint ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint);
	return soap_out_PointerToPointerTovd__ShipmentRoutePoint(soap, tag?tag:"vd:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoutePoint *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ShipmentRoutePoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, vd__ShipmentRoutePoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ShipmentRoutePoint);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint ** FASTCALL soap_in_PointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoutePoint **)soap_malloc(soap, sizeof(vd__ShipmentRoutePoint *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ShipmentRoutePoint *)soap_instantiate_vd__ShipmentRoutePoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ShipmentRoutePoint ** p = (vd__ShipmentRoutePoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ShipmentRoutePoint);
	return soap_out_PointerTovd__ShipmentRoutePoint(soap, tag?tag:"vd:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoutePoint ** SOAP_FMAC4 soap_get_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__TransportNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__TransportNumber(struct soap *soap, const char *tag, int id, vd__TransportNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__TransportNumber);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__TransportNumber ** FASTCALL soap_in_PointerTovd__TransportNumber(struct soap *soap, const char *tag, vd__TransportNumber **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__TransportNumber **)soap_malloc(soap, sizeof(vd__TransportNumber *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__TransportNumber *)soap_instantiate_vd__TransportNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__TransportNumber ** p = (vd__TransportNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__TransportNumber, sizeof(vd__TransportNumber), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__TransportNumber);
	return soap_out_PointerTovd__TransportNumber(soap, tag?tag:"vd:TransportNumber", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__TransportNumber ** SOAP_FMAC4 soap_get_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__TransportType(struct soap *soap, enum dic__TransportType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__TransportType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__TransportType(struct soap *soap, const char *tag, int id, enum dic__TransportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__TransportType);
	return (id < 0) ? soap->error : soap_out_dic__TransportType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__TransportType ** FASTCALL soap_in_PointerTodic__TransportType(struct soap *soap, const char *tag, enum dic__TransportType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__TransportType **)soap_malloc(soap, sizeof(enum dic__TransportType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__TransportType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__TransportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__TransportType, sizeof(enum dic__TransportType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__TransportType(struct soap *soap, enum dic__TransportType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__TransportType);
	return soap_out_PointerTodic__TransportType(soap, tag?tag:"dic:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__TransportType ** SOAP_FMAC4 soap_get_PointerTodic__TransportType(struct soap *soap, enum dic__TransportType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryList(struct soap *soap, const char *tag, int id, vd__StockEntryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntryList ** FASTCALL soap_in_PointerTovd__StockEntryList(struct soap *soap, const char *tag, vd__StockEntryList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntryList **)soap_malloc(soap, sizeof(vd__StockEntryList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntryList *)soap_instantiate_vd__StockEntryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntryList ** p = (vd__StockEntryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryList, sizeof(vd__StockEntryList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryList);
	return soap_out_PointerTovd__StockEntryList(soap, tag?tag:"vd:StockEntryList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntryList ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ComplexDate(struct soap *soap, dic__ComplexDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ComplexDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ComplexDate(struct soap *soap, const char *tag, int id, dic__ComplexDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ComplexDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ComplexDate ** FASTCALL soap_in_PointerTodic__ComplexDate(struct soap *soap, const char *tag, dic__ComplexDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ComplexDate **)soap_malloc(soap, sizeof(dic__ComplexDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ComplexDate *)soap_instantiate_dic__ComplexDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ComplexDate ** p = (dic__ComplexDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ComplexDate, sizeof(dic__ComplexDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ComplexDate(struct soap *soap, dic__ComplexDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ComplexDate);
	return soap_out_PointerTodic__ComplexDate(soap, tag?tag:"dic:ComplexDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ComplexDate ** SOAP_FMAC4 soap_get_PointerTodic__ComplexDate(struct soap *soap, dic__ComplexDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ReferencedDocument))
		soap_serialize_PointerTovd__ReferencedDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ReferencedDocument(struct soap *soap, const char *tag, int id, vd__ReferencedDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ReferencedDocument);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ReferencedDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ReferencedDocument *** FASTCALL soap_in_PointerToPointerTovd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ReferencedDocument ***)soap_malloc(soap, sizeof(vd__ReferencedDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ReferencedDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ReferencedDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ReferencedDocument, sizeof(vd__ReferencedDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ReferencedDocument);
	return soap_out_PointerToPointerTovd__ReferencedDocument(soap, tag?tag:"vd:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ReferencedDocument *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ReferencedDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ReferencedDocument(struct soap *soap, const char *tag, int id, vd__ReferencedDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ReferencedDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ReferencedDocument ** FASTCALL soap_in_PointerTovd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ReferencedDocument **)soap_malloc(soap, sizeof(vd__ReferencedDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ReferencedDocument *)soap_instantiate_vd__ReferencedDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ReferencedDocument ** p = (vd__ReferencedDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ReferencedDocument);
	return soap_out_PointerTovd__ReferencedDocument(soap, tag?tag:"vd:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ReferencedDocument ** SOAP_FMAC4 soap_get_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VetDocument))
		soap_serialize_PointerTovd__VetDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VetDocument(struct soap *soap, const char *tag, int id, vd__VetDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VetDocument);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VetDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VetDocument *** FASTCALL soap_in_PointerToPointerTovd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocument ***)soap_malloc(soap, sizeof(vd__VetDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VetDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VetDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VetDocument, sizeof(vd__VetDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VetDocument);
	return soap_out_PointerToPointerTovd__VetDocument(soap, tag?tag:"vd:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocument *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocument(struct soap *soap, const char *tag, int id, vd__VetDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocument ** FASTCALL soap_in_PointerTovd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocument **)soap_malloc(soap, sizeof(vd__VetDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocument *)soap_instantiate_vd__VetDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocument ** p = (vd__VetDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocument);
	return soap_out_PointerTovd__VetDocument(soap, tag?tag:"vd:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocument ** SOAP_FMAC4 soap_get_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Waybill(struct soap *soap, vd__Waybill *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Waybill))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Waybill(struct soap *soap, const char *tag, int id, vd__Waybill *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Waybill);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Waybill ** FASTCALL soap_in_PointerTovd__Waybill(struct soap *soap, const char *tag, vd__Waybill **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Waybill **)soap_malloc(soap, sizeof(vd__Waybill *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Waybill *)soap_instantiate_vd__Waybill(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Waybill ** p = (vd__Waybill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Waybill(struct soap *soap, vd__Waybill *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Waybill);
	return soap_out_PointerTovd__Waybill(soap, tag?tag:"vd:Waybill", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Waybill ** SOAP_FMAC4 soap_get_PointerTovd__Waybill(struct soap *soap, vd__Waybill **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__User(struct soap *soap, vd__User *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__User))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__User(struct soap *soap, const char *tag, int id, vd__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__User);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__User ** FASTCALL soap_in_PointerTovd__User(struct soap *soap, const char *tag, vd__User **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__User **)soap_malloc(soap, sizeof(vd__User *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__User *)soap_instantiate_vd__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__User ** p = (vd__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__User, sizeof(vd__User), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__User(struct soap *soap, vd__User *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__User);
	return soap_out_PointerTovd__User(soap, tag?tag:"vd:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__User ** SOAP_FMAC4 soap_get_PointerTovd__User(struct soap *soap, vd__User **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DeliveryInspection))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DeliveryInspection(struct soap *soap, const char *tag, int id, vd__DeliveryInspection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DeliveryInspection);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DeliveryInspection ** FASTCALL soap_in_PointerTovd__DeliveryInspection(struct soap *soap, const char *tag, vd__DeliveryInspection **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DeliveryInspection **)soap_malloc(soap, sizeof(vd__DeliveryInspection *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DeliveryInspection *)soap_instantiate_vd__DeliveryInspection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DeliveryInspection ** p = (vd__DeliveryInspection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DeliveryInspection, sizeof(vd__DeliveryInspection), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DeliveryInspection);
	return soap_out_PointerTovd__DeliveryInspection(soap, tag?tag:"vd:DeliveryInspection", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DeliveryInspection ** SOAP_FMAC4 soap_get_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntry(struct soap *soap, const char *tag, int id, vd__StockEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntry);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntry ** FASTCALL soap_in_PointerTovd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntry **)soap_malloc(soap, sizeof(vd__StockEntry *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntry *)soap_instantiate_vd__StockEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntry ** p = (vd__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntry, sizeof(vd__StockEntry), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntry);
	return soap_out_PointerTovd__StockEntry(soap, tag?tag:"vd:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntry ** SOAP_FMAC4 soap_get_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__PackageList(struct soap *soap, dic__PackageList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__PackageList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__PackageList(struct soap *soap, const char *tag, int id, dic__PackageList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__PackageList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__PackageList ** FASTCALL soap_in_PointerTodic__PackageList(struct soap *soap, const char *tag, dic__PackageList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__PackageList **)soap_malloc(soap, sizeof(dic__PackageList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__PackageList *)soap_instantiate_dic__PackageList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__PackageList ** p = (dic__PackageList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__PackageList, sizeof(dic__PackageList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__PackageList(struct soap *soap, dic__PackageList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__PackageList);
	return soap_out_PointerTodic__PackageList(soap, tag?tag:"dic:PackageList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__PackageList ** SOAP_FMAC4 soap_get_PointerTodic__PackageList(struct soap *soap, dic__PackageList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BatchOrigin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BatchOrigin(struct soap *soap, const char *tag, int id, vd__BatchOrigin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BatchOrigin);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BatchOrigin ** FASTCALL soap_in_PointerTovd__BatchOrigin(struct soap *soap, const char *tag, vd__BatchOrigin **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BatchOrigin **)soap_malloc(soap, sizeof(vd__BatchOrigin *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BatchOrigin *)soap_instantiate_vd__BatchOrigin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BatchOrigin ** p = (vd__BatchOrigin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BatchOrigin, sizeof(vd__BatchOrigin), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BatchOrigin);
	return soap_out_PointerTovd__BatchOrigin(soap, tag?tag:"vd:BatchOrigin", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BatchOrigin ** SOAP_FMAC4 soap_get_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__GoodsDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__GoodsDate(struct soap *soap, const char *tag, int id, vd__GoodsDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__GoodsDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__GoodsDate ** FASTCALL soap_in_PointerTovd__GoodsDate(struct soap *soap, const char *tag, vd__GoodsDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__GoodsDate **)soap_malloc(soap, sizeof(vd__GoodsDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__GoodsDate *)soap_instantiate_vd__GoodsDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__GoodsDate ** p = (vd__GoodsDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__GoodsDate, sizeof(vd__GoodsDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__GoodsDate);
	return soap_out_PointerTovd__GoodsDate(soap, tag?tag:"vd:GoodsDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__GoodsDate ** SOAP_FMAC4 soap_get_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ProductItem(struct soap *soap, dic__ProductItem *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ProductItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ProductItem(struct soap *soap, const char *tag, int id, dic__ProductItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ProductItem);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ProductItem ** FASTCALL soap_in_PointerTodic__ProductItem(struct soap *soap, const char *tag, dic__ProductItem **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductItem **)soap_malloc(soap, sizeof(dic__ProductItem *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ProductItem *)soap_instantiate_dic__ProductItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ProductItem ** p = (dic__ProductItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ProductItem, sizeof(dic__ProductItem), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ProductItem(struct soap *soap, dic__ProductItem *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ProductItem);
	return soap_out_PointerTodic__ProductItem(soap, tag?tag:"dic:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductItem ** SOAP_FMAC4 soap_get_PointerTodic__ProductItem(struct soap *soap, dic__ProductItem **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__SubProduct(struct soap *soap, dic__SubProduct *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__SubProduct))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__SubProduct(struct soap *soap, const char *tag, int id, dic__SubProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__SubProduct);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__SubProduct ** FASTCALL soap_in_PointerTodic__SubProduct(struct soap *soap, const char *tag, dic__SubProduct **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__SubProduct **)soap_malloc(soap, sizeof(dic__SubProduct *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__SubProduct *)soap_instantiate_dic__SubProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__SubProduct ** p = (dic__SubProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__SubProduct, sizeof(dic__SubProduct), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__SubProduct(struct soap *soap, dic__SubProduct *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__SubProduct);
	return soap_out_PointerTodic__SubProduct(soap, tag?tag:"dic:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__SubProduct ** SOAP_FMAC4 soap_get_PointerTodic__SubProduct(struct soap *soap, dic__SubProduct **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Product(struct soap *soap, dic__Product *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Product))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Product(struct soap *soap, const char *tag, int id, dic__Product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Product);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Product ** FASTCALL soap_in_PointerTodic__Product(struct soap *soap, const char *tag, dic__Product **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Product **)soap_malloc(soap, sizeof(dic__Product *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Product *)soap_instantiate_dic__Product(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Product ** p = (dic__Product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Product, sizeof(dic__Product), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Product(struct soap *soap, dic__Product *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Product);
	return soap_out_PointerTodic__Product(soap, tag?tag:"dic:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Product ** SOAP_FMAC4 soap_get_PointerTodic__Product(struct soap *soap, dic__Product **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ProductType(struct soap *soap, enum dic__ProductType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__ProductType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ProductType(struct soap *soap, const char *tag, int id, enum dic__ProductType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ProductType);
	return (id < 0) ? soap->error : soap_out_dic__ProductType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__ProductType ** FASTCALL soap_in_PointerTodic__ProductType(struct soap *soap, const char *tag, enum dic__ProductType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__ProductType **)soap_malloc(soap, sizeof(enum dic__ProductType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__ProductType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__ProductType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ProductType, sizeof(enum dic__ProductType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ProductType(struct soap *soap, enum dic__ProductType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ProductType);
	return soap_out_PointerTodic__ProductType(soap, tag?tag:"dic:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__ProductType ** SOAP_FMAC4 soap_get_PointerTodic__ProductType(struct soap *soap, enum dic__ProductType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationConditionGroup))
		soap_serialize_PointerTodic__RegionalizationConditionGroup(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, dic__RegionalizationConditionGroup **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationConditionGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationConditionGroup(struct soap *soap, const char *tag, dic__RegionalizationConditionGroup ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationConditionGroup ***)soap_malloc(soap, sizeof(dic__RegionalizationConditionGroup **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationConditionGroup(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationConditionGroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationConditionGroup, sizeof(dic__RegionalizationConditionGroup *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationConditionGroup);
	return soap_out_PointerToPointerTodic__RegionalizationConditionGroup(soap, tag?tag:"dic:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationConditionGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, dic__RegionalizationConditionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup ** FASTCALL soap_in_PointerTodic__RegionalizationConditionGroup(struct soap *soap, const char *tag, dic__RegionalizationConditionGroup **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationConditionGroup **)soap_malloc(soap, sizeof(dic__RegionalizationConditionGroup *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationConditionGroup *)soap_instantiate_dic__RegionalizationConditionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationConditionGroup ** p = (dic__RegionalizationConditionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationConditionGroup, sizeof(dic__RegionalizationConditionGroup), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationConditionGroup);
	return soap_out_PointerTodic__RegionalizationConditionGroup(soap, tag?tag:"dic:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationConditionGroup ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationConditionGroup(struct soap *soap, dic__RegionalizationConditionGroup **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__AnimalDisease))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__AnimalDisease(struct soap *soap, const char *tag, int id, dic__AnimalDisease *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__AnimalDisease);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__AnimalDisease ** FASTCALL soap_in_PointerTodic__AnimalDisease(struct soap *soap, const char *tag, dic__AnimalDisease **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__AnimalDisease **)soap_malloc(soap, sizeof(dic__AnimalDisease *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__AnimalDisease *)soap_instantiate_dic__AnimalDisease(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__AnimalDisease ** p = (dic__AnimalDisease **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__AnimalDisease, sizeof(dic__AnimalDisease), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__AnimalDisease);
	return soap_out_PointerTodic__AnimalDisease(soap, tag?tag:"dic:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__AnimalDisease ** SOAP_FMAC4 soap_get_PointerTodic__AnimalDisease(struct soap *soap, dic__AnimalDisease **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__RegionalizationCondition))
		soap_serialize_PointerTodic__RegionalizationCondition(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__RegionalizationCondition(struct soap *soap, const char *tag, int id, dic__RegionalizationCondition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__RegionalizationCondition);
	return (id < 0) ? soap->error : soap_out_PointerTodic__RegionalizationCondition(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__RegionalizationCondition *** FASTCALL soap_in_PointerToPointerTodic__RegionalizationCondition(struct soap *soap, const char *tag, dic__RegionalizationCondition ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationCondition ***)soap_malloc(soap, sizeof(dic__RegionalizationCondition **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__RegionalizationCondition(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__RegionalizationCondition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__RegionalizationCondition, sizeof(dic__RegionalizationCondition *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__RegionalizationCondition);
	return soap_out_PointerToPointerTodic__RegionalizationCondition(soap, tag?tag:"dic:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationCondition *** SOAP_FMAC4 soap_get_PointerToPointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__RegionalizationCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__RegionalizationCondition(struct soap *soap, const char *tag, int id, dic__RegionalizationCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__RegionalizationCondition);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__RegionalizationCondition ** FASTCALL soap_in_PointerTodic__RegionalizationCondition(struct soap *soap, const char *tag, dic__RegionalizationCondition **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__RegionalizationCondition **)soap_malloc(soap, sizeof(dic__RegionalizationCondition *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__RegionalizationCondition *)soap_instantiate_dic__RegionalizationCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__RegionalizationCondition ** p = (dic__RegionalizationCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__RegionalizationCondition, sizeof(dic__RegionalizationCondition), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__RegionalizationCondition);
	return soap_out_PointerTodic__RegionalizationCondition(soap, tag?tag:"dic:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__RegionalizationCondition ** SOAP_FMAC4 soap_get_PointerTodic__RegionalizationCondition(struct soap *soap, dic__RegionalizationCondition **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__BusinessMember))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__BusinessMember(struct soap *soap, const char *tag, int id, dic__BusinessMember *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__BusinessMember);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__BusinessMember ** FASTCALL soap_in_PointerTodic__BusinessMember(struct soap *soap, const char *tag, dic__BusinessMember **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__BusinessMember **)soap_malloc(soap, sizeof(dic__BusinessMember *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__BusinessMember *)soap_instantiate_dic__BusinessMember(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__BusinessMember ** p = (dic__BusinessMember **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__BusinessMember, sizeof(dic__BusinessMember), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__BusinessMember);
	return soap_out_PointerTodic__BusinessMember(soap, tag?tag:"dic:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__BusinessMember ** SOAP_FMAC4 soap_get_PointerTodic__BusinessMember(struct soap *soap, dic__BusinessMember **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Identifier(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Identifier))
		soap_serialize_base__Identifier(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Identifier(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Identifier);
	return (id < 0) ? soap->error : soap_out_base__Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__Identifier(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Identifier, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Identifier(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Identifier);
	return soap_out_PointerTobase__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__Identifier(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Address(struct soap *soap, dic__Address *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Address(struct soap *soap, const char *tag, int id, dic__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Address);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Address ** FASTCALL soap_in_PointerTodic__Address(struct soap *soap, const char *tag, dic__Address **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Address **)soap_malloc(soap, sizeof(dic__Address *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Address *)soap_instantiate_dic__Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Address ** p = (dic__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Address, sizeof(dic__Address), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (dic__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Area, sizeof(dic__Area), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Address(struct soap *soap, dic__Address *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Address);
	return soap_out_PointerTodic__Address(soap, tag?tag:"dic:Address", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Address ** SOAP_FMAC4 soap_get_PointerTodic__Address(struct soap *soap, dic__Address **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Unit(struct soap *soap, dic__Unit *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Unit))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Unit(struct soap *soap, const char *tag, int id, dic__Unit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Unit);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Unit ** FASTCALL soap_in_PointerTodic__Unit(struct soap *soap, const char *tag, dic__Unit **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Unit **)soap_malloc(soap, sizeof(dic__Unit *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Unit *)soap_instantiate_dic__Unit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Unit ** p = (dic__Unit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Unit, sizeof(dic__Unit), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Unit(struct soap *soap, dic__Unit *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Unit);
	return soap_out_PointerTodic__Unit(soap, tag?tag:"dic:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Unit ** SOAP_FMAC4 soap_get_PointerTodic__Unit(struct soap *soap, dic__Unit **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Decimal(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Decimal))
		soap_serialize_base__Decimal(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Decimal(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Decimal);
	return (id < 0) ? soap->error : soap_out_base__Decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__Decimal(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Decimal(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Decimal, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Decimal(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Decimal);
	return soap_out_PointerTobase__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__Decimal(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Minute(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__Minute);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Minute(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Minute);
	return (id < 0) ? soap->error : soap_out_dic__Minute(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTodic__Minute(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__Minute(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Minute, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Minute(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Minute);
	return soap_out_PointerTodic__Minute(soap, tag?tag:"dic:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTodic__Minute(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Hour(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__Hour);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Hour(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Hour);
	return (id < 0) ? soap->error : soap_out_dic__Hour(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTodic__Hour(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__Hour(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Hour, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Hour(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Hour);
	return soap_out_PointerTodic__Hour(soap, tag?tag:"dic:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTodic__Hour(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Day(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__Day);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Day(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Day);
	return (id < 0) ? soap->error : soap_out_dic__Day(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTodic__Day(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__Day(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Day, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Day(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Day);
	return soap_out_PointerTodic__Day(soap, tag?tag:"dic:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTodic__Day(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Month(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__Month);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Month(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Month);
	return (id < 0) ? soap->error : soap_out_dic__Month(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTodic__Month(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__Month(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Month, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Month(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Month);
	return soap_out_PointerTodic__Month(soap, tag?tag:"dic:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTodic__Month(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Year(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__Year);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Year(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Year);
	return (id < 0) ? soap->error : soap_out_dic__Year(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTodic__Year(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__Year(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Year, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Year(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Year);
	return soap_out_PointerTodic__Year(soap, tag?tag:"dic:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTodic__Year(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Package(struct soap *soap, dic__Package **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Package))
		soap_serialize_PointerTodic__Package(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Package(struct soap *soap, const char *tag, int id, dic__Package **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Package);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Package(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Package *** FASTCALL soap_in_PointerToPointerTodic__Package(struct soap *soap, const char *tag, dic__Package ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Package ***)soap_malloc(soap, sizeof(dic__Package **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Package(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Package ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Package, sizeof(dic__Package *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Package(struct soap *soap, dic__Package **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Package);
	return soap_out_PointerToPointerTodic__Package(soap, tag?tag:"dic:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Package *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Package(struct soap *soap, dic__Package ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Package(struct soap *soap, dic__Package *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Package))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Package(struct soap *soap, const char *tag, int id, dic__Package *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Package);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Package ** FASTCALL soap_in_PointerTodic__Package(struct soap *soap, const char *tag, dic__Package **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Package **)soap_malloc(soap, sizeof(dic__Package *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Package *)soap_instantiate_dic__Package(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Package ** p = (dic__Package **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Package, sizeof(dic__Package), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Package(struct soap *soap, dic__Package *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Package);
	return soap_out_PointerTodic__Package(soap, tag?tag:"dic:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Package ** SOAP_FMAC4 soap_get_PointerTodic__Package(struct soap *soap, dic__Package **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__ProductMarks))
		soap_serialize_PointerTodic__ProductMarks(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__ProductMarks(struct soap *soap, const char *tag, int id, dic__ProductMarks **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__ProductMarks);
	return (id < 0) ? soap->error : soap_out_PointerTodic__ProductMarks(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__ProductMarks *** FASTCALL soap_in_PointerToPointerTodic__ProductMarks(struct soap *soap, const char *tag, dic__ProductMarks ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductMarks ***)soap_malloc(soap, sizeof(dic__ProductMarks **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__ProductMarks(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__ProductMarks ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__ProductMarks, sizeof(dic__ProductMarks *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__ProductMarks);
	return soap_out_PointerToPointerTodic__ProductMarks(soap, tag?tag:"dic:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductMarks *** SOAP_FMAC4 soap_get_PointerToPointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__ProductMarks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__ProductMarks(struct soap *soap, const char *tag, int id, dic__ProductMarks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__ProductMarks);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__ProductMarks ** FASTCALL soap_in_PointerTodic__ProductMarks(struct soap *soap, const char *tag, dic__ProductMarks **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__ProductMarks **)soap_malloc(soap, sizeof(dic__ProductMarks *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__ProductMarks *)soap_instantiate_dic__ProductMarks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__ProductMarks ** p = (dic__ProductMarks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__ProductMarks, sizeof(dic__ProductMarks), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__ProductMarks);
	return soap_out_PointerTodic__ProductMarks(soap, tag?tag:"dic:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__ProductMarks ** SOAP_FMAC4 soap_get_PointerTodic__ProductMarks(struct soap *soap, dic__ProductMarks **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__PackingType(struct soap *soap, dic__PackingType *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__PackingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__PackingType(struct soap *soap, const char *tag, int id, dic__PackingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__PackingType);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__PackingType ** FASTCALL soap_in_PointerTodic__PackingType(struct soap *soap, const char *tag, dic__PackingType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__PackingType **)soap_malloc(soap, sizeof(dic__PackingType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__PackingType *)soap_instantiate_dic__PackingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__PackingType ** p = (dic__PackingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__PackingType, sizeof(dic__PackingType), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__PackingType(struct soap *soap, dic__PackingType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__PackingType);
	return soap_out_PointerTodic__PackingType(soap, tag?tag:"dic:PackingType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__PackingType ** SOAP_FMAC4 soap_get_PointerTodic__PackingType(struct soap *soap, dic__PackingType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__GLNType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__GLNType))
		soap_serialize_dic__GLNType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__GLNType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__GLNType);
	return (id < 0) ? soap->error : soap_out_dic__GLNType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTodic__GLNType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__GLNType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__GLNType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__GLNType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__GLNType);
	return soap_out_PointerTodic__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTodic__GLNType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__BusinessEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__BusinessEntity(struct soap *soap, const char *tag, int id, dic__BusinessEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__BusinessEntity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__BusinessEntity ** FASTCALL soap_in_PointerTodic__BusinessEntity(struct soap *soap, const char *tag, dic__BusinessEntity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__BusinessEntity **)soap_malloc(soap, sizeof(dic__BusinessEntity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__BusinessEntity *)soap_instantiate_dic__BusinessEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__BusinessEntity ** p = (dic__BusinessEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__BusinessEntity, sizeof(dic__BusinessEntity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__BusinessEntity);
	return soap_out_PointerTodic__BusinessEntity(soap, tag?tag:"dic:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__BusinessEntity ** SOAP_FMAC4 soap_get_PointerTodic__BusinessEntity(struct soap *soap, dic__BusinessEntity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__String255(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__String255))
		soap_serialize_base__String255(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__String255(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__String255);
	return (id < 0) ? soap->error : soap_out_base__String255(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__String255(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__String255(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__String255, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__String255(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__String255);
	return soap_out_PointerTobase__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__String255(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTodic__Producer(struct soap *soap, dic__Producer **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTodic__Producer))
		soap_serialize_PointerTodic__Producer(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTodic__Producer(struct soap *soap, const char *tag, int id, dic__Producer **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTodic__Producer);
	return (id < 0) ? soap->error : soap_out_PointerTodic__Producer(soap, tag, id, *a, type);
}

SOAP_FMAC3 dic__Producer *** FASTCALL soap_in_PointerToPointerTodic__Producer(struct soap *soap, const char *tag, dic__Producer ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Producer ***)soap_malloc(soap, sizeof(dic__Producer **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTodic__Producer(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (dic__Producer ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTodic__Producer, sizeof(dic__Producer *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTodic__Producer(struct soap *soap, dic__Producer **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTodic__Producer);
	return soap_out_PointerToPointerTodic__Producer(soap, tag?tag:"dic:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Producer *** SOAP_FMAC4 soap_get_PointerToPointerTodic__Producer(struct soap *soap, dic__Producer ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTodic__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Producer(struct soap *soap, dic__Producer *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Producer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Producer(struct soap *soap, const char *tag, int id, dic__Producer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Producer);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Producer ** FASTCALL soap_in_PointerTodic__Producer(struct soap *soap, const char *tag, dic__Producer **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Producer **)soap_malloc(soap, sizeof(dic__Producer *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Producer *)soap_instantiate_dic__Producer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Producer ** p = (dic__Producer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Producer, sizeof(dic__Producer), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Producer(struct soap *soap, dic__Producer *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Producer);
	return soap_out_PointerTodic__Producer(soap, tag?tag:"dic:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Producer ** SOAP_FMAC4 soap_get_PointerTodic__Producer(struct soap *soap, dic__Producer **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__EnterpriseRole(struct soap *soap, enum dic__EnterpriseRole *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_dic__EnterpriseRole);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__EnterpriseRole(struct soap *soap, const char *tag, int id, enum dic__EnterpriseRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__EnterpriseRole);
	return (id < 0) ? soap->error : soap_out_dic__EnterpriseRole(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum dic__EnterpriseRole ** FASTCALL soap_in_PointerTodic__EnterpriseRole(struct soap *soap, const char *tag, enum dic__EnterpriseRole **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum dic__EnterpriseRole **)soap_malloc(soap, sizeof(enum dic__EnterpriseRole *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_dic__EnterpriseRole(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum dic__EnterpriseRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__EnterpriseRole, sizeof(enum dic__EnterpriseRole), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__EnterpriseRole(struct soap *soap, enum dic__EnterpriseRole *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__EnterpriseRole);
	return soap_out_PointerTodic__EnterpriseRole(soap, tag?tag:"dic:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum dic__EnterpriseRole ** SOAP_FMAC4 soap_get_PointerTodic__EnterpriseRole(struct soap *soap, enum dic__EnterpriseRole **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Enterprise(struct soap *soap, dic__Enterprise *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Enterprise))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Enterprise(struct soap *soap, const char *tag, int id, dic__Enterprise *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Enterprise);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Enterprise ** FASTCALL soap_in_PointerTodic__Enterprise(struct soap *soap, const char *tag, dic__Enterprise **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Enterprise **)soap_malloc(soap, sizeof(dic__Enterprise *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Enterprise *)soap_instantiate_dic__Enterprise(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Enterprise ** p = (dic__Enterprise **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Enterprise, sizeof(dic__Enterprise), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Enterprise(struct soap *soap, dic__Enterprise *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Enterprise);
	return soap_out_PointerTodic__Enterprise(soap, tag?tag:"dic:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Enterprise ** SOAP_FMAC4 soap_get_PointerTodic__Enterprise(struct soap *soap, dic__Enterprise **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__NText(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__NText))
		soap_serialize_base__NText(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__NText(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__NText);
	return (id < 0) ? soap->error : soap_out_base__NText(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__NText(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__NText(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__NText, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__NText(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__NText);
	return soap_out_PointerTobase__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__NText(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Street(struct soap *soap, dic__Street *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Street))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Street(struct soap *soap, const char *tag, int id, dic__Street *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Street);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Street ** FASTCALL soap_in_PointerTodic__Street(struct soap *soap, const char *tag, dic__Street **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Street **)soap_malloc(soap, sizeof(dic__Street *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Street *)soap_instantiate_dic__Street(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Street ** p = (dic__Street **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Street, sizeof(dic__Street), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Street(struct soap *soap, dic__Street *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Street);
	return soap_out_PointerTodic__Street(soap, tag?tag:"dic:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Street ** SOAP_FMAC4 soap_get_PointerTodic__Street(struct soap *soap, dic__Street **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Locality(struct soap *soap, dic__Locality *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Locality))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Locality(struct soap *soap, const char *tag, int id, dic__Locality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Locality);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Locality ** FASTCALL soap_in_PointerTodic__Locality(struct soap *soap, const char *tag, dic__Locality **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Locality **)soap_malloc(soap, sizeof(dic__Locality *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Locality *)soap_instantiate_dic__Locality(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Locality ** p = (dic__Locality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Locality, sizeof(dic__Locality), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Locality(struct soap *soap, dic__Locality *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Locality);
	return soap_out_PointerTodic__Locality(soap, tag?tag:"dic:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Locality ** SOAP_FMAC4 soap_get_PointerTodic__Locality(struct soap *soap, dic__Locality **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__District(struct soap *soap, dic__District *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__District))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__District(struct soap *soap, const char *tag, int id, dic__District *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__District);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__District ** FASTCALL soap_in_PointerTodic__District(struct soap *soap, const char *tag, dic__District **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__District **)soap_malloc(soap, sizeof(dic__District *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__District *)soap_instantiate_dic__District(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__District ** p = (dic__District **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__District, sizeof(dic__District), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__District(struct soap *soap, dic__District *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__District);
	return soap_out_PointerTodic__District(soap, tag?tag:"dic:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__District ** SOAP_FMAC4 soap_get_PointerTodic__District(struct soap *soap, dic__District **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Region(struct soap *soap, dic__Region *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Region))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Region(struct soap *soap, const char *tag, int id, dic__Region *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Region);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Region ** FASTCALL soap_in_PointerTodic__Region(struct soap *soap, const char *tag, dic__Region **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Region **)soap_malloc(soap, sizeof(dic__Region *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Region *)soap_instantiate_dic__Region(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Region ** p = (dic__Region **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Region, sizeof(dic__Region), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Region(struct soap *soap, dic__Region *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Region);
	return soap_out_PointerTodic__Region(soap, tag?tag:"dic:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Region ** SOAP_FMAC4 soap_get_PointerTodic__Region(struct soap *soap, dic__Region **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__FederalDistrict(struct soap *soap, dic__FederalDistrict *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__FederalDistrict))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__FederalDistrict(struct soap *soap, const char *tag, int id, dic__FederalDistrict *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__FederalDistrict);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__FederalDistrict ** FASTCALL soap_in_PointerTodic__FederalDistrict(struct soap *soap, const char *tag, dic__FederalDistrict **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__FederalDistrict **)soap_malloc(soap, sizeof(dic__FederalDistrict *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__FederalDistrict *)soap_instantiate_dic__FederalDistrict(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__FederalDistrict ** p = (dic__FederalDistrict **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__FederalDistrict, sizeof(dic__FederalDistrict), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__FederalDistrict(struct soap *soap, dic__FederalDistrict *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__FederalDistrict);
	return soap_out_PointerTodic__FederalDistrict(soap, tag?tag:"dic:FederalDistrict", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__FederalDistrict ** SOAP_FMAC4 soap_get_PointerTodic__FederalDistrict(struct soap *soap, dic__FederalDistrict **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodic__Country(struct soap *soap, dic__Country *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_dic__Country))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTodic__Country(struct soap *soap, const char *tag, int id, dic__Country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dic__Country);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 dic__Country ** FASTCALL soap_in_PointerTodic__Country(struct soap *soap, const char *tag, dic__Country **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (dic__Country **)soap_malloc(soap, sizeof(dic__Country *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (dic__Country *)soap_instantiate_dic__Country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		dic__Country ** p = (dic__Country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dic__Country, sizeof(dic__Country), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodic__Country(struct soap *soap, dic__Country *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodic__Country);
	return soap_out_PointerTodic__Country(soap, tag?tag:"dic:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 dic__Country ** SOAP_FMAC4 soap_get_PointerTodic__Country(struct soap *soap, dic__Country **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTodic__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToapp__BusinessError))
		soap_serialize_PointerToapp__BusinessError(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToapp__BusinessError(struct soap *soap, const char *tag, int id, app__BusinessError **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToapp__BusinessError);
	return (id < 0) ? soap->error : soap_out_PointerToapp__BusinessError(soap, tag, id, *a, type);
}

SOAP_FMAC3 app__BusinessError *** FASTCALL soap_in_PointerToPointerToapp__BusinessError(struct soap *soap, const char *tag, app__BusinessError ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessError ***)soap_malloc(soap, sizeof(app__BusinessError **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToapp__BusinessError(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (app__BusinessError ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToapp__BusinessError, sizeof(app__BusinessError *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToapp__BusinessError);
	return soap_out_PointerToPointerToapp__BusinessError(soap, tag?tag:"app:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessError *** SOAP_FMAC4 soap_get_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToapp__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__BusinessError(struct soap *soap, app__BusinessError *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__BusinessError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__BusinessError(struct soap *soap, const char *tag, int id, app__BusinessError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__BusinessError);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__BusinessError ** FASTCALL soap_in_PointerToapp__BusinessError(struct soap *soap, const char *tag, app__BusinessError **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessError **)soap_malloc(soap, sizeof(app__BusinessError *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__BusinessError *)soap_instantiate_app__BusinessError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__BusinessError ** p = (app__BusinessError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__BusinessError(struct soap *soap, app__BusinessError *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__BusinessError);
	return soap_out_PointerToapp__BusinessError(soap, tag?tag:"app:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessError ** SOAP_FMAC4 soap_get_PointerToapp__BusinessError(struct soap *soap, app__BusinessError **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_app__ContentEncoding);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ContentEncoding(struct soap *soap, const char *tag, int id, enum app__ContentEncoding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ContentEncoding);
	return (id < 0) ? soap->error : soap_out_app__ContentEncoding(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum app__ContentEncoding ** FASTCALL soap_in_PointerToapp__ContentEncoding(struct soap *soap, const char *tag, enum app__ContentEncoding **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum app__ContentEncoding **)soap_malloc(soap, sizeof(enum app__ContentEncoding *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_app__ContentEncoding(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum app__ContentEncoding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ContentEncoding, sizeof(enum app__ContentEncoding), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ContentEncoding);
	return soap_out_PointerToapp__ContentEncoding(soap, tag?tag:"app:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ContentEncoding ** SOAP_FMAC4 soap_get_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__BusinessErrorList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__BusinessErrorList(struct soap *soap, const char *tag, int id, app__BusinessErrorList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__BusinessErrorList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__BusinessErrorList ** FASTCALL soap_in_PointerToapp__BusinessErrorList(struct soap *soap, const char *tag, app__BusinessErrorList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessErrorList **)soap_malloc(soap, sizeof(app__BusinessErrorList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__BusinessErrorList *)soap_instantiate_app__BusinessErrorList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__BusinessErrorList ** p = (app__BusinessErrorList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessErrorList, sizeof(app__BusinessErrorList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__BusinessErrorList);
	return soap_out_PointerToapp__BusinessErrorList(soap, tag?tag:"app:BusinessErrorList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessErrorList ** SOAP_FMAC4 soap_get_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__ApplicationResultWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, app__ApplicationResultWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationResultWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper ** FASTCALL soap_in_PointerToapp__ApplicationResultWrapper(struct soap *soap, const char *tag, app__ApplicationResultWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__ApplicationResultWrapper **)soap_malloc(soap, sizeof(app__ApplicationResultWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__ApplicationResultWrapper *)soap_instantiate_app__ApplicationResultWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__ApplicationResultWrapper ** p = (app__ApplicationResultWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationResultWrapper, sizeof(app__ApplicationResultWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationResultWrapper);
	return soap_out_PointerToapp__ApplicationResultWrapper(soap, tag?tag:"app:ApplicationResultWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__ApplicationResultWrapper ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__ApplicationDataWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, app__ApplicationDataWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationDataWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper ** FASTCALL soap_in_PointerToapp__ApplicationDataWrapper(struct soap *soap, const char *tag, app__ApplicationDataWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__ApplicationDataWrapper **)soap_malloc(soap, sizeof(app__ApplicationDataWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__ApplicationDataWrapper *)soap_instantiate_app__ApplicationDataWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__ApplicationDataWrapper ** p = (app__ApplicationDataWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationDataWrapper, sizeof(app__ApplicationDataWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationDataWrapper);
	return soap_out_PointerToapp__ApplicationDataWrapper(soap, tag?tag:"app:ApplicationDataWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__ApplicationDataWrapper ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_app__ApplicationStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationStatus(struct soap *soap, const char *tag, int id, enum app__ApplicationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationStatus);
	return (id < 0) ? soap->error : soap_out_app__ApplicationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum app__ApplicationStatus ** FASTCALL soap_in_PointerToapp__ApplicationStatus(struct soap *soap, const char *tag, enum app__ApplicationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum app__ApplicationStatus **)soap_malloc(soap, sizeof(enum app__ApplicationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_app__ApplicationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum app__ApplicationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationStatus, sizeof(enum app__ApplicationStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationStatus);
	return soap_out_PointerToapp__ApplicationStatus(soap, tag?tag:"app:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ApplicationStatus ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Hour(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__Hour);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Hour(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Hour);
	return (id < 0) ? soap->error : soap_out_base__Hour(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTobase__Hour(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Hour(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Hour, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Hour(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Hour);
	return soap_out_PointerTobase__Hour(soap, tag?tag:"base:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTobase__Hour(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Day(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__Day);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Day(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Day);
	return (id < 0) ? soap->error : soap_out_base__Day(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTobase__Day(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Day(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Day, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Day(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Day);
	return soap_out_PointerTobase__Day(soap, tag?tag:"base:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTobase__Day(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Month(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__Month);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Month(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Month);
	return (id < 0) ? soap->error : soap_out_base__Month(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTobase__Month(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Month(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Month, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Month(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Month);
	return soap_out_PointerTobase__Month(soap, tag?tag:"base:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTobase__Month(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Year(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__Year);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Year(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Year);
	return (id < 0) ? soap->error : soap_out_base__Year(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTobase__Year(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Year(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Year, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Year(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Year);
	return soap_out_PointerTobase__Year(soap, tag?tag:"base:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTobase__Year(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobase__Error(struct soap *soap, base__Error **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTobase__Error))
		soap_serialize_PointerTobase__Error(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTobase__Error(struct soap *soap, const char *tag, int id, base__Error **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobase__Error);
	return (id < 0) ? soap->error : soap_out_PointerTobase__Error(soap, tag, id, *a, type);
}

SOAP_FMAC3 base__Error *** FASTCALL soap_in_PointerToPointerTobase__Error(struct soap *soap, const char *tag, base__Error ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__Error ***)soap_malloc(soap, sizeof(base__Error **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTobase__Error(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (base__Error ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobase__Error, sizeof(base__Error *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobase__Error(struct soap *soap, base__Error **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobase__Error);
	return soap_out_PointerToPointerTobase__Error(soap, tag?tag:"base:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__Error *** SOAP_FMAC4 soap_get_PointerToPointerTobase__Error(struct soap *soap, base__Error ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTobase__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Error(struct soap *soap, base__Error *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Error))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Error(struct soap *soap, const char *tag, int id, base__Error *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Error);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__Error ** FASTCALL soap_in_PointerTobase__Error(struct soap *soap, const char *tag, base__Error **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__Error **)soap_malloc(soap, sizeof(base__Error *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__Error *)soap_instantiate_base__Error(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__Error ** p = (base__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Error, sizeof(base__Error), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (base__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Error(struct soap *soap, base__Error *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Error);
	return soap_out_PointerTobase__Error(soap, tag?tag:"base:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__Error ** SOAP_FMAC4 soap_get_PointerTobase__Error(struct soap *soap, base__Error **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	return (id < 0) ? soap->error : soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** FASTCALL soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	return soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	return (id < 0) ? soap->error : soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** FASTCALL soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	return soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	return (id < 0) ? soap->error : soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	return soap_out_PointerToint(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	return (id < 0) ? soap->error : soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** FASTCALL soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	return soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTotime(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__VetDocumentStatusChangeReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__VetDocumentStatusChangeReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentStatusChangeReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatusChangeReason);
	return soap_out_vd__VetDocumentStatusChangeReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__VetDocumentStatusChangeReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatusChangeReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__GRNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__GRNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__GRNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__GRNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__GRNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__GRNType);
	return soap_out_dic__GRNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__GRNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__GRNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__SNILSType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__SNILSType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__SNILSType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__SNILSType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__SNILSType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__SNILSType);
	return soap_out_vd__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__SNILSType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__StockEntryNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__StockEntryNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__StockEntryNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__StockEntryNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__StockEntryNumber);
	return soap_out_vd__StockEntryNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__StockEntryNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__OTPToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__OTPToken);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__OTPToken(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__OTPToken, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__OTPToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__OTPToken);
	return soap_out_dic__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__OTPToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__GTINType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__GTINType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__GTINType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__GTINType, 1, 8, 14);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__GTINType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__GTINType);
	return soap_out_dic__GTINType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__GTINType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__GTINType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__GLNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__GLNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__GLNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__GLNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__GLNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__GLNType);
	return soap_out_dic__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__GLNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__ENTModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__ENTModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__ENTModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__ENTModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__ENTModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__ENTModificationReason);
	return soap_out_dic__ENTModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__ENTModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__ENTModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__BEModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__BEModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__BEModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__BEModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__BEModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__BEModificationReason);
	return soap_out_dic__BEModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__BEModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__BEModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__EnterpriseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__EnterpriseType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__EnterpriseType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__EnterpriseType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__EnterpriseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__EnterpriseType);
	return soap_out_dic__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__EnterpriseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Code3(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__Code3);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__Code3(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__Code3, 1, 0, 3);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Code3(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Code3);
	return soap_out_dic__Code3(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__Code3(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Code3(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_dic__Code(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_dic__Code);
}

SOAP_FMAC3 char * * FASTCALL soap_in_dic__Code(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_dic__Code, 1, 0, 2);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dic__Code(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dic__Code);
	return soap_out_dic__Code(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_dic__Code(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_dic__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_app__APIKey(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_app__APIKey);
}

SOAP_FMAC3 char * * FASTCALL soap_in_app__APIKey(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_app__APIKey, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__APIKey(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__APIKey);
	return soap_out_app__APIKey(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_app__APIKey(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_app__APIKey(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__SequenceNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__SequenceNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__SequenceNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__SequenceNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__SequenceNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__SequenceNumber);
	return soap_out_base__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__SequenceNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Identifier(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Identifier);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Identifier(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Identifier, 1, 0, 100);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Identifier(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Identifier);
	return soap_out_base__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Identifier(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__VersionStatus(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__VersionStatus);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__VersionStatus(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__VersionStatus, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__VersionStatus(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__VersionStatus);
	return soap_out_base__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__VersionStatus(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Decimal);
	return soap_out_base__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__String32(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__String32);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__String32(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__String32, 1, 0, 32);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__String32(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__String32);
	return soap_out_base__String32(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__String32(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__String32(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__String255(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__String255);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__String255(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__String255, 1, 0, 255);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__String255(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__String255);
	return soap_out_base__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__String255(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__NText(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__NText);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__NText(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__NText, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__NText(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__NText);
	return soap_out_base__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__NText(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Text(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Text);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Text(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Text, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Text(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Text);
	return soap_out_base__Text(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Text(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Text(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__UUID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__UUID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__UUID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__UUID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__UUID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__UUID);
	return soap_out_base__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__UUID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	return soap_out_xsd__token(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__token(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	return soap_out_xsd__positiveInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	return soap_out_xsd__nonNegativeInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	return soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__integer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	return soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	return soap_out_xsd__date(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__date(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	return (id < 0) ? soap->error : soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** FASTCALL soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	return soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__Name);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__Name(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__Name, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__Name);
	return soap_out_xsd__Name(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__Name(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	return soap_out_xsd__NCName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREF);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__IDREF(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREF, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	return soap_out_xsd__IDREF(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	return soap_out_xsd__ID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__ID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * FASTCALL soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	return soap_out__QName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in__QName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int FASTCALL soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * FASTCALL soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	return soap_out_string(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_string(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of vetisamsC.cpp */
