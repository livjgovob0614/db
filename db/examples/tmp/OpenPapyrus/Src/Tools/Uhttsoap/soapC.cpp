/* soapC.cpp
   Generated by gSOAP 2.8.4 from d:\Papyrus\Src\Tools\Uhttsoap\universe_htt.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.4 2012-04-15 15:59:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__UhttOutStatus:
		return soap_in_ns1__UhttOutStatus(soap, NULL, NULL, "ns1:UhttOutStatus");
	case SOAP_TYPE_ns1__UhttQuot:
		return soap_in_ns1__UhttQuot(soap, NULL, NULL, "ns1:UhttQuot");
	case SOAP_TYPE_ns1__UhttSpoiledSerial:
		return soap_in_ns1__UhttSpoiledSerial(soap, NULL, NULL, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial:
		return soap_in_ns1__ArrayOfUhttSpoiledSerial(soap, NULL, NULL, "ns1:ArrayOfUhttSpoiledSerial");
	case SOAP_TYPE_ns1__UhttCalendarEntry:
		return soap_in_ns1__UhttCalendarEntry(soap, NULL, NULL, "ns1:UhttCalendarEntry");
	case SOAP_TYPE_ns1__UhttCalendar:
		return soap_in_ns1__UhttCalendar(soap, NULL, NULL, "ns1:UhttCalendar");
	case SOAP_TYPE_ns1__UhttGoods:
		return soap_in_ns1__UhttGoods(soap, NULL, NULL, "ns1:UhttGoods");
	case SOAP_TYPE_ns1__UhttGoodsTaxGroup:
		return soap_in_ns1__UhttGoodsTaxGroup(soap, NULL, NULL, "ns1:UhttGoodsTaxGroup");
	case SOAP_TYPE_ns1__UhttArCode:
		return soap_in_ns1__UhttArCode(soap, NULL, NULL, "ns1:UhttArCode");
	case SOAP_TYPE_ns1__UhttBarcode:
		return soap_in_ns1__UhttBarcode(soap, NULL, NULL, "ns1:UhttBarcode");
	case SOAP_TYPE_ns1__UhttBrand:
		return soap_in_ns1__UhttBrand(soap, NULL, NULL, "ns1:UhttBrand");
	case SOAP_TYPE_ns1__UhttGoodsGroup:
		return soap_in_ns1__UhttGoodsGroup(soap, NULL, NULL, "ns1:UhttGoodsGroup");
	case SOAP_TYPE_ns1__UhttPersonLocation:
		return soap_in_ns1__UhttPersonLocation(soap, NULL, NULL, "ns1:UhttPersonLocation");
	case SOAP_TYPE_ns1__UhttPerson:
		return soap_in_ns1__UhttPerson(soap, NULL, NULL, "ns1:UhttPerson");
	case SOAP_TYPE_ns1__UhttPersonRegister:
		return soap_in_ns1__UhttPersonRegister(soap, NULL, NULL, "ns1:UhttPersonRegister");
	case SOAP_TYPE_ns1__UhttPersonRegisterType:
		return soap_in_ns1__UhttPersonRegisterType(soap, NULL, NULL, "ns1:UhttPersonRegisterType");
	case SOAP_TYPE_ns1__UhttLocation:
		return soap_in_ns1__UhttLocation(soap, NULL, NULL, "ns1:UhttLocation");
	case SOAP_TYPE_ns1__UhttPersonCategory:
		return soap_in_ns1__UhttPersonCategory(soap, NULL, NULL, "ns1:UhttPersonCategory");
	case SOAP_TYPE_ns1__UhttPersonKind:
		return soap_in_ns1__UhttPersonKind(soap, NULL, NULL, "ns1:UhttPersonKind");
	case SOAP_TYPE_ns1__UhttCurrency:
		return soap_in_ns1__UhttCurrency(soap, NULL, NULL, "ns1:UhttCurrency");
	case SOAP_TYPE_ns1__UhttWorld:
		return soap_in_ns1__UhttWorld(soap, NULL, NULL, "ns1:UhttWorld");
	case SOAP_TYPE_ns1__UhttCommObjItem:
		return soap_in_ns1__UhttCommObjItem(soap, NULL, NULL, "ns1:UhttCommObjItem");
	case SOAP_TYPE_ns1__ArrayOfUhttCommObjItem:
		return soap_in_ns1__ArrayOfUhttCommObjItem(soap, NULL, NULL, "ns1:ArrayOfUhttCommObjItem");
	case SOAP_TYPE_ns1__UhttObjSelectCriteria:
		return soap_in_ns1__UhttObjSelectCriteria(soap, NULL, NULL, "ns1:UhttObjSelectCriteria");
	case SOAP_TYPE_ns1__Logout:
		return soap_in_ns1__Logout(soap, NULL, NULL, "ns1:Logout");
	case SOAP_TYPE_ns1__LogoutResponse:
		return soap_in_ns1__LogoutResponse(soap, NULL, NULL, "ns1:LogoutResponse");
	case SOAP_TYPE_ns1__Login:
		return soap_in_ns1__Login(soap, NULL, NULL, "ns1:Login");
	case SOAP_TYPE_ns1__LoginResponse:
		return soap_in_ns1__LoginResponse(soap, NULL, NULL, "ns1:LoginResponse");
	case SOAP_TYPE_ns1__GetSpoiledSeries:
		return soap_in_ns1__GetSpoiledSeries(soap, NULL, NULL, "ns1:GetSpoiledSeries");
	case SOAP_TYPE_ns1__GetSpoiledSeriesResponse:
		return soap_in_ns1__GetSpoiledSeriesResponse(soap, NULL, NULL, "ns1:GetSpoiledSeriesResponse");
	case SOAP_TYPE_ns1__GetGoodsPrice:
		return soap_in_ns1__GetGoodsPrice(soap, NULL, NULL, "ns1:GetGoodsPrice");
	case SOAP_TYPE_ns1__GetGoodsPriceResponse:
		return soap_in_ns1__GetGoodsPriceResponse(soap, NULL, NULL, "ns1:GetGoodsPriceResponse");
	case SOAP_TYPE_ns1__SetGoodsPrice:
		return soap_in_ns1__SetGoodsPrice(soap, NULL, NULL, "ns1:SetGoodsPrice");
	case SOAP_TYPE_ns1__SetGoodsPriceResponse:
		return soap_in_ns1__SetGoodsPriceResponse(soap, NULL, NULL, "ns1:SetGoodsPriceResponse");
	case SOAP_TYPE_ns1__GetGoodsCode:
		return soap_in_ns1__GetGoodsCode(soap, NULL, NULL, "ns1:GetGoodsCode");
	case SOAP_TYPE_ns1__GetGoodsCodeResponse:
		return soap_in_ns1__GetGoodsCodeResponse(soap, NULL, NULL, "ns1:GetGoodsCodeResponse");
	case SOAP_TYPE_ns1__SetGoodsCode:
		return soap_in_ns1__SetGoodsCode(soap, NULL, NULL, "ns1:SetGoodsCode");
	case SOAP_TYPE_ns1__SetGoodsCodeResponse:
		return soap_in_ns1__SetGoodsCodeResponse(soap, NULL, NULL, "ns1:SetGoodsCodeResponse");
	case SOAP_TYPE_ns1__Get_USCORECalendar:
		return soap_in_ns1__Get_USCORECalendar(soap, NULL, NULL, "ns1:Get_Calendar");
	case SOAP_TYPE_ns1__Get_USCORECalendarResponse:
		return soap_in_ns1__Get_USCORECalendarResponse(soap, NULL, NULL, "ns1:Get_CalendarResponse");
	case SOAP_TYPE_ns1__Get_USCOREGoods:
		return soap_in_ns1__Get_USCOREGoods(soap, NULL, NULL, "ns1:Get_Goods");
	case SOAP_TYPE_ns1__Get_USCOREGoodsResponse:
		return soap_in_ns1__Get_USCOREGoodsResponse(soap, NULL, NULL, "ns1:Get_GoodsResponse");
	case SOAP_TYPE_ns1__Get_USCOREBrand:
		return soap_in_ns1__Get_USCOREBrand(soap, NULL, NULL, "ns1:Get_Brand");
	case SOAP_TYPE_ns1__Get_USCOREBrandResponse:
		return soap_in_ns1__Get_USCOREBrandResponse(soap, NULL, NULL, "ns1:Get_BrandResponse");
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroup:
		return soap_in_ns1__Get_USCOREGoodsGroup(soap, NULL, NULL, "ns1:Get_GoodsGroup");
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse:
		return soap_in_ns1__Get_USCOREGoodsGroupResponse(soap, NULL, NULL, "ns1:Get_GoodsGroupResponse");
	case SOAP_TYPE_ns1__Get_USCOREPerson:
		return soap_in_ns1__Get_USCOREPerson(soap, NULL, NULL, "ns1:Get_Person");
	case SOAP_TYPE_ns1__Get_USCOREPersonResponse:
		return soap_in_ns1__Get_USCOREPersonResponse(soap, NULL, NULL, "ns1:Get_PersonResponse");
	case SOAP_TYPE_ns1__Get_USCORERegisterType:
		return soap_in_ns1__Get_USCORERegisterType(soap, NULL, NULL, "ns1:Get_RegisterType");
	case SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse:
		return soap_in_ns1__Get_USCORERegisterTypeResponse(soap, NULL, NULL, "ns1:Get_RegisterTypeResponse");
	case SOAP_TYPE_ns1__Get_USCOREPersonCategory:
		return soap_in_ns1__Get_USCOREPersonCategory(soap, NULL, NULL, "ns1:Get_PersonCategory");
	case SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse:
		return soap_in_ns1__Get_USCOREPersonCategoryResponse(soap, NULL, NULL, "ns1:Get_PersonCategoryResponse");
	case SOAP_TYPE_ns1__Get_USCOREPersonKind:
		return soap_in_ns1__Get_USCOREPersonKind(soap, NULL, NULL, "ns1:Get_PersonKind");
	case SOAP_TYPE_ns1__Get_USCOREPersonKindResponse:
		return soap_in_ns1__Get_USCOREPersonKindResponse(soap, NULL, NULL, "ns1:Get_PersonKindResponse");
	case SOAP_TYPE_ns1__Get_USCORECurrency:
		return soap_in_ns1__Get_USCORECurrency(soap, NULL, NULL, "ns1:Get_Currency");
	case SOAP_TYPE_ns1__Get_USCORECurrencyResponse:
		return soap_in_ns1__Get_USCORECurrencyResponse(soap, NULL, NULL, "ns1:Get_CurrencyResponse");
	case SOAP_TYPE_ns1__Get_USCOREWorld:
		return soap_in_ns1__Get_USCOREWorld(soap, NULL, NULL, "ns1:Get_World");
	case SOAP_TYPE_ns1__Get_USCOREWorldResponse:
		return soap_in_ns1__Get_USCOREWorldResponse(soap, NULL, NULL, "ns1:Get_WorldResponse");
	case SOAP_TYPE_ns1__SelectObject:
		return soap_in_ns1__SelectObject(soap, NULL, NULL, "ns1:SelectObject");
	case SOAP_TYPE_ns1__SelectObjectResponse:
		return soap_in_ns1__SelectObjectResponse(soap, NULL, NULL, "ns1:SelectObjectResponse");
	case SOAP_TYPE_PointerTons1__ArrayOfUhttSpoiledSerial:
		return soap_in_PointerTons1__ArrayOfUhttSpoiledSerial(soap, NULL, NULL, "ns1:ArrayOfUhttSpoiledSerial");
	case SOAP_TYPE_PointerTons1__UhttQuot:
		return soap_in_PointerTons1__UhttQuot(soap, NULL, NULL, "ns1:UhttQuot");
	case SOAP_TYPE_PointerTons1__UhttArCode:
		return soap_in_PointerTons1__UhttArCode(soap, NULL, NULL, "ns1:UhttArCode");
	case SOAP_TYPE_PointerTons1__UhttOutStatus:
		return soap_in_PointerTons1__UhttOutStatus(soap, NULL, NULL, "ns1:UhttOutStatus");
	case SOAP_TYPE_PointerTons1__UhttCalendar:
		return soap_in_PointerTons1__UhttCalendar(soap, NULL, NULL, "ns1:UhttCalendar");
	case SOAP_TYPE_PointerTons1__UhttGoods:
		return soap_in_PointerTons1__UhttGoods(soap, NULL, NULL, "ns1:UhttGoods");
	case SOAP_TYPE_PointerTons1__UhttBrand:
		return soap_in_PointerTons1__UhttBrand(soap, NULL, NULL, "ns1:UhttBrand");
	case SOAP_TYPE_PointerTons1__UhttGoodsGroup:
		return soap_in_PointerTons1__UhttGoodsGroup(soap, NULL, NULL, "ns1:UhttGoodsGroup");
	case SOAP_TYPE_PointerTons1__UhttPerson:
		return soap_in_PointerTons1__UhttPerson(soap, NULL, NULL, "ns1:UhttPerson");
	case SOAP_TYPE_PointerTons1__UhttPersonRegisterType:
		return soap_in_PointerTons1__UhttPersonRegisterType(soap, NULL, NULL, "ns1:UhttPersonRegisterType");
	case SOAP_TYPE_PointerTons1__UhttPersonCategory:
		return soap_in_PointerTons1__UhttPersonCategory(soap, NULL, NULL, "ns1:UhttPersonCategory");
	case SOAP_TYPE_PointerTons1__UhttPersonKind:
		return soap_in_PointerTons1__UhttPersonKind(soap, NULL, NULL, "ns1:UhttPersonKind");
	case SOAP_TYPE_PointerTons1__UhttCurrency:
		return soap_in_PointerTons1__UhttCurrency(soap, NULL, NULL, "ns1:UhttCurrency");
	case SOAP_TYPE_PointerTons1__UhttWorld:
		return soap_in_PointerTons1__UhttWorld(soap, NULL, NULL, "ns1:UhttWorld");
	case SOAP_TYPE_PointerTons1__UhttObjSelectCriteria:
		return soap_in_PointerTons1__UhttObjSelectCriteria(soap, NULL, NULL, "ns1:UhttObjSelectCriteria");
	case SOAP_TYPE_PointerTons1__ArrayOfUhttCommObjItem:
		return soap_in_PointerTons1__ArrayOfUhttCommObjItem(soap, NULL, NULL, "ns1:ArrayOfUhttCommObjItem");
	case SOAP_TYPE_PointerToPointerTons1__UhttSpoiledSerial:
		return soap_in_PointerToPointerTons1__UhttSpoiledSerial(soap, NULL, NULL, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_PointerTons1__UhttSpoiledSerial:
		return soap_in_PointerTons1__UhttSpoiledSerial(soap, NULL, NULL, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_PointerToPointerTons1__UhttBarcode:
		return soap_in_PointerToPointerTons1__UhttBarcode(soap, NULL, NULL, "ns1:UhttBarcode");
	case SOAP_TYPE_PointerTons1__UhttBarcode:
		return soap_in_PointerTons1__UhttBarcode(soap, NULL, NULL, "ns1:UhttBarcode");
	case SOAP_TYPE_PointerToPointerTons1__UhttPersonRegister:
		return soap_in_PointerToPointerTons1__UhttPersonRegister(soap, NULL, NULL, "ns1:UhttPersonRegister");
	case SOAP_TYPE_PointerTons1__UhttPersonRegister:
		return soap_in_PointerTons1__UhttPersonRegister(soap, NULL, NULL, "ns1:UhttPersonRegister");
	case SOAP_TYPE_PointerTons1__UhttLocation:
		return soap_in_PointerTons1__UhttLocation(soap, NULL, NULL, "ns1:UhttLocation");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__UhttCommObjItem:
		return soap_in_PointerToPointerTons1__UhttCommObjItem(soap, NULL, NULL, "ns1:UhttCommObjItem");
	case SOAP_TYPE_PointerTons1__UhttCommObjItem:
		return soap_in_PointerTons1__UhttCommObjItem(soap, NULL, NULL, "ns1:UhttCommObjItem");
	case SOAP_TYPE_xsd__time:
	{	char **s;
		s = soap_in_xsd__time(soap, NULL, NULL, "xsd:time");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:UhttOutStatus"))
		{	*type = SOAP_TYPE_ns1__UhttOutStatus;
			return soap_in_ns1__UhttOutStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttQuot"))
		{	*type = SOAP_TYPE_ns1__UhttQuot;
			return soap_in_ns1__UhttQuot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttSpoiledSerial"))
		{	*type = SOAP_TYPE_ns1__UhttSpoiledSerial;
			return soap_in_ns1__UhttSpoiledSerial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUhttSpoiledSerial"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial;
			return soap_in_ns1__ArrayOfUhttSpoiledSerial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttCalendarEntry"))
		{	*type = SOAP_TYPE_ns1__UhttCalendarEntry;
			return soap_in_ns1__UhttCalendarEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttCalendar"))
		{	*type = SOAP_TYPE_ns1__UhttCalendar;
			return soap_in_ns1__UhttCalendar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttGoods"))
		{	*type = SOAP_TYPE_ns1__UhttGoods;
			return soap_in_ns1__UhttGoods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttGoodsTaxGroup"))
		{	*type = SOAP_TYPE_ns1__UhttGoodsTaxGroup;
			return soap_in_ns1__UhttGoodsTaxGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttArCode"))
		{	*type = SOAP_TYPE_ns1__UhttArCode;
			return soap_in_ns1__UhttArCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttBarcode"))
		{	*type = SOAP_TYPE_ns1__UhttBarcode;
			return soap_in_ns1__UhttBarcode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttBrand"))
		{	*type = SOAP_TYPE_ns1__UhttBrand;
			return soap_in_ns1__UhttBrand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttGoodsGroup"))
		{	*type = SOAP_TYPE_ns1__UhttGoodsGroup;
			return soap_in_ns1__UhttGoodsGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPersonLocation"))
		{	*type = SOAP_TYPE_ns1__UhttPersonLocation;
			return soap_in_ns1__UhttPersonLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPerson"))
		{	*type = SOAP_TYPE_ns1__UhttPerson;
			return soap_in_ns1__UhttPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPersonRegister"))
		{	*type = SOAP_TYPE_ns1__UhttPersonRegister;
			return soap_in_ns1__UhttPersonRegister(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPersonRegisterType"))
		{	*type = SOAP_TYPE_ns1__UhttPersonRegisterType;
			return soap_in_ns1__UhttPersonRegisterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttLocation"))
		{	*type = SOAP_TYPE_ns1__UhttLocation;
			return soap_in_ns1__UhttLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPersonCategory"))
		{	*type = SOAP_TYPE_ns1__UhttPersonCategory;
			return soap_in_ns1__UhttPersonCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttPersonKind"))
		{	*type = SOAP_TYPE_ns1__UhttPersonKind;
			return soap_in_ns1__UhttPersonKind(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttCurrency"))
		{	*type = SOAP_TYPE_ns1__UhttCurrency;
			return soap_in_ns1__UhttCurrency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttWorld"))
		{	*type = SOAP_TYPE_ns1__UhttWorld;
			return soap_in_ns1__UhttWorld(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttCommObjItem"))
		{	*type = SOAP_TYPE_ns1__UhttCommObjItem;
			return soap_in_ns1__UhttCommObjItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUhttCommObjItem"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUhttCommObjItem;
			return soap_in_ns1__ArrayOfUhttCommObjItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UhttObjSelectCriteria"))
		{	*type = SOAP_TYPE_ns1__UhttObjSelectCriteria;
			return soap_in_ns1__UhttObjSelectCriteria(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Logout"))
		{	*type = SOAP_TYPE_ns1__Logout;
			return soap_in_ns1__Logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogoutResponse"))
		{	*type = SOAP_TYPE_ns1__LogoutResponse;
			return soap_in_ns1__LogoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login"))
		{	*type = SOAP_TYPE_ns1__Login;
			return soap_in_ns1__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginResponse"))
		{	*type = SOAP_TYPE_ns1__LoginResponse;
			return soap_in_ns1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSpoiledSeries"))
		{	*type = SOAP_TYPE_ns1__GetSpoiledSeries;
			return soap_in_ns1__GetSpoiledSeries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSpoiledSeriesResponse"))
		{	*type = SOAP_TYPE_ns1__GetSpoiledSeriesResponse;
			return soap_in_ns1__GetSpoiledSeriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGoodsPrice"))
		{	*type = SOAP_TYPE_ns1__GetGoodsPrice;
			return soap_in_ns1__GetGoodsPrice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGoodsPriceResponse"))
		{	*type = SOAP_TYPE_ns1__GetGoodsPriceResponse;
			return soap_in_ns1__GetGoodsPriceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGoodsPrice"))
		{	*type = SOAP_TYPE_ns1__SetGoodsPrice;
			return soap_in_ns1__SetGoodsPrice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGoodsPriceResponse"))
		{	*type = SOAP_TYPE_ns1__SetGoodsPriceResponse;
			return soap_in_ns1__SetGoodsPriceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGoodsCode"))
		{	*type = SOAP_TYPE_ns1__GetGoodsCode;
			return soap_in_ns1__GetGoodsCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGoodsCodeResponse"))
		{	*type = SOAP_TYPE_ns1__GetGoodsCodeResponse;
			return soap_in_ns1__GetGoodsCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGoodsCode"))
		{	*type = SOAP_TYPE_ns1__SetGoodsCode;
			return soap_in_ns1__SetGoodsCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGoodsCodeResponse"))
		{	*type = SOAP_TYPE_ns1__SetGoodsCodeResponse;
			return soap_in_ns1__SetGoodsCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_Calendar"))
		{	*type = SOAP_TYPE_ns1__Get_USCORECalendar;
			return soap_in_ns1__Get_USCORECalendar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_CalendarResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCORECalendarResponse;
			return soap_in_ns1__Get_USCORECalendarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_Goods"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREGoods;
			return soap_in_ns1__Get_USCOREGoods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_GoodsResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREGoodsResponse;
			return soap_in_ns1__Get_USCOREGoodsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_Brand"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREBrand;
			return soap_in_ns1__Get_USCOREBrand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_BrandResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREBrandResponse;
			return soap_in_ns1__Get_USCOREBrandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_GoodsGroup"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREGoodsGroup;
			return soap_in_ns1__Get_USCOREGoodsGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_GoodsGroupResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse;
			return soap_in_ns1__Get_USCOREGoodsGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_Person"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPerson;
			return soap_in_ns1__Get_USCOREPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_PersonResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPersonResponse;
			return soap_in_ns1__Get_USCOREPersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_RegisterType"))
		{	*type = SOAP_TYPE_ns1__Get_USCORERegisterType;
			return soap_in_ns1__Get_USCORERegisterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_RegisterTypeResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse;
			return soap_in_ns1__Get_USCORERegisterTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_PersonCategory"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPersonCategory;
			return soap_in_ns1__Get_USCOREPersonCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_PersonCategoryResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse;
			return soap_in_ns1__Get_USCOREPersonCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_PersonKind"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPersonKind;
			return soap_in_ns1__Get_USCOREPersonKind(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_PersonKindResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREPersonKindResponse;
			return soap_in_ns1__Get_USCOREPersonKindResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_Currency"))
		{	*type = SOAP_TYPE_ns1__Get_USCORECurrency;
			return soap_in_ns1__Get_USCORECurrency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_CurrencyResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCORECurrencyResponse;
			return soap_in_ns1__Get_USCORECurrencyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_World"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREWorld;
			return soap_in_ns1__Get_USCOREWorld(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Get_WorldResponse"))
		{	*type = SOAP_TYPE_ns1__Get_USCOREWorldResponse;
			return soap_in_ns1__Get_USCOREWorldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectObject"))
		{	*type = SOAP_TYPE_ns1__SelectObject;
			return soap_in_ns1__SelectObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectObjectResponse"))
		{	*type = SOAP_TYPE_ns1__SelectObjectResponse;
			return soap_in_ns1__SelectObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	char **s;
			*type = SOAP_TYPE_xsd__time;
			s = soap_in_xsd__time(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__UhttOutStatus:
		return ((ns1__UhttOutStatus *)ptr)->soap_out(soap, tag, id, "ns1:UhttOutStatus");
	case SOAP_TYPE_ns1__UhttQuot:
		return ((ns1__UhttQuot *)ptr)->soap_out(soap, tag, id, "ns1:UhttQuot");
	case SOAP_TYPE_ns1__UhttSpoiledSerial:
		return ((ns1__UhttSpoiledSerial *)ptr)->soap_out(soap, tag, id, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial:
		return ((ns1__ArrayOfUhttSpoiledSerial *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfUhttSpoiledSerial");
	case SOAP_TYPE_ns1__UhttCalendarEntry:
		return ((ns1__UhttCalendarEntry *)ptr)->soap_out(soap, tag, id, "ns1:UhttCalendarEntry");
	case SOAP_TYPE_ns1__UhttCalendar:
		return ((ns1__UhttCalendar *)ptr)->soap_out(soap, tag, id, "ns1:UhttCalendar");
	case SOAP_TYPE_ns1__UhttGoods:
		return ((ns1__UhttGoods *)ptr)->soap_out(soap, tag, id, "ns1:UhttGoods");
	case SOAP_TYPE_ns1__UhttGoodsTaxGroup:
		return ((ns1__UhttGoodsTaxGroup *)ptr)->soap_out(soap, tag, id, "ns1:UhttGoodsTaxGroup");
	case SOAP_TYPE_ns1__UhttArCode:
		return ((ns1__UhttArCode *)ptr)->soap_out(soap, tag, id, "ns1:UhttArCode");
	case SOAP_TYPE_ns1__UhttBarcode:
		return ((ns1__UhttBarcode *)ptr)->soap_out(soap, tag, id, "ns1:UhttBarcode");
	case SOAP_TYPE_ns1__UhttBrand:
		return ((ns1__UhttBrand *)ptr)->soap_out(soap, tag, id, "ns1:UhttBrand");
	case SOAP_TYPE_ns1__UhttGoodsGroup:
		return ((ns1__UhttGoodsGroup *)ptr)->soap_out(soap, tag, id, "ns1:UhttGoodsGroup");
	case SOAP_TYPE_ns1__UhttPersonLocation:
		return ((ns1__UhttPersonLocation *)ptr)->soap_out(soap, tag, id, "ns1:UhttPersonLocation");
	case SOAP_TYPE_ns1__UhttPerson:
		return ((ns1__UhttPerson *)ptr)->soap_out(soap, tag, id, "ns1:UhttPerson");
	case SOAP_TYPE_ns1__UhttPersonRegister:
		return ((ns1__UhttPersonRegister *)ptr)->soap_out(soap, tag, id, "ns1:UhttPersonRegister");
	case SOAP_TYPE_ns1__UhttPersonRegisterType:
		return ((ns1__UhttPersonRegisterType *)ptr)->soap_out(soap, tag, id, "ns1:UhttPersonRegisterType");
	case SOAP_TYPE_ns1__UhttLocation:
		return ((ns1__UhttLocation *)ptr)->soap_out(soap, tag, id, "ns1:UhttLocation");
	case SOAP_TYPE_ns1__UhttPersonCategory:
		return ((ns1__UhttPersonCategory *)ptr)->soap_out(soap, tag, id, "ns1:UhttPersonCategory");
	case SOAP_TYPE_ns1__UhttPersonKind:
		return ((ns1__UhttPersonKind *)ptr)->soap_out(soap, tag, id, "ns1:UhttPersonKind");
	case SOAP_TYPE_ns1__UhttCurrency:
		return ((ns1__UhttCurrency *)ptr)->soap_out(soap, tag, id, "ns1:UhttCurrency");
	case SOAP_TYPE_ns1__UhttWorld:
		return ((ns1__UhttWorld *)ptr)->soap_out(soap, tag, id, "ns1:UhttWorld");
	case SOAP_TYPE_ns1__UhttCommObjItem:
		return ((ns1__UhttCommObjItem *)ptr)->soap_out(soap, tag, id, "ns1:UhttCommObjItem");
	case SOAP_TYPE_ns1__ArrayOfUhttCommObjItem:
		return ((ns1__ArrayOfUhttCommObjItem *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfUhttCommObjItem");
	case SOAP_TYPE_ns1__UhttObjSelectCriteria:
		return ((ns1__UhttObjSelectCriteria *)ptr)->soap_out(soap, tag, id, "ns1:UhttObjSelectCriteria");
	case SOAP_TYPE_ns1__Logout:
		return soap_out_ns1__Logout(soap, tag, id, (const struct ns1__Logout *)ptr, "ns1:Logout");
	case SOAP_TYPE_ns1__LogoutResponse:
		return soap_out_ns1__LogoutResponse(soap, tag, id, (const struct ns1__LogoutResponse *)ptr, "ns1:LogoutResponse");
	case SOAP_TYPE_ns1__Login:
		return soap_out_ns1__Login(soap, tag, id, (const struct ns1__Login *)ptr, "ns1:Login");
	case SOAP_TYPE_ns1__LoginResponse:
		return soap_out_ns1__LoginResponse(soap, tag, id, (const struct ns1__LoginResponse *)ptr, "ns1:LoginResponse");
	case SOAP_TYPE_ns1__GetSpoiledSeries:
		return soap_out_ns1__GetSpoiledSeries(soap, tag, id, (const struct ns1__GetSpoiledSeries *)ptr, "ns1:GetSpoiledSeries");
	case SOAP_TYPE_ns1__GetSpoiledSeriesResponse:
		return soap_out_ns1__GetSpoiledSeriesResponse(soap, tag, id, (const struct ns1__GetSpoiledSeriesResponse *)ptr, "ns1:GetSpoiledSeriesResponse");
	case SOAP_TYPE_ns1__GetGoodsPrice:
		return soap_out_ns1__GetGoodsPrice(soap, tag, id, (const struct ns1__GetGoodsPrice *)ptr, "ns1:GetGoodsPrice");
	case SOAP_TYPE_ns1__GetGoodsPriceResponse:
		return soap_out_ns1__GetGoodsPriceResponse(soap, tag, id, (const struct ns1__GetGoodsPriceResponse *)ptr, "ns1:GetGoodsPriceResponse");
	case SOAP_TYPE_ns1__SetGoodsPrice:
		return soap_out_ns1__SetGoodsPrice(soap, tag, id, (const struct ns1__SetGoodsPrice *)ptr, "ns1:SetGoodsPrice");
	case SOAP_TYPE_ns1__SetGoodsPriceResponse:
		return soap_out_ns1__SetGoodsPriceResponse(soap, tag, id, (const struct ns1__SetGoodsPriceResponse *)ptr, "ns1:SetGoodsPriceResponse");
	case SOAP_TYPE_ns1__GetGoodsCode:
		return soap_out_ns1__GetGoodsCode(soap, tag, id, (const struct ns1__GetGoodsCode *)ptr, "ns1:GetGoodsCode");
	case SOAP_TYPE_ns1__GetGoodsCodeResponse:
		return soap_out_ns1__GetGoodsCodeResponse(soap, tag, id, (const struct ns1__GetGoodsCodeResponse *)ptr, "ns1:GetGoodsCodeResponse");
	case SOAP_TYPE_ns1__SetGoodsCode:
		return soap_out_ns1__SetGoodsCode(soap, tag, id, (const struct ns1__SetGoodsCode *)ptr, "ns1:SetGoodsCode");
	case SOAP_TYPE_ns1__SetGoodsCodeResponse:
		return soap_out_ns1__SetGoodsCodeResponse(soap, tag, id, (const struct ns1__SetGoodsCodeResponse *)ptr, "ns1:SetGoodsCodeResponse");
	case SOAP_TYPE_ns1__Get_USCORECalendar:
		return soap_out_ns1__Get_USCORECalendar(soap, tag, id, (const struct ns1__Get_USCORECalendar *)ptr, "ns1:Get_Calendar");
	case SOAP_TYPE_ns1__Get_USCORECalendarResponse:
		return soap_out_ns1__Get_USCORECalendarResponse(soap, tag, id, (const struct ns1__Get_USCORECalendarResponse *)ptr, "ns1:Get_CalendarResponse");
	case SOAP_TYPE_ns1__Get_USCOREGoods:
		return soap_out_ns1__Get_USCOREGoods(soap, tag, id, (const struct ns1__Get_USCOREGoods *)ptr, "ns1:Get_Goods");
	case SOAP_TYPE_ns1__Get_USCOREGoodsResponse:
		return soap_out_ns1__Get_USCOREGoodsResponse(soap, tag, id, (const struct ns1__Get_USCOREGoodsResponse *)ptr, "ns1:Get_GoodsResponse");
	case SOAP_TYPE_ns1__Get_USCOREBrand:
		return soap_out_ns1__Get_USCOREBrand(soap, tag, id, (const struct ns1__Get_USCOREBrand *)ptr, "ns1:Get_Brand");
	case SOAP_TYPE_ns1__Get_USCOREBrandResponse:
		return soap_out_ns1__Get_USCOREBrandResponse(soap, tag, id, (const struct ns1__Get_USCOREBrandResponse *)ptr, "ns1:Get_BrandResponse");
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroup:
		return soap_out_ns1__Get_USCOREGoodsGroup(soap, tag, id, (const struct ns1__Get_USCOREGoodsGroup *)ptr, "ns1:Get_GoodsGroup");
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse:
		return soap_out_ns1__Get_USCOREGoodsGroupResponse(soap, tag, id, (const struct ns1__Get_USCOREGoodsGroupResponse *)ptr, "ns1:Get_GoodsGroupResponse");
	case SOAP_TYPE_ns1__Get_USCOREPerson:
		return soap_out_ns1__Get_USCOREPerson(soap, tag, id, (const struct ns1__Get_USCOREPerson *)ptr, "ns1:Get_Person");
	case SOAP_TYPE_ns1__Get_USCOREPersonResponse:
		return soap_out_ns1__Get_USCOREPersonResponse(soap, tag, id, (const struct ns1__Get_USCOREPersonResponse *)ptr, "ns1:Get_PersonResponse");
	case SOAP_TYPE_ns1__Get_USCORERegisterType:
		return soap_out_ns1__Get_USCORERegisterType(soap, tag, id, (const struct ns1__Get_USCORERegisterType *)ptr, "ns1:Get_RegisterType");
	case SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse:
		return soap_out_ns1__Get_USCORERegisterTypeResponse(soap, tag, id, (const struct ns1__Get_USCORERegisterTypeResponse *)ptr, "ns1:Get_RegisterTypeResponse");
	case SOAP_TYPE_ns1__Get_USCOREPersonCategory:
		return soap_out_ns1__Get_USCOREPersonCategory(soap, tag, id, (const struct ns1__Get_USCOREPersonCategory *)ptr, "ns1:Get_PersonCategory");
	case SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse:
		return soap_out_ns1__Get_USCOREPersonCategoryResponse(soap, tag, id, (const struct ns1__Get_USCOREPersonCategoryResponse *)ptr, "ns1:Get_PersonCategoryResponse");
	case SOAP_TYPE_ns1__Get_USCOREPersonKind:
		return soap_out_ns1__Get_USCOREPersonKind(soap, tag, id, (const struct ns1__Get_USCOREPersonKind *)ptr, "ns1:Get_PersonKind");
	case SOAP_TYPE_ns1__Get_USCOREPersonKindResponse:
		return soap_out_ns1__Get_USCOREPersonKindResponse(soap, tag, id, (const struct ns1__Get_USCOREPersonKindResponse *)ptr, "ns1:Get_PersonKindResponse");
	case SOAP_TYPE_ns1__Get_USCORECurrency:
		return soap_out_ns1__Get_USCORECurrency(soap, tag, id, (const struct ns1__Get_USCORECurrency *)ptr, "ns1:Get_Currency");
	case SOAP_TYPE_ns1__Get_USCORECurrencyResponse:
		return soap_out_ns1__Get_USCORECurrencyResponse(soap, tag, id, (const struct ns1__Get_USCORECurrencyResponse *)ptr, "ns1:Get_CurrencyResponse");
	case SOAP_TYPE_ns1__Get_USCOREWorld:
		return soap_out_ns1__Get_USCOREWorld(soap, tag, id, (const struct ns1__Get_USCOREWorld *)ptr, "ns1:Get_World");
	case SOAP_TYPE_ns1__Get_USCOREWorldResponse:
		return soap_out_ns1__Get_USCOREWorldResponse(soap, tag, id, (const struct ns1__Get_USCOREWorldResponse *)ptr, "ns1:Get_WorldResponse");
	case SOAP_TYPE_ns1__SelectObject:
		return soap_out_ns1__SelectObject(soap, tag, id, (const struct ns1__SelectObject *)ptr, "ns1:SelectObject");
	case SOAP_TYPE_ns1__SelectObjectResponse:
		return soap_out_ns1__SelectObjectResponse(soap, tag, id, (const struct ns1__SelectObjectResponse *)ptr, "ns1:SelectObjectResponse");
	case SOAP_TYPE_PointerTons1__ArrayOfUhttSpoiledSerial:
		return soap_out_PointerTons1__ArrayOfUhttSpoiledSerial(soap, tag, id, (ns1__ArrayOfUhttSpoiledSerial *const*)ptr, "ns1:ArrayOfUhttSpoiledSerial");
	case SOAP_TYPE_PointerTons1__UhttQuot:
		return soap_out_PointerTons1__UhttQuot(soap, tag, id, (ns1__UhttQuot *const*)ptr, "ns1:UhttQuot");
	case SOAP_TYPE_PointerTons1__UhttArCode:
		return soap_out_PointerTons1__UhttArCode(soap, tag, id, (ns1__UhttArCode *const*)ptr, "ns1:UhttArCode");
	case SOAP_TYPE_PointerTons1__UhttOutStatus:
		return soap_out_PointerTons1__UhttOutStatus(soap, tag, id, (ns1__UhttOutStatus *const*)ptr, "ns1:UhttOutStatus");
	case SOAP_TYPE_PointerTons1__UhttCalendar:
		return soap_out_PointerTons1__UhttCalendar(soap, tag, id, (ns1__UhttCalendar *const*)ptr, "ns1:UhttCalendar");
	case SOAP_TYPE_PointerTons1__UhttGoods:
		return soap_out_PointerTons1__UhttGoods(soap, tag, id, (ns1__UhttGoods *const*)ptr, "ns1:UhttGoods");
	case SOAP_TYPE_PointerTons1__UhttBrand:
		return soap_out_PointerTons1__UhttBrand(soap, tag, id, (ns1__UhttBrand *const*)ptr, "ns1:UhttBrand");
	case SOAP_TYPE_PointerTons1__UhttGoodsGroup:
		return soap_out_PointerTons1__UhttGoodsGroup(soap, tag, id, (ns1__UhttGoodsGroup *const*)ptr, "ns1:UhttGoodsGroup");
	case SOAP_TYPE_PointerTons1__UhttPerson:
		return soap_out_PointerTons1__UhttPerson(soap, tag, id, (ns1__UhttPerson *const*)ptr, "ns1:UhttPerson");
	case SOAP_TYPE_PointerTons1__UhttPersonRegisterType:
		return soap_out_PointerTons1__UhttPersonRegisterType(soap, tag, id, (ns1__UhttPersonRegisterType *const*)ptr, "ns1:UhttPersonRegisterType");
	case SOAP_TYPE_PointerTons1__UhttPersonCategory:
		return soap_out_PointerTons1__UhttPersonCategory(soap, tag, id, (ns1__UhttPersonCategory *const*)ptr, "ns1:UhttPersonCategory");
	case SOAP_TYPE_PointerTons1__UhttPersonKind:
		return soap_out_PointerTons1__UhttPersonKind(soap, tag, id, (ns1__UhttPersonKind *const*)ptr, "ns1:UhttPersonKind");
	case SOAP_TYPE_PointerTons1__UhttCurrency:
		return soap_out_PointerTons1__UhttCurrency(soap, tag, id, (ns1__UhttCurrency *const*)ptr, "ns1:UhttCurrency");
	case SOAP_TYPE_PointerTons1__UhttWorld:
		return soap_out_PointerTons1__UhttWorld(soap, tag, id, (ns1__UhttWorld *const*)ptr, "ns1:UhttWorld");
	case SOAP_TYPE_PointerTons1__UhttObjSelectCriteria:
		return soap_out_PointerTons1__UhttObjSelectCriteria(soap, tag, id, (ns1__UhttObjSelectCriteria *const*)ptr, "ns1:UhttObjSelectCriteria");
	case SOAP_TYPE_PointerTons1__ArrayOfUhttCommObjItem:
		return soap_out_PointerTons1__ArrayOfUhttCommObjItem(soap, tag, id, (ns1__ArrayOfUhttCommObjItem *const*)ptr, "ns1:ArrayOfUhttCommObjItem");
	case SOAP_TYPE_PointerToPointerTons1__UhttSpoiledSerial:
		return soap_out_PointerToPointerTons1__UhttSpoiledSerial(soap, tag, id, (ns1__UhttSpoiledSerial **const*)ptr, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_PointerTons1__UhttSpoiledSerial:
		return soap_out_PointerTons1__UhttSpoiledSerial(soap, tag, id, (ns1__UhttSpoiledSerial *const*)ptr, "ns1:UhttSpoiledSerial");
	case SOAP_TYPE_PointerToPointerTons1__UhttBarcode:
		return soap_out_PointerToPointerTons1__UhttBarcode(soap, tag, id, (ns1__UhttBarcode **const*)ptr, "ns1:UhttBarcode");
	case SOAP_TYPE_PointerTons1__UhttBarcode:
		return soap_out_PointerTons1__UhttBarcode(soap, tag, id, (ns1__UhttBarcode *const*)ptr, "ns1:UhttBarcode");
	case SOAP_TYPE_PointerToPointerTons1__UhttPersonRegister:
		return soap_out_PointerToPointerTons1__UhttPersonRegister(soap, tag, id, (ns1__UhttPersonRegister **const*)ptr, "ns1:UhttPersonRegister");
	case SOAP_TYPE_PointerTons1__UhttPersonRegister:
		return soap_out_PointerTons1__UhttPersonRegister(soap, tag, id, (ns1__UhttPersonRegister *const*)ptr, "ns1:UhttPersonRegister");
	case SOAP_TYPE_PointerTons1__UhttLocation:
		return soap_out_PointerTons1__UhttLocation(soap, tag, id, (ns1__UhttLocation *const*)ptr, "ns1:UhttLocation");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__UhttCommObjItem:
		return soap_out_PointerToPointerTons1__UhttCommObjItem(soap, tag, id, (ns1__UhttCommObjItem **const*)ptr, "ns1:UhttCommObjItem");
	case SOAP_TYPE_PointerTons1__UhttCommObjItem:
		return soap_out_PointerTons1__UhttCommObjItem(soap, tag, id, (ns1__UhttCommObjItem *const*)ptr, "ns1:UhttCommObjItem");
	case SOAP_TYPE_xsd__time:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:time");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__UhttOutStatus:
		((ns1__UhttOutStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttQuot:
		((ns1__UhttQuot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttSpoiledSerial:
		((ns1__UhttSpoiledSerial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial:
		((ns1__ArrayOfUhttSpoiledSerial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttCalendarEntry:
		((ns1__UhttCalendarEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttCalendar:
		((ns1__UhttCalendar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttGoods:
		((ns1__UhttGoods *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttGoodsTaxGroup:
		((ns1__UhttGoodsTaxGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttArCode:
		((ns1__UhttArCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttBarcode:
		((ns1__UhttBarcode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttBrand:
		((ns1__UhttBrand *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttGoodsGroup:
		((ns1__UhttGoodsGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPersonLocation:
		((ns1__UhttPersonLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPerson:
		((ns1__UhttPerson *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPersonRegister:
		((ns1__UhttPersonRegister *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPersonRegisterType:
		((ns1__UhttPersonRegisterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttLocation:
		((ns1__UhttLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPersonCategory:
		((ns1__UhttPersonCategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttPersonKind:
		((ns1__UhttPersonKind *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttCurrency:
		((ns1__UhttCurrency *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttWorld:
		((ns1__UhttWorld *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttCommObjItem:
		((ns1__UhttCommObjItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfUhttCommObjItem:
		((ns1__ArrayOfUhttCommObjItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UhttObjSelectCriteria:
		((ns1__UhttObjSelectCriteria *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Logout:
		soap_serialize_ns1__Logout(soap, (const struct ns1__Logout *)ptr);
		break;
	case SOAP_TYPE_ns1__LogoutResponse:
		soap_serialize_ns1__LogoutResponse(soap, (const struct ns1__LogoutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Login:
		soap_serialize_ns1__Login(soap, (const struct ns1__Login *)ptr);
		break;
	case SOAP_TYPE_ns1__LoginResponse:
		soap_serialize_ns1__LoginResponse(soap, (const struct ns1__LoginResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSpoiledSeries:
		soap_serialize_ns1__GetSpoiledSeries(soap, (const struct ns1__GetSpoiledSeries *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSpoiledSeriesResponse:
		soap_serialize_ns1__GetSpoiledSeriesResponse(soap, (const struct ns1__GetSpoiledSeriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsPrice:
		soap_serialize_ns1__GetGoodsPrice(soap, (const struct ns1__GetGoodsPrice *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsPriceResponse:
		soap_serialize_ns1__GetGoodsPriceResponse(soap, (const struct ns1__GetGoodsPriceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsPrice:
		soap_serialize_ns1__SetGoodsPrice(soap, (const struct ns1__SetGoodsPrice *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsPriceResponse:
		soap_serialize_ns1__SetGoodsPriceResponse(soap, (const struct ns1__SetGoodsPriceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsCode:
		soap_serialize_ns1__GetGoodsCode(soap, (const struct ns1__GetGoodsCode *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsCodeResponse:
		soap_serialize_ns1__GetGoodsCodeResponse(soap, (const struct ns1__GetGoodsCodeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsCode:
		soap_serialize_ns1__SetGoodsCode(soap, (const struct ns1__SetGoodsCode *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsCodeResponse:
		soap_serialize_ns1__SetGoodsCodeResponse(soap, (const struct ns1__SetGoodsCodeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECalendar:
		soap_serialize_ns1__Get_USCORECalendar(soap, (const struct ns1__Get_USCORECalendar *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECalendarResponse:
		soap_serialize_ns1__Get_USCORECalendarResponse(soap, (const struct ns1__Get_USCORECalendarResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoods:
		soap_serialize_ns1__Get_USCOREGoods(soap, (const struct ns1__Get_USCOREGoods *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsResponse:
		soap_serialize_ns1__Get_USCOREGoodsResponse(soap, (const struct ns1__Get_USCOREGoodsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREBrand:
		soap_serialize_ns1__Get_USCOREBrand(soap, (const struct ns1__Get_USCOREBrand *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREBrandResponse:
		soap_serialize_ns1__Get_USCOREBrandResponse(soap, (const struct ns1__Get_USCOREBrandResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroup:
		soap_serialize_ns1__Get_USCOREGoodsGroup(soap, (const struct ns1__Get_USCOREGoodsGroup *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse:
		soap_serialize_ns1__Get_USCOREGoodsGroupResponse(soap, (const struct ns1__Get_USCOREGoodsGroupResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPerson:
		soap_serialize_ns1__Get_USCOREPerson(soap, (const struct ns1__Get_USCOREPerson *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonResponse:
		soap_serialize_ns1__Get_USCOREPersonResponse(soap, (const struct ns1__Get_USCOREPersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORERegisterType:
		soap_serialize_ns1__Get_USCORERegisterType(soap, (const struct ns1__Get_USCORERegisterType *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse:
		soap_serialize_ns1__Get_USCORERegisterTypeResponse(soap, (const struct ns1__Get_USCORERegisterTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonCategory:
		soap_serialize_ns1__Get_USCOREPersonCategory(soap, (const struct ns1__Get_USCOREPersonCategory *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse:
		soap_serialize_ns1__Get_USCOREPersonCategoryResponse(soap, (const struct ns1__Get_USCOREPersonCategoryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonKind:
		soap_serialize_ns1__Get_USCOREPersonKind(soap, (const struct ns1__Get_USCOREPersonKind *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonKindResponse:
		soap_serialize_ns1__Get_USCOREPersonKindResponse(soap, (const struct ns1__Get_USCOREPersonKindResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECurrency:
		soap_serialize_ns1__Get_USCORECurrency(soap, (const struct ns1__Get_USCORECurrency *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECurrencyResponse:
		soap_serialize_ns1__Get_USCORECurrencyResponse(soap, (const struct ns1__Get_USCORECurrencyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREWorld:
		soap_serialize_ns1__Get_USCOREWorld(soap, (const struct ns1__Get_USCOREWorld *)ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREWorldResponse:
		soap_serialize_ns1__Get_USCOREWorldResponse(soap, (const struct ns1__Get_USCOREWorldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SelectObject:
		soap_serialize_ns1__SelectObject(soap, (const struct ns1__SelectObject *)ptr);
		break;
	case SOAP_TYPE_ns1__SelectObjectResponse:
		soap_serialize_ns1__SelectObjectResponse(soap, (const struct ns1__SelectObjectResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfUhttSpoiledSerial:
		soap_serialize_PointerTons1__ArrayOfUhttSpoiledSerial(soap, (ns1__ArrayOfUhttSpoiledSerial *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttQuot:
		soap_serialize_PointerTons1__UhttQuot(soap, (ns1__UhttQuot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttArCode:
		soap_serialize_PointerTons1__UhttArCode(soap, (ns1__UhttArCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttOutStatus:
		soap_serialize_PointerTons1__UhttOutStatus(soap, (ns1__UhttOutStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttCalendar:
		soap_serialize_PointerTons1__UhttCalendar(soap, (ns1__UhttCalendar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttGoods:
		soap_serialize_PointerTons1__UhttGoods(soap, (ns1__UhttGoods *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttBrand:
		soap_serialize_PointerTons1__UhttBrand(soap, (ns1__UhttBrand *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttGoodsGroup:
		soap_serialize_PointerTons1__UhttGoodsGroup(soap, (ns1__UhttGoodsGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttPerson:
		soap_serialize_PointerTons1__UhttPerson(soap, (ns1__UhttPerson *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttPersonRegisterType:
		soap_serialize_PointerTons1__UhttPersonRegisterType(soap, (ns1__UhttPersonRegisterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttPersonCategory:
		soap_serialize_PointerTons1__UhttPersonCategory(soap, (ns1__UhttPersonCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttPersonKind:
		soap_serialize_PointerTons1__UhttPersonKind(soap, (ns1__UhttPersonKind *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttCurrency:
		soap_serialize_PointerTons1__UhttCurrency(soap, (ns1__UhttCurrency *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttWorld:
		soap_serialize_PointerTons1__UhttWorld(soap, (ns1__UhttWorld *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttObjSelectCriteria:
		soap_serialize_PointerTons1__UhttObjSelectCriteria(soap, (ns1__UhttObjSelectCriteria *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfUhttCommObjItem:
		soap_serialize_PointerTons1__ArrayOfUhttCommObjItem(soap, (ns1__ArrayOfUhttCommObjItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UhttSpoiledSerial:
		soap_serialize_PointerToPointerTons1__UhttSpoiledSerial(soap, (ns1__UhttSpoiledSerial **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttSpoiledSerial:
		soap_serialize_PointerTons1__UhttSpoiledSerial(soap, (ns1__UhttSpoiledSerial *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UhttBarcode:
		soap_serialize_PointerToPointerTons1__UhttBarcode(soap, (ns1__UhttBarcode **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttBarcode:
		soap_serialize_PointerTons1__UhttBarcode(soap, (ns1__UhttBarcode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UhttPersonRegister:
		soap_serialize_PointerToPointerTons1__UhttPersonRegister(soap, (ns1__UhttPersonRegister **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttPersonRegister:
		soap_serialize_PointerTons1__UhttPersonRegister(soap, (ns1__UhttPersonRegister *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttLocation:
		soap_serialize_PointerTons1__UhttLocation(soap, (ns1__UhttLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UhttCommObjItem:
		soap_serialize_PointerToPointerTons1__UhttCommObjItem(soap, (ns1__UhttCommObjItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UhttCommObjItem:
		soap_serialize_PointerTons1__UhttCommObjItem(soap, (ns1__UhttCommObjItem *const*)ptr);
		break;
	case SOAP_TYPE_xsd__time:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__UhttObjSelectCriteria:
		return (void*)soap_instantiate_ns1__UhttObjSelectCriteria(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfUhttCommObjItem:
		return (void*)soap_instantiate_ns1__ArrayOfUhttCommObjItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttCommObjItem:
		return (void*)soap_instantiate_ns1__UhttCommObjItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttWorld:
		return (void*)soap_instantiate_ns1__UhttWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttCurrency:
		return (void*)soap_instantiate_ns1__UhttCurrency(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPersonKind:
		return (void*)soap_instantiate_ns1__UhttPersonKind(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPersonCategory:
		return (void*)soap_instantiate_ns1__UhttPersonCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttLocation:
		return (void*)soap_instantiate_ns1__UhttLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPersonRegisterType:
		return (void*)soap_instantiate_ns1__UhttPersonRegisterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPersonRegister:
		return (void*)soap_instantiate_ns1__UhttPersonRegister(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPerson:
		return (void*)soap_instantiate_ns1__UhttPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttPersonLocation:
		return (void*)soap_instantiate_ns1__UhttPersonLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttGoodsGroup:
		return (void*)soap_instantiate_ns1__UhttGoodsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttBrand:
		return (void*)soap_instantiate_ns1__UhttBrand(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttBarcode:
		return (void*)soap_instantiate_ns1__UhttBarcode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttArCode:
		return (void*)soap_instantiate_ns1__UhttArCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttGoodsTaxGroup:
		return (void*)soap_instantiate_ns1__UhttGoodsTaxGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttGoods:
		return (void*)soap_instantiate_ns1__UhttGoods(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttCalendar:
		return (void*)soap_instantiate_ns1__UhttCalendar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttCalendarEntry:
		return (void*)soap_instantiate_ns1__UhttCalendarEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial:
		return (void*)soap_instantiate_ns1__ArrayOfUhttSpoiledSerial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttSpoiledSerial:
		return (void*)soap_instantiate_ns1__UhttSpoiledSerial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttQuot:
		return (void*)soap_instantiate_ns1__UhttQuot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UhttOutStatus:
		return (void*)soap_instantiate_ns1__UhttOutStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SelectObjectResponse:
		return (void*)soap_instantiate_ns1__SelectObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SelectObject:
		return (void*)soap_instantiate_ns1__SelectObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREWorldResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREWorldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREWorld:
		return (void*)soap_instantiate_ns1__Get_USCOREWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORECurrencyResponse:
		return (void*)soap_instantiate_ns1__Get_USCORECurrencyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORECurrency:
		return (void*)soap_instantiate_ns1__Get_USCORECurrency(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPersonKindResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREPersonKindResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPersonKind:
		return (void*)soap_instantiate_ns1__Get_USCOREPersonKind(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREPersonCategoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPersonCategory:
		return (void*)soap_instantiate_ns1__Get_USCOREPersonCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse:
		return (void*)soap_instantiate_ns1__Get_USCORERegisterTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORERegisterType:
		return (void*)soap_instantiate_ns1__Get_USCORERegisterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPersonResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREPersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREPerson:
		return (void*)soap_instantiate_ns1__Get_USCOREPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREGoodsGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroup:
		return (void*)soap_instantiate_ns1__Get_USCOREGoodsGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREBrandResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREBrandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREBrand:
		return (void*)soap_instantiate_ns1__Get_USCOREBrand(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREGoodsResponse:
		return (void*)soap_instantiate_ns1__Get_USCOREGoodsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCOREGoods:
		return (void*)soap_instantiate_ns1__Get_USCOREGoods(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORECalendarResponse:
		return (void*)soap_instantiate_ns1__Get_USCORECalendarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Get_USCORECalendar:
		return (void*)soap_instantiate_ns1__Get_USCORECalendar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGoodsCodeResponse:
		return (void*)soap_instantiate_ns1__SetGoodsCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGoodsCode:
		return (void*)soap_instantiate_ns1__SetGoodsCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGoodsCodeResponse:
		return (void*)soap_instantiate_ns1__GetGoodsCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGoodsCode:
		return (void*)soap_instantiate_ns1__GetGoodsCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGoodsPriceResponse:
		return (void*)soap_instantiate_ns1__SetGoodsPriceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGoodsPrice:
		return (void*)soap_instantiate_ns1__SetGoodsPrice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGoodsPriceResponse:
		return (void*)soap_instantiate_ns1__GetGoodsPriceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGoodsPrice:
		return (void*)soap_instantiate_ns1__GetGoodsPrice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSpoiledSeriesResponse:
		return (void*)soap_instantiate_ns1__GetSpoiledSeriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSpoiledSeries:
		return (void*)soap_instantiate_ns1__GetSpoiledSeries(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoginResponse:
		return (void*)soap_instantiate_ns1__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Login:
		return (void*)soap_instantiate_ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LogoutResponse:
		return (void*)soap_instantiate_ns1__LogoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Logout:
		return (void*)soap_instantiate_ns1__Logout(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__UhttObjSelectCriteria:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttObjSelectCriteria*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttObjSelectCriteria*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfUhttCommObjItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfUhttCommObjItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfUhttCommObjItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttCommObjItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttCommObjItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttCommObjItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttWorld:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttWorld*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttWorld*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttCurrency:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttCurrency*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttCurrency*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPersonKind:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPersonKind*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPersonKind*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPersonCategory:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPersonCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPersonCategory*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttLocation:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttLocation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttLocation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPersonRegisterType:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPersonRegisterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPersonRegisterType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPersonRegister:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPersonRegister*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPersonRegister*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPerson:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPerson*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPerson*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttPersonLocation:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttPersonLocation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttPersonLocation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttGoodsGroup:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttGoodsGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttGoodsGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttBrand:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttBrand*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttBrand*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttBarcode:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttBarcode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttBarcode*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttArCode:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttArCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttArCode*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttGoodsTaxGroup:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttGoodsTaxGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttGoodsTaxGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttGoods:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttGoods*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttGoods*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttCalendar:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttCalendar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttCalendar*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttCalendarEntry:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttCalendarEntry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttCalendarEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfUhttSpoiledSerial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfUhttSpoiledSerial*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttSpoiledSerial:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttSpoiledSerial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttSpoiledSerial*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttQuot:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttQuot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttQuot*)p->ptr);
		break;
	case SOAP_TYPE_ns1__UhttOutStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__UhttOutStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UhttOutStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SelectObjectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SelectObjectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SelectObjectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SelectObject:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SelectObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SelectObject*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREWorldResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREWorldResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREWorldResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREWorld:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREWorld*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREWorld*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECurrencyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORECurrencyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORECurrencyResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECurrency:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORECurrency*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORECurrency*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonKindResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPersonKindResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPersonKindResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonKind:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPersonKind*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPersonKind*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPersonCategoryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPersonCategoryResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonCategory:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPersonCategory*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPersonCategory*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORERegisterTypeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORERegisterTypeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORERegisterType:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORERegisterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORERegisterType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPersonResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPersonResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPersonResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREPerson:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREPerson*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREPerson*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREGoodsGroupResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREGoodsGroupResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsGroup:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREGoodsGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREGoodsGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREBrandResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREBrandResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREBrandResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREBrand:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREBrand*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREBrand*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoodsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREGoodsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREGoodsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCOREGoods:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCOREGoods*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCOREGoods*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECalendarResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORECalendarResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORECalendarResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Get_USCORECalendar:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Get_USCORECalendar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Get_USCORECalendar*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsCodeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGoodsCodeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGoodsCodeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsCode:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGoodsCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGoodsCode*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsCodeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGoodsCodeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGoodsCodeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsCode:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGoodsCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGoodsCode*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsPriceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGoodsPriceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGoodsPriceResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGoodsPrice:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGoodsPrice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGoodsPrice*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsPriceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGoodsPriceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGoodsPriceResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGoodsPrice:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGoodsPrice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGoodsPrice*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetSpoiledSeriesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetSpoiledSeriesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetSpoiledSeriesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetSpoiledSeries:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetSpoiledSeries*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetSpoiledSeries*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__LoginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__LoginResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Login:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Login*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LogoutResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__LogoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__LogoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Logout:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__Logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__Logout*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__UhttOutStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__UhttOutStatus::Status);
	soap_default_string(soap, &this->ns1__UhttOutStatus::Memo);
	/* transient soap skipped */
}

void ns1__UhttOutStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttOutStatus::Status);
	soap_serialize_string(soap, &this->ns1__UhttOutStatus::Memo);
	/* transient soap skipped */
}

int ns1__UhttOutStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttOutStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttOutStatus(struct soap *soap, const char *tag, int id, const ns1__UhttOutStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttOutStatus), type))
		return soap->error;
	if (a->ns1__UhttOutStatus::Status)
	{	if (soap_out_string(soap, "Status", -1, &a->ns1__UhttOutStatus::Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Status"))
		return soap->error;
	if (a->ns1__UhttOutStatus::Memo)
	{	if (soap_out_string(soap, "Memo", -1, &a->ns1__UhttOutStatus::Memo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Memo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttOutStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttOutStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttOutStatus * SOAP_FMAC4 soap_in_ns1__UhttOutStatus(struct soap *soap, const char *tag, ns1__UhttOutStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttOutStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttOutStatus, sizeof(ns1__UhttOutStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttOutStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttOutStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Status", &(a->ns1__UhttOutStatus::Status), "xsd:string"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Memo", &(a->ns1__UhttOutStatus::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttOutStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttOutStatus, 0, sizeof(ns1__UhttOutStatus), 0, soap_copy_ns1__UhttOutStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0 || soap_flag_Memo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttOutStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttOutStatus);
	if (this->soap_out(soap, tag?tag:"ns1:UhttOutStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttOutStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttOutStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttOutStatus * SOAP_FMAC4 soap_get_ns1__UhttOutStatus(struct soap *soap, ns1__UhttOutStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttOutStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttOutStatus * SOAP_FMAC2 soap_instantiate_ns1__UhttOutStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttOutStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttOutStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttOutStatus);
		if (size)
			*size = sizeof(ns1__UhttOutStatus);
		((ns1__UhttOutStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttOutStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttOutStatus);
		for (int i = 0; i < n; i++)
			((ns1__UhttOutStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttOutStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttOutStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttOutStatus %p -> %p\n", q, p));
	*(ns1__UhttOutStatus*)p = *(ns1__UhttOutStatus*)q;
}

void ns1__UhttQuot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttQuot::GoodsID);
	soap_default_int(soap, &this->ns1__UhttQuot::SellerID);
	soap_default_int(soap, &this->ns1__UhttQuot::BuyerID);
	soap_default_int(soap, &this->ns1__UhttQuot::CurID);
	soap_default_xsd__date(soap, &this->ns1__UhttQuot::Dt);
	soap_default_xsd__time(soap, &this->ns1__UhttQuot::Tm);
	soap_default_double(soap, &this->ns1__UhttQuot::Val);
	soap_default_string(soap, &this->ns1__UhttQuot::Memo);
	/* transient soap skipped */
}

void ns1__UhttQuot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->ns1__UhttQuot::Dt);
	soap_serialize_xsd__time(soap, &this->ns1__UhttQuot::Tm);
	soap_serialize_string(soap, &this->ns1__UhttQuot::Memo);
	/* transient soap skipped */
}

int ns1__UhttQuot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttQuot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttQuot(struct soap *soap, const char *tag, int id, const ns1__UhttQuot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttQuot), type))
		return soap->error;
	if (soap_out_int(soap, "GoodsID", -1, &(a->ns1__UhttQuot::GoodsID), ""))
		return soap->error;
	if (soap_out_int(soap, "SellerID", -1, &(a->ns1__UhttQuot::SellerID), ""))
		return soap->error;
	if (soap_out_int(soap, "BuyerID", -1, &(a->ns1__UhttQuot::BuyerID), ""))
		return soap->error;
	if (soap_out_int(soap, "CurID", -1, &(a->ns1__UhttQuot::CurID), ""))
		return soap->error;
	if (a->ns1__UhttQuot::Dt)
	{	if (soap_out_xsd__date(soap, "Dt", -1, &a->ns1__UhttQuot::Dt, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Dt"))
		return soap->error;
	if (a->ns1__UhttQuot::Tm)
	{	if (soap_out_xsd__time(soap, "Tm", -1, &a->ns1__UhttQuot::Tm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Tm"))
		return soap->error;
	if (soap_out_double(soap, "Val", -1, &(a->ns1__UhttQuot::Val), ""))
		return soap->error;
	if (a->ns1__UhttQuot::Memo)
	{	if (soap_out_string(soap, "Memo", -1, &a->ns1__UhttQuot::Memo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Memo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttQuot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttQuot(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttQuot * SOAP_FMAC4 soap_in_ns1__UhttQuot(struct soap *soap, const char *tag, ns1__UhttQuot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttQuot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttQuot, sizeof(ns1__UhttQuot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttQuot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttQuot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GoodsID1 = 1;
	size_t soap_flag_SellerID1 = 1;
	size_t soap_flag_BuyerID1 = 1;
	size_t soap_flag_CurID1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_Tm1 = 1;
	size_t soap_flag_Val1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GoodsID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "GoodsID", &(a->ns1__UhttQuot::GoodsID), "xsd:int"))
				{	soap_flag_GoodsID1--;
					continue;
				}
			if (soap_flag_SellerID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SellerID", &(a->ns1__UhttQuot::SellerID), "xsd:int"))
				{	soap_flag_SellerID1--;
					continue;
				}
			if (soap_flag_BuyerID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BuyerID", &(a->ns1__UhttQuot::BuyerID), "xsd:int"))
				{	soap_flag_BuyerID1--;
					continue;
				}
			if (soap_flag_CurID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CurID", &(a->ns1__UhttQuot::CurID), "xsd:int"))
				{	soap_flag_CurID1--;
					continue;
				}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "Dt", &(a->ns1__UhttQuot::Dt), "xsd:date"))
				{	soap_flag_Dt1--;
					continue;
				}
			if (soap_flag_Tm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__time(soap, "Tm", &(a->ns1__UhttQuot::Tm), "xsd:time"))
				{	soap_flag_Tm1--;
					continue;
				}
			if (soap_flag_Val1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Val", &(a->ns1__UhttQuot::Val), "xsd:double"))
				{	soap_flag_Val1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Memo", &(a->ns1__UhttQuot::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttQuot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttQuot, 0, sizeof(ns1__UhttQuot), 0, soap_copy_ns1__UhttQuot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GoodsID1 > 0 || soap_flag_SellerID1 > 0 || soap_flag_BuyerID1 > 0 || soap_flag_CurID1 > 0 || soap_flag_Dt1 > 0 || soap_flag_Tm1 > 0 || soap_flag_Val1 > 0 || soap_flag_Memo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttQuot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttQuot);
	if (this->soap_out(soap, tag?tag:"ns1:UhttQuot", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttQuot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttQuot(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttQuot * SOAP_FMAC4 soap_get_ns1__UhttQuot(struct soap *soap, ns1__UhttQuot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttQuot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttQuot * SOAP_FMAC2 soap_instantiate_ns1__UhttQuot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttQuot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttQuot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttQuot);
		if (size)
			*size = sizeof(ns1__UhttQuot);
		((ns1__UhttQuot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttQuot[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttQuot);
		for (int i = 0; i < n; i++)
			((ns1__UhttQuot*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttQuot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttQuot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttQuot %p -> %p\n", q, p));
	*(ns1__UhttQuot*)p = *(ns1__UhttQuot*)q;
}

void ns1__UhttSpoiledSerial::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::Serial);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::BarCode);
	soap_default_int(soap, &this->ns1__UhttSpoiledSerial::GoodsID);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::GoodsName);
	soap_default_int(soap, &this->ns1__UhttSpoiledSerial::ManufID);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::ManufName);
	soap_default_int(soap, &this->ns1__UhttSpoiledSerial::ManufCountryID);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::ManufCountryName);
	soap_default_int(soap, &this->ns1__UhttSpoiledSerial::LabID);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::LabName);
	soap_default_xsd__date(soap, &this->ns1__UhttSpoiledSerial::InfoDate);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::InfoIdent);
	soap_default_xsd__date(soap, &this->ns1__UhttSpoiledSerial::AllowDate);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::AllowNumber);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::SpecName);
	soap_default_string(soap, &this->ns1__UhttSpoiledSerial::LetterType);
	soap_default_int(soap, &this->ns1__UhttSpoiledSerial::Flags);
	/* transient soap skipped */
}

void ns1__UhttSpoiledSerial::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::Serial);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::BarCode);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::GoodsName);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::ManufName);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::ManufCountryName);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::LabName);
	soap_serialize_xsd__date(soap, &this->ns1__UhttSpoiledSerial::InfoDate);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::InfoIdent);
	soap_serialize_xsd__date(soap, &this->ns1__UhttSpoiledSerial::AllowDate);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::AllowNumber);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::SpecName);
	soap_serialize_string(soap, &this->ns1__UhttSpoiledSerial::LetterType);
	/* transient soap skipped */
}

int ns1__UhttSpoiledSerial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttSpoiledSerial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttSpoiledSerial(struct soap *soap, const char *tag, int id, const ns1__UhttSpoiledSerial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttSpoiledSerial), type))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::Serial)
	{	if (soap_out_string(soap, "Serial", -1, &a->ns1__UhttSpoiledSerial::Serial, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Serial"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::BarCode)
	{	if (soap_out_string(soap, "BarCode", -1, &a->ns1__UhttSpoiledSerial::BarCode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "BarCode"))
		return soap->error;
	if (soap_out_int(soap, "GoodsID", -1, &(a->ns1__UhttSpoiledSerial::GoodsID), ""))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::GoodsName)
	{	if (soap_out_string(soap, "GoodsName", -1, &a->ns1__UhttSpoiledSerial::GoodsName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "GoodsName"))
		return soap->error;
	if (soap_out_int(soap, "ManufID", -1, &(a->ns1__UhttSpoiledSerial::ManufID), ""))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::ManufName)
	{	if (soap_out_string(soap, "ManufName", -1, &a->ns1__UhttSpoiledSerial::ManufName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ManufName"))
		return soap->error;
	if (soap_out_int(soap, "ManufCountryID", -1, &(a->ns1__UhttSpoiledSerial::ManufCountryID), ""))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::ManufCountryName)
	{	if (soap_out_string(soap, "ManufCountryName", -1, &a->ns1__UhttSpoiledSerial::ManufCountryName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ManufCountryName"))
		return soap->error;
	if (soap_out_int(soap, "LabID", -1, &(a->ns1__UhttSpoiledSerial::LabID), ""))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::LabName)
	{	if (soap_out_string(soap, "LabName", -1, &a->ns1__UhttSpoiledSerial::LabName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "LabName"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::InfoDate)
	{	if (soap_out_xsd__date(soap, "InfoDate", -1, &a->ns1__UhttSpoiledSerial::InfoDate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "InfoDate"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::InfoIdent)
	{	if (soap_out_string(soap, "InfoIdent", -1, &a->ns1__UhttSpoiledSerial::InfoIdent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "InfoIdent"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::AllowDate)
	{	if (soap_out_xsd__date(soap, "AllowDate", -1, &a->ns1__UhttSpoiledSerial::AllowDate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "AllowDate"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::AllowNumber)
	{	if (soap_out_string(soap, "AllowNumber", -1, &a->ns1__UhttSpoiledSerial::AllowNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "AllowNumber"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::SpecName)
	{	if (soap_out_string(soap, "SpecName", -1, &a->ns1__UhttSpoiledSerial::SpecName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "SpecName"))
		return soap->error;
	if (a->ns1__UhttSpoiledSerial::LetterType)
	{	if (soap_out_string(soap, "LetterType", -1, &a->ns1__UhttSpoiledSerial::LetterType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "LetterType"))
		return soap->error;
	if (soap_out_int(soap, "Flags", -1, &(a->ns1__UhttSpoiledSerial::Flags), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttSpoiledSerial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttSpoiledSerial(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial * SOAP_FMAC4 soap_in_ns1__UhttSpoiledSerial(struct soap *soap, const char *tag, ns1__UhttSpoiledSerial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttSpoiledSerial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttSpoiledSerial, sizeof(ns1__UhttSpoiledSerial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttSpoiledSerial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttSpoiledSerial *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Serial1 = 1;
	size_t soap_flag_BarCode1 = 1;
	size_t soap_flag_GoodsID1 = 1;
	size_t soap_flag_GoodsName1 = 1;
	size_t soap_flag_ManufID1 = 1;
	size_t soap_flag_ManufName1 = 1;
	size_t soap_flag_ManufCountryID1 = 1;
	size_t soap_flag_ManufCountryName1 = 1;
	size_t soap_flag_LabID1 = 1;
	size_t soap_flag_LabName1 = 1;
	size_t soap_flag_InfoDate1 = 1;
	size_t soap_flag_InfoIdent1 = 1;
	size_t soap_flag_AllowDate1 = 1;
	size_t soap_flag_AllowNumber1 = 1;
	size_t soap_flag_SpecName1 = 1;
	size_t soap_flag_LetterType1 = 1;
	size_t soap_flag_Flags1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Serial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Serial", &(a->ns1__UhttSpoiledSerial::Serial), "xsd:string"))
				{	soap_flag_Serial1--;
					continue;
				}
			if (soap_flag_BarCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "BarCode", &(a->ns1__UhttSpoiledSerial::BarCode), "xsd:string"))
				{	soap_flag_BarCode1--;
					continue;
				}
			if (soap_flag_GoodsID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "GoodsID", &(a->ns1__UhttSpoiledSerial::GoodsID), "xsd:int"))
				{	soap_flag_GoodsID1--;
					continue;
				}
			if (soap_flag_GoodsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "GoodsName", &(a->ns1__UhttSpoiledSerial::GoodsName), "xsd:string"))
				{	soap_flag_GoodsName1--;
					continue;
				}
			if (soap_flag_ManufID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ManufID", &(a->ns1__UhttSpoiledSerial::ManufID), "xsd:int"))
				{	soap_flag_ManufID1--;
					continue;
				}
			if (soap_flag_ManufName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ManufName", &(a->ns1__UhttSpoiledSerial::ManufName), "xsd:string"))
				{	soap_flag_ManufName1--;
					continue;
				}
			if (soap_flag_ManufCountryID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ManufCountryID", &(a->ns1__UhttSpoiledSerial::ManufCountryID), "xsd:int"))
				{	soap_flag_ManufCountryID1--;
					continue;
				}
			if (soap_flag_ManufCountryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ManufCountryName", &(a->ns1__UhttSpoiledSerial::ManufCountryName), "xsd:string"))
				{	soap_flag_ManufCountryName1--;
					continue;
				}
			if (soap_flag_LabID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "LabID", &(a->ns1__UhttSpoiledSerial::LabID), "xsd:int"))
				{	soap_flag_LabID1--;
					continue;
				}
			if (soap_flag_LabName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "LabName", &(a->ns1__UhttSpoiledSerial::LabName), "xsd:string"))
				{	soap_flag_LabName1--;
					continue;
				}
			if (soap_flag_InfoDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "InfoDate", &(a->ns1__UhttSpoiledSerial::InfoDate), "xsd:date"))
				{	soap_flag_InfoDate1--;
					continue;
				}
			if (soap_flag_InfoIdent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "InfoIdent", &(a->ns1__UhttSpoiledSerial::InfoIdent), "xsd:string"))
				{	soap_flag_InfoIdent1--;
					continue;
				}
			if (soap_flag_AllowDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "AllowDate", &(a->ns1__UhttSpoiledSerial::AllowDate), "xsd:date"))
				{	soap_flag_AllowDate1--;
					continue;
				}
			if (soap_flag_AllowNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "AllowNumber", &(a->ns1__UhttSpoiledSerial::AllowNumber), "xsd:string"))
				{	soap_flag_AllowNumber1--;
					continue;
				}
			if (soap_flag_SpecName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SpecName", &(a->ns1__UhttSpoiledSerial::SpecName), "xsd:string"))
				{	soap_flag_SpecName1--;
					continue;
				}
			if (soap_flag_LetterType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "LetterType", &(a->ns1__UhttSpoiledSerial::LetterType), "xsd:string"))
				{	soap_flag_LetterType1--;
					continue;
				}
			if (soap_flag_Flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Flags", &(a->ns1__UhttSpoiledSerial::Flags), "xsd:int"))
				{	soap_flag_Flags1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttSpoiledSerial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttSpoiledSerial, 0, sizeof(ns1__UhttSpoiledSerial), 0, soap_copy_ns1__UhttSpoiledSerial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Serial1 > 0 || soap_flag_BarCode1 > 0 || soap_flag_GoodsID1 > 0 || soap_flag_GoodsName1 > 0 || soap_flag_ManufID1 > 0 || soap_flag_ManufName1 > 0 || soap_flag_ManufCountryID1 > 0 || soap_flag_ManufCountryName1 > 0 || soap_flag_LabID1 > 0 || soap_flag_LabName1 > 0 || soap_flag_InfoDate1 > 0 || soap_flag_InfoIdent1 > 0 || soap_flag_AllowDate1 > 0 || soap_flag_AllowNumber1 > 0 || soap_flag_SpecName1 > 0 || soap_flag_LetterType1 > 0 || soap_flag_Flags1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttSpoiledSerial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttSpoiledSerial);
	if (this->soap_out(soap, tag?tag:"ns1:UhttSpoiledSerial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttSpoiledSerial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttSpoiledSerial(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial * SOAP_FMAC4 soap_get_ns1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttSpoiledSerial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttSpoiledSerial * SOAP_FMAC2 soap_instantiate_ns1__UhttSpoiledSerial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttSpoiledSerial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttSpoiledSerial, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttSpoiledSerial);
		if (size)
			*size = sizeof(ns1__UhttSpoiledSerial);
		((ns1__UhttSpoiledSerial*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttSpoiledSerial[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttSpoiledSerial);
		for (int i = 0; i < n; i++)
			((ns1__UhttSpoiledSerial*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttSpoiledSerial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttSpoiledSerial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttSpoiledSerial %p -> %p\n", q, p));
	*(ns1__UhttSpoiledSerial*)p = *(ns1__UhttSpoiledSerial*)q;
}

void ns1__ArrayOfUhttSpoiledSerial::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfUhttSpoiledSerial::__sizeSpoiledSerial = 0;
	this->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfUhttSpoiledSerial::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfUhttSpoiledSerial::__sizeSpoiledSerial; i++)
		{
			soap_serialize_PointerTons1__UhttSpoiledSerial(soap, this->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfUhttSpoiledSerial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfUhttSpoiledSerial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUhttSpoiledSerial(struct soap *soap, const char *tag, int id, const ns1__ArrayOfUhttSpoiledSerial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial), type))
		return soap->error;
	if (a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfUhttSpoiledSerial::__sizeSpoiledSerial; i++)
			if (soap_out_PointerTons1__UhttSpoiledSerial(soap, "SpoiledSerial", -1, a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfUhttSpoiledSerial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfUhttSpoiledSerial(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttSpoiledSerial * SOAP_FMAC4 soap_in_ns1__ArrayOfUhttSpoiledSerial(struct soap *soap, const char *tag, ns1__ArrayOfUhttSpoiledSerial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfUhttSpoiledSerial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial, sizeof(ns1__ArrayOfUhttSpoiledSerial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfUhttSpoiledSerial *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_SpoiledSerial1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "SpoiledSerial", 1, NULL))
			{	if (a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial == NULL)
				{	if (soap_blist_SpoiledSerial1 == NULL)
						soap_blist_SpoiledSerial1 = soap_new_block(soap);
					a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = (ns1__UhttSpoiledSerial **)soap_push_block(soap, soap_blist_SpoiledSerial1, sizeof(ns1__UhttSpoiledSerial *));
					if (a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial == NULL)
						return NULL;
					*a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__UhttSpoiledSerial(soap, "SpoiledSerial", a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial, "ns1:UhttSpoiledSerial"))
				{	a->ns1__ArrayOfUhttSpoiledSerial::__sizeSpoiledSerial++;
					a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial)
			soap_pop_block(soap, soap_blist_SpoiledSerial1);
		if (a->ns1__ArrayOfUhttSpoiledSerial::__sizeSpoiledSerial)
			a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = (ns1__UhttSpoiledSerial **)soap_save_block(soap, soap_blist_SpoiledSerial1, NULL, 1);
		else
		{	a->ns1__ArrayOfUhttSpoiledSerial::SpoiledSerial = NULL;
			if (soap_blist_SpoiledSerial1)
				soap_end_block(soap, soap_blist_SpoiledSerial1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfUhttSpoiledSerial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial, 0, sizeof(ns1__ArrayOfUhttSpoiledSerial), 0, soap_copy_ns1__ArrayOfUhttSpoiledSerial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfUhttSpoiledSerial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfUhttSpoiledSerial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfUhttSpoiledSerial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfUhttSpoiledSerial(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttSpoiledSerial * SOAP_FMAC4 soap_get_ns1__ArrayOfUhttSpoiledSerial(struct soap *soap, ns1__ArrayOfUhttSpoiledSerial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUhttSpoiledSerial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfUhttSpoiledSerial * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfUhttSpoiledSerial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfUhttSpoiledSerial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfUhttSpoiledSerial);
		if (size)
			*size = sizeof(ns1__ArrayOfUhttSpoiledSerial);
		((ns1__ArrayOfUhttSpoiledSerial*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfUhttSpoiledSerial[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfUhttSpoiledSerial);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfUhttSpoiledSerial*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfUhttSpoiledSerial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfUhttSpoiledSerial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfUhttSpoiledSerial %p -> %p\n", q, p));
	*(ns1__ArrayOfUhttSpoiledSerial*)p = *(ns1__ArrayOfUhttSpoiledSerial*)q;
}

void ns1__UhttCalendarEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttCalendarEntry::CalID);
	soap_default_bool(soap, &this->ns1__UhttCalendarEntry::fSkip);
	soap_default_xsd__date(soap, &this->ns1__UhttCalendarEntry::Dt);
	soap_default_xsd__time(soap, &this->ns1__UhttCalendarEntry::TmStart);
	soap_default_xsd__time(soap, &this->ns1__UhttCalendarEntry::TmEnd);
	soap_default_string(soap, &this->ns1__UhttCalendarEntry::Memo);
	/* transient soap skipped */
}

void ns1__UhttCalendarEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->ns1__UhttCalendarEntry::Dt);
	soap_serialize_xsd__time(soap, &this->ns1__UhttCalendarEntry::TmStart);
	soap_serialize_xsd__time(soap, &this->ns1__UhttCalendarEntry::TmEnd);
	soap_serialize_string(soap, &this->ns1__UhttCalendarEntry::Memo);
	/* transient soap skipped */
}

int ns1__UhttCalendarEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttCalendarEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttCalendarEntry(struct soap *soap, const char *tag, int id, const ns1__UhttCalendarEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttCalendarEntry), type))
		return soap->error;
	if (soap_out_int(soap, "CalID", -1, &(a->ns1__UhttCalendarEntry::CalID), ""))
		return soap->error;
	if (soap_out_bool(soap, "fSkip", -1, &(a->ns1__UhttCalendarEntry::fSkip), ""))
		return soap->error;
	if (a->ns1__UhttCalendarEntry::Dt)
	{	if (soap_out_xsd__date(soap, "Dt", -1, &a->ns1__UhttCalendarEntry::Dt, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Dt"))
		return soap->error;
	if (a->ns1__UhttCalendarEntry::TmStart)
	{	if (soap_out_xsd__time(soap, "TmStart", -1, &a->ns1__UhttCalendarEntry::TmStart, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "TmStart"))
		return soap->error;
	if (a->ns1__UhttCalendarEntry::TmEnd)
	{	if (soap_out_xsd__time(soap, "TmEnd", -1, &a->ns1__UhttCalendarEntry::TmEnd, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "TmEnd"))
		return soap->error;
	if (a->ns1__UhttCalendarEntry::Memo)
	{	if (soap_out_string(soap, "Memo", -1, &a->ns1__UhttCalendarEntry::Memo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Memo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttCalendarEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttCalendarEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttCalendarEntry * SOAP_FMAC4 soap_in_ns1__UhttCalendarEntry(struct soap *soap, const char *tag, ns1__UhttCalendarEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttCalendarEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttCalendarEntry, sizeof(ns1__UhttCalendarEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttCalendarEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttCalendarEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CalID1 = 1;
	size_t soap_flag_fSkip1 = 1;
	size_t soap_flag_Dt1 = 1;
	size_t soap_flag_TmStart1 = 1;
	size_t soap_flag_TmEnd1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CalID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CalID", &(a->ns1__UhttCalendarEntry::CalID), "xsd:int"))
				{	soap_flag_CalID1--;
					continue;
				}
			if (soap_flag_fSkip1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fSkip", &(a->ns1__UhttCalendarEntry::fSkip), "xsd:boolean"))
				{	soap_flag_fSkip1--;
					continue;
				}
			if (soap_flag_Dt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "Dt", &(a->ns1__UhttCalendarEntry::Dt), "xsd:date"))
				{	soap_flag_Dt1--;
					continue;
				}
			if (soap_flag_TmStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__time(soap, "TmStart", &(a->ns1__UhttCalendarEntry::TmStart), "xsd:time"))
				{	soap_flag_TmStart1--;
					continue;
				}
			if (soap_flag_TmEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__time(soap, "TmEnd", &(a->ns1__UhttCalendarEntry::TmEnd), "xsd:time"))
				{	soap_flag_TmEnd1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Memo", &(a->ns1__UhttCalendarEntry::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttCalendarEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttCalendarEntry, 0, sizeof(ns1__UhttCalendarEntry), 0, soap_copy_ns1__UhttCalendarEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CalID1 > 0 || soap_flag_fSkip1 > 0 || soap_flag_Dt1 > 0 || soap_flag_TmStart1 > 0 || soap_flag_TmEnd1 > 0 || soap_flag_Memo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttCalendarEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttCalendarEntry);
	if (this->soap_out(soap, tag?tag:"ns1:UhttCalendarEntry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttCalendarEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttCalendarEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttCalendarEntry * SOAP_FMAC4 soap_get_ns1__UhttCalendarEntry(struct soap *soap, ns1__UhttCalendarEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttCalendarEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttCalendarEntry * SOAP_FMAC2 soap_instantiate_ns1__UhttCalendarEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttCalendarEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttCalendarEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCalendarEntry);
		if (size)
			*size = sizeof(ns1__UhttCalendarEntry);
		((ns1__UhttCalendarEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCalendarEntry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttCalendarEntry);
		for (int i = 0; i < n; i++)
			((ns1__UhttCalendarEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttCalendarEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttCalendarEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttCalendarEntry %p -> %p\n", q, p));
	*(ns1__UhttCalendarEntry*)p = *(ns1__UhttCalendarEntry*)q;
}

void ns1__UhttCalendar::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttCalendar::ID);
	soap_default_int(soap, &this->ns1__UhttCalendar::ParentID);
	soap_default_string(soap, &this->ns1__UhttCalendar::Name);
	soap_default_string(soap, &this->ns1__UhttCalendar::Code);
	soap_default_int(soap, &this->ns1__UhttCalendar::PersonID);
	soap_default_int(soap, &this->ns1__UhttCalendar::CountryID);
	/* transient soap skipped */
}

void ns1__UhttCalendar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttCalendar::Name);
	soap_serialize_string(soap, &this->ns1__UhttCalendar::Code);
	/* transient soap skipped */
}

int ns1__UhttCalendar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttCalendar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttCalendar(struct soap *soap, const char *tag, int id, const ns1__UhttCalendar *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttCalendar), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttCalendar::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ParentID", -1, &(a->ns1__UhttCalendar::ParentID), ""))
		return soap->error;
	if (a->ns1__UhttCalendar::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttCalendar::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttCalendar::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttCalendar::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_int(soap, "PersonID", -1, &(a->ns1__UhttCalendar::PersonID), ""))
		return soap->error;
	if (soap_out_int(soap, "CountryID", -1, &(a->ns1__UhttCalendar::CountryID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttCalendar::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttCalendar(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttCalendar * SOAP_FMAC4 soap_in_ns1__UhttCalendar(struct soap *soap, const char *tag, ns1__UhttCalendar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttCalendar *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttCalendar, sizeof(ns1__UhttCalendar), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttCalendar)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttCalendar *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_ParentID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_PersonID1 = 1;
	size_t soap_flag_CountryID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttCalendar::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_ParentID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ParentID", &(a->ns1__UhttCalendar::ParentID), "xsd:int"))
				{	soap_flag_ParentID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttCalendar::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttCalendar::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_PersonID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "PersonID", &(a->ns1__UhttCalendar::PersonID), "xsd:int"))
				{	soap_flag_PersonID1--;
					continue;
				}
			if (soap_flag_CountryID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CountryID", &(a->ns1__UhttCalendar::CountryID), "xsd:int"))
				{	soap_flag_CountryID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttCalendar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttCalendar, 0, sizeof(ns1__UhttCalendar), 0, soap_copy_ns1__UhttCalendar);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ParentID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0 || soap_flag_PersonID1 > 0 || soap_flag_CountryID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttCalendar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttCalendar);
	if (this->soap_out(soap, tag?tag:"ns1:UhttCalendar", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttCalendar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttCalendar(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttCalendar * SOAP_FMAC4 soap_get_ns1__UhttCalendar(struct soap *soap, ns1__UhttCalendar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttCalendar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttCalendar * SOAP_FMAC2 soap_instantiate_ns1__UhttCalendar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttCalendar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttCalendar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCalendar);
		if (size)
			*size = sizeof(ns1__UhttCalendar);
		((ns1__UhttCalendar*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCalendar[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttCalendar);
		for (int i = 0; i < n; i++)
			((ns1__UhttCalendar*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttCalendar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttCalendar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttCalendar %p -> %p\n", q, p));
	*(ns1__UhttCalendar*)p = *(ns1__UhttCalendar*)q;
}

void ns1__UhttGoods::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttGoods::ID);
	soap_default_int(soap, &this->ns1__UhttGoods::ParentID);
	soap_default_string(soap, &this->ns1__UhttGoods::Name);
	soap_default_int(soap, &this->ns1__UhttGoods::UnitID);
	soap_default_int(soap, &this->ns1__UhttGoods::PhUnitID);
	soap_default_double(soap, &this->ns1__UhttGoods::PhUPerU);
	soap_default_int(soap, &this->ns1__UhttGoods::BrandID);
	soap_default_int(soap, &this->ns1__UhttGoods::ManufID);
	soap_default_int(soap, &this->ns1__UhttGoods::TaxGrpID);
	soap_default_double(soap, &this->ns1__UhttGoods::Package);
	this->ns1__UhttGoods::__sizeBarcodeList = 0;
	this->ns1__UhttGoods::BarcodeList = NULL;
	/* transient soap skipped */
}

void ns1__UhttGoods::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttGoods::Name);
	if (this->ns1__UhttGoods::BarcodeList)
	{	int i;
		for (i = 0; i < this->ns1__UhttGoods::__sizeBarcodeList; i++)
		{
			soap_serialize_PointerTons1__UhttBarcode(soap, this->ns1__UhttGoods::BarcodeList + i);
		}
	}
	/* transient soap skipped */
}

int ns1__UhttGoods::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttGoods(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttGoods(struct soap *soap, const char *tag, int id, const ns1__UhttGoods *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttGoods), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttGoods::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ParentID", -1, &(a->ns1__UhttGoods::ParentID), ""))
		return soap->error;
	if (a->ns1__UhttGoods::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttGoods::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (soap_out_int(soap, "UnitID", -1, &(a->ns1__UhttGoods::UnitID), ""))
		return soap->error;
	if (soap_out_int(soap, "PhUnitID", -1, &(a->ns1__UhttGoods::PhUnitID), ""))
		return soap->error;
	if (soap_out_double(soap, "PhUPerU", -1, &(a->ns1__UhttGoods::PhUPerU), ""))
		return soap->error;
	if (soap_out_int(soap, "BrandID", -1, &(a->ns1__UhttGoods::BrandID), ""))
		return soap->error;
	if (soap_out_int(soap, "ManufID", -1, &(a->ns1__UhttGoods::ManufID), ""))
		return soap->error;
	if (soap_out_int(soap, "TaxGrpID", -1, &(a->ns1__UhttGoods::TaxGrpID), ""))
		return soap->error;
	if (soap_out_double(soap, "Package", -1, &(a->ns1__UhttGoods::Package), ""))
		return soap->error;
	if (a->ns1__UhttGoods::BarcodeList)
	{	int i;
		for (i = 0; i < a->ns1__UhttGoods::__sizeBarcodeList; i++)
			if (soap_out_PointerTons1__UhttBarcode(soap, "BarcodeList", -1, a->ns1__UhttGoods::BarcodeList + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttGoods::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttGoods(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttGoods * SOAP_FMAC4 soap_in_ns1__UhttGoods(struct soap *soap, const char *tag, ns1__UhttGoods *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttGoods *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttGoods, sizeof(ns1__UhttGoods), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttGoods)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttGoods *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_ParentID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UnitID1 = 1;
	size_t soap_flag_PhUnitID1 = 1;
	size_t soap_flag_PhUPerU1 = 1;
	size_t soap_flag_BrandID1 = 1;
	size_t soap_flag_ManufID1 = 1;
	size_t soap_flag_TaxGrpID1 = 1;
	size_t soap_flag_Package1 = 1;
	struct soap_blist *soap_blist_BarcodeList1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttGoods::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_ParentID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ParentID", &(a->ns1__UhttGoods::ParentID), "xsd:int"))
				{	soap_flag_ParentID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttGoods::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_UnitID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "UnitID", &(a->ns1__UhttGoods::UnitID), "xsd:int"))
				{	soap_flag_UnitID1--;
					continue;
				}
			if (soap_flag_PhUnitID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "PhUnitID", &(a->ns1__UhttGoods::PhUnitID), "xsd:int"))
				{	soap_flag_PhUnitID1--;
					continue;
				}
			if (soap_flag_PhUPerU1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "PhUPerU", &(a->ns1__UhttGoods::PhUPerU), "xsd:double"))
				{	soap_flag_PhUPerU1--;
					continue;
				}
			if (soap_flag_BrandID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "BrandID", &(a->ns1__UhttGoods::BrandID), "xsd:int"))
				{	soap_flag_BrandID1--;
					continue;
				}
			if (soap_flag_ManufID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ManufID", &(a->ns1__UhttGoods::ManufID), "xsd:int"))
				{	soap_flag_ManufID1--;
					continue;
				}
			if (soap_flag_TaxGrpID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TaxGrpID", &(a->ns1__UhttGoods::TaxGrpID), "xsd:int"))
				{	soap_flag_TaxGrpID1--;
					continue;
				}
			if (soap_flag_Package1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Package", &(a->ns1__UhttGoods::Package), "xsd:double"))
				{	soap_flag_Package1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "BarcodeList", 1, NULL))
			{	if (a->ns1__UhttGoods::BarcodeList == NULL)
				{	if (soap_blist_BarcodeList1 == NULL)
						soap_blist_BarcodeList1 = soap_new_block(soap);
					a->ns1__UhttGoods::BarcodeList = (ns1__UhttBarcode **)soap_push_block(soap, soap_blist_BarcodeList1, sizeof(ns1__UhttBarcode *));
					if (a->ns1__UhttGoods::BarcodeList == NULL)
						return NULL;
					*a->ns1__UhttGoods::BarcodeList = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__UhttBarcode(soap, "BarcodeList", a->ns1__UhttGoods::BarcodeList, "ns1:UhttBarcode"))
				{	a->ns1__UhttGoods::__sizeBarcodeList++;
					a->ns1__UhttGoods::BarcodeList = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__UhttGoods::BarcodeList)
			soap_pop_block(soap, soap_blist_BarcodeList1);
		if (a->ns1__UhttGoods::__sizeBarcodeList)
			a->ns1__UhttGoods::BarcodeList = (ns1__UhttBarcode **)soap_save_block(soap, soap_blist_BarcodeList1, NULL, 1);
		else
		{	a->ns1__UhttGoods::BarcodeList = NULL;
			if (soap_blist_BarcodeList1)
				soap_end_block(soap, soap_blist_BarcodeList1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttGoods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttGoods, 0, sizeof(ns1__UhttGoods), 0, soap_copy_ns1__UhttGoods);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ParentID1 > 0 || soap_flag_Name1 > 0 || soap_flag_UnitID1 > 0 || soap_flag_PhUnitID1 > 0 || soap_flag_PhUPerU1 > 0 || soap_flag_BrandID1 > 0 || soap_flag_ManufID1 > 0 || soap_flag_TaxGrpID1 > 0 || soap_flag_Package1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttGoods::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttGoods);
	if (this->soap_out(soap, tag?tag:"ns1:UhttGoods", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttGoods::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttGoods(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttGoods * SOAP_FMAC4 soap_get_ns1__UhttGoods(struct soap *soap, ns1__UhttGoods *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttGoods * SOAP_FMAC2 soap_instantiate_ns1__UhttGoods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttGoods(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttGoods, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoods);
		if (size)
			*size = sizeof(ns1__UhttGoods);
		((ns1__UhttGoods*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoods[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttGoods);
		for (int i = 0; i < n; i++)
			((ns1__UhttGoods*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttGoods*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttGoods(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttGoods %p -> %p\n", q, p));
	*(ns1__UhttGoods*)p = *(ns1__UhttGoods*)q;
}

void ns1__UhttGoodsTaxGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttGoodsTaxGroup::ID);
	soap_default_string(soap, &this->ns1__UhttGoodsTaxGroup::Name);
	soap_default_string(soap, &this->ns1__UhttGoodsTaxGroup::Code);
	soap_default_double(soap, &this->ns1__UhttGoodsTaxGroup::VatRate);
	soap_default_double(soap, &this->ns1__UhttGoodsTaxGroup::ExciseRate);
	soap_default_double(soap, &this->ns1__UhttGoodsTaxGroup::SalesTaxRate);
	/* transient soap skipped */
}

void ns1__UhttGoodsTaxGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttGoodsTaxGroup::Name);
	soap_serialize_string(soap, &this->ns1__UhttGoodsTaxGroup::Code);
	/* transient soap skipped */
}

int ns1__UhttGoodsTaxGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttGoodsTaxGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttGoodsTaxGroup(struct soap *soap, const char *tag, int id, const ns1__UhttGoodsTaxGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttGoodsTaxGroup), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttGoodsTaxGroup::ID), ""))
		return soap->error;
	if (a->ns1__UhttGoodsTaxGroup::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttGoodsTaxGroup::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttGoodsTaxGroup::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttGoodsTaxGroup::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_double(soap, "VatRate", -1, &(a->ns1__UhttGoodsTaxGroup::VatRate), ""))
		return soap->error;
	if (soap_out_double(soap, "ExciseRate", -1, &(a->ns1__UhttGoodsTaxGroup::ExciseRate), ""))
		return soap->error;
	if (soap_out_double(soap, "SalesTaxRate", -1, &(a->ns1__UhttGoodsTaxGroup::SalesTaxRate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttGoodsTaxGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttGoodsTaxGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttGoodsTaxGroup * SOAP_FMAC4 soap_in_ns1__UhttGoodsTaxGroup(struct soap *soap, const char *tag, ns1__UhttGoodsTaxGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttGoodsTaxGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttGoodsTaxGroup, sizeof(ns1__UhttGoodsTaxGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttGoodsTaxGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttGoodsTaxGroup *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_VatRate1 = 1;
	size_t soap_flag_ExciseRate1 = 1;
	size_t soap_flag_SalesTaxRate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttGoodsTaxGroup::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttGoodsTaxGroup::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttGoodsTaxGroup::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_VatRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "VatRate", &(a->ns1__UhttGoodsTaxGroup::VatRate), "xsd:double"))
				{	soap_flag_VatRate1--;
					continue;
				}
			if (soap_flag_ExciseRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ExciseRate", &(a->ns1__UhttGoodsTaxGroup::ExciseRate), "xsd:double"))
				{	soap_flag_ExciseRate1--;
					continue;
				}
			if (soap_flag_SalesTaxRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "SalesTaxRate", &(a->ns1__UhttGoodsTaxGroup::SalesTaxRate), "xsd:double"))
				{	soap_flag_SalesTaxRate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttGoodsTaxGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttGoodsTaxGroup, 0, sizeof(ns1__UhttGoodsTaxGroup), 0, soap_copy_ns1__UhttGoodsTaxGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0 || soap_flag_VatRate1 > 0 || soap_flag_ExciseRate1 > 0 || soap_flag_SalesTaxRate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttGoodsTaxGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttGoodsTaxGroup);
	if (this->soap_out(soap, tag?tag:"ns1:UhttGoodsTaxGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttGoodsTaxGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttGoodsTaxGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttGoodsTaxGroup * SOAP_FMAC4 soap_get_ns1__UhttGoodsTaxGroup(struct soap *soap, ns1__UhttGoodsTaxGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttGoodsTaxGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttGoodsTaxGroup * SOAP_FMAC2 soap_instantiate_ns1__UhttGoodsTaxGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttGoodsTaxGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttGoodsTaxGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoodsTaxGroup);
		if (size)
			*size = sizeof(ns1__UhttGoodsTaxGroup);
		((ns1__UhttGoodsTaxGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoodsTaxGroup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttGoodsTaxGroup);
		for (int i = 0; i < n; i++)
			((ns1__UhttGoodsTaxGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttGoodsTaxGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttGoodsTaxGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttGoodsTaxGroup %p -> %p\n", q, p));
	*(ns1__UhttGoodsTaxGroup*)p = *(ns1__UhttGoodsTaxGroup*)q;
}

void ns1__UhttArCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttArCode::OwnerID);
	soap_default_string(soap, &this->ns1__UhttArCode::Code);
	soap_default_double(soap, &this->ns1__UhttArCode::Package);
	/* transient soap skipped */
}

void ns1__UhttArCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttArCode::Code);
	/* transient soap skipped */
}

int ns1__UhttArCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttArCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttArCode(struct soap *soap, const char *tag, int id, const ns1__UhttArCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttArCode), type))
		return soap->error;
	if (soap_out_int(soap, "OwnerID", -1, &(a->ns1__UhttArCode::OwnerID), ""))
		return soap->error;
	if (a->ns1__UhttArCode::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttArCode::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_double(soap, "Package", -1, &(a->ns1__UhttArCode::Package), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttArCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttArCode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttArCode * SOAP_FMAC4 soap_in_ns1__UhttArCode(struct soap *soap, const char *tag, ns1__UhttArCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttArCode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttArCode, sizeof(ns1__UhttArCode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttArCode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttArCode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OwnerID1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Package1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OwnerID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "OwnerID", &(a->ns1__UhttArCode::OwnerID), "xsd:int"))
				{	soap_flag_OwnerID1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttArCode::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_Package1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Package", &(a->ns1__UhttArCode::Package), "xsd:double"))
				{	soap_flag_Package1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttArCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttArCode, 0, sizeof(ns1__UhttArCode), 0, soap_copy_ns1__UhttArCode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OwnerID1 > 0 || soap_flag_Code1 > 0 || soap_flag_Package1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttArCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttArCode);
	if (this->soap_out(soap, tag?tag:"ns1:UhttArCode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttArCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttArCode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttArCode * SOAP_FMAC4 soap_get_ns1__UhttArCode(struct soap *soap, ns1__UhttArCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttArCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttArCode * SOAP_FMAC2 soap_instantiate_ns1__UhttArCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttArCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttArCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttArCode);
		if (size)
			*size = sizeof(ns1__UhttArCode);
		((ns1__UhttArCode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttArCode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttArCode);
		for (int i = 0; i < n; i++)
			((ns1__UhttArCode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttArCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttArCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttArCode %p -> %p\n", q, p));
	*(ns1__UhttArCode*)p = *(ns1__UhttArCode*)q;
}

void ns1__UhttBarcode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__UhttBarcode::Code);
	soap_default_double(soap, &this->ns1__UhttBarcode::Package);
	/* transient soap skipped */
}

void ns1__UhttBarcode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttBarcode::Code);
	/* transient soap skipped */
}

int ns1__UhttBarcode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttBarcode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttBarcode(struct soap *soap, const char *tag, int id, const ns1__UhttBarcode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttBarcode), type))
		return soap->error;
	if (a->ns1__UhttBarcode::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttBarcode::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_double(soap, "Package", -1, &(a->ns1__UhttBarcode::Package), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttBarcode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttBarcode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttBarcode * SOAP_FMAC4 soap_in_ns1__UhttBarcode(struct soap *soap, const char *tag, ns1__UhttBarcode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttBarcode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttBarcode, sizeof(ns1__UhttBarcode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttBarcode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttBarcode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Package1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttBarcode::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_Package1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Package", &(a->ns1__UhttBarcode::Package), "xsd:double"))
				{	soap_flag_Package1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttBarcode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttBarcode, 0, sizeof(ns1__UhttBarcode), 0, soap_copy_ns1__UhttBarcode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0 || soap_flag_Package1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttBarcode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttBarcode);
	if (this->soap_out(soap, tag?tag:"ns1:UhttBarcode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttBarcode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttBarcode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttBarcode * SOAP_FMAC4 soap_get_ns1__UhttBarcode(struct soap *soap, ns1__UhttBarcode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttBarcode * SOAP_FMAC2 soap_instantiate_ns1__UhttBarcode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttBarcode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttBarcode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttBarcode);
		if (size)
			*size = sizeof(ns1__UhttBarcode);
		((ns1__UhttBarcode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttBarcode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttBarcode);
		for (int i = 0; i < n; i++)
			((ns1__UhttBarcode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttBarcode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttBarcode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttBarcode %p -> %p\n", q, p));
	*(ns1__UhttBarcode*)p = *(ns1__UhttBarcode*)q;
}

void ns1__UhttBrand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttBrand::ID);
	soap_default_string(soap, &this->ns1__UhttBrand::Name);
	soap_default_string(soap, &this->ns1__UhttBrand::Code);
	soap_default_int(soap, &this->ns1__UhttBrand::OwnerID);
	soap_default_int(soap, &this->ns1__UhttBrand::GoodsGroupID);
	/* transient soap skipped */
}

void ns1__UhttBrand::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttBrand::Name);
	soap_serialize_string(soap, &this->ns1__UhttBrand::Code);
	/* transient soap skipped */
}

int ns1__UhttBrand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttBrand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttBrand(struct soap *soap, const char *tag, int id, const ns1__UhttBrand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttBrand), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttBrand::ID), ""))
		return soap->error;
	if (a->ns1__UhttBrand::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttBrand::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttBrand::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttBrand::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_int(soap, "OwnerID", -1, &(a->ns1__UhttBrand::OwnerID), ""))
		return soap->error;
	if (soap_out_int(soap, "GoodsGroupID", -1, &(a->ns1__UhttBrand::GoodsGroupID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttBrand::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttBrand(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttBrand * SOAP_FMAC4 soap_in_ns1__UhttBrand(struct soap *soap, const char *tag, ns1__UhttBrand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttBrand *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttBrand, sizeof(ns1__UhttBrand), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttBrand)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttBrand *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_OwnerID1 = 1;
	size_t soap_flag_GoodsGroupID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttBrand::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttBrand::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttBrand::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_OwnerID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "OwnerID", &(a->ns1__UhttBrand::OwnerID), "xsd:int"))
				{	soap_flag_OwnerID1--;
					continue;
				}
			if (soap_flag_GoodsGroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "GoodsGroupID", &(a->ns1__UhttBrand::GoodsGroupID), "xsd:int"))
				{	soap_flag_GoodsGroupID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttBrand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttBrand, 0, sizeof(ns1__UhttBrand), 0, soap_copy_ns1__UhttBrand);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0 || soap_flag_OwnerID1 > 0 || soap_flag_GoodsGroupID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttBrand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttBrand);
	if (this->soap_out(soap, tag?tag:"ns1:UhttBrand", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttBrand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttBrand(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttBrand * SOAP_FMAC4 soap_get_ns1__UhttBrand(struct soap *soap, ns1__UhttBrand *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttBrand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttBrand * SOAP_FMAC2 soap_instantiate_ns1__UhttBrand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttBrand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttBrand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttBrand);
		if (size)
			*size = sizeof(ns1__UhttBrand);
		((ns1__UhttBrand*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttBrand[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttBrand);
		for (int i = 0; i < n; i++)
			((ns1__UhttBrand*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttBrand*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttBrand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttBrand %p -> %p\n", q, p));
	*(ns1__UhttBrand*)p = *(ns1__UhttBrand*)q;
}

void ns1__UhttGoodsGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttGoodsGroup::ID);
	soap_default_int(soap, &this->ns1__UhttGoodsGroup::ParentID);
	soap_default_string(soap, &this->ns1__UhttGoodsGroup::Name);
	soap_default_string(soap, &this->ns1__UhttGoodsGroup::Code);
	/* transient soap skipped */
}

void ns1__UhttGoodsGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttGoodsGroup::Name);
	soap_serialize_string(soap, &this->ns1__UhttGoodsGroup::Code);
	/* transient soap skipped */
}

int ns1__UhttGoodsGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttGoodsGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttGoodsGroup(struct soap *soap, const char *tag, int id, const ns1__UhttGoodsGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttGoodsGroup), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttGoodsGroup::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ParentID", -1, &(a->ns1__UhttGoodsGroup::ParentID), ""))
		return soap->error;
	if (a->ns1__UhttGoodsGroup::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttGoodsGroup::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttGoodsGroup::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttGoodsGroup::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttGoodsGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttGoodsGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttGoodsGroup * SOAP_FMAC4 soap_in_ns1__UhttGoodsGroup(struct soap *soap, const char *tag, ns1__UhttGoodsGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttGoodsGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttGoodsGroup, sizeof(ns1__UhttGoodsGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttGoodsGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttGoodsGroup *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_ParentID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttGoodsGroup::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_ParentID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ParentID", &(a->ns1__UhttGoodsGroup::ParentID), "xsd:int"))
				{	soap_flag_ParentID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttGoodsGroup::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttGoodsGroup::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttGoodsGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttGoodsGroup, 0, sizeof(ns1__UhttGoodsGroup), 0, soap_copy_ns1__UhttGoodsGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ParentID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttGoodsGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttGoodsGroup);
	if (this->soap_out(soap, tag?tag:"ns1:UhttGoodsGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttGoodsGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttGoodsGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttGoodsGroup * SOAP_FMAC4 soap_get_ns1__UhttGoodsGroup(struct soap *soap, ns1__UhttGoodsGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttGoodsGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttGoodsGroup * SOAP_FMAC2 soap_instantiate_ns1__UhttGoodsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttGoodsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttGoodsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoodsGroup);
		if (size)
			*size = sizeof(ns1__UhttGoodsGroup);
		((ns1__UhttGoodsGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttGoodsGroup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttGoodsGroup);
		for (int i = 0; i < n; i++)
			((ns1__UhttGoodsGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttGoodsGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttGoodsGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttGoodsGroup %p -> %p\n", q, p));
	*(ns1__UhttGoodsGroup*)p = *(ns1__UhttGoodsGroup*)q;
}

void ns1__UhttPersonLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPersonLocation::PersonID);
	this->ns1__UhttPersonLocation::Location = NULL;
	/* transient soap skipped */
}

void ns1__UhttPersonLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttLocation(soap, &this->ns1__UhttPersonLocation::Location);
	/* transient soap skipped */
}

int ns1__UhttPersonLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPersonLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPersonLocation(struct soap *soap, const char *tag, int id, const ns1__UhttPersonLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPersonLocation), type))
		return soap->error;
	if (soap_out_int(soap, "PersonID", -1, &(a->ns1__UhttPersonLocation::PersonID), ""))
		return soap->error;
	if (a->ns1__UhttPersonLocation::Location)
	{	if (soap_out_PointerTons1__UhttLocation(soap, "Location", -1, &a->ns1__UhttPersonLocation::Location, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Location"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPersonLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPersonLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPersonLocation * SOAP_FMAC4 soap_in_ns1__UhttPersonLocation(struct soap *soap, const char *tag, ns1__UhttPersonLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPersonLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPersonLocation, sizeof(ns1__UhttPersonLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPersonLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPersonLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PersonID1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PersonID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "PersonID", &(a->ns1__UhttPersonLocation::PersonID), "xsd:int"))
				{	soap_flag_PersonID1--;
					continue;
				}
			if (soap_flag_Location1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttLocation(soap, "Location", &(a->ns1__UhttPersonLocation::Location), "ns1:UhttLocation"))
				{	soap_flag_Location1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPersonLocation, 0, sizeof(ns1__UhttPersonLocation), 0, soap_copy_ns1__UhttPersonLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PersonID1 > 0 || soap_flag_Location1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPersonLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPersonLocation);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPersonLocation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPersonLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPersonLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPersonLocation * SOAP_FMAC4 soap_get_ns1__UhttPersonLocation(struct soap *soap, ns1__UhttPersonLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPersonLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPersonLocation * SOAP_FMAC2 soap_instantiate_ns1__UhttPersonLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPersonLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPersonLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonLocation);
		if (size)
			*size = sizeof(ns1__UhttPersonLocation);
		((ns1__UhttPersonLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonLocation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPersonLocation);
		for (int i = 0; i < n; i++)
			((ns1__UhttPersonLocation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPersonLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPersonLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPersonLocation %p -> %p\n", q, p));
	*(ns1__UhttPersonLocation*)p = *(ns1__UhttPersonLocation*)q;
}

void ns1__UhttPerson::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPerson::ID);
	soap_default_string(soap, &this->ns1__UhttPerson::Name);
	soap_default_string(soap, &this->ns1__UhttPerson::Code);
	this->ns1__UhttPerson::__sizeKindNameList = 0;
	this->ns1__UhttPerson::KindNameList = NULL;
	soap_default_string(soap, &this->ns1__UhttPerson::CategoryName);
	soap_default_string(soap, &this->ns1__UhttPerson::StatusName);
	this->ns1__UhttPerson::Addr = NULL;
	this->ns1__UhttPerson::RAddr = NULL;
	this->ns1__UhttPerson::__sizePhoneList = 0;
	this->ns1__UhttPerson::PhoneList = NULL;
	this->ns1__UhttPerson::__sizeEMailList = 0;
	this->ns1__UhttPerson::EMailList = NULL;
	soap_default_string(soap, &this->ns1__UhttPerson::URL);
	this->ns1__UhttPerson::__sizeRegisterList = 0;
	this->ns1__UhttPerson::RegisterList = NULL;
	/* transient soap skipped */
}

void ns1__UhttPerson::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttPerson::Name);
	soap_serialize_string(soap, &this->ns1__UhttPerson::Code);
	if (this->ns1__UhttPerson::KindNameList)
	{	int i;
		for (i = 0; i < this->ns1__UhttPerson::__sizeKindNameList; i++)
		{
			soap_serialize_string(soap, this->ns1__UhttPerson::KindNameList + i);
		}
	}
	soap_serialize_string(soap, &this->ns1__UhttPerson::CategoryName);
	soap_serialize_string(soap, &this->ns1__UhttPerson::StatusName);
	soap_serialize_PointerTons1__UhttLocation(soap, &this->ns1__UhttPerson::Addr);
	soap_serialize_PointerTons1__UhttLocation(soap, &this->ns1__UhttPerson::RAddr);
	if (this->ns1__UhttPerson::PhoneList)
	{	int i;
		for (i = 0; i < this->ns1__UhttPerson::__sizePhoneList; i++)
		{
			soap_serialize_string(soap, this->ns1__UhttPerson::PhoneList + i);
		}
	}
	if (this->ns1__UhttPerson::EMailList)
	{	int i;
		for (i = 0; i < this->ns1__UhttPerson::__sizeEMailList; i++)
		{
			soap_serialize_string(soap, this->ns1__UhttPerson::EMailList + i);
		}
	}
	soap_serialize_string(soap, &this->ns1__UhttPerson::URL);
	if (this->ns1__UhttPerson::RegisterList)
	{	int i;
		for (i = 0; i < this->ns1__UhttPerson::__sizeRegisterList; i++)
		{
			soap_serialize_PointerTons1__UhttPersonRegister(soap, this->ns1__UhttPerson::RegisterList + i);
		}
	}
	/* transient soap skipped */
}

int ns1__UhttPerson::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPerson(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPerson(struct soap *soap, const char *tag, int id, const ns1__UhttPerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPerson), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttPerson::ID), ""))
		return soap->error;
	if (a->ns1__UhttPerson::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttPerson::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttPerson::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttPerson::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (a->ns1__UhttPerson::KindNameList)
	{	int i;
		for (i = 0; i < a->ns1__UhttPerson::__sizeKindNameList; i++)
			if (soap_out_string(soap, "KindNameList", -1, a->ns1__UhttPerson::KindNameList + i, ""))
				return soap->error;
	}
	if (a->ns1__UhttPerson::CategoryName)
	{	if (soap_out_string(soap, "CategoryName", -1, &a->ns1__UhttPerson::CategoryName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "CategoryName"))
		return soap->error;
	if (a->ns1__UhttPerson::StatusName)
	{	if (soap_out_string(soap, "StatusName", -1, &a->ns1__UhttPerson::StatusName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "StatusName"))
		return soap->error;
	if (a->ns1__UhttPerson::Addr)
	{	if (soap_out_PointerTons1__UhttLocation(soap, "Addr", -1, &a->ns1__UhttPerson::Addr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Addr"))
		return soap->error;
	if (a->ns1__UhttPerson::RAddr)
	{	if (soap_out_PointerTons1__UhttLocation(soap, "RAddr", -1, &a->ns1__UhttPerson::RAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RAddr"))
		return soap->error;
	if (a->ns1__UhttPerson::PhoneList)
	{	int i;
		for (i = 0; i < a->ns1__UhttPerson::__sizePhoneList; i++)
			if (soap_out_string(soap, "PhoneList", -1, a->ns1__UhttPerson::PhoneList + i, ""))
				return soap->error;
	}
	if (a->ns1__UhttPerson::EMailList)
	{	int i;
		for (i = 0; i < a->ns1__UhttPerson::__sizeEMailList; i++)
			if (soap_out_string(soap, "EMailList", -1, a->ns1__UhttPerson::EMailList + i, ""))
				return soap->error;
	}
	if (a->ns1__UhttPerson::URL)
	{	if (soap_out_string(soap, "URL", -1, &a->ns1__UhttPerson::URL, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "URL"))
		return soap->error;
	if (a->ns1__UhttPerson::RegisterList)
	{	int i;
		for (i = 0; i < a->ns1__UhttPerson::__sizeRegisterList; i++)
			if (soap_out_PointerTons1__UhttPersonRegister(soap, "RegisterList", -1, a->ns1__UhttPerson::RegisterList + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPerson::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPerson(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPerson * SOAP_FMAC4 soap_in_ns1__UhttPerson(struct soap *soap, const char *tag, ns1__UhttPerson *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPerson *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPerson, sizeof(ns1__UhttPerson), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPerson)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPerson *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	struct soap_blist *soap_blist_KindNameList1 = NULL;
	size_t soap_flag_CategoryName1 = 1;
	size_t soap_flag_StatusName1 = 1;
	size_t soap_flag_Addr1 = 1;
	size_t soap_flag_RAddr1 = 1;
	struct soap_blist *soap_blist_PhoneList1 = NULL;
	struct soap_blist *soap_blist_EMailList1 = NULL;
	size_t soap_flag_URL1 = 1;
	struct soap_blist *soap_blist_RegisterList1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttPerson::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttPerson::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttPerson::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "KindNameList", 1, NULL))
			{	if (a->ns1__UhttPerson::KindNameList == NULL)
				{	if (soap_blist_KindNameList1 == NULL)
						soap_blist_KindNameList1 = soap_new_block(soap);
					a->ns1__UhttPerson::KindNameList = (char **)soap_push_block(soap, soap_blist_KindNameList1, sizeof(char *));
					if (a->ns1__UhttPerson::KindNameList == NULL)
						return NULL;
					*a->ns1__UhttPerson::KindNameList = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "KindNameList", a->ns1__UhttPerson::KindNameList, "xsd:string"))
				{	a->ns1__UhttPerson::__sizeKindNameList++;
					a->ns1__UhttPerson::KindNameList = NULL;
					continue;
				}
			}
			if (soap_flag_CategoryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "CategoryName", &(a->ns1__UhttPerson::CategoryName), "xsd:string"))
				{	soap_flag_CategoryName1--;
					continue;
				}
			if (soap_flag_StatusName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "StatusName", &(a->ns1__UhttPerson::StatusName), "xsd:string"))
				{	soap_flag_StatusName1--;
					continue;
				}
			if (soap_flag_Addr1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttLocation(soap, "Addr", &(a->ns1__UhttPerson::Addr), "ns1:UhttLocation"))
				{	soap_flag_Addr1--;
					continue;
				}
			if (soap_flag_RAddr1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttLocation(soap, "RAddr", &(a->ns1__UhttPerson::RAddr), "ns1:UhttLocation"))
				{	soap_flag_RAddr1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "PhoneList", 1, NULL))
			{	if (a->ns1__UhttPerson::PhoneList == NULL)
				{	if (soap_blist_PhoneList1 == NULL)
						soap_blist_PhoneList1 = soap_new_block(soap);
					a->ns1__UhttPerson::PhoneList = (char **)soap_push_block(soap, soap_blist_PhoneList1, sizeof(char *));
					if (a->ns1__UhttPerson::PhoneList == NULL)
						return NULL;
					*a->ns1__UhttPerson::PhoneList = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "PhoneList", a->ns1__UhttPerson::PhoneList, "xsd:string"))
				{	a->ns1__UhttPerson::__sizePhoneList++;
					a->ns1__UhttPerson::PhoneList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "EMailList", 1, NULL))
			{	if (a->ns1__UhttPerson::EMailList == NULL)
				{	if (soap_blist_EMailList1 == NULL)
						soap_blist_EMailList1 = soap_new_block(soap);
					a->ns1__UhttPerson::EMailList = (char **)soap_push_block(soap, soap_blist_EMailList1, sizeof(char *));
					if (a->ns1__UhttPerson::EMailList == NULL)
						return NULL;
					*a->ns1__UhttPerson::EMailList = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "EMailList", a->ns1__UhttPerson::EMailList, "xsd:string"))
				{	a->ns1__UhttPerson::__sizeEMailList++;
					a->ns1__UhttPerson::EMailList = NULL;
					continue;
				}
			}
			if (soap_flag_URL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "URL", &(a->ns1__UhttPerson::URL), "xsd:string"))
				{	soap_flag_URL1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "RegisterList", 1, NULL))
			{	if (a->ns1__UhttPerson::RegisterList == NULL)
				{	if (soap_blist_RegisterList1 == NULL)
						soap_blist_RegisterList1 = soap_new_block(soap);
					a->ns1__UhttPerson::RegisterList = (ns1__UhttPersonRegister **)soap_push_block(soap, soap_blist_RegisterList1, sizeof(ns1__UhttPersonRegister *));
					if (a->ns1__UhttPerson::RegisterList == NULL)
						return NULL;
					*a->ns1__UhttPerson::RegisterList = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__UhttPersonRegister(soap, "RegisterList", a->ns1__UhttPerson::RegisterList, "ns1:UhttPersonRegister"))
				{	a->ns1__UhttPerson::__sizeRegisterList++;
					a->ns1__UhttPerson::RegisterList = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__UhttPerson::KindNameList)
			soap_pop_block(soap, soap_blist_KindNameList1);
		if (a->ns1__UhttPerson::__sizeKindNameList)
			a->ns1__UhttPerson::KindNameList = (char **)soap_save_block(soap, soap_blist_KindNameList1, NULL, 1);
		else
		{	a->ns1__UhttPerson::KindNameList = NULL;
			if (soap_blist_KindNameList1)
				soap_end_block(soap, soap_blist_KindNameList1);
		}
		if (a->ns1__UhttPerson::PhoneList)
			soap_pop_block(soap, soap_blist_PhoneList1);
		if (a->ns1__UhttPerson::__sizePhoneList)
			a->ns1__UhttPerson::PhoneList = (char **)soap_save_block(soap, soap_blist_PhoneList1, NULL, 1);
		else
		{	a->ns1__UhttPerson::PhoneList = NULL;
			if (soap_blist_PhoneList1)
				soap_end_block(soap, soap_blist_PhoneList1);
		}
		if (a->ns1__UhttPerson::EMailList)
			soap_pop_block(soap, soap_blist_EMailList1);
		if (a->ns1__UhttPerson::__sizeEMailList)
			a->ns1__UhttPerson::EMailList = (char **)soap_save_block(soap, soap_blist_EMailList1, NULL, 1);
		else
		{	a->ns1__UhttPerson::EMailList = NULL;
			if (soap_blist_EMailList1)
				soap_end_block(soap, soap_blist_EMailList1);
		}
		if (a->ns1__UhttPerson::RegisterList)
			soap_pop_block(soap, soap_blist_RegisterList1);
		if (a->ns1__UhttPerson::__sizeRegisterList)
			a->ns1__UhttPerson::RegisterList = (ns1__UhttPersonRegister **)soap_save_block(soap, soap_blist_RegisterList1, NULL, 1);
		else
		{	a->ns1__UhttPerson::RegisterList = NULL;
			if (soap_blist_RegisterList1)
				soap_end_block(soap, soap_blist_RegisterList1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPerson, 0, sizeof(ns1__UhttPerson), 0, soap_copy_ns1__UhttPerson);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0 || soap_flag_CategoryName1 > 0 || soap_flag_StatusName1 > 0 || soap_flag_Addr1 > 0 || soap_flag_RAddr1 > 0 || soap_flag_URL1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPerson::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPerson);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPerson", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPerson::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPerson(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPerson * SOAP_FMAC4 soap_get_ns1__UhttPerson(struct soap *soap, ns1__UhttPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPerson * SOAP_FMAC2 soap_instantiate_ns1__UhttPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPerson);
		if (size)
			*size = sizeof(ns1__UhttPerson);
		((ns1__UhttPerson*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPerson[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPerson);
		for (int i = 0; i < n; i++)
			((ns1__UhttPerson*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPerson*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPerson %p -> %p\n", q, p));
	*(ns1__UhttPerson*)p = *(ns1__UhttPerson*)q;
}

void ns1__UhttPersonRegister::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPersonRegister::RegID);
	soap_default_int(soap, &this->ns1__UhttPersonRegister::RegTypeID);
	soap_default_int(soap, &this->ns1__UhttPersonRegister::RegPersonID);
	soap_default_int(soap, &this->ns1__UhttPersonRegister::RegOrgID);
	soap_default_xsd__date(soap, &this->ns1__UhttPersonRegister::RegDt);
	soap_default_xsd__date(soap, &this->ns1__UhttPersonRegister::RegExpiry);
	soap_default_string(soap, &this->ns1__UhttPersonRegister::RegSerial);
	soap_default_string(soap, &this->ns1__UhttPersonRegister::RegNumber);
	/* transient soap skipped */
}

void ns1__UhttPersonRegister::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->ns1__UhttPersonRegister::RegDt);
	soap_serialize_xsd__date(soap, &this->ns1__UhttPersonRegister::RegExpiry);
	soap_serialize_string(soap, &this->ns1__UhttPersonRegister::RegSerial);
	soap_serialize_string(soap, &this->ns1__UhttPersonRegister::RegNumber);
	/* transient soap skipped */
}

int ns1__UhttPersonRegister::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPersonRegister(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPersonRegister(struct soap *soap, const char *tag, int id, const ns1__UhttPersonRegister *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPersonRegister), type))
		return soap->error;
	if (soap_out_int(soap, "RegID", -1, &(a->ns1__UhttPersonRegister::RegID), ""))
		return soap->error;
	if (soap_out_int(soap, "RegTypeID", -1, &(a->ns1__UhttPersonRegister::RegTypeID), ""))
		return soap->error;
	if (soap_out_int(soap, "RegPersonID", -1, &(a->ns1__UhttPersonRegister::RegPersonID), ""))
		return soap->error;
	if (soap_out_int(soap, "RegOrgID", -1, &(a->ns1__UhttPersonRegister::RegOrgID), ""))
		return soap->error;
	if (a->ns1__UhttPersonRegister::RegDt)
	{	if (soap_out_xsd__date(soap, "RegDt", -1, &a->ns1__UhttPersonRegister::RegDt, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RegDt"))
		return soap->error;
	if (a->ns1__UhttPersonRegister::RegExpiry)
	{	if (soap_out_xsd__date(soap, "RegExpiry", -1, &a->ns1__UhttPersonRegister::RegExpiry, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RegExpiry"))
		return soap->error;
	if (a->ns1__UhttPersonRegister::RegSerial)
	{	if (soap_out_string(soap, "RegSerial", -1, &a->ns1__UhttPersonRegister::RegSerial, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RegSerial"))
		return soap->error;
	if (a->ns1__UhttPersonRegister::RegNumber)
	{	if (soap_out_string(soap, "RegNumber", -1, &a->ns1__UhttPersonRegister::RegNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RegNumber"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPersonRegister::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPersonRegister(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPersonRegister * SOAP_FMAC4 soap_in_ns1__UhttPersonRegister(struct soap *soap, const char *tag, ns1__UhttPersonRegister *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPersonRegister *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPersonRegister, sizeof(ns1__UhttPersonRegister), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPersonRegister)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPersonRegister *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RegID1 = 1;
	size_t soap_flag_RegTypeID1 = 1;
	size_t soap_flag_RegPersonID1 = 1;
	size_t soap_flag_RegOrgID1 = 1;
	size_t soap_flag_RegDt1 = 1;
	size_t soap_flag_RegExpiry1 = 1;
	size_t soap_flag_RegSerial1 = 1;
	size_t soap_flag_RegNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RegID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RegID", &(a->ns1__UhttPersonRegister::RegID), "xsd:int"))
				{	soap_flag_RegID1--;
					continue;
				}
			if (soap_flag_RegTypeID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RegTypeID", &(a->ns1__UhttPersonRegister::RegTypeID), "xsd:int"))
				{	soap_flag_RegTypeID1--;
					continue;
				}
			if (soap_flag_RegPersonID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RegPersonID", &(a->ns1__UhttPersonRegister::RegPersonID), "xsd:int"))
				{	soap_flag_RegPersonID1--;
					continue;
				}
			if (soap_flag_RegOrgID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RegOrgID", &(a->ns1__UhttPersonRegister::RegOrgID), "xsd:int"))
				{	soap_flag_RegOrgID1--;
					continue;
				}
			if (soap_flag_RegDt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "RegDt", &(a->ns1__UhttPersonRegister::RegDt), "xsd:date"))
				{	soap_flag_RegDt1--;
					continue;
				}
			if (soap_flag_RegExpiry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "RegExpiry", &(a->ns1__UhttPersonRegister::RegExpiry), "xsd:date"))
				{	soap_flag_RegExpiry1--;
					continue;
				}
			if (soap_flag_RegSerial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "RegSerial", &(a->ns1__UhttPersonRegister::RegSerial), "xsd:string"))
				{	soap_flag_RegSerial1--;
					continue;
				}
			if (soap_flag_RegNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "RegNumber", &(a->ns1__UhttPersonRegister::RegNumber), "xsd:string"))
				{	soap_flag_RegNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonRegister *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPersonRegister, 0, sizeof(ns1__UhttPersonRegister), 0, soap_copy_ns1__UhttPersonRegister);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RegID1 > 0 || soap_flag_RegTypeID1 > 0 || soap_flag_RegPersonID1 > 0 || soap_flag_RegOrgID1 > 0 || soap_flag_RegDt1 > 0 || soap_flag_RegExpiry1 > 0 || soap_flag_RegSerial1 > 0 || soap_flag_RegNumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPersonRegister::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPersonRegister);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPersonRegister", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPersonRegister::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPersonRegister(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPersonRegister * SOAP_FMAC4 soap_get_ns1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPersonRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPersonRegister * SOAP_FMAC2 soap_instantiate_ns1__UhttPersonRegister(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPersonRegister(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPersonRegister, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonRegister);
		if (size)
			*size = sizeof(ns1__UhttPersonRegister);
		((ns1__UhttPersonRegister*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonRegister[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPersonRegister);
		for (int i = 0; i < n; i++)
			((ns1__UhttPersonRegister*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPersonRegister*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPersonRegister(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPersonRegister %p -> %p\n", q, p));
	*(ns1__UhttPersonRegister*)p = *(ns1__UhttPersonRegister*)q;
}

void ns1__UhttPersonRegisterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPersonRegisterType::ID);
	soap_default_string(soap, &this->ns1__UhttPersonRegisterType::Name);
	soap_default_string(soap, &this->ns1__UhttPersonRegisterType::Code);
	/* transient soap skipped */
}

void ns1__UhttPersonRegisterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttPersonRegisterType::Name);
	soap_serialize_string(soap, &this->ns1__UhttPersonRegisterType::Code);
	/* transient soap skipped */
}

int ns1__UhttPersonRegisterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPersonRegisterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPersonRegisterType(struct soap *soap, const char *tag, int id, const ns1__UhttPersonRegisterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPersonRegisterType), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttPersonRegisterType::ID), ""))
		return soap->error;
	if (a->ns1__UhttPersonRegisterType::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttPersonRegisterType::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttPersonRegisterType::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttPersonRegisterType::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPersonRegisterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPersonRegisterType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPersonRegisterType * SOAP_FMAC4 soap_in_ns1__UhttPersonRegisterType(struct soap *soap, const char *tag, ns1__UhttPersonRegisterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPersonRegisterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPersonRegisterType, sizeof(ns1__UhttPersonRegisterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPersonRegisterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPersonRegisterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttPersonRegisterType::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttPersonRegisterType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttPersonRegisterType::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonRegisterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPersonRegisterType, 0, sizeof(ns1__UhttPersonRegisterType), 0, soap_copy_ns1__UhttPersonRegisterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPersonRegisterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPersonRegisterType);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPersonRegisterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPersonRegisterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPersonRegisterType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPersonRegisterType * SOAP_FMAC4 soap_get_ns1__UhttPersonRegisterType(struct soap *soap, ns1__UhttPersonRegisterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPersonRegisterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPersonRegisterType * SOAP_FMAC2 soap_instantiate_ns1__UhttPersonRegisterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPersonRegisterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPersonRegisterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonRegisterType);
		if (size)
			*size = sizeof(ns1__UhttPersonRegisterType);
		((ns1__UhttPersonRegisterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonRegisterType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPersonRegisterType);
		for (int i = 0; i < n; i++)
			((ns1__UhttPersonRegisterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPersonRegisterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPersonRegisterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPersonRegisterType %p -> %p\n", q, p));
	*(ns1__UhttPersonRegisterType*)p = *(ns1__UhttPersonRegisterType*)q;
}

void ns1__UhttLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttLocation::LocID);
	soap_default_int(soap, &this->ns1__UhttLocation::LocKind);
	soap_default_string(soap, &this->ns1__UhttLocation::LocCode);
	soap_default_string(soap, &this->ns1__UhttLocation::LocName);
	soap_default_int(soap, &this->ns1__UhttLocation::CountryID);
	soap_default_string(soap, &this->ns1__UhttLocation::Country);
	soap_default_int(soap, &this->ns1__UhttLocation::CityID);
	soap_default_string(soap, &this->ns1__UhttLocation::City);
	soap_default_string(soap, &this->ns1__UhttLocation::ZIP);
	soap_default_string(soap, &this->ns1__UhttLocation::Address);
	soap_default_double(soap, &this->ns1__UhttLocation::Latitude);
	soap_default_double(soap, &this->ns1__UhttLocation::Longitude);
	/* transient soap skipped */
}

void ns1__UhttLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttLocation::LocCode);
	soap_serialize_string(soap, &this->ns1__UhttLocation::LocName);
	soap_serialize_string(soap, &this->ns1__UhttLocation::Country);
	soap_serialize_string(soap, &this->ns1__UhttLocation::City);
	soap_serialize_string(soap, &this->ns1__UhttLocation::ZIP);
	soap_serialize_string(soap, &this->ns1__UhttLocation::Address);
	/* transient soap skipped */
}

int ns1__UhttLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttLocation(struct soap *soap, const char *tag, int id, const ns1__UhttLocation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttLocation), type))
		return soap->error;
	if (soap_out_int(soap, "LocID", -1, &(a->ns1__UhttLocation::LocID), ""))
		return soap->error;
	if (soap_out_int(soap, "LocKind", -1, &(a->ns1__UhttLocation::LocKind), ""))
		return soap->error;
	if (a->ns1__UhttLocation::LocCode)
	{	if (soap_out_string(soap, "LocCode", -1, &a->ns1__UhttLocation::LocCode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "LocCode"))
		return soap->error;
	if (a->ns1__UhttLocation::LocName)
	{	if (soap_out_string(soap, "LocName", -1, &a->ns1__UhttLocation::LocName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "LocName"))
		return soap->error;
	if (soap_out_int(soap, "CountryID", -1, &(a->ns1__UhttLocation::CountryID), ""))
		return soap->error;
	if (a->ns1__UhttLocation::Country)
	{	if (soap_out_string(soap, "Country", -1, &a->ns1__UhttLocation::Country, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Country"))
		return soap->error;
	if (soap_out_int(soap, "CityID", -1, &(a->ns1__UhttLocation::CityID), ""))
		return soap->error;
	if (a->ns1__UhttLocation::City)
	{	if (soap_out_string(soap, "City", -1, &a->ns1__UhttLocation::City, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "City"))
		return soap->error;
	if (a->ns1__UhttLocation::ZIP)
	{	if (soap_out_string(soap, "ZIP", -1, &a->ns1__UhttLocation::ZIP, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ZIP"))
		return soap->error;
	if (a->ns1__UhttLocation::Address)
	{	if (soap_out_string(soap, "Address", -1, &a->ns1__UhttLocation::Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Address"))
		return soap->error;
	if (soap_out_double(soap, "Latitude", -1, &(a->ns1__UhttLocation::Latitude), ""))
		return soap->error;
	if (soap_out_double(soap, "Longitude", -1, &(a->ns1__UhttLocation::Longitude), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttLocation * SOAP_FMAC4 soap_in_ns1__UhttLocation(struct soap *soap, const char *tag, ns1__UhttLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttLocation, sizeof(ns1__UhttLocation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttLocation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttLocation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LocID1 = 1;
	size_t soap_flag_LocKind1 = 1;
	size_t soap_flag_LocCode1 = 1;
	size_t soap_flag_LocName1 = 1;
	size_t soap_flag_CountryID1 = 1;
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_CityID1 = 1;
	size_t soap_flag_City1 = 1;
	size_t soap_flag_ZIP1 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "LocID", &(a->ns1__UhttLocation::LocID), "xsd:int"))
				{	soap_flag_LocID1--;
					continue;
				}
			if (soap_flag_LocKind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "LocKind", &(a->ns1__UhttLocation::LocKind), "xsd:int"))
				{	soap_flag_LocKind1--;
					continue;
				}
			if (soap_flag_LocCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "LocCode", &(a->ns1__UhttLocation::LocCode), "xsd:string"))
				{	soap_flag_LocCode1--;
					continue;
				}
			if (soap_flag_LocName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "LocName", &(a->ns1__UhttLocation::LocName), "xsd:string"))
				{	soap_flag_LocName1--;
					continue;
				}
			if (soap_flag_CountryID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CountryID", &(a->ns1__UhttLocation::CountryID), "xsd:int"))
				{	soap_flag_CountryID1--;
					continue;
				}
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Country", &(a->ns1__UhttLocation::Country), "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_CityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CityID", &(a->ns1__UhttLocation::CityID), "xsd:int"))
				{	soap_flag_CityID1--;
					continue;
				}
			if (soap_flag_City1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "City", &(a->ns1__UhttLocation::City), "xsd:string"))
				{	soap_flag_City1--;
					continue;
				}
			if (soap_flag_ZIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ZIP", &(a->ns1__UhttLocation::ZIP), "xsd:string"))
				{	soap_flag_ZIP1--;
					continue;
				}
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Address", &(a->ns1__UhttLocation::Address), "xsd:string"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Latitude", &(a->ns1__UhttLocation::Latitude), "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Longitude", &(a->ns1__UhttLocation::Longitude), "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttLocation, 0, sizeof(ns1__UhttLocation), 0, soap_copy_ns1__UhttLocation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocID1 > 0 || soap_flag_LocKind1 > 0 || soap_flag_LocCode1 > 0 || soap_flag_LocName1 > 0 || soap_flag_CountryID1 > 0 || soap_flag_Country1 > 0 || soap_flag_CityID1 > 0 || soap_flag_City1 > 0 || soap_flag_ZIP1 > 0 || soap_flag_Address1 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttLocation);
	if (this->soap_out(soap, tag?tag:"ns1:UhttLocation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttLocation * SOAP_FMAC4 soap_get_ns1__UhttLocation(struct soap *soap, ns1__UhttLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttLocation * SOAP_FMAC2 soap_instantiate_ns1__UhttLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttLocation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttLocation);
		if (size)
			*size = sizeof(ns1__UhttLocation);
		((ns1__UhttLocation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttLocation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttLocation);
		for (int i = 0; i < n; i++)
			((ns1__UhttLocation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttLocation %p -> %p\n", q, p));
	*(ns1__UhttLocation*)p = *(ns1__UhttLocation*)q;
}

void ns1__UhttPersonCategory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPersonCategory::ID);
	soap_default_string(soap, &this->ns1__UhttPersonCategory::Name);
	soap_default_string(soap, &this->ns1__UhttPersonCategory::Code);
	/* transient soap skipped */
}

void ns1__UhttPersonCategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttPersonCategory::Name);
	soap_serialize_string(soap, &this->ns1__UhttPersonCategory::Code);
	/* transient soap skipped */
}

int ns1__UhttPersonCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPersonCategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPersonCategory(struct soap *soap, const char *tag, int id, const ns1__UhttPersonCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPersonCategory), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttPersonCategory::ID), ""))
		return soap->error;
	if (a->ns1__UhttPersonCategory::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttPersonCategory::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttPersonCategory::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttPersonCategory::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPersonCategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPersonCategory(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPersonCategory * SOAP_FMAC4 soap_in_ns1__UhttPersonCategory(struct soap *soap, const char *tag, ns1__UhttPersonCategory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPersonCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPersonCategory, sizeof(ns1__UhttPersonCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPersonCategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPersonCategory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttPersonCategory::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttPersonCategory::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttPersonCategory::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPersonCategory, 0, sizeof(ns1__UhttPersonCategory), 0, soap_copy_ns1__UhttPersonCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPersonCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPersonCategory);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPersonCategory", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPersonCategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPersonCategory(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPersonCategory * SOAP_FMAC4 soap_get_ns1__UhttPersonCategory(struct soap *soap, ns1__UhttPersonCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPersonCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPersonCategory * SOAP_FMAC2 soap_instantiate_ns1__UhttPersonCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPersonCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPersonCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonCategory);
		if (size)
			*size = sizeof(ns1__UhttPersonCategory);
		((ns1__UhttPersonCategory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPersonCategory);
		for (int i = 0; i < n; i++)
			((ns1__UhttPersonCategory*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPersonCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPersonCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPersonCategory %p -> %p\n", q, p));
	*(ns1__UhttPersonCategory*)p = *(ns1__UhttPersonCategory*)q;
}

void ns1__UhttPersonKind::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttPersonKind::ID);
	soap_default_string(soap, &this->ns1__UhttPersonKind::Name);
	soap_default_string(soap, &this->ns1__UhttPersonKind::Code);
	/* transient soap skipped */
}

void ns1__UhttPersonKind::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttPersonKind::Name);
	soap_serialize_string(soap, &this->ns1__UhttPersonKind::Code);
	/* transient soap skipped */
}

int ns1__UhttPersonKind::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttPersonKind(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttPersonKind(struct soap *soap, const char *tag, int id, const ns1__UhttPersonKind *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttPersonKind), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttPersonKind::ID), ""))
		return soap->error;
	if (a->ns1__UhttPersonKind::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttPersonKind::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttPersonKind::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttPersonKind::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttPersonKind::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttPersonKind(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttPersonKind * SOAP_FMAC4 soap_in_ns1__UhttPersonKind(struct soap *soap, const char *tag, ns1__UhttPersonKind *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttPersonKind *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttPersonKind, sizeof(ns1__UhttPersonKind), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttPersonKind)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttPersonKind *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttPersonKind::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttPersonKind::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttPersonKind::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonKind *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttPersonKind, 0, sizeof(ns1__UhttPersonKind), 0, soap_copy_ns1__UhttPersonKind);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttPersonKind::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttPersonKind);
	if (this->soap_out(soap, tag?tag:"ns1:UhttPersonKind", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttPersonKind::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttPersonKind(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttPersonKind * SOAP_FMAC4 soap_get_ns1__UhttPersonKind(struct soap *soap, ns1__UhttPersonKind *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttPersonKind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttPersonKind * SOAP_FMAC2 soap_instantiate_ns1__UhttPersonKind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttPersonKind(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttPersonKind, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonKind);
		if (size)
			*size = sizeof(ns1__UhttPersonKind);
		((ns1__UhttPersonKind*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttPersonKind[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttPersonKind);
		for (int i = 0; i < n; i++)
			((ns1__UhttPersonKind*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttPersonKind*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttPersonKind(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttPersonKind %p -> %p\n", q, p));
	*(ns1__UhttPersonKind*)p = *(ns1__UhttPersonKind*)q;
}

void ns1__UhttCurrency::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttCurrency::ID);
	soap_default_string(soap, &this->ns1__UhttCurrency::Name);
	soap_default_string(soap, &this->ns1__UhttCurrency::Code);
	soap_default_int(soap, &this->ns1__UhttCurrency::DigitCode);
	/* transient soap skipped */
}

void ns1__UhttCurrency::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttCurrency::Name);
	soap_serialize_string(soap, &this->ns1__UhttCurrency::Code);
	/* transient soap skipped */
}

int ns1__UhttCurrency::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttCurrency(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttCurrency(struct soap *soap, const char *tag, int id, const ns1__UhttCurrency *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttCurrency), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttCurrency::ID), ""))
		return soap->error;
	if (a->ns1__UhttCurrency::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttCurrency::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (a->ns1__UhttCurrency::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttCurrency::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (soap_out_int(soap, "DigitCode", -1, &(a->ns1__UhttCurrency::DigitCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttCurrency::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttCurrency(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttCurrency * SOAP_FMAC4 soap_in_ns1__UhttCurrency(struct soap *soap, const char *tag, ns1__UhttCurrency *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttCurrency *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttCurrency, sizeof(ns1__UhttCurrency), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttCurrency)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttCurrency *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_DigitCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttCurrency::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttCurrency::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttCurrency::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_DigitCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "DigitCode", &(a->ns1__UhttCurrency::DigitCode), "xsd:int"))
				{	soap_flag_DigitCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttCurrency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttCurrency, 0, sizeof(ns1__UhttCurrency), 0, soap_copy_ns1__UhttCurrency);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Code1 > 0 || soap_flag_DigitCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttCurrency::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttCurrency);
	if (this->soap_out(soap, tag?tag:"ns1:UhttCurrency", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttCurrency::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttCurrency(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttCurrency * SOAP_FMAC4 soap_get_ns1__UhttCurrency(struct soap *soap, ns1__UhttCurrency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttCurrency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttCurrency * SOAP_FMAC2 soap_instantiate_ns1__UhttCurrency(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttCurrency(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttCurrency, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCurrency);
		if (size)
			*size = sizeof(ns1__UhttCurrency);
		((ns1__UhttCurrency*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCurrency[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttCurrency);
		for (int i = 0; i < n; i++)
			((ns1__UhttCurrency*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttCurrency*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttCurrency(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttCurrency %p -> %p\n", q, p));
	*(ns1__UhttCurrency*)p = *(ns1__UhttCurrency*)q;
}

void ns1__UhttWorld::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttWorld::ID);
	soap_default_int(soap, &this->ns1__UhttWorld::ParentID);
	soap_default_string(soap, &this->ns1__UhttWorld::Name);
	soap_default_int(soap, &this->ns1__UhttWorld::Kind);
	soap_default_string(soap, &this->ns1__UhttWorld::ParentName);
	soap_default_int(soap, &this->ns1__UhttWorld::CountryID);
	soap_default_double(soap, &this->ns1__UhttWorld::Latitude);
	soap_default_double(soap, &this->ns1__UhttWorld::Longitude);
	soap_default_string(soap, &this->ns1__UhttWorld::Code);
	soap_default_string(soap, &this->ns1__UhttWorld::CountryIsoAlpha2);
	soap_default_int(soap, &this->ns1__UhttWorld::CountryIsoDigit);
	soap_default_int(soap, &this->ns1__UhttWorld::CurrencyID);
	/* transient soap skipped */
}

void ns1__UhttWorld::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttWorld::Name);
	soap_serialize_string(soap, &this->ns1__UhttWorld::ParentName);
	soap_serialize_string(soap, &this->ns1__UhttWorld::Code);
	soap_serialize_string(soap, &this->ns1__UhttWorld::CountryIsoAlpha2);
	/* transient soap skipped */
}

int ns1__UhttWorld::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttWorld(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttWorld(struct soap *soap, const char *tag, int id, const ns1__UhttWorld *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttWorld), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttWorld::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ParentID", -1, &(a->ns1__UhttWorld::ParentID), ""))
		return soap->error;
	if (a->ns1__UhttWorld::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttWorld::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	if (soap_out_int(soap, "Kind", -1, &(a->ns1__UhttWorld::Kind), ""))
		return soap->error;
	if (a->ns1__UhttWorld::ParentName)
	{	if (soap_out_string(soap, "ParentName", -1, &a->ns1__UhttWorld::ParentName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ParentName"))
		return soap->error;
	if (soap_out_int(soap, "CountryID", -1, &(a->ns1__UhttWorld::CountryID), ""))
		return soap->error;
	if (soap_out_double(soap, "Latitude", -1, &(a->ns1__UhttWorld::Latitude), ""))
		return soap->error;
	if (soap_out_double(soap, "Longitude", -1, &(a->ns1__UhttWorld::Longitude), ""))
		return soap->error;
	if (a->ns1__UhttWorld::Code)
	{	if (soap_out_string(soap, "Code", -1, &a->ns1__UhttWorld::Code, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Code"))
		return soap->error;
	if (a->ns1__UhttWorld::CountryIsoAlpha2)
	{	if (soap_out_string(soap, "CountryIsoAlpha2", -1, &a->ns1__UhttWorld::CountryIsoAlpha2, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "CountryIsoAlpha2"))
		return soap->error;
	if (soap_out_int(soap, "CountryIsoDigit", -1, &(a->ns1__UhttWorld::CountryIsoDigit), ""))
		return soap->error;
	if (soap_out_int(soap, "CurrencyID", -1, &(a->ns1__UhttWorld::CurrencyID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttWorld::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttWorld(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttWorld * SOAP_FMAC4 soap_in_ns1__UhttWorld(struct soap *soap, const char *tag, ns1__UhttWorld *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttWorld *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttWorld, sizeof(ns1__UhttWorld), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttWorld)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttWorld *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_ParentID1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Kind1 = 1;
	size_t soap_flag_ParentName1 = 1;
	size_t soap_flag_CountryID1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_CountryIsoAlpha21 = 1;
	size_t soap_flag_CountryIsoDigit1 = 1;
	size_t soap_flag_CurrencyID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttWorld::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_ParentID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ParentID", &(a->ns1__UhttWorld::ParentID), "xsd:int"))
				{	soap_flag_ParentID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttWorld::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Kind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Kind", &(a->ns1__UhttWorld::Kind), "xsd:int"))
				{	soap_flag_Kind1--;
					continue;
				}
			if (soap_flag_ParentName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ParentName", &(a->ns1__UhttWorld::ParentName), "xsd:string"))
				{	soap_flag_ParentName1--;
					continue;
				}
			if (soap_flag_CountryID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CountryID", &(a->ns1__UhttWorld::CountryID), "xsd:int"))
				{	soap_flag_CountryID1--;
					continue;
				}
			if (soap_flag_Latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Latitude", &(a->ns1__UhttWorld::Latitude), "xsd:double"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Longitude", &(a->ns1__UhttWorld::Longitude), "xsd:double"))
				{	soap_flag_Longitude1--;
					continue;
				}
			if (soap_flag_Code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Code", &(a->ns1__UhttWorld::Code), "xsd:string"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_CountryIsoAlpha21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "CountryIsoAlpha2", &(a->ns1__UhttWorld::CountryIsoAlpha2), "xsd:string"))
				{	soap_flag_CountryIsoAlpha21--;
					continue;
				}
			if (soap_flag_CountryIsoDigit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CountryIsoDigit", &(a->ns1__UhttWorld::CountryIsoDigit), "xsd:int"))
				{	soap_flag_CountryIsoDigit1--;
					continue;
				}
			if (soap_flag_CurrencyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CurrencyID", &(a->ns1__UhttWorld::CurrencyID), "xsd:int"))
				{	soap_flag_CurrencyID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttWorld, 0, sizeof(ns1__UhttWorld), 0, soap_copy_ns1__UhttWorld);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ParentID1 > 0 || soap_flag_Name1 > 0 || soap_flag_Kind1 > 0 || soap_flag_ParentName1 > 0 || soap_flag_CountryID1 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0 || soap_flag_Code1 > 0 || soap_flag_CountryIsoAlpha21 > 0 || soap_flag_CountryIsoDigit1 > 0 || soap_flag_CurrencyID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttWorld::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttWorld);
	if (this->soap_out(soap, tag?tag:"ns1:UhttWorld", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttWorld::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttWorld(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttWorld * SOAP_FMAC4 soap_get_ns1__UhttWorld(struct soap *soap, ns1__UhttWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttWorld * SOAP_FMAC2 soap_instantiate_ns1__UhttWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttWorld(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttWorld, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttWorld);
		if (size)
			*size = sizeof(ns1__UhttWorld);
		((ns1__UhttWorld*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttWorld[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttWorld);
		for (int i = 0; i < n; i++)
			((ns1__UhttWorld*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttWorld*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttWorld(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttWorld %p -> %p\n", q, p));
	*(ns1__UhttWorld*)p = *(ns1__UhttWorld*)q;
}

void ns1__UhttCommObjItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__UhttCommObjItem::ID);
	soap_default_int(soap, &this->ns1__UhttCommObjItem::ParentID);
	soap_default_string(soap, &this->ns1__UhttCommObjItem::Name);
	/* transient soap skipped */
}

void ns1__UhttCommObjItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttCommObjItem::Name);
	/* transient soap skipped */
}

int ns1__UhttCommObjItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttCommObjItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttCommObjItem(struct soap *soap, const char *tag, int id, const ns1__UhttCommObjItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttCommObjItem), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &(a->ns1__UhttCommObjItem::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ParentID", -1, &(a->ns1__UhttCommObjItem::ParentID), ""))
		return soap->error;
	if (a->ns1__UhttCommObjItem::Name)
	{	if (soap_out_string(soap, "Name", -1, &a->ns1__UhttCommObjItem::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttCommObjItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttCommObjItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttCommObjItem * SOAP_FMAC4 soap_in_ns1__UhttCommObjItem(struct soap *soap, const char *tag, ns1__UhttCommObjItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttCommObjItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttCommObjItem, sizeof(ns1__UhttCommObjItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttCommObjItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttCommObjItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_ParentID1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &(a->ns1__UhttCommObjItem::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_ParentID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ParentID", &(a->ns1__UhttCommObjItem::ParentID), "xsd:int"))
				{	soap_flag_ParentID1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", &(a->ns1__UhttCommObjItem::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttCommObjItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttCommObjItem, 0, sizeof(ns1__UhttCommObjItem), 0, soap_copy_ns1__UhttCommObjItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ParentID1 > 0 || soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttCommObjItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttCommObjItem);
	if (this->soap_out(soap, tag?tag:"ns1:UhttCommObjItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttCommObjItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttCommObjItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttCommObjItem * SOAP_FMAC4 soap_get_ns1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttCommObjItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttCommObjItem * SOAP_FMAC2 soap_instantiate_ns1__UhttCommObjItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttCommObjItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttCommObjItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCommObjItem);
		if (size)
			*size = sizeof(ns1__UhttCommObjItem);
		((ns1__UhttCommObjItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttCommObjItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttCommObjItem);
		for (int i = 0; i < n; i++)
			((ns1__UhttCommObjItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttCommObjItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttCommObjItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttCommObjItem %p -> %p\n", q, p));
	*(ns1__UhttCommObjItem*)p = *(ns1__UhttCommObjItem*)q;
}

void ns1__ArrayOfUhttCommObjItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfUhttCommObjItem::__sizeCommObjItem = 0;
	this->ns1__ArrayOfUhttCommObjItem::CommObjItem = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfUhttCommObjItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfUhttCommObjItem::CommObjItem)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfUhttCommObjItem::__sizeCommObjItem; i++)
		{
			soap_serialize_PointerTons1__UhttCommObjItem(soap, this->ns1__ArrayOfUhttCommObjItem::CommObjItem + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfUhttCommObjItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfUhttCommObjItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUhttCommObjItem(struct soap *soap, const char *tag, int id, const ns1__ArrayOfUhttCommObjItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem), type))
		return soap->error;
	if (a->ns1__ArrayOfUhttCommObjItem::CommObjItem)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfUhttCommObjItem::__sizeCommObjItem; i++)
			if (soap_out_PointerTons1__UhttCommObjItem(soap, "CommObjItem", -1, a->ns1__ArrayOfUhttCommObjItem::CommObjItem + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfUhttCommObjItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfUhttCommObjItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttCommObjItem * SOAP_FMAC4 soap_in_ns1__ArrayOfUhttCommObjItem(struct soap *soap, const char *tag, ns1__ArrayOfUhttCommObjItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfUhttCommObjItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem, sizeof(ns1__ArrayOfUhttCommObjItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfUhttCommObjItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfUhttCommObjItem *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CommObjItem1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "CommObjItem", 1, NULL))
			{	if (a->ns1__ArrayOfUhttCommObjItem::CommObjItem == NULL)
				{	if (soap_blist_CommObjItem1 == NULL)
						soap_blist_CommObjItem1 = soap_new_block(soap);
					a->ns1__ArrayOfUhttCommObjItem::CommObjItem = (ns1__UhttCommObjItem **)soap_push_block(soap, soap_blist_CommObjItem1, sizeof(ns1__UhttCommObjItem *));
					if (a->ns1__ArrayOfUhttCommObjItem::CommObjItem == NULL)
						return NULL;
					*a->ns1__ArrayOfUhttCommObjItem::CommObjItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__UhttCommObjItem(soap, "CommObjItem", a->ns1__ArrayOfUhttCommObjItem::CommObjItem, "ns1:UhttCommObjItem"))
				{	a->ns1__ArrayOfUhttCommObjItem::__sizeCommObjItem++;
					a->ns1__ArrayOfUhttCommObjItem::CommObjItem = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfUhttCommObjItem::CommObjItem)
			soap_pop_block(soap, soap_blist_CommObjItem1);
		if (a->ns1__ArrayOfUhttCommObjItem::__sizeCommObjItem)
			a->ns1__ArrayOfUhttCommObjItem::CommObjItem = (ns1__UhttCommObjItem **)soap_save_block(soap, soap_blist_CommObjItem1, NULL, 1);
		else
		{	a->ns1__ArrayOfUhttCommObjItem::CommObjItem = NULL;
			if (soap_blist_CommObjItem1)
				soap_end_block(soap, soap_blist_CommObjItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfUhttCommObjItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem, 0, sizeof(ns1__ArrayOfUhttCommObjItem), 0, soap_copy_ns1__ArrayOfUhttCommObjItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfUhttCommObjItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfUhttCommObjItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfUhttCommObjItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfUhttCommObjItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttCommObjItem * SOAP_FMAC4 soap_get_ns1__ArrayOfUhttCommObjItem(struct soap *soap, ns1__ArrayOfUhttCommObjItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUhttCommObjItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfUhttCommObjItem * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfUhttCommObjItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfUhttCommObjItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfUhttCommObjItem);
		if (size)
			*size = sizeof(ns1__ArrayOfUhttCommObjItem);
		((ns1__ArrayOfUhttCommObjItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfUhttCommObjItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfUhttCommObjItem);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfUhttCommObjItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfUhttCommObjItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfUhttCommObjItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfUhttCommObjItem %p -> %p\n", q, p));
	*(ns1__ArrayOfUhttCommObjItem*)p = *(ns1__ArrayOfUhttCommObjItem*)q;
}

void ns1__UhttObjSelectCriteria::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__UhttObjSelectCriteria::ObjName);
	soap_default_string(soap, &this->ns1__UhttObjSelectCriteria::ByCriteria);
	/* transient soap skipped */
}

void ns1__UhttObjSelectCriteria::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__UhttObjSelectCriteria::ObjName);
	soap_serialize_string(soap, &this->ns1__UhttObjSelectCriteria::ByCriteria);
	/* transient soap skipped */
}

int ns1__UhttObjSelectCriteria::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UhttObjSelectCriteria(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UhttObjSelectCriteria(struct soap *soap, const char *tag, int id, const ns1__UhttObjSelectCriteria *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UhttObjSelectCriteria), type))
		return soap->error;
	if (a->ns1__UhttObjSelectCriteria::ObjName)
	{	if (soap_out_string(soap, "ObjName", -1, &a->ns1__UhttObjSelectCriteria::ObjName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ObjName"))
		return soap->error;
	if (a->ns1__UhttObjSelectCriteria::ByCriteria)
	{	if (soap_out_string(soap, "ByCriteria", -1, &a->ns1__UhttObjSelectCriteria::ByCriteria, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ByCriteria"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UhttObjSelectCriteria::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UhttObjSelectCriteria(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UhttObjSelectCriteria * SOAP_FMAC4 soap_in_ns1__UhttObjSelectCriteria(struct soap *soap, const char *tag, ns1__UhttObjSelectCriteria *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UhttObjSelectCriteria *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UhttObjSelectCriteria, sizeof(ns1__UhttObjSelectCriteria), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UhttObjSelectCriteria)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UhttObjSelectCriteria *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ObjName1 = 1;
	size_t soap_flag_ByCriteria1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ObjName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ObjName", &(a->ns1__UhttObjSelectCriteria::ObjName), "xsd:string"))
				{	soap_flag_ObjName1--;
					continue;
				}
			if (soap_flag_ByCriteria1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ByCriteria", &(a->ns1__UhttObjSelectCriteria::ByCriteria), "xsd:string"))
				{	soap_flag_ByCriteria1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UhttObjSelectCriteria *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UhttObjSelectCriteria, 0, sizeof(ns1__UhttObjSelectCriteria), 0, soap_copy_ns1__UhttObjSelectCriteria);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ObjName1 > 0 || soap_flag_ByCriteria1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__UhttObjSelectCriteria::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UhttObjSelectCriteria);
	if (this->soap_out(soap, tag?tag:"ns1:UhttObjSelectCriteria", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UhttObjSelectCriteria::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UhttObjSelectCriteria(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UhttObjSelectCriteria * SOAP_FMAC4 soap_get_ns1__UhttObjSelectCriteria(struct soap *soap, ns1__UhttObjSelectCriteria *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UhttObjSelectCriteria(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UhttObjSelectCriteria * SOAP_FMAC2 soap_instantiate_ns1__UhttObjSelectCriteria(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UhttObjSelectCriteria(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UhttObjSelectCriteria, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttObjSelectCriteria);
		if (size)
			*size = sizeof(ns1__UhttObjSelectCriteria);
		((ns1__UhttObjSelectCriteria*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__UhttObjSelectCriteria[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UhttObjSelectCriteria);
		for (int i = 0; i < n; i++)
			((ns1__UhttObjSelectCriteria*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UhttObjSelectCriteria*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UhttObjSelectCriteria(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UhttObjSelectCriteria %p -> %p\n", q, p));
	*(ns1__UhttObjSelectCriteria*)p = *(ns1__UhttObjSelectCriteria*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Logout(struct soap *soap, struct ns1__Logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Logout(struct soap *soap, const struct ns1__Logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Logout(struct soap *soap, const char *tag, int id, const struct ns1__Logout *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Logout), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Logout * SOAP_FMAC4 soap_in_ns1__Logout(struct soap *soap, const char *tag, struct ns1__Logout *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Logout, sizeof(struct ns1__Logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Logout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Logout, 0, sizeof(struct ns1__Logout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Logout(struct soap *soap, const struct ns1__Logout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Logout);
	if (soap_out_ns1__Logout(soap, tag?tag:"ns1:Logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Logout * SOAP_FMAC4 soap_get_ns1__Logout(struct soap *soap, struct ns1__Logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Logout * SOAP_FMAC2 soap_instantiate_ns1__Logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Logout);
		if (size)
			*size = sizeof(struct ns1__Logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Logout);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Logout %p -> %p\n", q, p));
	*(struct ns1__Logout*)p = *(struct ns1__Logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LogoutResponse(struct soap *soap, struct ns1__LogoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__LogoutResponse(struct soap *soap, const struct ns1__LogoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttOutStatus(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LogoutResponse(struct soap *soap, const char *tag, int id, const struct ns1__LogoutResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LogoutResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttOutStatus(soap, "Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__LogoutResponse * SOAP_FMAC4 soap_in_ns1__LogoutResponse(struct soap *soap, const char *tag, struct ns1__LogoutResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__LogoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LogoutResponse, sizeof(struct ns1__LogoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__LogoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttOutStatus(soap, "Status", &a->Status, "ns1:UhttOutStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__LogoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LogoutResponse, 0, sizeof(struct ns1__LogoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LogoutResponse(struct soap *soap, const struct ns1__LogoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LogoutResponse);
	if (soap_out_ns1__LogoutResponse(soap, tag?tag:"ns1:LogoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__LogoutResponse * SOAP_FMAC4 soap_get_ns1__LogoutResponse(struct soap *soap, struct ns1__LogoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LogoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__LogoutResponse * SOAP_FMAC2 soap_instantiate_ns1__LogoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LogoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LogoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__LogoutResponse);
		if (size)
			*size = sizeof(struct ns1__LogoutResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__LogoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__LogoutResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__LogoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LogoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__LogoutResponse %p -> %p\n", q, p));
	*(struct ns1__LogoutResponse*)p = *(struct ns1__LogoutResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Login(struct soap *soap, struct ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Login);
	soap_default_string(soap, &a->Password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Login(struct soap *soap, const struct ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Login);
	soap_serialize_string(soap, &a->Password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Login(struct soap *soap, const char *tag, int id, const struct ns1__Login *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Login), type))
		return soap->error;
	if (soap_out_string(soap, "Login", -1, &a->Login, ""))
		return soap->error;
	if (soap_out_string(soap, "Password", -1, &a->Password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Login * SOAP_FMAC4 soap_in_ns1__Login(struct soap *soap, const char *tag, struct ns1__Login *a, const char *type)
{
	size_t soap_flag_Login = 1;
	size_t soap_flag_Password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Login, sizeof(struct ns1__Login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Login", &a->Login, "xsd:string"))
				{	soap_flag_Login--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Login, 0, sizeof(struct ns1__Login), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Login(struct soap *soap, const struct ns1__Login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Login);
	if (soap_out_ns1__Login(soap, tag?tag:"ns1:Login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Login * SOAP_FMAC4 soap_get_ns1__Login(struct soap *soap, struct ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Login * SOAP_FMAC2 soap_instantiate_ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Login);
		if (size)
			*size = sizeof(struct ns1__Login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Login %p -> %p\n", q, p));
	*(struct ns1__Login*)p = *(struct ns1__Login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LoginResponse(struct soap *soap, struct ns1__LoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__LoginResponse(struct soap *soap, const struct ns1__LoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttOutStatus(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoginResponse(struct soap *soap, const char *tag, int id, const struct ns1__LoginResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoginResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttOutStatus(soap, "Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__LoginResponse * SOAP_FMAC4 soap_in_ns1__LoginResponse(struct soap *soap, const char *tag, struct ns1__LoginResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoginResponse, sizeof(struct ns1__LoginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__LoginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttOutStatus(soap, "Status", &a->Status, "ns1:UhttOutStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoginResponse, 0, sizeof(struct ns1__LoginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LoginResponse(struct soap *soap, const struct ns1__LoginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LoginResponse);
	if (soap_out_ns1__LoginResponse(soap, tag?tag:"ns1:LoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__LoginResponse * SOAP_FMAC4 soap_get_ns1__LoginResponse(struct soap *soap, struct ns1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__LoginResponse * SOAP_FMAC2 soap_instantiate_ns1__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LoginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__LoginResponse);
		if (size)
			*size = sizeof(struct ns1__LoginResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__LoginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__LoginResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__LoginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__LoginResponse %p -> %p\n", q, p));
	*(struct ns1__LoginResponse*)p = *(struct ns1__LoginResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSpoiledSeries(struct soap *soap, struct ns1__GetSpoiledSeries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSpoiledSeries(struct soap *soap, const struct ns1__GetSpoiledSeries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSpoiledSeries(struct soap *soap, const char *tag, int id, const struct ns1__GetSpoiledSeries *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSpoiledSeries), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSpoiledSeries * SOAP_FMAC4 soap_in_ns1__GetSpoiledSeries(struct soap *soap, const char *tag, struct ns1__GetSpoiledSeries *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSpoiledSeries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSpoiledSeries, sizeof(struct ns1__GetSpoiledSeries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetSpoiledSeries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetSpoiledSeries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSpoiledSeries, 0, sizeof(struct ns1__GetSpoiledSeries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSpoiledSeries(struct soap *soap, const struct ns1__GetSpoiledSeries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetSpoiledSeries);
	if (soap_out_ns1__GetSpoiledSeries(soap, tag?tag:"ns1:GetSpoiledSeries", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSpoiledSeries * SOAP_FMAC4 soap_get_ns1__GetSpoiledSeries(struct soap *soap, struct ns1__GetSpoiledSeries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSpoiledSeries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetSpoiledSeries * SOAP_FMAC2 soap_instantiate_ns1__GetSpoiledSeries(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSpoiledSeries(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetSpoiledSeries, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetSpoiledSeries);
		if (size)
			*size = sizeof(struct ns1__GetSpoiledSeries);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetSpoiledSeries[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetSpoiledSeries);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetSpoiledSeries*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetSpoiledSeries(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetSpoiledSeries %p -> %p\n", q, p));
	*(struct ns1__GetSpoiledSeries*)p = *(struct ns1__GetSpoiledSeries*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSpoiledSeriesResponse(struct soap *soap, struct ns1__GetSpoiledSeriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpoiledSeries = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSpoiledSeriesResponse(struct soap *soap, const struct ns1__GetSpoiledSeriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfUhttSpoiledSerial(soap, &a->SpoiledSeries);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSpoiledSeriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetSpoiledSeriesResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSpoiledSeriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfUhttSpoiledSerial(soap, "SpoiledSeries", -1, &a->SpoiledSeries, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSpoiledSeriesResponse * SOAP_FMAC4 soap_in_ns1__GetSpoiledSeriesResponse(struct soap *soap, const char *tag, struct ns1__GetSpoiledSeriesResponse *a, const char *type)
{
	size_t soap_flag_SpoiledSeries = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSpoiledSeriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSpoiledSeriesResponse, sizeof(struct ns1__GetSpoiledSeriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetSpoiledSeriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SpoiledSeries && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfUhttSpoiledSerial(soap, "SpoiledSeries", &a->SpoiledSeries, "ns1:ArrayOfUhttSpoiledSerial"))
				{	soap_flag_SpoiledSeries--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetSpoiledSeriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSpoiledSeriesResponse, 0, sizeof(struct ns1__GetSpoiledSeriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSpoiledSeriesResponse(struct soap *soap, const struct ns1__GetSpoiledSeriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetSpoiledSeriesResponse);
	if (soap_out_ns1__GetSpoiledSeriesResponse(soap, tag?tag:"ns1:GetSpoiledSeriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSpoiledSeriesResponse * SOAP_FMAC4 soap_get_ns1__GetSpoiledSeriesResponse(struct soap *soap, struct ns1__GetSpoiledSeriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSpoiledSeriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetSpoiledSeriesResponse * SOAP_FMAC2 soap_instantiate_ns1__GetSpoiledSeriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSpoiledSeriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetSpoiledSeriesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetSpoiledSeriesResponse);
		if (size)
			*size = sizeof(struct ns1__GetSpoiledSeriesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetSpoiledSeriesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetSpoiledSeriesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetSpoiledSeriesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetSpoiledSeriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetSpoiledSeriesResponse %p -> %p\n", q, p));
	*(struct ns1__GetSpoiledSeriesResponse*)p = *(struct ns1__GetSpoiledSeriesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGoodsPrice(struct soap *soap, struct ns1__GetGoodsPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Quot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGoodsPrice(struct soap *soap, const struct ns1__GetGoodsPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttQuot(soap, &a->Quot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGoodsPrice(struct soap *soap, const char *tag, int id, const struct ns1__GetGoodsPrice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGoodsPrice), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttQuot(soap, "Quot", -1, &a->Quot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGoodsPrice * SOAP_FMAC4 soap_in_ns1__GetGoodsPrice(struct soap *soap, const char *tag, struct ns1__GetGoodsPrice *a, const char *type)
{
	size_t soap_flag_Quot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGoodsPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGoodsPrice, sizeof(struct ns1__GetGoodsPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGoodsPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Quot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttQuot(soap, "Quot", &a->Quot, "ns1:UhttQuot"))
				{	soap_flag_Quot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGoodsPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGoodsPrice, 0, sizeof(struct ns1__GetGoodsPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGoodsPrice(struct soap *soap, const struct ns1__GetGoodsPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGoodsPrice);
	if (soap_out_ns1__GetGoodsPrice(soap, tag?tag:"ns1:GetGoodsPrice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGoodsPrice * SOAP_FMAC4 soap_get_ns1__GetGoodsPrice(struct soap *soap, struct ns1__GetGoodsPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGoodsPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGoodsPrice * SOAP_FMAC2 soap_instantiate_ns1__GetGoodsPrice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGoodsPrice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGoodsPrice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsPrice);
		if (size)
			*size = sizeof(struct ns1__GetGoodsPrice);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsPrice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGoodsPrice);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGoodsPrice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGoodsPrice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGoodsPrice %p -> %p\n", q, p));
	*(struct ns1__GetGoodsPrice*)p = *(struct ns1__GetGoodsPrice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGoodsPriceResponse(struct soap *soap, struct ns1__GetGoodsPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Quot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGoodsPriceResponse(struct soap *soap, const struct ns1__GetGoodsPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttQuot(soap, &a->Quot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGoodsPriceResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetGoodsPriceResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGoodsPriceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttQuot(soap, "Quot", -1, &a->Quot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGoodsPriceResponse * SOAP_FMAC4 soap_in_ns1__GetGoodsPriceResponse(struct soap *soap, const char *tag, struct ns1__GetGoodsPriceResponse *a, const char *type)
{
	size_t soap_flag_Quot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGoodsPriceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGoodsPriceResponse, sizeof(struct ns1__GetGoodsPriceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGoodsPriceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Quot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttQuot(soap, "Quot", &a->Quot, "ns1:UhttQuot"))
				{	soap_flag_Quot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGoodsPriceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGoodsPriceResponse, 0, sizeof(struct ns1__GetGoodsPriceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGoodsPriceResponse(struct soap *soap, const struct ns1__GetGoodsPriceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGoodsPriceResponse);
	if (soap_out_ns1__GetGoodsPriceResponse(soap, tag?tag:"ns1:GetGoodsPriceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGoodsPriceResponse * SOAP_FMAC4 soap_get_ns1__GetGoodsPriceResponse(struct soap *soap, struct ns1__GetGoodsPriceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGoodsPriceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGoodsPriceResponse * SOAP_FMAC2 soap_instantiate_ns1__GetGoodsPriceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGoodsPriceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGoodsPriceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsPriceResponse);
		if (size)
			*size = sizeof(struct ns1__GetGoodsPriceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsPriceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGoodsPriceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGoodsPriceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGoodsPriceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGoodsPriceResponse %p -> %p\n", q, p));
	*(struct ns1__GetGoodsPriceResponse*)p = *(struct ns1__GetGoodsPriceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGoodsPrice(struct soap *soap, struct ns1__SetGoodsPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Quot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGoodsPrice(struct soap *soap, const struct ns1__SetGoodsPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttQuot(soap, &a->Quot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGoodsPrice(struct soap *soap, const char *tag, int id, const struct ns1__SetGoodsPrice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGoodsPrice), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttQuot(soap, "Quot", -1, &a->Quot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGoodsPrice * SOAP_FMAC4 soap_in_ns1__SetGoodsPrice(struct soap *soap, const char *tag, struct ns1__SetGoodsPrice *a, const char *type)
{
	size_t soap_flag_Quot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGoodsPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGoodsPrice, sizeof(struct ns1__SetGoodsPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGoodsPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Quot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttQuot(soap, "Quot", &a->Quot, "ns1:UhttQuot"))
				{	soap_flag_Quot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGoodsPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGoodsPrice, 0, sizeof(struct ns1__SetGoodsPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGoodsPrice(struct soap *soap, const struct ns1__SetGoodsPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGoodsPrice);
	if (soap_out_ns1__SetGoodsPrice(soap, tag?tag:"ns1:SetGoodsPrice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGoodsPrice * SOAP_FMAC4 soap_get_ns1__SetGoodsPrice(struct soap *soap, struct ns1__SetGoodsPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGoodsPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGoodsPrice * SOAP_FMAC2 soap_instantiate_ns1__SetGoodsPrice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGoodsPrice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGoodsPrice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsPrice);
		if (size)
			*size = sizeof(struct ns1__SetGoodsPrice);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsPrice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGoodsPrice);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGoodsPrice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGoodsPrice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGoodsPrice %p -> %p\n", q, p));
	*(struct ns1__SetGoodsPrice*)p = *(struct ns1__SetGoodsPrice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGoodsPriceResponse(struct soap *soap, struct ns1__SetGoodsPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGoodsPriceResponse(struct soap *soap, const struct ns1__SetGoodsPriceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttOutStatus(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGoodsPriceResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetGoodsPriceResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGoodsPriceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttOutStatus(soap, "Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGoodsPriceResponse * SOAP_FMAC4 soap_in_ns1__SetGoodsPriceResponse(struct soap *soap, const char *tag, struct ns1__SetGoodsPriceResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGoodsPriceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGoodsPriceResponse, sizeof(struct ns1__SetGoodsPriceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGoodsPriceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttOutStatus(soap, "Status", &a->Status, "ns1:UhttOutStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGoodsPriceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGoodsPriceResponse, 0, sizeof(struct ns1__SetGoodsPriceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGoodsPriceResponse(struct soap *soap, const struct ns1__SetGoodsPriceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGoodsPriceResponse);
	if (soap_out_ns1__SetGoodsPriceResponse(soap, tag?tag:"ns1:SetGoodsPriceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGoodsPriceResponse * SOAP_FMAC4 soap_get_ns1__SetGoodsPriceResponse(struct soap *soap, struct ns1__SetGoodsPriceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGoodsPriceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGoodsPriceResponse * SOAP_FMAC2 soap_instantiate_ns1__SetGoodsPriceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGoodsPriceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGoodsPriceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsPriceResponse);
		if (size)
			*size = sizeof(struct ns1__SetGoodsPriceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsPriceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGoodsPriceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGoodsPriceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGoodsPriceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGoodsPriceResponse %p -> %p\n", q, p));
	*(struct ns1__SetGoodsPriceResponse*)p = *(struct ns1__SetGoodsPriceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGoodsCode(struct soap *soap, struct ns1__GetGoodsCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ArCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGoodsCode(struct soap *soap, const struct ns1__GetGoodsCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttArCode(soap, &a->ArCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGoodsCode(struct soap *soap, const char *tag, int id, const struct ns1__GetGoodsCode *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGoodsCode), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttArCode(soap, "ArCode", -1, &a->ArCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGoodsCode * SOAP_FMAC4 soap_in_ns1__GetGoodsCode(struct soap *soap, const char *tag, struct ns1__GetGoodsCode *a, const char *type)
{
	size_t soap_flag_ArCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGoodsCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGoodsCode, sizeof(struct ns1__GetGoodsCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGoodsCode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttArCode(soap, "ArCode", &a->ArCode, "ns1:UhttArCode"))
				{	soap_flag_ArCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGoodsCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGoodsCode, 0, sizeof(struct ns1__GetGoodsCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGoodsCode(struct soap *soap, const struct ns1__GetGoodsCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGoodsCode);
	if (soap_out_ns1__GetGoodsCode(soap, tag?tag:"ns1:GetGoodsCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGoodsCode * SOAP_FMAC4 soap_get_ns1__GetGoodsCode(struct soap *soap, struct ns1__GetGoodsCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGoodsCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGoodsCode * SOAP_FMAC2 soap_instantiate_ns1__GetGoodsCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGoodsCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGoodsCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsCode);
		if (size)
			*size = sizeof(struct ns1__GetGoodsCode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsCode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGoodsCode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGoodsCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGoodsCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGoodsCode %p -> %p\n", q, p));
	*(struct ns1__GetGoodsCode*)p = *(struct ns1__GetGoodsCode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGoodsCodeResponse(struct soap *soap, struct ns1__GetGoodsCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ArCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGoodsCodeResponse(struct soap *soap, const struct ns1__GetGoodsCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttArCode(soap, &a->ArCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGoodsCodeResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetGoodsCodeResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGoodsCodeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttArCode(soap, "ArCode", -1, &a->ArCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGoodsCodeResponse * SOAP_FMAC4 soap_in_ns1__GetGoodsCodeResponse(struct soap *soap, const char *tag, struct ns1__GetGoodsCodeResponse *a, const char *type)
{
	size_t soap_flag_ArCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGoodsCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGoodsCodeResponse, sizeof(struct ns1__GetGoodsCodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGoodsCodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttArCode(soap, "ArCode", &a->ArCode, "ns1:UhttArCode"))
				{	soap_flag_ArCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGoodsCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGoodsCodeResponse, 0, sizeof(struct ns1__GetGoodsCodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGoodsCodeResponse(struct soap *soap, const struct ns1__GetGoodsCodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGoodsCodeResponse);
	if (soap_out_ns1__GetGoodsCodeResponse(soap, tag?tag:"ns1:GetGoodsCodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGoodsCodeResponse * SOAP_FMAC4 soap_get_ns1__GetGoodsCodeResponse(struct soap *soap, struct ns1__GetGoodsCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGoodsCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGoodsCodeResponse * SOAP_FMAC2 soap_instantiate_ns1__GetGoodsCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGoodsCodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGoodsCodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsCodeResponse);
		if (size)
			*size = sizeof(struct ns1__GetGoodsCodeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGoodsCodeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGoodsCodeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGoodsCodeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGoodsCodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGoodsCodeResponse %p -> %p\n", q, p));
	*(struct ns1__GetGoodsCodeResponse*)p = *(struct ns1__GetGoodsCodeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGoodsCode(struct soap *soap, struct ns1__SetGoodsCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ArCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGoodsCode(struct soap *soap, const struct ns1__SetGoodsCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttArCode(soap, &a->ArCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGoodsCode(struct soap *soap, const char *tag, int id, const struct ns1__SetGoodsCode *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGoodsCode), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttArCode(soap, "ArCode", -1, &a->ArCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGoodsCode * SOAP_FMAC4 soap_in_ns1__SetGoodsCode(struct soap *soap, const char *tag, struct ns1__SetGoodsCode *a, const char *type)
{
	size_t soap_flag_ArCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGoodsCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGoodsCode, sizeof(struct ns1__SetGoodsCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGoodsCode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ArCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttArCode(soap, "ArCode", &a->ArCode, "ns1:UhttArCode"))
				{	soap_flag_ArCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGoodsCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGoodsCode, 0, sizeof(struct ns1__SetGoodsCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGoodsCode(struct soap *soap, const struct ns1__SetGoodsCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGoodsCode);
	if (soap_out_ns1__SetGoodsCode(soap, tag?tag:"ns1:SetGoodsCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGoodsCode * SOAP_FMAC4 soap_get_ns1__SetGoodsCode(struct soap *soap, struct ns1__SetGoodsCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGoodsCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGoodsCode * SOAP_FMAC2 soap_instantiate_ns1__SetGoodsCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGoodsCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGoodsCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsCode);
		if (size)
			*size = sizeof(struct ns1__SetGoodsCode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsCode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGoodsCode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGoodsCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGoodsCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGoodsCode %p -> %p\n", q, p));
	*(struct ns1__SetGoodsCode*)p = *(struct ns1__SetGoodsCode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGoodsCodeResponse(struct soap *soap, struct ns1__SetGoodsCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGoodsCodeResponse(struct soap *soap, const struct ns1__SetGoodsCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttOutStatus(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGoodsCodeResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetGoodsCodeResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGoodsCodeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttOutStatus(soap, "Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGoodsCodeResponse * SOAP_FMAC4 soap_in_ns1__SetGoodsCodeResponse(struct soap *soap, const char *tag, struct ns1__SetGoodsCodeResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGoodsCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGoodsCodeResponse, sizeof(struct ns1__SetGoodsCodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGoodsCodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttOutStatus(soap, "Status", &a->Status, "ns1:UhttOutStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGoodsCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGoodsCodeResponse, 0, sizeof(struct ns1__SetGoodsCodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGoodsCodeResponse(struct soap *soap, const struct ns1__SetGoodsCodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGoodsCodeResponse);
	if (soap_out_ns1__SetGoodsCodeResponse(soap, tag?tag:"ns1:SetGoodsCodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGoodsCodeResponse * SOAP_FMAC4 soap_get_ns1__SetGoodsCodeResponse(struct soap *soap, struct ns1__SetGoodsCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGoodsCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGoodsCodeResponse * SOAP_FMAC2 soap_instantiate_ns1__SetGoodsCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGoodsCodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGoodsCodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsCodeResponse);
		if (size)
			*size = sizeof(struct ns1__SetGoodsCodeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGoodsCodeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGoodsCodeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGoodsCodeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGoodsCodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGoodsCodeResponse %p -> %p\n", q, p));
	*(struct ns1__SetGoodsCodeResponse*)p = *(struct ns1__SetGoodsCodeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORECalendar(struct soap *soap, struct ns1__Get_USCORECalendar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORECalendar(struct soap *soap, const struct ns1__Get_USCORECalendar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORECalendar(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORECalendar *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORECalendar), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORECalendar * SOAP_FMAC4 soap_in_ns1__Get_USCORECalendar(struct soap *soap, const char *tag, struct ns1__Get_USCORECalendar *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORECalendar *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORECalendar, sizeof(struct ns1__Get_USCORECalendar), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORECalendar(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORECalendar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORECalendar, 0, sizeof(struct ns1__Get_USCORECalendar), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORECalendar(struct soap *soap, const struct ns1__Get_USCORECalendar *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORECalendar);
	if (soap_out_ns1__Get_USCORECalendar(soap, tag?tag:"ns1:Get_Calendar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORECalendar * SOAP_FMAC4 soap_get_ns1__Get_USCORECalendar(struct soap *soap, struct ns1__Get_USCORECalendar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORECalendar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORECalendar * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORECalendar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORECalendar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORECalendar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECalendar);
		if (size)
			*size = sizeof(struct ns1__Get_USCORECalendar);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECalendar[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORECalendar);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORECalendar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORECalendar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORECalendar %p -> %p\n", q, p));
	*(struct ns1__Get_USCORECalendar*)p = *(struct ns1__Get_USCORECalendar*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORECalendarResponse(struct soap *soap, struct ns1__Get_USCORECalendarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Calendar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORECalendarResponse(struct soap *soap, const struct ns1__Get_USCORECalendarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttCalendar(soap, &a->Calendar);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORECalendarResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORECalendarResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORECalendarResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttCalendar(soap, "Calendar", -1, &a->Calendar, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORECalendarResponse * SOAP_FMAC4 soap_in_ns1__Get_USCORECalendarResponse(struct soap *soap, const char *tag, struct ns1__Get_USCORECalendarResponse *a, const char *type)
{
	size_t soap_flag_Calendar = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORECalendarResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORECalendarResponse, sizeof(struct ns1__Get_USCORECalendarResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORECalendarResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Calendar && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttCalendar(soap, "Calendar", &a->Calendar, "ns1:UhttCalendar"))
				{	soap_flag_Calendar--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORECalendarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORECalendarResponse, 0, sizeof(struct ns1__Get_USCORECalendarResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORECalendarResponse(struct soap *soap, const struct ns1__Get_USCORECalendarResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORECalendarResponse);
	if (soap_out_ns1__Get_USCORECalendarResponse(soap, tag?tag:"ns1:Get_CalendarResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORECalendarResponse * SOAP_FMAC4 soap_get_ns1__Get_USCORECalendarResponse(struct soap *soap, struct ns1__Get_USCORECalendarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORECalendarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORECalendarResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORECalendarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORECalendarResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORECalendarResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECalendarResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCORECalendarResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECalendarResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORECalendarResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORECalendarResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORECalendarResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORECalendarResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCORECalendarResponse*)p = *(struct ns1__Get_USCORECalendarResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREGoods(struct soap *soap, struct ns1__Get_USCOREGoods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREGoods(struct soap *soap, const struct ns1__Get_USCOREGoods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREGoods(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREGoods *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREGoods), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoods * SOAP_FMAC4 soap_in_ns1__Get_USCOREGoods(struct soap *soap, const char *tag, struct ns1__Get_USCOREGoods *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREGoods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREGoods, sizeof(struct ns1__Get_USCOREGoods), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREGoods(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREGoods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREGoods, 0, sizeof(struct ns1__Get_USCOREGoods), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREGoods(struct soap *soap, const struct ns1__Get_USCOREGoods *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREGoods);
	if (soap_out_ns1__Get_USCOREGoods(soap, tag?tag:"ns1:Get_Goods", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoods * SOAP_FMAC4 soap_get_ns1__Get_USCOREGoods(struct soap *soap, struct ns1__Get_USCOREGoods *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREGoods * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREGoods(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREGoods(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREGoods, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoods);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREGoods);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoods[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREGoods);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREGoods*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREGoods(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREGoods %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREGoods*)p = *(struct ns1__Get_USCOREGoods*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREGoodsResponse(struct soap *soap, struct ns1__Get_USCOREGoodsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Goods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREGoodsResponse(struct soap *soap, const struct ns1__Get_USCOREGoodsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttGoods(soap, &a->Goods);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREGoodsResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREGoodsResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREGoodsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttGoods(soap, "Goods", -1, &a->Goods, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREGoodsResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREGoodsResponse *a, const char *type)
{
	size_t soap_flag_Goods = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREGoodsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREGoodsResponse, sizeof(struct ns1__Get_USCOREGoodsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREGoodsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Goods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttGoods(soap, "Goods", &a->Goods, "ns1:UhttGoods"))
				{	soap_flag_Goods--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREGoodsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREGoodsResponse, 0, sizeof(struct ns1__Get_USCOREGoodsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREGoodsResponse(struct soap *soap, const struct ns1__Get_USCOREGoodsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREGoodsResponse);
	if (soap_out_ns1__Get_USCOREGoodsResponse(soap, tag?tag:"ns1:Get_GoodsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREGoodsResponse(struct soap *soap, struct ns1__Get_USCOREGoodsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREGoodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREGoodsResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREGoodsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREGoodsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREGoodsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREGoodsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREGoodsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREGoodsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREGoodsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREGoodsResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREGoodsResponse*)p = *(struct ns1__Get_USCOREGoodsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREBrand(struct soap *soap, struct ns1__Get_USCOREBrand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREBrand(struct soap *soap, const struct ns1__Get_USCOREBrand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREBrand(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREBrand *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREBrand), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREBrand * SOAP_FMAC4 soap_in_ns1__Get_USCOREBrand(struct soap *soap, const char *tag, struct ns1__Get_USCOREBrand *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREBrand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREBrand, sizeof(struct ns1__Get_USCOREBrand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREBrand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREBrand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREBrand, 0, sizeof(struct ns1__Get_USCOREBrand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREBrand(struct soap *soap, const struct ns1__Get_USCOREBrand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREBrand);
	if (soap_out_ns1__Get_USCOREBrand(soap, tag?tag:"ns1:Get_Brand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREBrand * SOAP_FMAC4 soap_get_ns1__Get_USCOREBrand(struct soap *soap, struct ns1__Get_USCOREBrand *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREBrand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREBrand * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREBrand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREBrand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREBrand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREBrand);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREBrand);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREBrand[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREBrand);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREBrand*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREBrand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREBrand %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREBrand*)p = *(struct ns1__Get_USCOREBrand*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREBrandResponse(struct soap *soap, struct ns1__Get_USCOREBrandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Brand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREBrandResponse(struct soap *soap, const struct ns1__Get_USCOREBrandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttBrand(soap, &a->Brand);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREBrandResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREBrandResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREBrandResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttBrand(soap, "Brand", -1, &a->Brand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREBrandResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREBrandResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREBrandResponse *a, const char *type)
{
	size_t soap_flag_Brand = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREBrandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREBrandResponse, sizeof(struct ns1__Get_USCOREBrandResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREBrandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Brand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttBrand(soap, "Brand", &a->Brand, "ns1:UhttBrand"))
				{	soap_flag_Brand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREBrandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREBrandResponse, 0, sizeof(struct ns1__Get_USCOREBrandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREBrandResponse(struct soap *soap, const struct ns1__Get_USCOREBrandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREBrandResponse);
	if (soap_out_ns1__Get_USCOREBrandResponse(soap, tag?tag:"ns1:Get_BrandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREBrandResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREBrandResponse(struct soap *soap, struct ns1__Get_USCOREBrandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREBrandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREBrandResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREBrandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREBrandResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREBrandResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREBrandResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREBrandResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREBrandResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREBrandResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREBrandResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREBrandResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREBrandResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREBrandResponse*)p = *(struct ns1__Get_USCOREBrandResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREGoodsGroup(struct soap *soap, struct ns1__Get_USCOREGoodsGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREGoodsGroup(struct soap *soap, const struct ns1__Get_USCOREGoodsGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREGoodsGroup(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREGoodsGroup *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREGoodsGroup), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsGroup * SOAP_FMAC4 soap_in_ns1__Get_USCOREGoodsGroup(struct soap *soap, const char *tag, struct ns1__Get_USCOREGoodsGroup *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREGoodsGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREGoodsGroup, sizeof(struct ns1__Get_USCOREGoodsGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREGoodsGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREGoodsGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREGoodsGroup, 0, sizeof(struct ns1__Get_USCOREGoodsGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREGoodsGroup(struct soap *soap, const struct ns1__Get_USCOREGoodsGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREGoodsGroup);
	if (soap_out_ns1__Get_USCOREGoodsGroup(soap, tag?tag:"ns1:Get_GoodsGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsGroup * SOAP_FMAC4 soap_get_ns1__Get_USCOREGoodsGroup(struct soap *soap, struct ns1__Get_USCOREGoodsGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREGoodsGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREGoodsGroup * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREGoodsGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREGoodsGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREGoodsGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsGroup);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREGoodsGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsGroup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREGoodsGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREGoodsGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREGoodsGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREGoodsGroup %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREGoodsGroup*)p = *(struct ns1__Get_USCOREGoodsGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, struct ns1__Get_USCOREGoodsGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GoodsGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, const struct ns1__Get_USCOREGoodsGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttGoodsGroup(soap, &a->GoodsGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREGoodsGroupResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttGoodsGroup(soap, "GoodsGroup", -1, &a->GoodsGroup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsGroupResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREGoodsGroupResponse *a, const char *type)
{
	size_t soap_flag_GoodsGroup = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREGoodsGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse, sizeof(struct ns1__Get_USCOREGoodsGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREGoodsGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GoodsGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttGoodsGroup(soap, "GoodsGroup", &a->GoodsGroup, "ns1:UhttGoodsGroup"))
				{	soap_flag_GoodsGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREGoodsGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse, 0, sizeof(struct ns1__Get_USCOREGoodsGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, const struct ns1__Get_USCOREGoodsGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse);
	if (soap_out_ns1__Get_USCOREGoodsGroupResponse(soap, tag?tag:"ns1:Get_GoodsGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREGoodsGroupResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, struct ns1__Get_USCOREGoodsGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREGoodsGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREGoodsGroupResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREGoodsGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREGoodsGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsGroupResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREGoodsGroupResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREGoodsGroupResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREGoodsGroupResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREGoodsGroupResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREGoodsGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREGoodsGroupResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREGoodsGroupResponse*)p = *(struct ns1__Get_USCOREGoodsGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPerson(struct soap *soap, struct ns1__Get_USCOREPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPerson(struct soap *soap, const struct ns1__Get_USCOREPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPerson(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPerson *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPerson), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPerson * SOAP_FMAC4 soap_in_ns1__Get_USCOREPerson(struct soap *soap, const char *tag, struct ns1__Get_USCOREPerson *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPerson, sizeof(struct ns1__Get_USCOREPerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPerson, 0, sizeof(struct ns1__Get_USCOREPerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPerson(struct soap *soap, const struct ns1__Get_USCOREPerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPerson);
	if (soap_out_ns1__Get_USCOREPerson(soap, tag?tag:"ns1:Get_Person", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPerson * SOAP_FMAC4 soap_get_ns1__Get_USCOREPerson(struct soap *soap, struct ns1__Get_USCOREPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPerson * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPerson);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPerson);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPerson[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPerson);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPerson*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPerson %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPerson*)p = *(struct ns1__Get_USCOREPerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPersonResponse(struct soap *soap, struct ns1__Get_USCOREPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Person = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPersonResponse(struct soap *soap, const struct ns1__Get_USCOREPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttPerson(soap, &a->Person);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPersonResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPersonResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPersonResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttPerson(soap, "Person", -1, &a->Person, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREPersonResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREPersonResponse *a, const char *type)
{
	size_t soap_flag_Person = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPersonResponse, sizeof(struct ns1__Get_USCOREPersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Person && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttPerson(soap, "Person", &a->Person, "ns1:UhttPerson"))
				{	soap_flag_Person--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPersonResponse, 0, sizeof(struct ns1__Get_USCOREPersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPersonResponse(struct soap *soap, const struct ns1__Get_USCOREPersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPersonResponse);
	if (soap_out_ns1__Get_USCOREPersonResponse(soap, tag?tag:"ns1:Get_PersonResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREPersonResponse(struct soap *soap, struct ns1__Get_USCOREPersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPersonResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPersonResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPersonResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPersonResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPersonResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPersonResponse*)p = *(struct ns1__Get_USCOREPersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORERegisterType(struct soap *soap, struct ns1__Get_USCORERegisterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORERegisterType(struct soap *soap, const struct ns1__Get_USCORERegisterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORERegisterType(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORERegisterType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORERegisterType), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORERegisterType * SOAP_FMAC4 soap_in_ns1__Get_USCORERegisterType(struct soap *soap, const char *tag, struct ns1__Get_USCORERegisterType *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORERegisterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORERegisterType, sizeof(struct ns1__Get_USCORERegisterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORERegisterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORERegisterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORERegisterType, 0, sizeof(struct ns1__Get_USCORERegisterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORERegisterType(struct soap *soap, const struct ns1__Get_USCORERegisterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORERegisterType);
	if (soap_out_ns1__Get_USCORERegisterType(soap, tag?tag:"ns1:Get_RegisterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORERegisterType * SOAP_FMAC4 soap_get_ns1__Get_USCORERegisterType(struct soap *soap, struct ns1__Get_USCORERegisterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORERegisterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORERegisterType * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORERegisterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORERegisterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORERegisterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORERegisterType);
		if (size)
			*size = sizeof(struct ns1__Get_USCORERegisterType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORERegisterType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORERegisterType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORERegisterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORERegisterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORERegisterType %p -> %p\n", q, p));
	*(struct ns1__Get_USCORERegisterType*)p = *(struct ns1__Get_USCORERegisterType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, struct ns1__Get_USCORERegisterTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PersonRegisterType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, const struct ns1__Get_USCORERegisterTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttPersonRegisterType(soap, &a->PersonRegisterType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORERegisterTypeResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttPersonRegisterType(soap, "PersonRegisterType", -1, &a->PersonRegisterType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORERegisterTypeResponse * SOAP_FMAC4 soap_in_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, const char *tag, struct ns1__Get_USCORERegisterTypeResponse *a, const char *type)
{
	size_t soap_flag_PersonRegisterType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORERegisterTypeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse, sizeof(struct ns1__Get_USCORERegisterTypeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORERegisterTypeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PersonRegisterType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttPersonRegisterType(soap, "PersonRegisterType", &a->PersonRegisterType, "ns1:UhttPersonRegisterType"))
				{	soap_flag_PersonRegisterType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORERegisterTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse, 0, sizeof(struct ns1__Get_USCORERegisterTypeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, const struct ns1__Get_USCORERegisterTypeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse);
	if (soap_out_ns1__Get_USCORERegisterTypeResponse(soap, tag?tag:"ns1:Get_RegisterTypeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORERegisterTypeResponse * SOAP_FMAC4 soap_get_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, struct ns1__Get_USCORERegisterTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORERegisterTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORERegisterTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORERegisterTypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORERegisterTypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORERegisterTypeResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCORERegisterTypeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORERegisterTypeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORERegisterTypeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORERegisterTypeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORERegisterTypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORERegisterTypeResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCORERegisterTypeResponse*)p = *(struct ns1__Get_USCORERegisterTypeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPersonCategory(struct soap *soap, struct ns1__Get_USCOREPersonCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPersonCategory(struct soap *soap, const struct ns1__Get_USCOREPersonCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPersonCategory(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPersonCategory *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPersonCategory), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonCategory * SOAP_FMAC4 soap_in_ns1__Get_USCOREPersonCategory(struct soap *soap, const char *tag, struct ns1__Get_USCOREPersonCategory *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPersonCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPersonCategory, sizeof(struct ns1__Get_USCOREPersonCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPersonCategory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPersonCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPersonCategory, 0, sizeof(struct ns1__Get_USCOREPersonCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPersonCategory(struct soap *soap, const struct ns1__Get_USCOREPersonCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPersonCategory);
	if (soap_out_ns1__Get_USCOREPersonCategory(soap, tag?tag:"ns1:Get_PersonCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonCategory * SOAP_FMAC4 soap_get_ns1__Get_USCOREPersonCategory(struct soap *soap, struct ns1__Get_USCOREPersonCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPersonCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPersonCategory * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPersonCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPersonCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPersonCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonCategory);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPersonCategory);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonCategory[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPersonCategory);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPersonCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPersonCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPersonCategory %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPersonCategory*)p = *(struct ns1__Get_USCOREPersonCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, struct ns1__Get_USCOREPersonCategoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PersonCategory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, const struct ns1__Get_USCOREPersonCategoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttPersonCategory(soap, &a->PersonCategory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPersonCategoryResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttPersonCategory(soap, "PersonCategory", -1, &a->PersonCategory, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonCategoryResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREPersonCategoryResponse *a, const char *type)
{
	size_t soap_flag_PersonCategory = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPersonCategoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse, sizeof(struct ns1__Get_USCOREPersonCategoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPersonCategoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PersonCategory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttPersonCategory(soap, "PersonCategory", &a->PersonCategory, "ns1:UhttPersonCategory"))
				{	soap_flag_PersonCategory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPersonCategoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse, 0, sizeof(struct ns1__Get_USCOREPersonCategoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, const struct ns1__Get_USCOREPersonCategoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse);
	if (soap_out_ns1__Get_USCOREPersonCategoryResponse(soap, tag?tag:"ns1:Get_PersonCategoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonCategoryResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, struct ns1__Get_USCOREPersonCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPersonCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPersonCategoryResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPersonCategoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPersonCategoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonCategoryResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPersonCategoryResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonCategoryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPersonCategoryResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPersonCategoryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPersonCategoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPersonCategoryResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPersonCategoryResponse*)p = *(struct ns1__Get_USCOREPersonCategoryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPersonKind(struct soap *soap, struct ns1__Get_USCOREPersonKind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPersonKind(struct soap *soap, const struct ns1__Get_USCOREPersonKind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPersonKind(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPersonKind *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPersonKind), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonKind * SOAP_FMAC4 soap_in_ns1__Get_USCOREPersonKind(struct soap *soap, const char *tag, struct ns1__Get_USCOREPersonKind *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPersonKind *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPersonKind, sizeof(struct ns1__Get_USCOREPersonKind), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPersonKind(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPersonKind *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPersonKind, 0, sizeof(struct ns1__Get_USCOREPersonKind), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPersonKind(struct soap *soap, const struct ns1__Get_USCOREPersonKind *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPersonKind);
	if (soap_out_ns1__Get_USCOREPersonKind(soap, tag?tag:"ns1:Get_PersonKind", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonKind * SOAP_FMAC4 soap_get_ns1__Get_USCOREPersonKind(struct soap *soap, struct ns1__Get_USCOREPersonKind *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPersonKind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPersonKind * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPersonKind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPersonKind(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPersonKind, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonKind);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPersonKind);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonKind[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPersonKind);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPersonKind*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPersonKind(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPersonKind %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPersonKind*)p = *(struct ns1__Get_USCOREPersonKind*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREPersonKindResponse(struct soap *soap, struct ns1__Get_USCOREPersonKindResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PersonKind = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREPersonKindResponse(struct soap *soap, const struct ns1__Get_USCOREPersonKindResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttPersonKind(soap, &a->PersonKind);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREPersonKindResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREPersonKindResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREPersonKindResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttPersonKind(soap, "PersonKind", -1, &a->PersonKind, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonKindResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREPersonKindResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREPersonKindResponse *a, const char *type)
{
	size_t soap_flag_PersonKind = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREPersonKindResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREPersonKindResponse, sizeof(struct ns1__Get_USCOREPersonKindResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREPersonKindResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PersonKind && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttPersonKind(soap, "PersonKind", &a->PersonKind, "ns1:UhttPersonKind"))
				{	soap_flag_PersonKind--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREPersonKindResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREPersonKindResponse, 0, sizeof(struct ns1__Get_USCOREPersonKindResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREPersonKindResponse(struct soap *soap, const struct ns1__Get_USCOREPersonKindResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREPersonKindResponse);
	if (soap_out_ns1__Get_USCOREPersonKindResponse(soap, tag?tag:"ns1:Get_PersonKindResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREPersonKindResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREPersonKindResponse(struct soap *soap, struct ns1__Get_USCOREPersonKindResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREPersonKindResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREPersonKindResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREPersonKindResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREPersonKindResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREPersonKindResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonKindResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREPersonKindResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREPersonKindResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREPersonKindResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREPersonKindResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREPersonKindResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREPersonKindResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREPersonKindResponse*)p = *(struct ns1__Get_USCOREPersonKindResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORECurrency(struct soap *soap, struct ns1__Get_USCORECurrency *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORECurrency(struct soap *soap, const struct ns1__Get_USCORECurrency *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORECurrency(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORECurrency *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORECurrency), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORECurrency * SOAP_FMAC4 soap_in_ns1__Get_USCORECurrency(struct soap *soap, const char *tag, struct ns1__Get_USCORECurrency *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORECurrency *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORECurrency, sizeof(struct ns1__Get_USCORECurrency), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORECurrency(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORECurrency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORECurrency, 0, sizeof(struct ns1__Get_USCORECurrency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORECurrency(struct soap *soap, const struct ns1__Get_USCORECurrency *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORECurrency);
	if (soap_out_ns1__Get_USCORECurrency(soap, tag?tag:"ns1:Get_Currency", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORECurrency * SOAP_FMAC4 soap_get_ns1__Get_USCORECurrency(struct soap *soap, struct ns1__Get_USCORECurrency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORECurrency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORECurrency * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORECurrency(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORECurrency(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORECurrency, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECurrency);
		if (size)
			*size = sizeof(struct ns1__Get_USCORECurrency);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECurrency[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORECurrency);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORECurrency*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORECurrency(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORECurrency %p -> %p\n", q, p));
	*(struct ns1__Get_USCORECurrency*)p = *(struct ns1__Get_USCORECurrency*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCORECurrencyResponse(struct soap *soap, struct ns1__Get_USCORECurrencyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Currency = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCORECurrencyResponse(struct soap *soap, const struct ns1__Get_USCORECurrencyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttCurrency(soap, &a->Currency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCORECurrencyResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCORECurrencyResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCORECurrencyResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttCurrency(soap, "Currency", -1, &a->Currency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCORECurrencyResponse * SOAP_FMAC4 soap_in_ns1__Get_USCORECurrencyResponse(struct soap *soap, const char *tag, struct ns1__Get_USCORECurrencyResponse *a, const char *type)
{
	size_t soap_flag_Currency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCORECurrencyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCORECurrencyResponse, sizeof(struct ns1__Get_USCORECurrencyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCORECurrencyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Currency && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttCurrency(soap, "Currency", &a->Currency, "ns1:UhttCurrency"))
				{	soap_flag_Currency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCORECurrencyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCORECurrencyResponse, 0, sizeof(struct ns1__Get_USCORECurrencyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCORECurrencyResponse(struct soap *soap, const struct ns1__Get_USCORECurrencyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCORECurrencyResponse);
	if (soap_out_ns1__Get_USCORECurrencyResponse(soap, tag?tag:"ns1:Get_CurrencyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCORECurrencyResponse * SOAP_FMAC4 soap_get_ns1__Get_USCORECurrencyResponse(struct soap *soap, struct ns1__Get_USCORECurrencyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCORECurrencyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCORECurrencyResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCORECurrencyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCORECurrencyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCORECurrencyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECurrencyResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCORECurrencyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCORECurrencyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCORECurrencyResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCORECurrencyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCORECurrencyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCORECurrencyResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCORECurrencyResponse*)p = *(struct ns1__Get_USCORECurrencyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREWorld(struct soap *soap, struct ns1__Get_USCOREWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREWorld(struct soap *soap, const struct ns1__Get_USCOREWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREWorld(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREWorld *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREWorld), type))
		return soap->error;
	if (soap_out_int(soap, "ID", -1, &a->ID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREWorld * SOAP_FMAC4 soap_in_ns1__Get_USCOREWorld(struct soap *soap, const char *tag, struct ns1__Get_USCOREWorld *a, const char *type)
{
	size_t soap_flag_ID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREWorld *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREWorld, sizeof(struct ns1__Get_USCOREWorld), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREWorld(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ID", &a->ID, "xsd:int"))
				{	soap_flag_ID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREWorld, 0, sizeof(struct ns1__Get_USCOREWorld), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREWorld(struct soap *soap, const struct ns1__Get_USCOREWorld *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREWorld);
	if (soap_out_ns1__Get_USCOREWorld(soap, tag?tag:"ns1:Get_World", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREWorld * SOAP_FMAC4 soap_get_ns1__Get_USCOREWorld(struct soap *soap, struct ns1__Get_USCOREWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREWorld * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREWorld(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREWorld, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREWorld);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREWorld);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREWorld[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREWorld);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREWorld*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREWorld(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREWorld %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREWorld*)p = *(struct ns1__Get_USCOREWorld*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Get_USCOREWorldResponse(struct soap *soap, struct ns1__Get_USCOREWorldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->World = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Get_USCOREWorldResponse(struct soap *soap, const struct ns1__Get_USCOREWorldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttWorld(soap, &a->World);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Get_USCOREWorldResponse(struct soap *soap, const char *tag, int id, const struct ns1__Get_USCOREWorldResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Get_USCOREWorldResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttWorld(soap, "World", -1, &a->World, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Get_USCOREWorldResponse * SOAP_FMAC4 soap_in_ns1__Get_USCOREWorldResponse(struct soap *soap, const char *tag, struct ns1__Get_USCOREWorldResponse *a, const char *type)
{
	size_t soap_flag_World = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Get_USCOREWorldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Get_USCOREWorldResponse, sizeof(struct ns1__Get_USCOREWorldResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Get_USCOREWorldResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_World && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttWorld(soap, "World", &a->World, "ns1:UhttWorld"))
				{	soap_flag_World--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Get_USCOREWorldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Get_USCOREWorldResponse, 0, sizeof(struct ns1__Get_USCOREWorldResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Get_USCOREWorldResponse(struct soap *soap, const struct ns1__Get_USCOREWorldResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Get_USCOREWorldResponse);
	if (soap_out_ns1__Get_USCOREWorldResponse(soap, tag?tag:"ns1:Get_WorldResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Get_USCOREWorldResponse * SOAP_FMAC4 soap_get_ns1__Get_USCOREWorldResponse(struct soap *soap, struct ns1__Get_USCOREWorldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Get_USCOREWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__Get_USCOREWorldResponse * SOAP_FMAC2 soap_instantiate_ns1__Get_USCOREWorldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Get_USCOREWorldResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Get_USCOREWorldResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREWorldResponse);
		if (size)
			*size = sizeof(struct ns1__Get_USCOREWorldResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__Get_USCOREWorldResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__Get_USCOREWorldResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__Get_USCOREWorldResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Get_USCOREWorldResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__Get_USCOREWorldResponse %p -> %p\n", q, p));
	*(struct ns1__Get_USCOREWorldResponse*)p = *(struct ns1__Get_USCOREWorldResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SelectObject(struct soap *soap, struct ns1__SelectObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ObjSelectCriteria = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SelectObject(struct soap *soap, const struct ns1__SelectObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UhttObjSelectCriteria(soap, &a->ObjSelectCriteria);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SelectObject(struct soap *soap, const char *tag, int id, const struct ns1__SelectObject *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SelectObject), type))
		return soap->error;
	if (soap_out_PointerTons1__UhttObjSelectCriteria(soap, "ObjSelectCriteria", -1, &a->ObjSelectCriteria, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SelectObject * SOAP_FMAC4 soap_in_ns1__SelectObject(struct soap *soap, const char *tag, struct ns1__SelectObject *a, const char *type)
{
	size_t soap_flag_ObjSelectCriteria = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SelectObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SelectObject, sizeof(struct ns1__SelectObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SelectObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ObjSelectCriteria && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UhttObjSelectCriteria(soap, "ObjSelectCriteria", &a->ObjSelectCriteria, "ns1:UhttObjSelectCriteria"))
				{	soap_flag_ObjSelectCriteria--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SelectObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SelectObject, 0, sizeof(struct ns1__SelectObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SelectObject(struct soap *soap, const struct ns1__SelectObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SelectObject);
	if (soap_out_ns1__SelectObject(soap, tag?tag:"ns1:SelectObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SelectObject * SOAP_FMAC4 soap_get_ns1__SelectObject(struct soap *soap, struct ns1__SelectObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SelectObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SelectObject * SOAP_FMAC2 soap_instantiate_ns1__SelectObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SelectObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SelectObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SelectObject);
		if (size)
			*size = sizeof(struct ns1__SelectObject);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SelectObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SelectObject);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SelectObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SelectObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SelectObject %p -> %p\n", q, p));
	*(struct ns1__SelectObject*)p = *(struct ns1__SelectObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SelectObjectResponse(struct soap *soap, struct ns1__SelectObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CommObjItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SelectObjectResponse(struct soap *soap, const struct ns1__SelectObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfUhttCommObjItem(soap, &a->CommObjItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SelectObjectResponse(struct soap *soap, const char *tag, int id, const struct ns1__SelectObjectResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SelectObjectResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfUhttCommObjItem(soap, "CommObjItem", -1, &a->CommObjItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SelectObjectResponse * SOAP_FMAC4 soap_in_ns1__SelectObjectResponse(struct soap *soap, const char *tag, struct ns1__SelectObjectResponse *a, const char *type)
{
	size_t soap_flag_CommObjItem = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SelectObjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SelectObjectResponse, sizeof(struct ns1__SelectObjectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SelectObjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommObjItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfUhttCommObjItem(soap, "CommObjItem", &a->CommObjItem, "ns1:ArrayOfUhttCommObjItem"))
				{	soap_flag_CommObjItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SelectObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SelectObjectResponse, 0, sizeof(struct ns1__SelectObjectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SelectObjectResponse(struct soap *soap, const struct ns1__SelectObjectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SelectObjectResponse);
	if (soap_out_ns1__SelectObjectResponse(soap, tag?tag:"ns1:SelectObjectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SelectObjectResponse * SOAP_FMAC4 soap_get_ns1__SelectObjectResponse(struct soap *soap, struct ns1__SelectObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SelectObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SelectObjectResponse * SOAP_FMAC2 soap_instantiate_ns1__SelectObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SelectObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SelectObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SelectObjectResponse);
		if (size)
			*size = sizeof(struct ns1__SelectObjectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SelectObjectResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SelectObjectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SelectObjectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SelectObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SelectObjectResponse %p -> %p\n", q, p));
	*(struct ns1__SelectObjectResponse*)p = *(struct ns1__SelectObjectResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfUhttSpoiledSerial(struct soap *soap, ns1__ArrayOfUhttSpoiledSerial *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfUhttSpoiledSerial(struct soap *soap, const char *tag, int id, ns1__ArrayOfUhttSpoiledSerial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttSpoiledSerial ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfUhttSpoiledSerial(struct soap *soap, const char *tag, ns1__ArrayOfUhttSpoiledSerial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfUhttSpoiledSerial **)soap_malloc(soap, sizeof(ns1__ArrayOfUhttSpoiledSerial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfUhttSpoiledSerial *)soap_instantiate_ns1__ArrayOfUhttSpoiledSerial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfUhttSpoiledSerial ** p = (ns1__ArrayOfUhttSpoiledSerial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfUhttSpoiledSerial, sizeof(ns1__ArrayOfUhttSpoiledSerial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfUhttSpoiledSerial(struct soap *soap, ns1__ArrayOfUhttSpoiledSerial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfUhttSpoiledSerial);
	if (soap_out_PointerTons1__ArrayOfUhttSpoiledSerial(soap, tag?tag:"ns1:ArrayOfUhttSpoiledSerial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfUhttSpoiledSerial ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfUhttSpoiledSerial(struct soap *soap, ns1__ArrayOfUhttSpoiledSerial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfUhttSpoiledSerial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttQuot(struct soap *soap, ns1__UhttQuot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttQuot))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttQuot(struct soap *soap, const char *tag, int id, ns1__UhttQuot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttQuot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttQuot ** SOAP_FMAC4 soap_in_PointerTons1__UhttQuot(struct soap *soap, const char *tag, ns1__UhttQuot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttQuot **)soap_malloc(soap, sizeof(ns1__UhttQuot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttQuot *)soap_instantiate_ns1__UhttQuot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttQuot ** p = (ns1__UhttQuot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttQuot, sizeof(ns1__UhttQuot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttQuot(struct soap *soap, ns1__UhttQuot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttQuot);
	if (soap_out_PointerTons1__UhttQuot(soap, tag?tag:"ns1:UhttQuot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttQuot ** SOAP_FMAC4 soap_get_PointerTons1__UhttQuot(struct soap *soap, ns1__UhttQuot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttQuot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttArCode(struct soap *soap, ns1__UhttArCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttArCode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttArCode(struct soap *soap, const char *tag, int id, ns1__UhttArCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttArCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttArCode ** SOAP_FMAC4 soap_in_PointerTons1__UhttArCode(struct soap *soap, const char *tag, ns1__UhttArCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttArCode **)soap_malloc(soap, sizeof(ns1__UhttArCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttArCode *)soap_instantiate_ns1__UhttArCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttArCode ** p = (ns1__UhttArCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttArCode, sizeof(ns1__UhttArCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttArCode(struct soap *soap, ns1__UhttArCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttArCode);
	if (soap_out_PointerTons1__UhttArCode(soap, tag?tag:"ns1:UhttArCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttArCode ** SOAP_FMAC4 soap_get_PointerTons1__UhttArCode(struct soap *soap, ns1__UhttArCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttArCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttOutStatus(struct soap *soap, ns1__UhttOutStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttOutStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttOutStatus(struct soap *soap, const char *tag, int id, ns1__UhttOutStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttOutStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttOutStatus ** SOAP_FMAC4 soap_in_PointerTons1__UhttOutStatus(struct soap *soap, const char *tag, ns1__UhttOutStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttOutStatus **)soap_malloc(soap, sizeof(ns1__UhttOutStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttOutStatus *)soap_instantiate_ns1__UhttOutStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttOutStatus ** p = (ns1__UhttOutStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttOutStatus, sizeof(ns1__UhttOutStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttOutStatus(struct soap *soap, ns1__UhttOutStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttOutStatus);
	if (soap_out_PointerTons1__UhttOutStatus(soap, tag?tag:"ns1:UhttOutStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttOutStatus ** SOAP_FMAC4 soap_get_PointerTons1__UhttOutStatus(struct soap *soap, ns1__UhttOutStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttOutStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttCalendar(struct soap *soap, ns1__UhttCalendar *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttCalendar))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttCalendar(struct soap *soap, const char *tag, int id, ns1__UhttCalendar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttCalendar);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttCalendar ** SOAP_FMAC4 soap_in_PointerTons1__UhttCalendar(struct soap *soap, const char *tag, ns1__UhttCalendar **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttCalendar **)soap_malloc(soap, sizeof(ns1__UhttCalendar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttCalendar *)soap_instantiate_ns1__UhttCalendar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttCalendar ** p = (ns1__UhttCalendar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttCalendar, sizeof(ns1__UhttCalendar), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttCalendar(struct soap *soap, ns1__UhttCalendar *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttCalendar);
	if (soap_out_PointerTons1__UhttCalendar(soap, tag?tag:"ns1:UhttCalendar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttCalendar ** SOAP_FMAC4 soap_get_PointerTons1__UhttCalendar(struct soap *soap, ns1__UhttCalendar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttCalendar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttGoods(struct soap *soap, ns1__UhttGoods *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttGoods))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttGoods(struct soap *soap, const char *tag, int id, ns1__UhttGoods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttGoods);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttGoods ** SOAP_FMAC4 soap_in_PointerTons1__UhttGoods(struct soap *soap, const char *tag, ns1__UhttGoods **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttGoods **)soap_malloc(soap, sizeof(ns1__UhttGoods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttGoods *)soap_instantiate_ns1__UhttGoods(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttGoods ** p = (ns1__UhttGoods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttGoods, sizeof(ns1__UhttGoods), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttGoods(struct soap *soap, ns1__UhttGoods *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttGoods);
	if (soap_out_PointerTons1__UhttGoods(soap, tag?tag:"ns1:UhttGoods", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttGoods ** SOAP_FMAC4 soap_get_PointerTons1__UhttGoods(struct soap *soap, ns1__UhttGoods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttGoods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttBrand(struct soap *soap, ns1__UhttBrand *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttBrand))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttBrand(struct soap *soap, const char *tag, int id, ns1__UhttBrand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttBrand);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttBrand ** SOAP_FMAC4 soap_in_PointerTons1__UhttBrand(struct soap *soap, const char *tag, ns1__UhttBrand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttBrand **)soap_malloc(soap, sizeof(ns1__UhttBrand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttBrand *)soap_instantiate_ns1__UhttBrand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttBrand ** p = (ns1__UhttBrand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttBrand, sizeof(ns1__UhttBrand), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttBrand(struct soap *soap, ns1__UhttBrand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttBrand);
	if (soap_out_PointerTons1__UhttBrand(soap, tag?tag:"ns1:UhttBrand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttBrand ** SOAP_FMAC4 soap_get_PointerTons1__UhttBrand(struct soap *soap, ns1__UhttBrand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttBrand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttGoodsGroup(struct soap *soap, ns1__UhttGoodsGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttGoodsGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttGoodsGroup(struct soap *soap, const char *tag, int id, ns1__UhttGoodsGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttGoodsGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttGoodsGroup ** SOAP_FMAC4 soap_in_PointerTons1__UhttGoodsGroup(struct soap *soap, const char *tag, ns1__UhttGoodsGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttGoodsGroup **)soap_malloc(soap, sizeof(ns1__UhttGoodsGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttGoodsGroup *)soap_instantiate_ns1__UhttGoodsGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttGoodsGroup ** p = (ns1__UhttGoodsGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttGoodsGroup, sizeof(ns1__UhttGoodsGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttGoodsGroup(struct soap *soap, ns1__UhttGoodsGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttGoodsGroup);
	if (soap_out_PointerTons1__UhttGoodsGroup(soap, tag?tag:"ns1:UhttGoodsGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttGoodsGroup ** SOAP_FMAC4 soap_get_PointerTons1__UhttGoodsGroup(struct soap *soap, ns1__UhttGoodsGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttGoodsGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttPerson(struct soap *soap, ns1__UhttPerson *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttPerson))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttPerson(struct soap *soap, const char *tag, int id, ns1__UhttPerson *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttPerson);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttPerson ** SOAP_FMAC4 soap_in_PointerTons1__UhttPerson(struct soap *soap, const char *tag, ns1__UhttPerson **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPerson **)soap_malloc(soap, sizeof(ns1__UhttPerson *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttPerson *)soap_instantiate_ns1__UhttPerson(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttPerson ** p = (ns1__UhttPerson **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttPerson, sizeof(ns1__UhttPerson), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttPerson(struct soap *soap, ns1__UhttPerson *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttPerson);
	if (soap_out_PointerTons1__UhttPerson(soap, tag?tag:"ns1:UhttPerson", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPerson ** SOAP_FMAC4 soap_get_PointerTons1__UhttPerson(struct soap *soap, ns1__UhttPerson **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttPersonRegisterType(struct soap *soap, ns1__UhttPersonRegisterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttPersonRegisterType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttPersonRegisterType(struct soap *soap, const char *tag, int id, ns1__UhttPersonRegisterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttPersonRegisterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttPersonRegisterType ** SOAP_FMAC4 soap_in_PointerTons1__UhttPersonRegisterType(struct soap *soap, const char *tag, ns1__UhttPersonRegisterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPersonRegisterType **)soap_malloc(soap, sizeof(ns1__UhttPersonRegisterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttPersonRegisterType *)soap_instantiate_ns1__UhttPersonRegisterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttPersonRegisterType ** p = (ns1__UhttPersonRegisterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttPersonRegisterType, sizeof(ns1__UhttPersonRegisterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttPersonRegisterType(struct soap *soap, ns1__UhttPersonRegisterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttPersonRegisterType);
	if (soap_out_PointerTons1__UhttPersonRegisterType(soap, tag?tag:"ns1:UhttPersonRegisterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPersonRegisterType ** SOAP_FMAC4 soap_get_PointerTons1__UhttPersonRegisterType(struct soap *soap, ns1__UhttPersonRegisterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttPersonRegisterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttPersonCategory(struct soap *soap, ns1__UhttPersonCategory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttPersonCategory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttPersonCategory(struct soap *soap, const char *tag, int id, ns1__UhttPersonCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttPersonCategory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttPersonCategory ** SOAP_FMAC4 soap_in_PointerTons1__UhttPersonCategory(struct soap *soap, const char *tag, ns1__UhttPersonCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPersonCategory **)soap_malloc(soap, sizeof(ns1__UhttPersonCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttPersonCategory *)soap_instantiate_ns1__UhttPersonCategory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttPersonCategory ** p = (ns1__UhttPersonCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttPersonCategory, sizeof(ns1__UhttPersonCategory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttPersonCategory(struct soap *soap, ns1__UhttPersonCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttPersonCategory);
	if (soap_out_PointerTons1__UhttPersonCategory(soap, tag?tag:"ns1:UhttPersonCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPersonCategory ** SOAP_FMAC4 soap_get_PointerTons1__UhttPersonCategory(struct soap *soap, ns1__UhttPersonCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttPersonCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttPersonKind(struct soap *soap, ns1__UhttPersonKind *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttPersonKind))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttPersonKind(struct soap *soap, const char *tag, int id, ns1__UhttPersonKind *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttPersonKind);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttPersonKind ** SOAP_FMAC4 soap_in_PointerTons1__UhttPersonKind(struct soap *soap, const char *tag, ns1__UhttPersonKind **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPersonKind **)soap_malloc(soap, sizeof(ns1__UhttPersonKind *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttPersonKind *)soap_instantiate_ns1__UhttPersonKind(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttPersonKind ** p = (ns1__UhttPersonKind **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttPersonKind, sizeof(ns1__UhttPersonKind), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttPersonKind(struct soap *soap, ns1__UhttPersonKind *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttPersonKind);
	if (soap_out_PointerTons1__UhttPersonKind(soap, tag?tag:"ns1:UhttPersonKind", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPersonKind ** SOAP_FMAC4 soap_get_PointerTons1__UhttPersonKind(struct soap *soap, ns1__UhttPersonKind **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttPersonKind(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttCurrency(struct soap *soap, ns1__UhttCurrency *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttCurrency))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttCurrency(struct soap *soap, const char *tag, int id, ns1__UhttCurrency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttCurrency);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttCurrency ** SOAP_FMAC4 soap_in_PointerTons1__UhttCurrency(struct soap *soap, const char *tag, ns1__UhttCurrency **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttCurrency **)soap_malloc(soap, sizeof(ns1__UhttCurrency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttCurrency *)soap_instantiate_ns1__UhttCurrency(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttCurrency ** p = (ns1__UhttCurrency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttCurrency, sizeof(ns1__UhttCurrency), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttCurrency(struct soap *soap, ns1__UhttCurrency *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttCurrency);
	if (soap_out_PointerTons1__UhttCurrency(soap, tag?tag:"ns1:UhttCurrency", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttCurrency ** SOAP_FMAC4 soap_get_PointerTons1__UhttCurrency(struct soap *soap, ns1__UhttCurrency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttCurrency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttWorld(struct soap *soap, ns1__UhttWorld *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttWorld))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttWorld(struct soap *soap, const char *tag, int id, ns1__UhttWorld *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttWorld);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttWorld ** SOAP_FMAC4 soap_in_PointerTons1__UhttWorld(struct soap *soap, const char *tag, ns1__UhttWorld **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttWorld **)soap_malloc(soap, sizeof(ns1__UhttWorld *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttWorld *)soap_instantiate_ns1__UhttWorld(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttWorld ** p = (ns1__UhttWorld **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttWorld, sizeof(ns1__UhttWorld), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttWorld(struct soap *soap, ns1__UhttWorld *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttWorld);
	if (soap_out_PointerTons1__UhttWorld(soap, tag?tag:"ns1:UhttWorld", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttWorld ** SOAP_FMAC4 soap_get_PointerTons1__UhttWorld(struct soap *soap, ns1__UhttWorld **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttObjSelectCriteria(struct soap *soap, ns1__UhttObjSelectCriteria *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttObjSelectCriteria))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttObjSelectCriteria(struct soap *soap, const char *tag, int id, ns1__UhttObjSelectCriteria *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttObjSelectCriteria);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttObjSelectCriteria ** SOAP_FMAC4 soap_in_PointerTons1__UhttObjSelectCriteria(struct soap *soap, const char *tag, ns1__UhttObjSelectCriteria **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttObjSelectCriteria **)soap_malloc(soap, sizeof(ns1__UhttObjSelectCriteria *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttObjSelectCriteria *)soap_instantiate_ns1__UhttObjSelectCriteria(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttObjSelectCriteria ** p = (ns1__UhttObjSelectCriteria **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttObjSelectCriteria, sizeof(ns1__UhttObjSelectCriteria), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttObjSelectCriteria(struct soap *soap, ns1__UhttObjSelectCriteria *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttObjSelectCriteria);
	if (soap_out_PointerTons1__UhttObjSelectCriteria(soap, tag?tag:"ns1:UhttObjSelectCriteria", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttObjSelectCriteria ** SOAP_FMAC4 soap_get_PointerTons1__UhttObjSelectCriteria(struct soap *soap, ns1__UhttObjSelectCriteria **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttObjSelectCriteria(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfUhttCommObjItem(struct soap *soap, ns1__ArrayOfUhttCommObjItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfUhttCommObjItem(struct soap *soap, const char *tag, int id, ns1__ArrayOfUhttCommObjItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfUhttCommObjItem ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfUhttCommObjItem(struct soap *soap, const char *tag, ns1__ArrayOfUhttCommObjItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfUhttCommObjItem **)soap_malloc(soap, sizeof(ns1__ArrayOfUhttCommObjItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfUhttCommObjItem *)soap_instantiate_ns1__ArrayOfUhttCommObjItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfUhttCommObjItem ** p = (ns1__ArrayOfUhttCommObjItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfUhttCommObjItem, sizeof(ns1__ArrayOfUhttCommObjItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfUhttCommObjItem(struct soap *soap, ns1__ArrayOfUhttCommObjItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfUhttCommObjItem);
	if (soap_out_PointerTons1__ArrayOfUhttCommObjItem(soap, tag?tag:"ns1:ArrayOfUhttCommObjItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfUhttCommObjItem ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfUhttCommObjItem(struct soap *soap, ns1__ArrayOfUhttCommObjItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfUhttCommObjItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UhttSpoiledSerial))
		soap_serialize_PointerTons1__UhttSpoiledSerial(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UhttSpoiledSerial(struct soap *soap, const char *tag, int id, ns1__UhttSpoiledSerial **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UhttSpoiledSerial);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UhttSpoiledSerial(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UhttSpoiledSerial(struct soap *soap, const char *tag, ns1__UhttSpoiledSerial ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttSpoiledSerial ***)soap_malloc(soap, sizeof(ns1__UhttSpoiledSerial **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UhttSpoiledSerial(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UhttSpoiledSerial ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UhttSpoiledSerial, sizeof(ns1__UhttSpoiledSerial *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UhttSpoiledSerial);
	if (soap_out_PointerToPointerTons1__UhttSpoiledSerial(soap, tag?tag:"ns1:UhttSpoiledSerial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UhttSpoiledSerial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttSpoiledSerial))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttSpoiledSerial(struct soap *soap, const char *tag, int id, ns1__UhttSpoiledSerial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttSpoiledSerial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial ** SOAP_FMAC4 soap_in_PointerTons1__UhttSpoiledSerial(struct soap *soap, const char *tag, ns1__UhttSpoiledSerial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttSpoiledSerial **)soap_malloc(soap, sizeof(ns1__UhttSpoiledSerial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttSpoiledSerial *)soap_instantiate_ns1__UhttSpoiledSerial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttSpoiledSerial ** p = (ns1__UhttSpoiledSerial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttSpoiledSerial, sizeof(ns1__UhttSpoiledSerial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttSpoiledSerial);
	if (soap_out_PointerTons1__UhttSpoiledSerial(soap, tag?tag:"ns1:UhttSpoiledSerial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttSpoiledSerial ** SOAP_FMAC4 soap_get_PointerTons1__UhttSpoiledSerial(struct soap *soap, ns1__UhttSpoiledSerial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttSpoiledSerial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UhttBarcode))
		soap_serialize_PointerTons1__UhttBarcode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UhttBarcode(struct soap *soap, const char *tag, int id, ns1__UhttBarcode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UhttBarcode);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UhttBarcode(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UhttBarcode *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UhttBarcode(struct soap *soap, const char *tag, ns1__UhttBarcode ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttBarcode ***)soap_malloc(soap, sizeof(ns1__UhttBarcode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UhttBarcode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UhttBarcode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UhttBarcode, sizeof(ns1__UhttBarcode *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UhttBarcode);
	if (soap_out_PointerToPointerTons1__UhttBarcode(soap, tag?tag:"ns1:UhttBarcode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttBarcode *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UhttBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttBarcode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttBarcode(struct soap *soap, const char *tag, int id, ns1__UhttBarcode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttBarcode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttBarcode ** SOAP_FMAC4 soap_in_PointerTons1__UhttBarcode(struct soap *soap, const char *tag, ns1__UhttBarcode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttBarcode **)soap_malloc(soap, sizeof(ns1__UhttBarcode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttBarcode *)soap_instantiate_ns1__UhttBarcode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttBarcode ** p = (ns1__UhttBarcode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttBarcode, sizeof(ns1__UhttBarcode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttBarcode);
	if (soap_out_PointerTons1__UhttBarcode(soap, tag?tag:"ns1:UhttBarcode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttBarcode ** SOAP_FMAC4 soap_get_PointerTons1__UhttBarcode(struct soap *soap, ns1__UhttBarcode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttBarcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UhttPersonRegister))
		soap_serialize_PointerTons1__UhttPersonRegister(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UhttPersonRegister(struct soap *soap, const char *tag, int id, ns1__UhttPersonRegister **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UhttPersonRegister);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UhttPersonRegister(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UhttPersonRegister *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UhttPersonRegister(struct soap *soap, const char *tag, ns1__UhttPersonRegister ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPersonRegister ***)soap_malloc(soap, sizeof(ns1__UhttPersonRegister **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UhttPersonRegister(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UhttPersonRegister ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UhttPersonRegister, sizeof(ns1__UhttPersonRegister *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UhttPersonRegister);
	if (soap_out_PointerToPointerTons1__UhttPersonRegister(soap, tag?tag:"ns1:UhttPersonRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPersonRegister *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UhttPersonRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttPersonRegister))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttPersonRegister(struct soap *soap, const char *tag, int id, ns1__UhttPersonRegister *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttPersonRegister);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttPersonRegister ** SOAP_FMAC4 soap_in_PointerTons1__UhttPersonRegister(struct soap *soap, const char *tag, ns1__UhttPersonRegister **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttPersonRegister **)soap_malloc(soap, sizeof(ns1__UhttPersonRegister *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttPersonRegister *)soap_instantiate_ns1__UhttPersonRegister(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttPersonRegister ** p = (ns1__UhttPersonRegister **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttPersonRegister, sizeof(ns1__UhttPersonRegister), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttPersonRegister);
	if (soap_out_PointerTons1__UhttPersonRegister(soap, tag?tag:"ns1:UhttPersonRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttPersonRegister ** SOAP_FMAC4 soap_get_PointerTons1__UhttPersonRegister(struct soap *soap, ns1__UhttPersonRegister **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttPersonRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttLocation(struct soap *soap, ns1__UhttLocation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttLocation(struct soap *soap, const char *tag, int id, ns1__UhttLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttLocation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttLocation ** SOAP_FMAC4 soap_in_PointerTons1__UhttLocation(struct soap *soap, const char *tag, ns1__UhttLocation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttLocation **)soap_malloc(soap, sizeof(ns1__UhttLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttLocation *)soap_instantiate_ns1__UhttLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttLocation ** p = (ns1__UhttLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttLocation, sizeof(ns1__UhttLocation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttLocation(struct soap *soap, ns1__UhttLocation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttLocation);
	if (soap_out_PointerTons1__UhttLocation(soap, tag?tag:"ns1:UhttLocation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttLocation ** SOAP_FMAC4 soap_get_PointerTons1__UhttLocation(struct soap *soap, ns1__UhttLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UhttCommObjItem))
		soap_serialize_PointerTons1__UhttCommObjItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UhttCommObjItem(struct soap *soap, const char *tag, int id, ns1__UhttCommObjItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UhttCommObjItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UhttCommObjItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UhttCommObjItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UhttCommObjItem(struct soap *soap, const char *tag, ns1__UhttCommObjItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttCommObjItem ***)soap_malloc(soap, sizeof(ns1__UhttCommObjItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UhttCommObjItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UhttCommObjItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UhttCommObjItem, sizeof(ns1__UhttCommObjItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UhttCommObjItem);
	if (soap_out_PointerToPointerTons1__UhttCommObjItem(soap, tag?tag:"ns1:UhttCommObjItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttCommObjItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UhttCommObjItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UhttCommObjItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UhttCommObjItem(struct soap *soap, const char *tag, int id, ns1__UhttCommObjItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UhttCommObjItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UhttCommObjItem ** SOAP_FMAC4 soap_in_PointerTons1__UhttCommObjItem(struct soap *soap, const char *tag, ns1__UhttCommObjItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UhttCommObjItem **)soap_malloc(soap, sizeof(ns1__UhttCommObjItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UhttCommObjItem *)soap_instantiate_ns1__UhttCommObjItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UhttCommObjItem ** p = (ns1__UhttCommObjItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UhttCommObjItem, sizeof(ns1__UhttCommObjItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UhttCommObjItem);
	if (soap_out_PointerTons1__UhttCommObjItem(soap, tag?tag:"ns1:UhttCommObjItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UhttCommObjItem ** SOAP_FMAC4 soap_get_PointerTons1__UhttCommObjItem(struct soap *soap, ns1__UhttCommObjItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UhttCommObjItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__time(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__time
	*a = SOAP_DEFAULT_xsd__time;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__time, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__time);
	if (soap_out_xsd__time(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__date
	*a = SOAP_DEFAULT_xsd__date;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
